(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&i(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerPolicy&&(r.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?r.credentials="include":s.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function i(s){if(s.ep)return;s.ep=!0;const r=t(s);fetch(s.href,r)}})();function Wb(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function cT(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function i(){var s=!1;try{s=this instanceof i}catch{}return s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(i){var s=Object.getOwnPropertyDescriptor(n,i);Object.defineProperty(t,i,s.get?s:{enumerable:!0,get:function(){return n[i]}})}),t}var Xx={exports:{}},z0={};var iA;function az(){if(iA)return z0;iA=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.fragment");function t(i,s,r){var o=null;if(r!==void 0&&(o=""+r),s.key!==void 0&&(o=""+s.key),"key"in s){r={};for(var l in s)l!=="key"&&(r[l]=s[l])}else r=s;return s=r.ref,{$$typeof:n,type:i,key:o,ref:s!==void 0?s:null,props:r}}return z0.Fragment=e,z0.jsx=t,z0.jsxs=t,z0}var sA;function oz(){return sA||(sA=1,Xx.exports=az()),Xx.exports}var zt=oz(),Yx={exports:{}},Ti={};var rA;function lz(){if(rA)return Ti;rA=1;var n=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),i=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),r=Symbol.for("react.consumer"),o=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),g=Symbol.for("react.lazy"),p=Symbol.for("react.activity"),h=Symbol.iterator;function v(ee){return ee===null||typeof ee!="object"?null:(ee=h&&ee[h]||ee["@@iterator"],typeof ee=="function"?ee:null)}var y={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},w=Object.assign,S={};function M(ee,te,ue){this.props=ee,this.context=te,this.refs=S,this.updater=ue||y}M.prototype.isReactComponent={},M.prototype.setState=function(ee,te){if(typeof ee!="object"&&typeof ee!="function"&&ee!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,ee,te,"setState")},M.prototype.forceUpdate=function(ee){this.updater.enqueueForceUpdate(this,ee,"forceUpdate")};function T(){}T.prototype=M.prototype;function C(ee,te,ue){this.props=ee,this.context=te,this.refs=S,this.updater=ue||y}var x=C.prototype=new T;x.constructor=C,w(x,M.prototype),x.isPureReactComponent=!0;var R=Array.isArray;function P(){}var D={H:null,A:null,T:null,S:null},z=Object.prototype.hasOwnProperty;function U(ee,te,ue){var ae=ue.ref;return{$$typeof:n,type:ee,key:te,ref:ae!==void 0?ae:null,props:ue}}function N(ee,te){return U(ee.type,te,ee.props)}function j(ee){return typeof ee=="object"&&ee!==null&&ee.$$typeof===n}function J(ee){var te={"=":"=0",":":"=2"};return"$"+ee.replace(/[=:]/g,function(ue){return te[ue]})}var W=/\/+/g;function oe(ee,te){return typeof ee=="object"&&ee!==null&&ee.key!=null?J(""+ee.key):te.toString(36)}function ne(ee){switch(ee.status){case"fulfilled":return ee.value;case"rejected":throw ee.reason;default:switch(typeof ee.status=="string"?ee.then(P,P):(ee.status="pending",ee.then(function(te){ee.status==="pending"&&(ee.status="fulfilled",ee.value=te)},function(te){ee.status==="pending"&&(ee.status="rejected",ee.reason=te)})),ee.status){case"fulfilled":return ee.value;case"rejected":throw ee.reason}}throw ee}function q(ee,te,ue,ae,ce){var Be=typeof ee;(Be==="undefined"||Be==="boolean")&&(ee=null);var He=!1;if(ee===null)He=!0;else switch(Be){case"bigint":case"string":case"number":He=!0;break;case"object":switch(ee.$$typeof){case n:case e:He=!0;break;case g:return He=ee._init,q(He(ee._payload),te,ue,ae,ce)}}if(He)return ce=ce(ee),He=ae===""?"."+oe(ee,0):ae,R(ce)?(ue="",He!=null&&(ue=He.replace(W,"$&/")+"/"),q(ce,te,ue,"",function(tt){return tt})):ce!=null&&(j(ce)&&(ce=N(ce,ue+(ce.key==null||ee&&ee.key===ce.key?"":(""+ce.key).replace(W,"$&/")+"/")+He)),te.push(ce)),1;He=0;var Xe=ae===""?".":ae+":";if(R(ee))for(var ot=0;ot<ee.length;ot++)ae=ee[ot],Be=Xe+oe(ae,ot),He+=q(ae,te,ue,Be,ce);else if(ot=v(ee),typeof ot=="function")for(ee=ot.call(ee),ot=0;!(ae=ee.next()).done;)ae=ae.value,Be=Xe+oe(ae,ot++),He+=q(ae,te,ue,Be,ce);else if(Be==="object"){if(typeof ee.then=="function")return q(ne(ee),te,ue,ae,ce);throw te=String(ee),Error("Objects are not valid as a React child (found: "+(te==="[object Object]"?"object with keys {"+Object.keys(ee).join(", ")+"}":te)+"). If you meant to render a collection of children, use an array instead.")}return He}function le(ee,te,ue){if(ee==null)return ee;var ae=[],ce=0;return q(ee,ae,"","",function(Be){return te.call(ue,Be,ce++)}),ae}function se(ee){if(ee._status===-1){var te=ee._result;te=te(),te.then(function(ue){(ee._status===0||ee._status===-1)&&(ee._status=1,ee._result=ue)},function(ue){(ee._status===0||ee._status===-1)&&(ee._status=2,ee._result=ue)}),ee._status===-1&&(ee._status=0,ee._result=te)}if(ee._status===1)return ee._result.default;throw ee._result}var pe=typeof reportError=="function"?reportError:function(ee){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var te=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof ee=="object"&&ee!==null&&typeof ee.message=="string"?String(ee.message):String(ee),error:ee});if(!window.dispatchEvent(te))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",ee);return}console.error(ee)},be={map:le,forEach:function(ee,te,ue){le(ee,function(){te.apply(this,arguments)},ue)},count:function(ee){var te=0;return le(ee,function(){te++}),te},toArray:function(ee){return le(ee,function(te){return te})||[]},only:function(ee){if(!j(ee))throw Error("React.Children.only expected to receive a single React element child.");return ee}};return Ti.Activity=p,Ti.Children=be,Ti.Component=M,Ti.Fragment=t,Ti.Profiler=s,Ti.PureComponent=C,Ti.StrictMode=i,Ti.Suspense=c,Ti.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=D,Ti.__COMPILER_RUNTIME={__proto__:null,c:function(ee){return D.H.useMemoCache(ee)}},Ti.cache=function(ee){return function(){return ee.apply(null,arguments)}},Ti.cacheSignal=function(){return null},Ti.cloneElement=function(ee,te,ue){if(ee==null)throw Error("The argument must be a React element, but you passed "+ee+".");var ae=w({},ee.props),ce=ee.key;if(te!=null)for(Be in te.key!==void 0&&(ce=""+te.key),te)!z.call(te,Be)||Be==="key"||Be==="__self"||Be==="__source"||Be==="ref"&&te.ref===void 0||(ae[Be]=te[Be]);var Be=arguments.length-2;if(Be===1)ae.children=ue;else if(1<Be){for(var He=Array(Be),Xe=0;Xe<Be;Xe++)He[Xe]=arguments[Xe+2];ae.children=He}return U(ee.type,ce,ae)},Ti.createContext=function(ee){return ee={$$typeof:o,_currentValue:ee,_currentValue2:ee,_threadCount:0,Provider:null,Consumer:null},ee.Provider=ee,ee.Consumer={$$typeof:r,_context:ee},ee},Ti.createElement=function(ee,te,ue){var ae,ce={},Be=null;if(te!=null)for(ae in te.key!==void 0&&(Be=""+te.key),te)z.call(te,ae)&&ae!=="key"&&ae!=="__self"&&ae!=="__source"&&(ce[ae]=te[ae]);var He=arguments.length-2;if(He===1)ce.children=ue;else if(1<He){for(var Xe=Array(He),ot=0;ot<He;ot++)Xe[ot]=arguments[ot+2];ce.children=Xe}if(ee&&ee.defaultProps)for(ae in He=ee.defaultProps,He)ce[ae]===void 0&&(ce[ae]=He[ae]);return U(ee,Be,ce)},Ti.createRef=function(){return{current:null}},Ti.forwardRef=function(ee){return{$$typeof:l,render:ee}},Ti.isValidElement=j,Ti.lazy=function(ee){return{$$typeof:g,_payload:{_status:-1,_result:ee},_init:se}},Ti.memo=function(ee,te){return{$$typeof:d,type:ee,compare:te===void 0?null:te}},Ti.startTransition=function(ee){var te=D.T,ue={};D.T=ue;try{var ae=ee(),ce=D.S;ce!==null&&ce(ue,ae),typeof ae=="object"&&ae!==null&&typeof ae.then=="function"&&ae.then(P,pe)}catch(Be){pe(Be)}finally{te!==null&&ue.types!==null&&(te.types=ue.types),D.T=te}},Ti.unstable_useCacheRefresh=function(){return D.H.useCacheRefresh()},Ti.use=function(ee){return D.H.use(ee)},Ti.useActionState=function(ee,te,ue){return D.H.useActionState(ee,te,ue)},Ti.useCallback=function(ee,te){return D.H.useCallback(ee,te)},Ti.useContext=function(ee){return D.H.useContext(ee)},Ti.useDebugValue=function(){},Ti.useDeferredValue=function(ee,te){return D.H.useDeferredValue(ee,te)},Ti.useEffect=function(ee,te){return D.H.useEffect(ee,te)},Ti.useEffectEvent=function(ee){return D.H.useEffectEvent(ee)},Ti.useId=function(){return D.H.useId()},Ti.useImperativeHandle=function(ee,te,ue){return D.H.useImperativeHandle(ee,te,ue)},Ti.useInsertionEffect=function(ee,te){return D.H.useInsertionEffect(ee,te)},Ti.useLayoutEffect=function(ee,te){return D.H.useLayoutEffect(ee,te)},Ti.useMemo=function(ee,te){return D.H.useMemo(ee,te)},Ti.useOptimistic=function(ee,te){return D.H.useOptimistic(ee,te)},Ti.useReducer=function(ee,te,ue){return D.H.useReducer(ee,te,ue)},Ti.useRef=function(ee){return D.H.useRef(ee)},Ti.useState=function(ee){return D.H.useState(ee)},Ti.useSyncExternalStore=function(ee,te,ue){return D.H.useSyncExternalStore(ee,te,ue)},Ti.useTransition=function(){return D.H.useTransition()},Ti.version="19.2.0",Ti}var aA;function m0(){return aA||(aA=1,Yx.exports=lz()),Yx.exports}var Ft=m0();const wB=Wb(Ft);var Jx={exports:{}},U0={},Qx={exports:{}},Zx={};var oA;function uz(){return oA||(oA=1,(function(n){function e(q,le){var se=q.length;q.push(le);e:for(;0<se;){var pe=se-1>>>1,be=q[pe];if(0<s(be,le))q[pe]=le,q[se]=be,se=pe;else break e}}function t(q){return q.length===0?null:q[0]}function i(q){if(q.length===0)return null;var le=q[0],se=q.pop();if(se!==le){q[0]=se;e:for(var pe=0,be=q.length,ee=be>>>1;pe<ee;){var te=2*(pe+1)-1,ue=q[te],ae=te+1,ce=q[ae];if(0>s(ue,se))ae<be&&0>s(ce,ue)?(q[pe]=ce,q[ae]=se,pe=ae):(q[pe]=ue,q[te]=se,pe=te);else if(ae<be&&0>s(ce,se))q[pe]=ce,q[ae]=se,pe=ae;else break e}}return le}function s(q,le){var se=q.sortIndex-le.sortIndex;return se!==0?se:q.id-le.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var r=performance;n.unstable_now=function(){return r.now()}}else{var o=Date,l=o.now();n.unstable_now=function(){return o.now()-l}}var c=[],d=[],g=1,p=null,h=3,v=!1,y=!1,w=!1,S=!1,M=typeof setTimeout=="function"?setTimeout:null,T=typeof clearTimeout=="function"?clearTimeout:null,C=typeof setImmediate<"u"?setImmediate:null;function x(q){for(var le=t(d);le!==null;){if(le.callback===null)i(d);else if(le.startTime<=q)i(d),le.sortIndex=le.expirationTime,e(c,le);else break;le=t(d)}}function R(q){if(w=!1,x(q),!y)if(t(c)!==null)y=!0,P||(P=!0,J());else{var le=t(d);le!==null&&ne(R,le.startTime-q)}}var P=!1,D=-1,z=5,U=-1;function N(){return S?!0:!(n.unstable_now()-U<z)}function j(){if(S=!1,P){var q=n.unstable_now();U=q;var le=!0;try{e:{y=!1,w&&(w=!1,T(D),D=-1),v=!0;var se=h;try{t:{for(x(q),p=t(c);p!==null&&!(p.expirationTime>q&&N());){var pe=p.callback;if(typeof pe=="function"){p.callback=null,h=p.priorityLevel;var be=pe(p.expirationTime<=q);if(q=n.unstable_now(),typeof be=="function"){p.callback=be,x(q),le=!0;break t}p===t(c)&&i(c),x(q)}else i(c);p=t(c)}if(p!==null)le=!0;else{var ee=t(d);ee!==null&&ne(R,ee.startTime-q),le=!1}}break e}finally{p=null,h=se,v=!1}le=void 0}}finally{le?J():P=!1}}}var J;if(typeof C=="function")J=function(){C(j)};else if(typeof MessageChannel<"u"){var W=new MessageChannel,oe=W.port2;W.port1.onmessage=j,J=function(){oe.postMessage(null)}}else J=function(){M(j,0)};function ne(q,le){D=M(function(){q(n.unstable_now())},le)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(q){q.callback=null},n.unstable_forceFrameRate=function(q){0>q||125<q?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):z=0<q?Math.floor(1e3/q):5},n.unstable_getCurrentPriorityLevel=function(){return h},n.unstable_next=function(q){switch(h){case 1:case 2:case 3:var le=3;break;default:le=h}var se=h;h=le;try{return q()}finally{h=se}},n.unstable_requestPaint=function(){S=!0},n.unstable_runWithPriority=function(q,le){switch(q){case 1:case 2:case 3:case 4:case 5:break;default:q=3}var se=h;h=q;try{return le()}finally{h=se}},n.unstable_scheduleCallback=function(q,le,se){var pe=n.unstable_now();switch(typeof se=="object"&&se!==null?(se=se.delay,se=typeof se=="number"&&0<se?pe+se:pe):se=pe,q){case 1:var be=-1;break;case 2:be=250;break;case 5:be=1073741823;break;case 4:be=1e4;break;default:be=5e3}return be=se+be,q={id:g++,callback:le,priorityLevel:q,startTime:se,expirationTime:be,sortIndex:-1},se>pe?(q.sortIndex=se,e(d,q),t(c)===null&&q===t(d)&&(w?(T(D),D=-1):w=!0,ne(R,se-pe))):(q.sortIndex=be,e(c,q),y||v||(y=!0,P||(P=!0,J()))),q},n.unstable_shouldYield=N,n.unstable_wrapCallback=function(q){var le=h;return function(){var se=h;h=le;try{return q.apply(this,arguments)}finally{h=se}}}})(Zx)),Zx}var lA;function cz(){return lA||(lA=1,Qx.exports=uz()),Qx.exports}var ew={exports:{}},jo={};var uA;function dz(){if(uA)return jo;uA=1;var n=m0();function e(c){var d="https://react.dev/errors/"+c;if(1<arguments.length){d+="?args[]="+encodeURIComponent(arguments[1]);for(var g=2;g<arguments.length;g++)d+="&args[]="+encodeURIComponent(arguments[g])}return"Minified React error #"+c+"; visit "+d+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function t(){}var i={d:{f:t,r:function(){throw Error(e(522))},D:t,C:t,L:t,m:t,X:t,S:t,M:t},p:0,findDOMNode:null},s=Symbol.for("react.portal");function r(c,d,g){var p=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:s,key:p==null?null:""+p,children:c,containerInfo:d,implementation:g}}var o=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function l(c,d){if(c==="font")return"";if(typeof d=="string")return d==="use-credentials"?d:""}return jo.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=i,jo.createPortal=function(c,d){var g=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!d||d.nodeType!==1&&d.nodeType!==9&&d.nodeType!==11)throw Error(e(299));return r(c,d,null,g)},jo.flushSync=function(c){var d=o.T,g=i.p;try{if(o.T=null,i.p=2,c)return c()}finally{o.T=d,i.p=g,i.d.f()}},jo.preconnect=function(c,d){typeof c=="string"&&(d?(d=d.crossOrigin,d=typeof d=="string"?d==="use-credentials"?d:"":void 0):d=null,i.d.C(c,d))},jo.prefetchDNS=function(c){typeof c=="string"&&i.d.D(c)},jo.preinit=function(c,d){if(typeof c=="string"&&d&&typeof d.as=="string"){var g=d.as,p=l(g,d.crossOrigin),h=typeof d.integrity=="string"?d.integrity:void 0,v=typeof d.fetchPriority=="string"?d.fetchPriority:void 0;g==="style"?i.d.S(c,typeof d.precedence=="string"?d.precedence:void 0,{crossOrigin:p,integrity:h,fetchPriority:v}):g==="script"&&i.d.X(c,{crossOrigin:p,integrity:h,fetchPriority:v,nonce:typeof d.nonce=="string"?d.nonce:void 0})}},jo.preinitModule=function(c,d){if(typeof c=="string")if(typeof d=="object"&&d!==null){if(d.as==null||d.as==="script"){var g=l(d.as,d.crossOrigin);i.d.M(c,{crossOrigin:g,integrity:typeof d.integrity=="string"?d.integrity:void 0,nonce:typeof d.nonce=="string"?d.nonce:void 0})}}else d==null&&i.d.M(c)},jo.preload=function(c,d){if(typeof c=="string"&&typeof d=="object"&&d!==null&&typeof d.as=="string"){var g=d.as,p=l(g,d.crossOrigin);i.d.L(c,g,{crossOrigin:p,integrity:typeof d.integrity=="string"?d.integrity:void 0,nonce:typeof d.nonce=="string"?d.nonce:void 0,type:typeof d.type=="string"?d.type:void 0,fetchPriority:typeof d.fetchPriority=="string"?d.fetchPriority:void 0,referrerPolicy:typeof d.referrerPolicy=="string"?d.referrerPolicy:void 0,imageSrcSet:typeof d.imageSrcSet=="string"?d.imageSrcSet:void 0,imageSizes:typeof d.imageSizes=="string"?d.imageSizes:void 0,media:typeof d.media=="string"?d.media:void 0})}},jo.preloadModule=function(c,d){if(typeof c=="string")if(d){var g=l(d.as,d.crossOrigin);i.d.m(c,{as:typeof d.as=="string"&&d.as!=="script"?d.as:void 0,crossOrigin:g,integrity:typeof d.integrity=="string"?d.integrity:void 0})}else i.d.m(c)},jo.requestFormReset=function(c){i.d.r(c)},jo.unstable_batchedUpdates=function(c,d){return c(d)},jo.useFormState=function(c,d,g){return o.H.useFormState(c,d,g)},jo.useFormStatus=function(){return o.H.useHostTransitionStatus()},jo.version="19.2.0",jo}var cA;function fz(){if(cA)return ew.exports;cA=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),ew.exports=dz(),ew.exports}var dA;function hz(){if(dA)return U0;dA=1;var n=cz(),e=m0(),t=fz();function i(a){var u="https://react.dev/errors/"+a;if(1<arguments.length){u+="?args[]="+encodeURIComponent(arguments[1]);for(var _=2;_<arguments.length;_++)u+="&args[]="+encodeURIComponent(arguments[_])}return"Minified React error #"+a+"; visit "+u+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function s(a){return!(!a||a.nodeType!==1&&a.nodeType!==9&&a.nodeType!==11)}function r(a){var u=a,_=a;if(a.alternate)for(;u.return;)u=u.return;else{a=u;do u=a,(u.flags&4098)!==0&&(_=u.return),a=u.return;while(a)}return u.tag===3?_:null}function o(a){if(a.tag===13){var u=a.memoizedState;if(u===null&&(a=a.alternate,a!==null&&(u=a.memoizedState)),u!==null)return u.dehydrated}return null}function l(a){if(a.tag===31){var u=a.memoizedState;if(u===null&&(a=a.alternate,a!==null&&(u=a.memoizedState)),u!==null)return u.dehydrated}return null}function c(a){if(r(a)!==a)throw Error(i(188))}function d(a){var u=a.alternate;if(!u){if(u=r(a),u===null)throw Error(i(188));return u!==a?null:a}for(var _=a,b=u;;){var O=_.return;if(O===null)break;var V=O.alternate;if(V===null){if(b=O.return,b!==null){_=b;continue}break}if(O.child===V.child){for(V=O.child;V;){if(V===_)return c(O),a;if(V===b)return c(O),u;V=V.sibling}throw Error(i(188))}if(_.return!==b.return)_=O,b=V;else{for(var he=!1,Ce=O.child;Ce;){if(Ce===_){he=!0,_=O,b=V;break}if(Ce===b){he=!0,b=O,_=V;break}Ce=Ce.sibling}if(!he){for(Ce=V.child;Ce;){if(Ce===_){he=!0,_=V,b=O;break}if(Ce===b){he=!0,b=V,_=O;break}Ce=Ce.sibling}if(!he)throw Error(i(189))}}if(_.alternate!==b)throw Error(i(190))}if(_.tag!==3)throw Error(i(188));return _.stateNode.current===_?a:u}function g(a){var u=a.tag;if(u===5||u===26||u===27||u===6)return a;for(a=a.child;a!==null;){if(u=g(a),u!==null)return u;a=a.sibling}return null}var p=Object.assign,h=Symbol.for("react.element"),v=Symbol.for("react.transitional.element"),y=Symbol.for("react.portal"),w=Symbol.for("react.fragment"),S=Symbol.for("react.strict_mode"),M=Symbol.for("react.profiler"),T=Symbol.for("react.consumer"),C=Symbol.for("react.context"),x=Symbol.for("react.forward_ref"),R=Symbol.for("react.suspense"),P=Symbol.for("react.suspense_list"),D=Symbol.for("react.memo"),z=Symbol.for("react.lazy"),U=Symbol.for("react.activity"),N=Symbol.for("react.memo_cache_sentinel"),j=Symbol.iterator;function J(a){return a===null||typeof a!="object"?null:(a=j&&a[j]||a["@@iterator"],typeof a=="function"?a:null)}var W=Symbol.for("react.client.reference");function oe(a){if(a==null)return null;if(typeof a=="function")return a.$$typeof===W?null:a.displayName||a.name||null;if(typeof a=="string")return a;switch(a){case w:return"Fragment";case M:return"Profiler";case S:return"StrictMode";case R:return"Suspense";case P:return"SuspenseList";case U:return"Activity"}if(typeof a=="object")switch(a.$$typeof){case y:return"Portal";case C:return a.displayName||"Context";case T:return(a._context.displayName||"Context")+".Consumer";case x:var u=a.render;return a=a.displayName,a||(a=u.displayName||u.name||"",a=a!==""?"ForwardRef("+a+")":"ForwardRef"),a;case D:return u=a.displayName||null,u!==null?u:oe(a.type)||"Memo";case z:u=a._payload,a=a._init;try{return oe(a(u))}catch{}}return null}var ne=Array.isArray,q=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,le=t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,se={pending:!1,data:null,method:null,action:null},pe=[],be=-1;function ee(a){return{current:a}}function te(a){0>be||(a.current=pe[be],pe[be]=null,be--)}function ue(a,u){be++,pe[be]=a.current,a.current=u}var ae=ee(null),ce=ee(null),Be=ee(null),He=ee(null);function Xe(a,u){switch(ue(Be,u),ue(ce,a),ue(ae,null),u.nodeType){case 9:case 11:a=(a=u.documentElement)&&(a=a.namespaceURI)?Hs(a):0;break;default:if(a=u.tagName,u=u.namespaceURI)u=Hs(u),a=Js(u,a);else switch(a){case"svg":a=1;break;case"math":a=2;break;default:a=0}}te(ae),ue(ae,a)}function ot(){te(ae),te(ce),te(Be)}function tt(a){a.memoizedState!==null&&ue(He,a);var u=ae.current,_=Js(u,a.type);u!==_&&(ue(ce,a),ue(ae,_))}function Ae(a){ce.current===a&&(te(ae),te(ce)),He.current===a&&(te(He),O0._currentValue=se)}var ye,xe;function ke(a){if(ye===void 0)try{throw Error()}catch(_){var u=_.stack.trim().match(/\n( *(at )?)/);ye=u&&u[1]||"",xe=-1<_.stack.indexOf(`
    at`)?" (<anonymous>)":-1<_.stack.indexOf("@")?"@unknown:0:0":""}return`
`+ye+a+xe}var ze=!1;function je(a,u){if(!a||ze)return"";ze=!0;var _=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var b={DetermineComponentFrameRoot:function(){try{if(u){var nn=function(){throw Error()};if(Object.defineProperty(nn.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(nn,[])}catch(kt){var It=kt}Reflect.construct(a,[],nn)}else{try{nn.call()}catch(kt){It=kt}a.call(nn.prototype)}}else{try{throw Error()}catch(kt){It=kt}(nn=a())&&typeof nn.catch=="function"&&nn.catch(function(){})}}catch(kt){if(kt&&It&&typeof kt.stack=="string")return[kt.stack,It.stack]}return[null,null]}};b.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var O=Object.getOwnPropertyDescriptor(b.DetermineComponentFrameRoot,"name");O&&O.configurable&&Object.defineProperty(b.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var V=b.DetermineComponentFrameRoot(),he=V[0],Ce=V[1];if(he&&Ce){var st=he.split(`
`),Pt=Ce.split(`
`);for(O=b=0;b<st.length&&!st[b].includes("DetermineComponentFrameRoot");)b++;for(;O<Pt.length&&!Pt[O].includes("DetermineComponentFrameRoot");)O++;if(b===st.length||O===Pt.length)for(b=st.length-1,O=Pt.length-1;1<=b&&0<=O&&st[b]!==Pt[O];)O--;for(;1<=b&&0<=O;b--,O--)if(st[b]!==Pt[O]){if(b!==1||O!==1)do if(b--,O--,0>O||st[b]!==Pt[O]){var qt=`
`+st[b].replace(" at new "," at ");return a.displayName&&qt.includes("<anonymous>")&&(qt=qt.replace("<anonymous>",a.displayName)),qt}while(1<=b&&0<=O);break}}}finally{ze=!1,Error.prepareStackTrace=_}return(_=a?a.displayName||a.name:"")?ke(_):""}function Fe(a,u){switch(a.tag){case 26:case 27:case 5:return ke(a.type);case 16:return ke("Lazy");case 13:return a.child!==u&&u!==null?ke("Suspense Fallback"):ke("Suspense");case 19:return ke("SuspenseList");case 0:case 15:return je(a.type,!1);case 11:return je(a.type.render,!1);case 1:return je(a.type,!0);case 31:return ke("Activity");default:return""}}function Ye(a){try{var u="",_=null;do u+=Fe(a,_),_=a,a=a.return;while(a);return u}catch(b){return`
Error generating stack: `+b.message+`
`+b.stack}}var Ve=Object.prototype.hasOwnProperty,Qe=n.unstable_scheduleCallback,mt=n.unstable_cancelCallback,Tt=n.unstable_shouldYield,Me=n.unstable_requestPaint,me=n.unstable_now,$e=n.unstable_getCurrentPriorityLevel,et=n.unstable_ImmediatePriority,ht=n.unstable_UserBlockingPriority,at=n.unstable_NormalPriority,Et=n.unstable_LowPriority,Dt=n.unstable_IdlePriority,Vt=n.log,an=n.unstable_setDisableYieldValue,bt=null,Jt=null;function Tn(a){if(typeof Vt=="function"&&an(a),Jt&&typeof Jt.setStrictMode=="function")try{Jt.setStrictMode(bt,a)}catch{}}var We=Math.clz32?Math.clz32:qe,vt=Math.log,Yt=Math.LN2;function qe(a){return a>>>=0,a===0?32:31-(vt(a)/Yt|0)|0}var Kt=256,rn=262144,fe=4194304;function B(a){var u=a&42;if(u!==0)return u;switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return a&261888;case 262144:case 524288:case 1048576:case 2097152:return a&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return a&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return a}}function I(a,u,_){var b=a.pendingLanes;if(b===0)return 0;var O=0,V=a.suspendedLanes,he=a.pingedLanes;a=a.warmLanes;var Ce=b&134217727;return Ce!==0?(b=Ce&~V,b!==0?O=B(b):(he&=Ce,he!==0?O=B(he):_||(_=Ce&~a,_!==0&&(O=B(_))))):(Ce=b&~V,Ce!==0?O=B(Ce):he!==0?O=B(he):_||(_=b&~a,_!==0&&(O=B(_)))),O===0?0:u!==0&&u!==O&&(u&V)===0&&(V=O&-O,_=u&-u,V>=_||V===32&&(_&4194048)!==0)?u:O}function A(a,u){return(a.pendingLanes&~(a.suspendedLanes&~a.pingedLanes)&u)===0}function F(a,u){switch(a){case 1:case 2:case 4:case 8:case 64:return u+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return u+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function K(){var a=fe;return fe<<=1,(fe&62914560)===0&&(fe=4194304),a}function Ee(a){for(var u=[],_=0;31>_;_++)u.push(a);return u}function k(a,u){a.pendingLanes|=u,u!==268435456&&(a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0)}function re(a,u,_,b,O,V){var he=a.pendingLanes;a.pendingLanes=_,a.suspendedLanes=0,a.pingedLanes=0,a.warmLanes=0,a.expiredLanes&=_,a.entangledLanes&=_,a.errorRecoveryDisabledLanes&=_,a.shellSuspendCounter=0;var Ce=a.entanglements,st=a.expirationTimes,Pt=a.hiddenUpdates;for(_=he&~_;0<_;){var qt=31-We(_),nn=1<<qt;Ce[qt]=0,st[qt]=-1;var It=Pt[qt];if(It!==null)for(Pt[qt]=null,qt=0;qt<It.length;qt++){var kt=It[qt];kt!==null&&(kt.lane&=-536870913)}_&=~nn}b!==0&&Q(a,b,0),V!==0&&O===0&&a.tag!==0&&(a.suspendedLanes|=V&~(he&~u))}function Q(a,u,_){a.pendingLanes|=u,a.suspendedLanes&=~u;var b=31-We(u);a.entangledLanes|=u,a.entanglements[b]=a.entanglements[b]|1073741824|_&261930}function ve(a,u){var _=a.entangledLanes|=u;for(a=a.entanglements;_;){var b=31-We(_),O=1<<b;O&u|a[b]&u&&(a[b]|=u),_&=~O}}function ge(a,u){var _=u&-u;return _=(_&42)!==0?1:Le(_),(_&(a.suspendedLanes|u))!==0?0:_}function Le(a){switch(a){case 2:a=1;break;case 8:a=4;break;case 32:a=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:a=128;break;case 268435456:a=134217728;break;default:a=0}return a}function rt(a){return a&=-a,2<a?8<a?(a&134217727)!==0?32:268435456:8:2}function nt(){var a=le.p;return a!==0?a:(a=window.event,a===void 0?32:YS(a.type))}function ft(a,u){var _=le.p;try{return le.p=a,u()}finally{le.p=_}}var yt=Math.random().toString(36).slice(2),Ne="__reactFiber$"+yt,Bt="__reactProps$"+yt,on="__reactContainer$"+yt,xn="__reactEvents$"+yt,Bn="__reactListeners$"+yt,bi="__reactHandles$"+yt,gn="__reactResources$"+yt,Mn="__reactMarker$"+yt;function Se(a){delete a[Ne],delete a[Bt],delete a[xn],delete a[Bn],delete a[bi]}function we(a){var u=a[Ne];if(u)return u;for(var _=a.parentNode;_;){if(u=_[on]||_[Ne]){if(_=u.alternate,u.child!==null||_!==null&&_.child!==null)for(a=p_(a);a!==null;){if(_=a[Ne])return _;a=p_(a)}return u}a=_,_=a.parentNode}return null}function Ge(a){if(a=a[Ne]||a[on]){var u=a.tag;if(u===5||u===6||u===13||u===31||u===26||u===27||u===3)return a}return null}function Je(a){var u=a.tag;if(u===5||u===26||u===27||u===6)return a.stateNode;throw Error(i(33))}function Ue(a){var u=a[gn];return u||(u=a[gn]={hoistableStyles:new Map,hoistableScripts:new Map}),u}function Ot(a){a[Mn]=!0}var jt=new Set,tn={};function en(a,u){dn(a,u),dn(a+"Capture",u)}function dn(a,u){for(tn[a]=u,a=0;a<u.length;a++)jt.add(u[a])}var wn=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),_n={},Fn={};function ti(a){return Ve.call(Fn,a)?!0:Ve.call(_n,a)?!1:wn.test(a)?Fn[a]=!0:(_n[a]=!0,!1)}function Pn(a,u,_){if(ti(u))if(_===null)a.removeAttribute(u);else{switch(typeof _){case"undefined":case"function":case"symbol":a.removeAttribute(u);return;case"boolean":var b=u.toLowerCase().slice(0,5);if(b!=="data-"&&b!=="aria-"){a.removeAttribute(u);return}}a.setAttribute(u,""+_)}}function Ln(a,u,_){if(_===null)a.removeAttribute(u);else{switch(typeof _){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(u);return}a.setAttribute(u,""+_)}}function Ct(a,u,_,b){if(b===null)a.removeAttribute(_);else{switch(typeof b){case"undefined":case"function":case"symbol":case"boolean":a.removeAttribute(_);return}a.setAttributeNS(u,_,""+b)}}function gt(a){switch(typeof a){case"bigint":case"boolean":case"number":case"string":case"undefined":return a;case"object":return a;default:return""}}function Qt(a){var u=a.type;return(a=a.nodeName)&&a.toLowerCase()==="input"&&(u==="checkbox"||u==="radio")}function Nn(a,u,_){var b=Object.getOwnPropertyDescriptor(a.constructor.prototype,u);if(!a.hasOwnProperty(u)&&typeof b<"u"&&typeof b.get=="function"&&typeof b.set=="function"){var O=b.get,V=b.set;return Object.defineProperty(a,u,{configurable:!0,get:function(){return O.call(this)},set:function(he){_=""+he,V.call(this,he)}}),Object.defineProperty(a,u,{enumerable:b.enumerable}),{getValue:function(){return _},setValue:function(he){_=""+he},stopTracking:function(){a._valueTracker=null,delete a[u]}}}}function Ss(a){if(!a._valueTracker){var u=Qt(a)?"checked":"value";a._valueTracker=Nn(a,u,""+a[u])}}function yr(a){if(!a)return!1;var u=a._valueTracker;if(!u)return!0;var _=u.getValue(),b="";return a&&(b=Qt(a)?a.checked?"true":"false":a.value),a=b,a!==_?(u.setValue(a),!0):!1}function $i(a){if(a=a||(typeof document<"u"?document:void 0),typeof a>"u")return null;try{return a.activeElement||a.body}catch{return a.body}}var ma=/[\n"\\]/g;function fi(a){return a.replace(ma,function(u){return"\\"+u.charCodeAt(0).toString(16)+" "})}function ks(a,u,_,b,O,V,he,Ce){a.name="",he!=null&&typeof he!="function"&&typeof he!="symbol"&&typeof he!="boolean"?a.type=he:a.removeAttribute("type"),u!=null?he==="number"?(u===0&&a.value===""||a.value!=u)&&(a.value=""+gt(u)):a.value!==""+gt(u)&&(a.value=""+gt(u)):he!=="submit"&&he!=="reset"||a.removeAttribute("value"),u!=null?Ds(a,he,gt(u)):_!=null?Ds(a,he,gt(_)):b!=null&&a.removeAttribute("value"),O==null&&V!=null&&(a.defaultChecked=!!V),O!=null&&(a.checked=O&&typeof O!="function"&&typeof O!="symbol"),Ce!=null&&typeof Ce!="function"&&typeof Ce!="symbol"&&typeof Ce!="boolean"?a.name=""+gt(Ce):a.removeAttribute("name")}function $s(a,u,_,b,O,V,he,Ce){if(V!=null&&typeof V!="function"&&typeof V!="symbol"&&typeof V!="boolean"&&(a.type=V),u!=null||_!=null){if(!(V!=="submit"&&V!=="reset"||u!=null)){Ss(a);return}_=_!=null?""+gt(_):"",u=u!=null?""+gt(u):_,Ce||u===a.value||(a.value=u),a.defaultValue=u}b=b??O,b=typeof b!="function"&&typeof b!="symbol"&&!!b,a.checked=Ce?a.checked:!!b,a.defaultChecked=!!b,he!=null&&typeof he!="function"&&typeof he!="symbol"&&typeof he!="boolean"&&(a.name=he),Ss(a)}function Ds(a,u,_){u==="number"&&$i(a.ownerDocument)===a||a.defaultValue===""+_||(a.defaultValue=""+_)}function lt(a,u,_,b){if(a=a.options,u){u={};for(var O=0;O<_.length;O++)u["$"+_[O]]=!0;for(_=0;_<a.length;_++)O=u.hasOwnProperty("$"+a[_].value),a[_].selected!==O&&(a[_].selected=O),O&&b&&(a[_].defaultSelected=!0)}else{for(_=""+gt(_),u=null,O=0;O<a.length;O++){if(a[O].value===_){a[O].selected=!0,b&&(a[O].defaultSelected=!0);return}u!==null||a[O].disabled||(u=a[O])}u!==null&&(u.selected=!0)}}function de(a,u,_){if(u!=null&&(u=""+gt(u),u!==a.value&&(a.value=u),_==null)){a.defaultValue!==u&&(a.defaultValue=u);return}a.defaultValue=_!=null?""+gt(_):""}function Ie(a,u,_,b){if(u==null){if(b!=null){if(_!=null)throw Error(i(92));if(ne(b)){if(1<b.length)throw Error(i(93));b=b[0]}_=b}_==null&&(_=""),u=_}_=gt(u),a.defaultValue=_,b=a.textContent,b===_&&b!==""&&b!==null&&(a.value=b),Ss(a)}function Ke(a,u){if(u){var _=a.firstChild;if(_&&_===a.lastChild&&_.nodeType===3){_.nodeValue=u;return}}a.textContent=u}var Ze=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function wt(a,u,_){var b=u.indexOf("--")===0;_==null||typeof _=="boolean"||_===""?b?a.setProperty(u,""):u==="float"?a.cssFloat="":a[u]="":b?a.setProperty(u,_):typeof _!="number"||_===0||Ze.has(u)?u==="float"?a.cssFloat=_:a[u]=(""+_).trim():a[u]=_+"px"}function $t(a,u,_){if(u!=null&&typeof u!="object")throw Error(i(62));if(a=a.style,_!=null){for(var b in _)!_.hasOwnProperty(b)||u!=null&&u.hasOwnProperty(b)||(b.indexOf("--")===0?a.setProperty(b,""):b==="float"?a.cssFloat="":a[b]="");for(var O in u)b=u[O],u.hasOwnProperty(O)&&_[O]!==b&&wt(a,O,b)}else for(var V in u)u.hasOwnProperty(V)&&wt(a,V,u[V])}function vn(a){if(a.indexOf("-")===-1)return!1;switch(a){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var bn=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),En=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function un(a){return En.test(""+a)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":a}function Qn(){}var ni=null;function Ms(a){return a=a.target||a.srcElement||window,a.correspondingUseElement&&(a=a.correspondingUseElement),a.nodeType===3?a.parentNode:a}var bs=null,Ci=null;function ps(a){var u=Ge(a);if(u&&(a=u.stateNode)){var _=a[Bt]||null;e:switch(a=u.stateNode,u.type){case"input":if(ks(a,_.value,_.defaultValue,_.defaultValue,_.checked,_.defaultChecked,_.type,_.name),u=_.name,_.type==="radio"&&u!=null){for(_=a;_.parentNode;)_=_.parentNode;for(_=_.querySelectorAll('input[name="'+fi(""+u)+'"][type="radio"]'),u=0;u<_.length;u++){var b=_[u];if(b!==a&&b.form===a.form){var O=b[Bt]||null;if(!O)throw Error(i(90));ks(b,O.value,O.defaultValue,O.defaultValue,O.checked,O.defaultChecked,O.type,O.name)}}for(u=0;u<_.length;u++)b=_[u],b.form===a.form&&yr(b)}break e;case"textarea":de(a,_.value,_.defaultValue);break e;case"select":u=_.value,u!=null&&lt(a,!!_.multiple,u,!1)}}}var Ws=!1;function Wr(a,u,_){if(Ws)return a(u,_);Ws=!0;try{var b=a(u);return b}finally{if(Ws=!1,(bs!==null||Ci!==null)&&(De(),bs&&(u=bs,a=Ci,Ci=bs=null,ps(u),a)))for(u=0;u<a.length;u++)ps(a[u])}}function Kr(a,u){var _=a.stateNode;if(_===null)return null;var b=_[Bt]||null;if(b===null)return null;_=b[u];e:switch(u){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(b=!b.disabled)||(a=a.type,b=!(a==="button"||a==="input"||a==="select"||a==="textarea")),a=!b;break e;default:a=!1}if(a)return null;if(_&&typeof _!="function")throw Error(i(231,u,typeof _));return _}var Bs=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),co=!1;if(Bs)try{var es={};Object.defineProperty(es,"passive",{get:function(){co=!0}}),window.addEventListener("test",es,es),window.removeEventListener("test",es,es)}catch{co=!1}var ms=null,Sr=null,Fr=null;function na(){if(Fr)return Fr;var a,u=Sr,_=u.length,b,O="value"in ms?ms.value:ms.textContent,V=O.length;for(a=0;a<_&&u[a]===O[a];a++);var he=_-a;for(b=1;b<=he&&u[_-b]===O[V-b];b++);return Fr=O.slice(a,1<b?1-b:void 0)}function Ks(a){var u=a.keyCode;return"charCode"in a?(a=a.charCode,a===0&&u===13&&(a=13)):a=u,a===10&&(a=13),32<=a||a===13?a:0}function ia(){return!0}function Gs(){return!1}function Pi(a){function u(_,b,O,V,he){this._reactName=_,this._targetInst=O,this.type=b,this.nativeEvent=V,this.target=he,this.currentTarget=null;for(var Ce in a)a.hasOwnProperty(Ce)&&(_=a[Ce],this[Ce]=_?_(V):V[Ce]);return this.isDefaultPrevented=(V.defaultPrevented!=null?V.defaultPrevented:V.returnValue===!1)?ia:Gs,this.isPropagationStopped=Gs,this}return p(u.prototype,{preventDefault:function(){this.defaultPrevented=!0;var _=this.nativeEvent;_&&(_.preventDefault?_.preventDefault():typeof _.returnValue!="unknown"&&(_.returnValue=!1),this.isDefaultPrevented=ia)},stopPropagation:function(){var _=this.nativeEvent;_&&(_.stopPropagation?_.stopPropagation():typeof _.cancelBubble!="unknown"&&(_.cancelBubble=!0),this.isPropagationStopped=ia)},persist:function(){},isPersistent:ia}),u}var ns={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Ns=Pi(ns),Vs=p({},ns,{view:0,detail:0}),Ba=Pi(Vs),Dl,ec,uu,tc=p({},Vs,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:cu,button:0,buttons:0,relatedTarget:function(a){return a.relatedTarget===void 0?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){return"movementX"in a?a.movementX:(a!==uu&&(uu&&a.type==="mousemove"?(Dl=a.screenX-uu.screenX,ec=a.screenY-uu.screenY):ec=Dl=0,uu=a),Dl)},movementY:function(a){return"movementY"in a?a.movementY:ec}}),Vf=Pi(tc),qs=p({},tc,{dataTransfer:0}),Hf=Pi(qs),jf=p({},Vs,{relatedTarget:0}),Uc=Pi(jf),$f=p({},ns,{animationName:0,elapsedTime:0,pseudoElement:0}),Wf=Pi($f),Do=p({},ns,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Vd=Pi(Do),Hd=p({},ns,{data:0}),kc=Pi(Hd),jd={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},$d={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Gc={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Wd(a){var u=this.nativeEvent;return u.getModifierState?u.getModifierState(a):(a=Gc[a])?!!u[a]:!1}function cu(){return Wd}var el=p({},Vs,{key:function(a){if(a.key){var u=jd[a.key]||a.key;if(u!=="Unidentified")return u}return a.type==="keypress"?(a=Ks(a),a===13?"Enter":String.fromCharCode(a)):a.type==="keydown"||a.type==="keyup"?$d[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:cu,charCode:function(a){return a.type==="keypress"?Ks(a):0},keyCode:function(a){return a.type==="keydown"||a.type==="keyup"?a.keyCode:0},which:function(a){return a.type==="keypress"?Ks(a):a.type==="keydown"||a.type==="keyup"?a.keyCode:0}}),Kd=Pi(el),Vc=p({},tc,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Hc=Pi(Vc),qd=p({},Vs,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:cu}),tl=Pi(qd),nc=p({},ns,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=Pi(nc),Yd=p({},tc,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),fo=Pi(Yd),Bo=p({},ns,{newState:0,oldState:0}),Jd=Pi(Bo),Qd=[9,13,27,32],Bl=Bs&&"CompositionEvent"in window,nl=null;Bs&&"documentMode"in document&&(nl=document.documentMode);var Il=Bs&&"TextEvent"in window&&!nl,Ar=Bs&&(!Bl||nl&&8<nl&&11>=nl),il=" ",sl=!1;function ic(a,u){switch(a){case"keyup":return Qd.indexOf(u.keyCode)!==-1;case"keydown":return u.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function rl(a){return a=a.detail,typeof a=="object"&&"data"in a?a.data:null}var Io=!1;function du(a,u){switch(a){case"compositionend":return rl(u);case"keypress":return u.which!==32?null:(sl=!0,il);case"textInput":return a=u.data,a===il&&sl?null:a;default:return null}}function sc(a,u){if(Io)return a==="compositionend"||!Bl&&ic(a,u)?(a=na(),Fr=Sr=ms=null,Io=!1,a):null;switch(a){case"paste":return null;case"keypress":if(!(u.ctrlKey||u.altKey||u.metaKey)||u.ctrlKey&&u.altKey){if(u.char&&1<u.char.length)return u.char;if(u.which)return String.fromCharCode(u.which)}return null;case"compositionend":return Ar&&u.locale!=="ko"?null:u.data;default:return null}}var cr={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function jc(a){var u=a&&a.nodeName&&a.nodeName.toLowerCase();return u==="input"?!!cr[a.type]:u==="textarea"}function $c(a,u,_,b){bs?Ci?Ci.push(b):Ci=[b]:bs=b,u=ut(u,"onChange"),0<u.length&&(_=new Ns("onChange","change",null,_,b),a.push({event:_,listeners:u}))}var Ol=null,fu=null;function Wc(a){Ca(a,0)}function Ll(a){var u=Je(a);if(yr(u))return a}function Kc(a,u){if(a==="change")return u}var hu=!1;if(Bs){var ho;if(Bs){var yn="oninput"in document;if(!yn){var Kf=document.createElement("div");Kf.setAttribute("oninput","return;"),yn=typeof Kf.oninput=="function"}ho=yn}else ho=!1;hu=ho&&(!document.documentMode||9<document.documentMode)}function rc(){Ol&&(Ol.detachEvent("onpropertychange",qc),fu=Ol=null)}function qc(a){if(a.propertyName==="value"&&Ll(fu)){var u=[];$c(u,fu,a,Ms(a)),Wr(Wc,u)}}function al(a,u,_){a==="focusin"?(rc(),Ol=u,fu=_,Ol.attachEvent("onpropertychange",qc)):a==="focusout"&&rc()}function Cr(a){if(a==="selectionchange"||a==="keyup"||a==="keydown")return Ll(fu)}function pu(a,u){if(a==="click")return Ll(u)}function Xc(a,u){if(a==="input"||a==="change")return Ll(u)}function ol(a,u){return a===u&&(a!==0||1/a===1/u)||a!==a&&u!==u}var gs=typeof Object.is=="function"?Object.is:ol;function Fl(a,u){if(gs(a,u))return!0;if(typeof a!="object"||a===null||typeof u!="object"||u===null)return!1;var _=Object.keys(a),b=Object.keys(u);if(_.length!==b.length)return!1;for(b=0;b<_.length;b++){var O=_[b];if(!Ve.call(u,O)||!gs(a[O],u[O]))return!1}return!0}function ac(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function oc(a,u){var _=ac(a);a=0;for(var b;_;){if(_.nodeType===3){if(b=a+_.textContent.length,a<=u&&b>=u)return{node:_,offset:u-a};a=b}e:{for(;_;){if(_.nextSibling){_=_.nextSibling;break e}_=_.parentNode}_=void 0}_=ac(_)}}function lc(a,u){return a&&u?a===u?!0:a&&a.nodeType===3?!1:u&&u.nodeType===3?lc(a,u.parentNode):"contains"in a?a.contains(u):a.compareDocumentPosition?!!(a.compareDocumentPosition(u)&16):!1:!1}function uc(a){a=a!=null&&a.ownerDocument!=null&&a.ownerDocument.defaultView!=null?a.ownerDocument.defaultView:window;for(var u=$i(a.document);u instanceof a.HTMLIFrameElement;){try{var _=typeof u.contentWindow.location.href=="string"}catch{_=!1}if(_)a=u.contentWindow;else break;u=$i(a.document)}return u}function po(a){var u=a&&a.nodeName&&a.nodeName.toLowerCase();return u&&(u==="input"&&(a.type==="text"||a.type==="search"||a.type==="tel"||a.type==="url"||a.type==="password")||u==="textarea"||a.contentEditable==="true")}var Yc=Bs&&"documentMode"in document&&11>=document.documentMode,ll=null,mu=null,Nl=null,sa=!1;function gu(a,u,_){var b=_.window===_?_.document:_.nodeType===9?_:_.ownerDocument;sa||ll==null||ll!==$i(b)||(b=ll,"selectionStart"in b&&po(b)?b={start:b.selectionStart,end:b.selectionEnd}:(b=(b.ownerDocument&&b.ownerDocument.defaultView||window).getSelection(),b={anchorNode:b.anchorNode,anchorOffset:b.anchorOffset,focusNode:b.focusNode,focusOffset:b.focusOffset}),Nl&&Fl(Nl,b)||(Nl=b,b=ut(mu,"onSelect"),0<b.length&&(u=new Ns("onSelect","select",null,u,_),a.push({event:u,listeners:b}),u.target=ll)))}function Oo(a,u){var _={};return _[a.toLowerCase()]=u.toLowerCase(),_["Webkit"+a]="webkit"+u,_["Moz"+a]="moz"+u,_}var G={animationend:Oo("Animation","AnimationEnd"),animationiteration:Oo("Animation","AnimationIteration"),animationstart:Oo("Animation","AnimationStart"),transitionrun:Oo("Transition","TransitionRun"),transitionstart:Oo("Transition","TransitionStart"),transitioncancel:Oo("Transition","TransitionCancel"),transitionend:Oo("Transition","TransitionEnd")},Z={},_e={};Bs&&(_e=document.createElement("div").style,"AnimationEvent"in window||(delete G.animationend.animation,delete G.animationiteration.animation,delete G.animationstart.animation),"TransitionEvent"in window||delete G.transitionend.transition);function Te(a){if(Z[a])return Z[a];if(!G[a])return a;var u=G[a],_;for(_ in u)if(u.hasOwnProperty(_)&&_ in _e)return Z[a]=u[_];return a}var Re=Te("animationend"),ct=Te("animationiteration"),Nt=Te("animationstart"),sn=Te("transitionrun"),pn=Te("transitionstart"),On=Te("transitioncancel"),Zn=Te("transitionend"),hi=new Map,zi="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");zi.push("scrollEnd");function ki(a,u){hi.set(a,u),en(u,[a])}var ga=typeof reportError=="function"?reportError:function(a){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var u=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof a=="object"&&a!==null&&typeof a.message=="string"?String(a.message):String(a),error:a});if(!window.dispatchEvent(u))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",a);return}console.error(a)},dr=[],cc=0,qf=0;function zl(){for(var a=cc,u=qf=cc=0;u<a;){var _=dr[u];dr[u++]=null;var b=dr[u];dr[u++]=null;var O=dr[u];dr[u++]=null;var V=dr[u];if(dr[u++]=null,b!==null&&O!==null){var he=b.pending;he===null?O.next=O:(O.next=he.next,he.next=O),b.pending=O}V!==0&&Xf(_,O,V)}}function Zd(a,u,_,b){dr[cc++]=a,dr[cc++]=u,dr[cc++]=_,dr[cc++]=b,qf|=b,a.lanes|=b,a=a.alternate,a!==null&&(a.lanes|=b)}function Jc(a,u,_,b){return Zd(a,u,_,b),Qc(a)}function Ul(a,u){return Zd(a,null,null,u),Qc(a)}function Xf(a,u,_){a.lanes|=_;var b=a.alternate;b!==null&&(b.lanes|=_);for(var O=!1,V=a.return;V!==null;)V.childLanes|=_,b=V.alternate,b!==null&&(b.childLanes|=_),V.tag===22&&(a=V.stateNode,a===null||a._visibility&1||(O=!0)),a=V,V=V.return;return a.tag===3?(V=a.stateNode,O&&u!==null&&(O=31-We(_),a=V.hiddenUpdates,b=a[O],b===null?a[O]=[u]:b.push(u),u.lane=_|536870912),V):null}function Qc(a){if(50<Fu)throw Fu=0,yd=null,Error(i(185));for(var u=a.return;u!==null;)a=u,u=a.return;return a.tag===3?a.stateNode:null}var kl={};function Mm(a,u,_,b){this.tag=a,this.key=_,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=u,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=b,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function _a(a,u,_,b){return new Mm(a,u,_,b)}function ra(a){return a=a.prototype,!(!a||!a.isReactComponent)}function ul(a,u){var _=a.alternate;return _===null?(_=_a(a.tag,u,a.key,a.mode),_.elementType=a.elementType,_.type=a.type,_.stateNode=a.stateNode,_.alternate=a,a.alternate=_):(_.pendingProps=u,_.type=a.type,_.flags=0,_.subtreeFlags=0,_.deletions=null),_.flags=a.flags&65011712,_.childLanes=a.childLanes,_.lanes=a.lanes,_.child=a.child,_.memoizedProps=a.memoizedProps,_.memoizedState=a.memoizedState,_.updateQueue=a.updateQueue,u=a.dependencies,_.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext},_.sibling=a.sibling,_.index=a.index,_.ref=a.ref,_.refCleanup=a.refCleanup,_}function aa(a,u){a.flags&=65011714;var _=a.alternate;return _===null?(a.childLanes=0,a.lanes=u,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=_.childLanes,a.lanes=_.lanes,a.child=_.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=_.memoizedProps,a.memoizedState=_.memoizedState,a.updateQueue=_.updateQueue,a.type=_.type,u=_.dependencies,a.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext}),a}function Zc(a,u,_,b,O,V){var he=0;if(b=a,typeof a=="function")ra(a)&&(he=1);else if(typeof a=="string")he=qN(a,_,ae.current)?26:a==="html"||a==="head"||a==="body"?27:5;else e:switch(a){case U:return a=_a(31,_,u,O),a.elementType=U,a.lanes=V,a;case w:return Gl(_.children,O,V,u);case S:he=8,O|=24;break;case M:return a=_a(12,_,u,O|2),a.elementType=M,a.lanes=V,a;case R:return a=_a(13,_,u,O),a.elementType=R,a.lanes=V,a;case P:return a=_a(19,_,u,O),a.elementType=P,a.lanes=V,a;default:if(typeof a=="object"&&a!==null)switch(a.$$typeof){case C:he=10;break e;case T:he=9;break e;case x:he=11;break e;case D:he=14;break e;case z:he=16,b=null;break e}he=29,_=Error(i(130,a===null?"null":typeof a,"")),b=null}return u=_a(he,_,u,O),u.elementType=a,u.type=b,u.lanes=V,u}function Gl(a,u,_,b){return a=_a(7,a,b,u),a.lanes=_,a}function Yf(a,u,_){return a=_a(6,a,null,u),a.lanes=_,a}function Xh(a){var u=_a(18,null,null,0);return u.stateNode=a,u}function Lo(a,u,_){return u=_a(4,a.children!==null?a.children:[],a.key,u),u.lanes=_,u.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation},u}var Yh=new WeakMap;function va(a,u){if(typeof a=="object"&&a!==null){var _=Yh.get(a);return _!==void 0?_:(u={value:a,source:u,stack:Ye(u)},Yh.set(a,u),u)}return{value:a,source:u,stack:Ye(u)}}var Fo=[],dc=0,ed=null,td=0,Ka=[],ya=0,cl=null,dl=1,No="";function Vl(a,u){Fo[dc++]=td,Fo[dc++]=ed,ed=a,td=u}function Jh(a,u,_){Ka[ya++]=dl,Ka[ya++]=No,Ka[ya++]=cl,cl=a;var b=dl;a=No;var O=32-We(b)-1;b&=~(1<<O),_+=1;var V=32-We(u)+O;if(30<V){var he=O-O%5;V=(b&(1<<he)-1).toString(32),b>>=he,O-=he,dl=1<<32-We(u)+O|_<<O|b,No=V+a}else dl=1<<V|_<<O|b,No=a}function ef(a){a.return!==null&&(Vl(a,1),Jh(a,1,0))}function _u(a){for(;a===ed;)ed=Fo[--dc],Fo[dc]=null,td=Fo[--dc],Fo[dc]=null;for(;a===cl;)cl=Ka[--ya],Ka[ya]=null,No=Ka[--ya],Ka[ya]=null,dl=Ka[--ya],Ka[ya]=null}function tf(a,u){Ka[ya++]=dl,Ka[ya++]=No,Ka[ya++]=cl,dl=u.id,No=u.overflow,cl=a}var Pr=null,Is=null,Ui=!1,fl=null,Nr=!1,Jf=Error(i(519));function Ri(a){var u=Error(i(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw nd(va(u,a)),Jf}function Qf(a){var u=a.stateNode,_=a.type,b=a.memoizedProps;switch(u[Ne]=a,u[Bt]=b,_){case"dialog":yi("cancel",u),yi("close",u);break;case"iframe":case"object":case"embed":yi("load",u);break;case"video":case"audio":for(_=0;_<gr.length;_++)yi(gr[_],u);break;case"source":yi("error",u);break;case"img":case"image":case"link":yi("error",u),yi("load",u);break;case"details":yi("toggle",u);break;case"input":yi("invalid",u),$s(u,b.value,b.defaultValue,b.checked,b.defaultChecked,b.type,b.name,!0);break;case"select":yi("invalid",u);break;case"textarea":yi("invalid",u),Ie(u,b.value,b.defaultValue,b.children)}_=b.children,typeof _!="string"&&typeof _!="number"&&typeof _!="bigint"||u.textContent===""+_||b.suppressHydrationWarning===!0||In(u.textContent,_)?(b.popover!=null&&(yi("beforetoggle",u),yi("toggle",u)),b.onScroll!=null&&yi("scroll",u),b.onScrollEnd!=null&&yi("scrollend",u),b.onClick!=null&&(u.onclick=Qn),u=!0):u=!1,u||Ri(a,!0)}function bm(a){for(Pr=a.return;Pr;)switch(Pr.tag){case 5:case 31:case 13:Nr=!1;return;case 27:case 3:Nr=!0;return;default:Pr=Pr.return}}function vu(a){if(a!==Pr)return!1;if(!Ui)return bm(a),Ui=!0,!1;var u=a.tag,_;if((_=u!==3&&u!==27)&&((_=u===5)&&(_=a.type,_=!(_!=="form"&&_!=="button")||or(a.type,a.memoizedProps)),_=!_),_&&Is&&Ri(a),bm(a),u===13){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(i(317));Is=h_(a)}else if(u===31){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(i(317));Is=h_(a)}else u===27?(u=Is,El(a.type)?(a=Qm,Qm=null,Is=a):Is=u):Is=Pr?Co(a.stateNode.nextSibling):null;return!0}function fc(){Is=Pr=null,Ui=!1}function Qh(){var a=fl;return a!==null&&(ca===null?ca=a:ca.push.apply(ca,a),fl=null),a}function nd(a){fl===null?fl=[a]:fl.push(a)}var Zh=ee(null),Hl=null,qr=null;function jl(a,u,_){ue(Zh,u._currentValue),u._currentValue=_}function mo(a){a._currentValue=Zh.current,te(Zh)}function hl(a,u,_){for(;a!==null;){var b=a.alternate;if((a.childLanes&u)!==u?(a.childLanes|=u,b!==null&&(b.childLanes|=u)):b!==null&&(b.childLanes&u)!==u&&(b.childLanes|=u),a===_)break;a=a.return}}function Zf(a,u,_,b){var O=a.child;for(O!==null&&(O.return=a);O!==null;){var V=O.dependencies;if(V!==null){var he=O.child;V=V.firstContext;e:for(;V!==null;){var Ce=V;V=O;for(var st=0;st<u.length;st++)if(Ce.context===u[st]){V.lanes|=_,Ce=V.alternate,Ce!==null&&(Ce.lanes|=_),hl(V.return,_,a),b||(he=null);break e}V=Ce.next}}else if(O.tag===18){if(he=O.return,he===null)throw Error(i(341));he.lanes|=_,V=he.alternate,V!==null&&(V.lanes|=_),hl(he,_,a),he=null}else he=O.child;if(he!==null)he.return=O;else for(he=O;he!==null;){if(he===a){he=null;break}if(O=he.sibling,O!==null){O.return=he.return,he=O;break}he=he.return}O=he}}function yu(a,u,_,b){a=null;for(var O=u,V=!1;O!==null;){if(!V){if((O.flags&524288)!==0)V=!0;else if((O.flags&262144)!==0)break}if(O.tag===10){var he=O.alternate;if(he===null)throw Error(i(387));if(he=he.memoizedProps,he!==null){var Ce=O.type;gs(O.pendingProps.value,he.value)||(a!==null?a.push(Ce):a=[Ce])}}else if(O===He.current){if(he=O.alternate,he===null)throw Error(i(387));he.memoizedState.memoizedState!==O.memoizedState.memoizedState&&(a!==null?a.push(O0):a=[O0])}O=O.return}a!==null&&Zf(u,a,_,b),u.flags|=262144}function id(a){for(a=a.firstContext;a!==null;){if(!gs(a.context._currentValue,a.memoizedValue))return!0;a=a.next}return!1}function hc(a){Hl=a,qr=null,a=a.dependencies,a!==null&&(a.firstContext=null)}function Rr(a){return ep(Hl,a)}function nf(a,u){return Hl===null&&hc(a),ep(a,u)}function ep(a,u){var _=u._currentValue;if(u={context:u,memoizedValue:_,next:null},qr===null){if(a===null)throw Error(i(308));qr=u,a.dependencies={lanes:0,firstContext:u},a.flags|=524288}else qr=qr.next=u;return _}var tp=typeof AbortController<"u"?AbortController:function(){var a=[],u=this.signal={aborted:!1,addEventListener:function(_,b){a.push(b)}};this.abort=function(){u.aborted=!0,a.forEach(function(_){return _()})}},xm=n.unstable_scheduleCallback,np=n.unstable_NormalPriority,Kn={$$typeof:C,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function ip(){return{controller:new tp,data:new Map,refCount:0}}function Xr(a){a.refCount--,a.refCount===0&&xm(np,function(){a.controller.abort()})}var Mu=null,sp=0,$l=0,go=null;function sd(a,u){if(Mu===null){var _=Mu=[];sp=0,$l=C0(),go={status:"pending",value:void 0,then:function(b){_.push(b)}}}return sp++,u.then(rp,rp),u}function rp(){if(--sp===0&&Mu!==null){go!==null&&(go.status="fulfilled");var a=Mu;Mu=null,$l=0,go=null;for(var u=0;u<a.length;u++)(0,a[u])()}}function eh(a,u){var _=[],b={status:"pending",value:null,reason:null,then:function(O){_.push(O)}};return a.then(function(){b.status="fulfilled",b.value=u;for(var O=0;O<_.length;O++)(0,_[O])(u)},function(O){for(b.status="rejected",b.reason=O,O=0;O<_.length;O++)(0,_[O])(void 0)}),b}var wm=q.S;q.S=function(a,u){Li=me(),typeof u=="object"&&u!==null&&typeof u.then=="function"&&sd(a,u),wm!==null&&wm(a,u)};var bu=ee(null);function zo(){var a=bu.current;return a!==null?a:rs.pooledCache}function rd(a,u){u===null?ue(bu,bu.current):ue(bu,u.pool)}function th(){var a=zo();return a===null?null:{parent:Kn._currentValue,pool:a}}var xu=Error(i(460)),sf=Error(i(474)),_o=Error(i(542)),rf={then:function(){}};function Em(a){return a=a.status,a==="fulfilled"||a==="rejected"}function ap(a,u,_){switch(_=a[_],_===void 0?a.push(u):_!==u&&(u.then(Qn,Qn),u=_),u.status){case"fulfilled":return u.value;case"rejected":throw a=u.reason,op(a),a;default:if(typeof u.status=="string")u.then(Qn,Qn);else{if(a=rs,a!==null&&100<a.shellSuspendCounter)throw Error(i(482));a=u,a.status="pending",a.then(function(b){if(u.status==="pending"){var O=u;O.status="fulfilled",O.value=b}},function(b){if(u.status==="pending"){var O=u;O.status="rejected",O.reason=b}})}switch(u.status){case"fulfilled":return u.value;case"rejected":throw a=u.reason,op(a),a}throw Jn=u,xu}}function pc(a){try{var u=a._init;return u(a._payload)}catch(_){throw _!==null&&typeof _=="object"&&typeof _.then=="function"?(Jn=_,xu):_}}var Jn=null;function nh(){if(Jn===null)throw Error(i(459));var a=Jn;return Jn=null,a}function op(a){if(a===xu||a===_o)throw Error(i(483))}var wu=null,Eu=0;function af(a){var u=Eu;return Eu+=1,wu===null&&(wu=[]),ap(wu,a,u)}function of(a,u){u=u.props.ref,a.ref=u!==void 0?u:null}function lf(a,u){throw u.$$typeof===h?Error(i(525)):(a=Object.prototype.toString.call(u),Error(i(31,a==="[object Object]"?"object with keys {"+Object.keys(u).join(", ")+"}":a)))}function ad(a){function u(Mt,dt){if(a){var At=Mt.deletions;At===null?(Mt.deletions=[dt],Mt.flags|=16):At.push(dt)}}function _(Mt,dt){if(!a)return null;for(;dt!==null;)u(Mt,dt),dt=dt.sibling;return null}function b(Mt){for(var dt=new Map;Mt!==null;)Mt.key!==null?dt.set(Mt.key,Mt):dt.set(Mt.index,Mt),Mt=Mt.sibling;return dt}function O(Mt,dt){return Mt=ul(Mt,dt),Mt.index=0,Mt.sibling=null,Mt}function V(Mt,dt,At){return Mt.index=At,a?(At=Mt.alternate,At!==null?(At=At.index,At<dt?(Mt.flags|=67108866,dt):At):(Mt.flags|=67108866,dt)):(Mt.flags|=1048576,dt)}function he(Mt){return a&&Mt.alternate===null&&(Mt.flags|=67108866),Mt}function Ce(Mt,dt,At,Zt){return dt===null||dt.tag!==6?(dt=Yf(At,Mt.mode,Zt),dt.return=Mt,dt):(dt=O(dt,At),dt.return=Mt,dt)}function st(Mt,dt,At,Zt){var ei=At.type;return ei===w?qt(Mt,dt,At.props.children,Zt,At.key):dt!==null&&(dt.elementType===ei||typeof ei=="object"&&ei!==null&&ei.$$typeof===z&&pc(ei)===dt.type)?(dt=O(dt,At.props),of(dt,At),dt.return=Mt,dt):(dt=Zc(At.type,At.key,At.props,null,Mt.mode,Zt),of(dt,At),dt.return=Mt,dt)}function Pt(Mt,dt,At,Zt){return dt===null||dt.tag!==4||dt.stateNode.containerInfo!==At.containerInfo||dt.stateNode.implementation!==At.implementation?(dt=Lo(At,Mt.mode,Zt),dt.return=Mt,dt):(dt=O(dt,At.children||[]),dt.return=Mt,dt)}function qt(Mt,dt,At,Zt,ei){return dt===null||dt.tag!==7?(dt=Gl(At,Mt.mode,Zt,ei),dt.return=Mt,dt):(dt=O(dt,At),dt.return=Mt,dt)}function nn(Mt,dt,At){if(typeof dt=="string"&&dt!==""||typeof dt=="number"||typeof dt=="bigint")return dt=Yf(""+dt,Mt.mode,At),dt.return=Mt,dt;if(typeof dt=="object"&&dt!==null){switch(dt.$$typeof){case v:return At=Zc(dt.type,dt.key,dt.props,null,Mt.mode,At),of(At,dt),At.return=Mt,At;case y:return dt=Lo(dt,Mt.mode,At),dt.return=Mt,dt;case z:return dt=pc(dt),nn(Mt,dt,At)}if(ne(dt)||J(dt))return dt=Gl(dt,Mt.mode,At,null),dt.return=Mt,dt;if(typeof dt.then=="function")return nn(Mt,af(dt),At);if(dt.$$typeof===C)return nn(Mt,nf(Mt,dt),At);lf(Mt,dt)}return null}function It(Mt,dt,At,Zt){var ei=dt!==null?dt.key:null;if(typeof At=="string"&&At!==""||typeof At=="number"||typeof At=="bigint")return ei!==null?null:Ce(Mt,dt,""+At,Zt);if(typeof At=="object"&&At!==null){switch(At.$$typeof){case v:return At.key===ei?st(Mt,dt,At,Zt):null;case y:return At.key===ei?Pt(Mt,dt,At,Zt):null;case z:return At=pc(At),It(Mt,dt,At,Zt)}if(ne(At)||J(At))return ei!==null?null:qt(Mt,dt,At,Zt,null);if(typeof At.then=="function")return It(Mt,dt,af(At),Zt);if(At.$$typeof===C)return It(Mt,dt,nf(Mt,At),Zt);lf(Mt,At)}return null}function kt(Mt,dt,At,Zt,ei){if(typeof Zt=="string"&&Zt!==""||typeof Zt=="number"||typeof Zt=="bigint")return Mt=Mt.get(At)||null,Ce(dt,Mt,""+Zt,ei);if(typeof Zt=="object"&&Zt!==null){switch(Zt.$$typeof){case v:return Mt=Mt.get(Zt.key===null?At:Zt.key)||null,st(dt,Mt,Zt,ei);case y:return Mt=Mt.get(Zt.key===null?At:Zt.key)||null,Pt(dt,Mt,Zt,ei);case z:return Zt=pc(Zt),kt(Mt,dt,At,Zt,ei)}if(ne(Zt)||J(Zt))return Mt=Mt.get(At)||null,qt(dt,Mt,Zt,ei,null);if(typeof Zt.then=="function")return kt(Mt,dt,At,af(Zt),ei);if(Zt.$$typeof===C)return kt(Mt,dt,At,nf(dt,Zt),ei);lf(dt,Zt)}return null}function Gn(Mt,dt,At,Zt){for(var ei=null,As=null,Yn=dt,Fi=dt=0,ts=null;Yn!==null&&Fi<At.length;Fi++){Yn.index>Fi?(ts=Yn,Yn=null):ts=Yn.sibling;var Cs=It(Mt,Yn,At[Fi],Zt);if(Cs===null){Yn===null&&(Yn=ts);break}a&&Yn&&Cs.alternate===null&&u(Mt,Yn),dt=V(Cs,dt,Fi),As===null?ei=Cs:As.sibling=Cs,As=Cs,Yn=ts}if(Fi===At.length)return _(Mt,Yn),Ui&&Vl(Mt,Fi),ei;if(Yn===null){for(;Fi<At.length;Fi++)Yn=nn(Mt,At[Fi],Zt),Yn!==null&&(dt=V(Yn,dt,Fi),As===null?ei=Yn:As.sibling=Yn,As=Yn);return Ui&&Vl(Mt,Fi),ei}for(Yn=b(Yn);Fi<At.length;Fi++)ts=kt(Yn,Mt,Fi,At[Fi],Zt),ts!==null&&(a&&ts.alternate!==null&&Yn.delete(ts.key===null?Fi:ts.key),dt=V(ts,dt,Fi),As===null?ei=ts:As.sibling=ts,As=ts);return a&&Yn.forEach(function(qp){return u(Mt,qp)}),Ui&&Vl(Mt,Fi),ei}function ui(Mt,dt,At,Zt){if(At==null)throw Error(i(151));for(var ei=null,As=null,Yn=dt,Fi=dt=0,ts=null,Cs=At.next();Yn!==null&&!Cs.done;Fi++,Cs=At.next()){Yn.index>Fi?(ts=Yn,Yn=null):ts=Yn.sibling;var qp=It(Mt,Yn,Cs.value,Zt);if(qp===null){Yn===null&&(Yn=ts);break}a&&Yn&&qp.alternate===null&&u(Mt,Yn),dt=V(qp,dt,Fi),As===null?ei=qp:As.sibling=qp,As=qp,Yn=ts}if(Cs.done)return _(Mt,Yn),Ui&&Vl(Mt,Fi),ei;if(Yn===null){for(;!Cs.done;Fi++,Cs=At.next())Cs=nn(Mt,Cs.value,Zt),Cs!==null&&(dt=V(Cs,dt,Fi),As===null?ei=Cs:As.sibling=Cs,As=Cs);return Ui&&Vl(Mt,Fi),ei}for(Yn=b(Yn);!Cs.done;Fi++,Cs=At.next())Cs=kt(Yn,Mt,Fi,Cs.value,Zt),Cs!==null&&(a&&Cs.alternate!==null&&Yn.delete(Cs.key===null?Fi:Cs.key),dt=V(Cs,dt,Fi),As===null?ei=Cs:As.sibling=Cs,As=Cs);return a&&Yn.forEach(function(rz){return u(Mt,rz)}),Ui&&Vl(Mt,Fi),ei}function Zs(Mt,dt,At,Zt){if(typeof At=="object"&&At!==null&&At.type===w&&At.key===null&&(At=At.props.children),typeof At=="object"&&At!==null){switch(At.$$typeof){case v:e:{for(var ei=At.key;dt!==null;){if(dt.key===ei){if(ei=At.type,ei===w){if(dt.tag===7){_(Mt,dt.sibling),Zt=O(dt,At.props.children),Zt.return=Mt,Mt=Zt;break e}}else if(dt.elementType===ei||typeof ei=="object"&&ei!==null&&ei.$$typeof===z&&pc(ei)===dt.type){_(Mt,dt.sibling),Zt=O(dt,At.props),of(Zt,At),Zt.return=Mt,Mt=Zt;break e}_(Mt,dt);break}else u(Mt,dt);dt=dt.sibling}At.type===w?(Zt=Gl(At.props.children,Mt.mode,Zt,At.key),Zt.return=Mt,Mt=Zt):(Zt=Zc(At.type,At.key,At.props,null,Mt.mode,Zt),of(Zt,At),Zt.return=Mt,Mt=Zt)}return he(Mt);case y:e:{for(ei=At.key;dt!==null;){if(dt.key===ei)if(dt.tag===4&&dt.stateNode.containerInfo===At.containerInfo&&dt.stateNode.implementation===At.implementation){_(Mt,dt.sibling),Zt=O(dt,At.children||[]),Zt.return=Mt,Mt=Zt;break e}else{_(Mt,dt);break}else u(Mt,dt);dt=dt.sibling}Zt=Lo(At,Mt.mode,Zt),Zt.return=Mt,Mt=Zt}return he(Mt);case z:return At=pc(At),Zs(Mt,dt,At,Zt)}if(ne(At))return Gn(Mt,dt,At,Zt);if(J(At)){if(ei=J(At),typeof ei!="function")throw Error(i(150));return At=ei.call(At),ui(Mt,dt,At,Zt)}if(typeof At.then=="function")return Zs(Mt,dt,af(At),Zt);if(At.$$typeof===C)return Zs(Mt,dt,nf(Mt,At),Zt);lf(Mt,At)}return typeof At=="string"&&At!==""||typeof At=="number"||typeof At=="bigint"?(At=""+At,dt!==null&&dt.tag===6?(_(Mt,dt.sibling),Zt=O(dt,At),Zt.return=Mt,Mt=Zt):(_(Mt,dt),Zt=Yf(At,Mt.mode,Zt),Zt.return=Mt,Mt=Zt),he(Mt)):_(Mt,dt)}return function(Mt,dt,At,Zt){try{Eu=0;var ei=Zs(Mt,dt,At,Zt);return wu=null,ei}catch(Yn){if(Yn===xu||Yn===_o)throw Yn;var As=_a(29,Yn,null,Mt.mode);return As.lanes=Zt,As.return=Mt,As}finally{}}}var mc=ad(!0),lp=ad(!1),Tu=!1;function up(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function ih(a,u){a=a.updateQueue,u.updateQueue===a&&(u.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,callbacks:null})}function pl(a){return{lane:a,tag:0,payload:null,callback:null,next:null}}function Wl(a,u,_){var b=a.updateQueue;if(b===null)return null;if(b=b.shared,(Vi&2)!==0){var O=b.pending;return O===null?u.next=u:(u.next=O.next,O.next=u),b.pending=u,u=Qc(a),Xf(a,null,_),u}return Zd(a,b,u,_),Qc(a)}function Kl(a,u,_){if(u=u.updateQueue,u!==null&&(u=u.shared,(_&4194048)!==0)){var b=u.lanes;b&=a.pendingLanes,_|=b,u.lanes=_,ve(a,_)}}function sh(a,u){var _=a.updateQueue,b=a.alternate;if(b!==null&&(b=b.updateQueue,_===b)){var O=null,V=null;if(_=_.firstBaseUpdate,_!==null){do{var he={lane:_.lane,tag:_.tag,payload:_.payload,callback:null,next:null};V===null?O=V=he:V=V.next=he,_=_.next}while(_!==null);V===null?O=V=u:V=V.next=u}else O=V=u;_={baseState:b.baseState,firstBaseUpdate:O,lastBaseUpdate:V,shared:b.shared,callbacks:b.callbacks},a.updateQueue=_;return}a=_.lastBaseUpdate,a===null?_.firstBaseUpdate=u:a.next=u,_.lastBaseUpdate=u}var cp=!1;function od(){if(cp){var a=go;if(a!==null)throw a}}function gc(a,u,_,b){cp=!1;var O=a.updateQueue;Tu=!1;var V=O.firstBaseUpdate,he=O.lastBaseUpdate,Ce=O.shared.pending;if(Ce!==null){O.shared.pending=null;var st=Ce,Pt=st.next;st.next=null,he===null?V=Pt:he.next=Pt,he=st;var qt=a.alternate;qt!==null&&(qt=qt.updateQueue,Ce=qt.lastBaseUpdate,Ce!==he&&(Ce===null?qt.firstBaseUpdate=Pt:Ce.next=Pt,qt.lastBaseUpdate=st))}if(V!==null){var nn=O.baseState;he=0,qt=Pt=st=null,Ce=V;do{var It=Ce.lane&-536870913,kt=It!==Ce.lane;if(kt?(Oi&It)===It:(b&It)===It){It!==0&&It===$l&&(cp=!0),qt!==null&&(qt=qt.next={lane:0,tag:Ce.tag,payload:Ce.payload,callback:null,next:null});e:{var Gn=a,ui=Ce;It=u;var Zs=_;switch(ui.tag){case 1:if(Gn=ui.payload,typeof Gn=="function"){nn=Gn.call(Zs,nn,It);break e}nn=Gn;break e;case 3:Gn.flags=Gn.flags&-65537|128;case 0:if(Gn=ui.payload,It=typeof Gn=="function"?Gn.call(Zs,nn,It):Gn,It==null)break e;nn=p({},nn,It);break e;case 2:Tu=!0}}It=Ce.callback,It!==null&&(a.flags|=64,kt&&(a.flags|=8192),kt=O.callbacks,kt===null?O.callbacks=[It]:kt.push(It))}else kt={lane:It,tag:Ce.tag,payload:Ce.payload,callback:Ce.callback,next:null},qt===null?(Pt=qt=kt,st=nn):qt=qt.next=kt,he|=It;if(Ce=Ce.next,Ce===null){if(Ce=O.shared.pending,Ce===null)break;kt=Ce,Ce=kt.next,kt.next=null,O.lastBaseUpdate=kt,O.shared.pending=null}}while(!0);qt===null&&(st=nn),O.baseState=st,O.firstBaseUpdate=Pt,O.lastBaseUpdate=qt,V===null&&(O.shared.lanes=0),no|=he,a.lanes=he,a.memoizedState=nn}}function ml(a,u){if(typeof a!="function")throw Error(i(191,a));a.call(u)}function zr(a,u){var _=a.callbacks;if(_!==null)for(a.callbacks=null,a=0;a<_.length;a++)ml(_[a],u)}var qa=ee(null),Ma=ee(0);function uf(a,u){a=mr,ue(Ma,a),ue(qa,u),mr=a|u.baseLanes}function dp(){ue(Ma,mr),ue(qa,qa.current)}function oa(){mr=Ma.current,te(qa),te(Ma)}var Mr=ee(null),Xa=null;function Su(a){var u=a.alternate;ue(Xs,Xs.current&1),ue(Mr,a),Xa===null&&(u===null||qa.current!==null||u.memoizedState!==null)&&(Xa=a)}function rh(a){ue(Xs,Xs.current),ue(Mr,a),Xa===null&&(Xa=a)}function Tm(a){a.tag===22?(ue(Xs,Xs.current),ue(Mr,a),Xa===null&&(Xa=a)):ql()}function ql(){ue(Xs,Xs.current),ue(Mr,Mr.current)}function la(a){te(Mr),Xa===a&&(Xa=null),te(Xs)}var Xs=ee(0);function ah(a){for(var u=a;u!==null;){if(u.tag===13){var _=u.memoizedState;if(_!==null&&(_=_.dehydrated,_===null||Ac(_)||Md(_)))return u}else if(u.tag===19&&(u.memoizedProps.revealOrder==="forwards"||u.memoizedProps.revealOrder==="backwards"||u.memoizedProps.revealOrder==="unstable_legacy-backwards"||u.memoizedProps.revealOrder==="together")){if((u.flags&128)!==0)return u}else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===a)break;for(;u.sibling===null;){if(u.return===null||u.return===a)return null;u=u.return}u.sibling.return=u.return,u=u.sibling}return null}var Ia=0,si=null,_s=null,br=null,oh=!1,gl=!1,Au=!1,lh=0,cf=0,Uo=null,s_=0;function tr(){throw Error(i(321))}function fp(a,u){if(u===null)return!1;for(var _=0;_<u.length&&_<a.length;_++)if(!gs(a[_],u[_]))return!1;return!0}function uh(a,u,_,b,O,V){return Ia=V,si=u,u.memoizedState=null,u.updateQueue=null,u.lanes=0,q.H=a===null||a.memoizedState===null?Vm:Mc,Au=!1,V=_(b,O),Au=!1,gl&&(V=Am(u,_,b,O)),Sm(a),V}function Sm(a){q.H=_f;var u=_s!==null&&_s.next!==null;if(Ia=0,br=_s=si=null,oh=!1,cf=0,Uo=null,u)throw Error(i(300));a===null||zs||(a=a.dependencies,a!==null&&id(a)&&(zs=!0))}function Am(a,u,_,b){si=a;var O=0;do{if(gl&&(Uo=null),cf=0,gl=!1,25<=O)throw Error(i(301));if(O+=1,br=_s=null,a.updateQueue!=null){var V=a.updateQueue;V.lastEffect=null,V.events=null,V.stores=null,V.memoCache!=null&&(V.memoCache.index=0)}q.H=vf,V=u(_,b)}while(gl);return V}function Cm(){var a=q.H,u=a.useState()[0];return u=typeof u.then=="function"?df(u):u,a=a.useState()[0],(_s!==null?_s.memoizedState:null)!==a&&(si.flags|=1024),u}function hp(){var a=lh!==0;return lh=0,a}function pp(a,u,_){u.updateQueue=a.updateQueue,u.flags&=-2053,a.lanes&=~_}function ch(a){if(oh){for(a=a.memoizedState;a!==null;){var u=a.queue;u!==null&&(u.pending=null),a=a.next}oh=!1}Ia=0,br=_s=si=null,gl=!1,cf=lh=0,Uo=null}function ba(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return br===null?si.memoizedState=br=a:br=br.next=a,br}function fr(){if(_s===null){var a=si.alternate;a=a!==null?a.memoizedState:null}else a=_s.next;var u=br===null?si.memoizedState:br.next;if(u!==null)br=u,_s=a;else{if(a===null)throw si.alternate===null?Error(i(467)):Error(i(310));_s=a,a={memoizedState:_s.memoizedState,baseState:_s.baseState,baseQueue:_s.baseQueue,queue:_s.queue,next:null},br===null?si.memoizedState=br=a:br=br.next=a}return br}function _c(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function df(a){var u=cf;return cf+=1,Uo===null&&(Uo=[]),a=ap(Uo,a,u),u=si,(br===null?u.memoizedState:br.next)===null&&(u=u.alternate,q.H=u===null||u.memoizedState===null?Vm:Mc),a}function dh(a){if(a!==null&&typeof a=="object"){if(typeof a.then=="function")return df(a);if(a.$$typeof===C)return Rr(a)}throw Error(i(438,String(a)))}function mp(a){var u=null,_=si.updateQueue;if(_!==null&&(u=_.memoCache),u==null){var b=si.alternate;b!==null&&(b=b.updateQueue,b!==null&&(b=b.memoCache,b!=null&&(u={data:b.data.map(function(O){return O.slice()}),index:0})))}if(u==null&&(u={data:[],index:0}),_===null&&(_=_c(),si.updateQueue=_),_.memoCache=u,_=u.data[u.index],_===void 0)for(_=u.data[u.index]=Array(a),b=0;b<a;b++)_[b]=N;return u.index++,_}function _l(a,u){return typeof u=="function"?u(a):u}function fh(a){var u=fr();return gp(u,_s,a)}function gp(a,u,_){var b=a.queue;if(b===null)throw Error(i(311));b.lastRenderedReducer=_;var O=a.baseQueue,V=b.pending;if(V!==null){if(O!==null){var he=O.next;O.next=V.next,V.next=he}u.baseQueue=O=V,b.pending=null}if(V=a.baseState,O===null)a.memoizedState=V;else{u=O.next;var Ce=he=null,st=null,Pt=u,qt=!1;do{var nn=Pt.lane&-536870913;if(nn!==Pt.lane?(Oi&nn)===nn:(Ia&nn)===nn){var It=Pt.revertLane;if(It===0)st!==null&&(st=st.next={lane:0,revertLane:0,gesture:null,action:Pt.action,hasEagerState:Pt.hasEagerState,eagerState:Pt.eagerState,next:null}),nn===$l&&(qt=!0);else if((Ia&It)===It){Pt=Pt.next,It===$l&&(qt=!0);continue}else nn={lane:0,revertLane:Pt.revertLane,gesture:null,action:Pt.action,hasEagerState:Pt.hasEagerState,eagerState:Pt.eagerState,next:null},st===null?(Ce=st=nn,he=V):st=st.next=nn,si.lanes|=It,no|=It;nn=Pt.action,Au&&_(V,nn),V=Pt.hasEagerState?Pt.eagerState:_(V,nn)}else It={lane:nn,revertLane:Pt.revertLane,gesture:Pt.gesture,action:Pt.action,hasEagerState:Pt.hasEagerState,eagerState:Pt.eagerState,next:null},st===null?(Ce=st=It,he=V):st=st.next=It,si.lanes|=nn,no|=nn;Pt=Pt.next}while(Pt!==null&&Pt!==u);if(st===null?he=V:st.next=Ce,!gs(V,a.memoizedState)&&(zs=!0,qt&&(_=go,_!==null)))throw _;a.memoizedState=V,a.baseState=he,a.baseQueue=st,b.lastRenderedState=V}return O===null&&(b.lanes=0),[a.memoizedState,b.dispatch]}function ff(a){var u=fr(),_=u.queue;if(_===null)throw Error(i(311));_.lastRenderedReducer=a;var b=_.dispatch,O=_.pending,V=u.memoizedState;if(O!==null){_.pending=null;var he=O=O.next;do V=a(V,he.action),he=he.next;while(he!==O);gs(V,u.memoizedState)||(zs=!0),u.memoizedState=V,u.baseQueue===null&&(u.baseState=V),_.lastRenderedState=V}return[V,b]}function _p(a,u,_){var b=si,O=fr(),V=Ui;if(V){if(_===void 0)throw Error(i(407));_=_()}else _=u();var he=!gs((_s||O).memoizedState,_);if(he&&(O.memoizedState=_,zs=!0),O=O.queue,gh(yp.bind(null,b,O,a),[a]),O.getSnapshot!==u||he||br!==null&&br.memoizedState.tag&1){if(b.flags|=2048,ld(9,{destroy:void 0},vp.bind(null,b,O,_,u),null),rs===null)throw Error(i(349));V||(Ia&127)!==0||Pm(b,u,_)}return _}function Pm(a,u,_){a.flags|=16384,a={getSnapshot:u,value:_},u=si.updateQueue,u===null?(u=_c(),si.updateQueue=u,u.stores=[a]):(_=u.stores,_===null?u.stores=[a]:_.push(a))}function vp(a,u,_,b){u.value=_,u.getSnapshot=b,hf(u)&&hh(a)}function yp(a,u,_){return _(function(){hf(u)&&hh(a)})}function hf(a){var u=a.getSnapshot;a=a.value;try{var _=u();return!gs(a,_)}catch{return!0}}function hh(a){var u=Ul(a,2);u!==null&&m(u,a,2)}function pf(a){var u=ba();if(typeof a=="function"){var _=a;if(a=_(),Au){Tn(!0);try{_()}finally{Tn(!1)}}}return u.memoizedState=u.baseState=a,u.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:_l,lastRenderedState:a},u}function Rm(a,u,_,b){return a.baseState=_,gp(a,_s,typeof b=="function"?b:_l)}function r_(a,u,_,b,O){if(Xl(a))throw Error(i(485));if(a=u.action,a!==null){var V={payload:O,action:a,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(he){V.listeners.push(he)}};q.T!==null?_(!0):V.isTransition=!1,b(V),_=u.pending,_===null?(V.next=u.pending=V,Dm(u,V)):(V.next=_.next,u.pending=_.next=V)}}function Dm(a,u){var _=u.action,b=u.payload,O=a.state;if(u.isTransition){var V=q.T,he={};q.T=he;try{var Ce=_(O,b),st=q.S;st!==null&&st(he,Ce),Bm(a,u,Ce)}catch(Pt){ph(a,u,Pt)}finally{V!==null&&he.types!==null&&(V.types=he.types),q.T=V}}else try{V=_(O,b),Bm(a,u,V)}catch(Pt){ph(a,u,Pt)}}function Bm(a,u,_){_!==null&&typeof _=="object"&&typeof _.then=="function"?_.then(function(b){Mp(a,u,b)},function(b){return ph(a,u,b)}):Mp(a,u,_)}function Mp(a,u,_){u.status="fulfilled",u.value=_,Im(u),a.state=_,u=a.pending,u!==null&&(_=u.next,_===u?a.pending=null:(_=_.next,u.next=_,Dm(a,_)))}function ph(a,u,_){var b=a.pending;if(a.pending=null,b!==null){b=b.next;do u.status="rejected",u.reason=_,Im(u),u=u.next;while(u!==b)}a.action=null}function Im(a){a=a.listeners;for(var u=0;u<a.length;u++)(0,a[u])()}function bp(a,u){return u}function Om(a,u){if(Ui){var _=rs.formState;if(_!==null){e:{var b=si;if(Ui){if(Is){t:{for(var O=Is,V=Nr;O.nodeType!==8;){if(!V){O=null;break t}if(O=Co(O.nextSibling),O===null){O=null;break t}}V=O.data,O=V==="F!"||V==="F"?O:null}if(O){Is=Co(O.nextSibling),b=O.data==="F!";break e}}Ri(b)}b=!1}b&&(u=_[0])}}return _=ba(),_.memoizedState=_.baseState=u,b={pending:null,lanes:0,dispatch:null,lastRenderedReducer:bp,lastRenderedState:u},_.queue=b,_=Gm.bind(null,si,b),b.dispatch=_,b=pf(!1),V=vc.bind(null,si,!1,b.queue),b=ba(),O={state:u,dispatch:null,action:a,pending:null},b.queue=O,_=r_.bind(null,si,O,V,_),O.dispatch=_,b.memoizedState=a,[u,_,!1]}function Lm(a){var u=fr();return xp(u,_s,a)}function xp(a,u,_){if(u=gp(a,u,bp)[0],a=fh(_l)[0],typeof u=="object"&&u!==null&&typeof u.then=="function")try{var b=df(u)}catch(he){throw he===xu?_o:he}else b=u;u=fr();var O=u.queue,V=O.dispatch;return _!==u.memoizedState&&(si.flags|=2048,ld(9,{destroy:void 0},a_.bind(null,O,_),null)),[b,V,a]}function a_(a,u){a.action=u}function Fm(a){var u=fr(),_=_s;if(_!==null)return xp(u,_,a);fr(),u=u.memoizedState,_=fr();var b=_.queue.dispatch;return _.memoizedState=a,[u,b,!1]}function ld(a,u,_,b){return a={tag:a,create:_,deps:b,inst:u,next:null},u=si.updateQueue,u===null&&(u=_c(),si.updateQueue=u),_=u.lastEffect,_===null?u.lastEffect=a.next=a:(b=_.next,_.next=a,a.next=b,u.lastEffect=a),a}function Nm(){return fr().memoizedState}function mf(a,u,_,b){var O=ba();si.flags|=a,O.memoizedState=ld(1|u,{destroy:void 0},_,b===void 0?null:b)}function mh(a,u,_,b){var O=fr();b=b===void 0?null:b;var V=O.memoizedState.inst;_s!==null&&b!==null&&fp(b,_s.memoizedState.deps)?O.memoizedState=ld(u,V,_,b):(si.flags|=a,O.memoizedState=ld(1|u,V,_,b))}function zm(a,u){mf(8390656,8,a,u)}function gh(a,u){mh(2048,8,a,u)}function Um(a){si.flags|=4;var u=si.updateQueue;if(u===null)u=_c(),si.updateQueue=u,u.events=[a];else{var _=u.events;_===null?u.events=[a]:_.push(a)}}function km(a){var u=fr().memoizedState;return Um({ref:u,nextImpl:a}),function(){if((Vi&2)!==0)throw Error(i(440));return u.impl.apply(void 0,arguments)}}function wp(a,u){return mh(4,2,a,u)}function Ya(a,u){return mh(4,4,a,u)}function Ep(a,u){if(typeof u=="function"){a=a();var _=u(a);return function(){typeof _=="function"?_():u(null)}}if(u!=null)return a=a(),u.current=a,function(){u.current=null}}function gf(a,u,_){_=_!=null?_.concat([a]):null,mh(4,4,Ep.bind(null,u,a),_)}function _h(){}function Tp(a,u){var _=fr();u=u===void 0?null:u;var b=_.memoizedState;return u!==null&&fp(u,b[1])?b[0]:(_.memoizedState=[a,u],a)}function Sp(a,u){var _=fr();u=u===void 0?null:u;var b=_.memoizedState;if(u!==null&&fp(u,b[1]))return b[0];if(b=a(),Au){Tn(!0);try{a()}finally{Tn(!1)}}return _.memoizedState=[b,u],b}function Ap(a,u,_){return _===void 0||(Ia&1073741824)!==0&&(Oi&261930)===0?a.memoizedState=u:(a.memoizedState=_,a=f(),si.lanes|=a,no|=a,_)}function Cp(a,u,_,b){return gs(_,u)?_:qa.current!==null?(a=Ap(a,_,b),gs(a,u)||(zs=!0),a):(Ia&42)===0||(Ia&1073741824)!==0&&(Oi&261930)===0?(zs=!0,a.memoizedState=_):(a=f(),si.lanes|=a,no|=a,u)}function Pp(a,u,_,b,O){var V=le.p;le.p=V!==0&&8>V?V:8;var he=q.T,Ce={};q.T=Ce,vc(a,!1,u,_);try{var st=O(),Pt=q.S;if(Pt!==null&&Pt(Ce,st),st!==null&&typeof st=="object"&&typeof st.then=="function"){var qt=eh(st,b);ud(a,u,qt,Aa(a))}else ud(a,u,b,Aa(a))}catch(nn){ud(a,u,{then:function(){},status:"rejected",reason:nn},Aa())}finally{le.p=V,he!==null&&Ce.types!==null&&(he.types=Ce.types),q.T=he}}function o_(){}function Rp(a,u,_,b){if(a.tag!==5)throw Error(i(476));var O=Dp(a).queue;Pp(a,O,u,se,_===null?o_:function(){return Bp(a),_(b)})}function Dp(a){var u=a.memoizedState;if(u!==null)return u;u={memoizedState:se,baseState:se,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:_l,lastRenderedState:se},next:null};var _={};return u.next={memoizedState:_,baseState:_,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:_l,lastRenderedState:_},next:null},a.memoizedState=u,a=a.alternate,a!==null&&(a.memoizedState=u),u}function Bp(a){var u=Dp(a);u.next===null&&(u=a.alternate.memoizedState),ud(a,u.next.queue,{},Aa())}function Ip(){return Rr(O0)}function Yr(){return fr().memoizedState}function Op(){return fr().memoizedState}function l_(a){for(var u=a.return;u!==null;){switch(u.tag){case 24:case 3:var _=Aa();a=pl(_);var b=Wl(u,a,_);b!==null&&(m(b,u,_),Kl(b,u,_)),u={cache:ip()},a.payload=u;return}u=u.return}}function u_(a,u,_){var b=Aa();_={lane:b,revertLane:0,gesture:null,action:_,hasEagerState:!1,eagerState:null,next:null},Xl(a)?yc(u,_):(_=Jc(a,u,_,b),_!==null&&(m(_,a,b),xa(_,u,b)))}function Gm(a,u,_){var b=Aa();ud(a,u,_,b)}function ud(a,u,_,b){var O={lane:b,revertLane:0,gesture:null,action:_,hasEagerState:!1,eagerState:null,next:null};if(Xl(a))yc(u,O);else{var V=a.alternate;if(a.lanes===0&&(V===null||V.lanes===0)&&(V=u.lastRenderedReducer,V!==null))try{var he=u.lastRenderedState,Ce=V(he,_);if(O.hasEagerState=!0,O.eagerState=Ce,gs(Ce,he))return Zd(a,u,O,0),rs===null&&zl(),!1}catch{}finally{}if(_=Jc(a,u,O,b),_!==null)return m(_,a,b),xa(_,u,b),!0}return!1}function vc(a,u,_,b){if(b={lane:2,revertLane:C0(),gesture:null,action:b,hasEagerState:!1,eagerState:null,next:null},Xl(a)){if(u)throw Error(i(479))}else u=Jc(a,_,b,2),u!==null&&m(u,a,2)}function Xl(a){var u=a.alternate;return a===si||u!==null&&u===si}function yc(a,u){gl=oh=!0;var _=a.pending;_===null?u.next=u:(u.next=_.next,_.next=u),a.pending=u}function xa(a,u,_){if((_&4194048)!==0){var b=u.lanes;b&=a.pendingLanes,_|=b,u.lanes=_,ve(a,_)}}var _f={readContext:Rr,use:dh,useCallback:tr,useContext:tr,useEffect:tr,useImperativeHandle:tr,useLayoutEffect:tr,useInsertionEffect:tr,useMemo:tr,useReducer:tr,useRef:tr,useState:tr,useDebugValue:tr,useDeferredValue:tr,useTransition:tr,useSyncExternalStore:tr,useId:tr,useHostTransitionStatus:tr,useFormState:tr,useActionState:tr,useOptimistic:tr,useMemoCache:tr,useCacheRefresh:tr};_f.useEffectEvent=tr;var Vm={readContext:Rr,use:dh,useCallback:function(a,u){return ba().memoizedState=[a,u===void 0?null:u],a},useContext:Rr,useEffect:zm,useImperativeHandle:function(a,u,_){_=_!=null?_.concat([a]):null,mf(4194308,4,Ep.bind(null,u,a),_)},useLayoutEffect:function(a,u){return mf(4194308,4,a,u)},useInsertionEffect:function(a,u){mf(4,2,a,u)},useMemo:function(a,u){var _=ba();u=u===void 0?null:u;var b=a();if(Au){Tn(!0);try{a()}finally{Tn(!1)}}return _.memoizedState=[b,u],b},useReducer:function(a,u,_){var b=ba();if(_!==void 0){var O=_(u);if(Au){Tn(!0);try{_(u)}finally{Tn(!1)}}}else O=u;return b.memoizedState=b.baseState=O,a={pending:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:O},b.queue=a,a=a.dispatch=u_.bind(null,si,a),[b.memoizedState,a]},useRef:function(a){var u=ba();return a={current:a},u.memoizedState=a},useState:function(a){a=pf(a);var u=a.queue,_=Gm.bind(null,si,u);return u.dispatch=_,[a.memoizedState,_]},useDebugValue:_h,useDeferredValue:function(a,u){var _=ba();return Ap(_,a,u)},useTransition:function(){var a=pf(!1);return a=Pp.bind(null,si,a.queue,!0,!1),ba().memoizedState=a,[!1,a]},useSyncExternalStore:function(a,u,_){var b=si,O=ba();if(Ui){if(_===void 0)throw Error(i(407));_=_()}else{if(_=u(),rs===null)throw Error(i(349));(Oi&127)!==0||Pm(b,u,_)}O.memoizedState=_;var V={value:_,getSnapshot:u};return O.queue=V,zm(yp.bind(null,b,V,a),[a]),b.flags|=2048,ld(9,{destroy:void 0},vp.bind(null,b,V,_,u),null),_},useId:function(){var a=ba(),u=rs.identifierPrefix;if(Ui){var _=No,b=dl;_=(b&~(1<<32-We(b)-1)).toString(32)+_,u="_"+u+"R_"+_,_=lh++,0<_&&(u+="H"+_.toString(32)),u+="_"}else _=s_++,u="_"+u+"r_"+_.toString(32)+"_";return a.memoizedState=u},useHostTransitionStatus:Ip,useFormState:Om,useActionState:Om,useOptimistic:function(a){var u=ba();u.memoizedState=u.baseState=a;var _={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return u.queue=_,u=vc.bind(null,si,!0,_),_.dispatch=u,[a,u]},useMemoCache:mp,useCacheRefresh:function(){return ba().memoizedState=l_.bind(null,si)},useEffectEvent:function(a){var u=ba(),_={impl:a};return u.memoizedState=_,function(){if((Vi&2)!==0)throw Error(i(440));return _.impl.apply(void 0,arguments)}}},Mc={readContext:Rr,use:dh,useCallback:Tp,useContext:Rr,useEffect:gh,useImperativeHandle:gf,useInsertionEffect:wp,useLayoutEffect:Ya,useMemo:Sp,useReducer:fh,useRef:Nm,useState:function(){return fh(_l)},useDebugValue:_h,useDeferredValue:function(a,u){var _=fr();return Cp(_,_s.memoizedState,a,u)},useTransition:function(){var a=fh(_l)[0],u=fr().memoizedState;return[typeof a=="boolean"?a:df(a),u]},useSyncExternalStore:_p,useId:Yr,useHostTransitionStatus:Ip,useFormState:Lm,useActionState:Lm,useOptimistic:function(a,u){var _=fr();return Rm(_,_s,a,u)},useMemoCache:mp,useCacheRefresh:Op};Mc.useEffectEvent=km;var vf={readContext:Rr,use:dh,useCallback:Tp,useContext:Rr,useEffect:gh,useImperativeHandle:gf,useInsertionEffect:wp,useLayoutEffect:Ya,useMemo:Sp,useReducer:ff,useRef:Nm,useState:function(){return ff(_l)},useDebugValue:_h,useDeferredValue:function(a,u){var _=fr();return _s===null?Ap(_,a,u):Cp(_,_s.memoizedState,a,u)},useTransition:function(){var a=ff(_l)[0],u=fr().memoizedState;return[typeof a=="boolean"?a:df(a),u]},useSyncExternalStore:_p,useId:Yr,useHostTransitionStatus:Ip,useFormState:Fm,useActionState:Fm,useOptimistic:function(a,u){var _=fr();return _s!==null?Rm(_,_s,a,u):(_.baseState=a,[a,_.queue.dispatch])},useMemoCache:mp,useCacheRefresh:Op};vf.useEffectEvent=km;function cd(a,u,_,b){u=a.memoizedState,_=_(b,u),_=_==null?u:p({},u,_),a.memoizedState=_,a.lanes===0&&(a.updateQueue.baseState=_)}var ko={enqueueSetState:function(a,u,_){a=a._reactInternals;var b=Aa(),O=pl(b);O.payload=u,_!=null&&(O.callback=_),u=Wl(a,O,b),u!==null&&(m(u,a,b),Kl(u,a,b))},enqueueReplaceState:function(a,u,_){a=a._reactInternals;var b=Aa(),O=pl(b);O.tag=1,O.payload=u,_!=null&&(O.callback=_),u=Wl(a,O,b),u!==null&&(m(u,a,b),Kl(u,a,b))},enqueueForceUpdate:function(a,u){a=a._reactInternals;var _=Aa(),b=pl(_);b.tag=2,u!=null&&(b.callback=u),u=Wl(a,b,_),u!==null&&(m(u,a,_),Kl(u,a,_))}};function Hm(a,u,_,b,O,V,he){return a=a.stateNode,typeof a.shouldComponentUpdate=="function"?a.shouldComponentUpdate(b,V,he):u.prototype&&u.prototype.isPureReactComponent?!Fl(_,b)||!Fl(O,V):!0}function jm(a,u,_,b){a=u.state,typeof u.componentWillReceiveProps=="function"&&u.componentWillReceiveProps(_,b),typeof u.UNSAFE_componentWillReceiveProps=="function"&&u.UNSAFE_componentWillReceiveProps(_,b),u.state!==a&&ko.enqueueReplaceState(u,u.state,null)}function Jr(a,u){var _=u;if("ref"in u){_={};for(var b in u)b!=="ref"&&(_[b]=u[b])}if(a=a.defaultProps){_===u&&(_=p({},_));for(var O in a)_[O]===void 0&&(_[O]=a[O])}return _}function Lp(a){ga(a)}function $m(a){console.error(a)}function vh(a){ga(a)}function yf(a,u){try{var _=a.onUncaughtError;_(u.value,{componentStack:u.stack})}catch(b){setTimeout(function(){throw b})}}function Wm(a,u,_){try{var b=a.onCaughtError;b(_.value,{componentStack:_.stack,errorBoundary:u.tag===1?u.stateNode:null})}catch(O){setTimeout(function(){throw O})}}function Fp(a,u,_){return _=pl(_),_.tag=3,_.payload={element:null},_.callback=function(){yf(a,u)},_}function dd(a){return a=pl(a),a.tag=3,a}function Oa(a,u,_,b){var O=_.type.getDerivedStateFromError;if(typeof O=="function"){var V=b.value;a.payload=function(){return O(V)},a.callback=function(){Wm(u,_,b)}}var he=_.stateNode;he!==null&&typeof he.componentDidCatch=="function"&&(a.callback=function(){Wm(u,_,b),typeof O!="function"&&(iu===null?iu=new Set([this]):iu.add(this));var Ce=b.stack;this.componentDidCatch(b.value,{componentStack:Ce!==null?Ce:""})})}function wa(a,u,_,b,O){if(_.flags|=32768,b!==null&&typeof b=="object"&&typeof b.then=="function"){if(u=_.alternate,u!==null&&yu(u,_,O,!0),_=Mr.current,_!==null){switch(_.tag){case 31:case 13:return Xa===null?ci():_.alternate===null&&qi===0&&(qi=3),_.flags&=-257,_.flags|=65536,_.lanes=O,b===rf?_.flags|=16384:(u=_.updateQueue,u===null?_.updateQueue=new Set([b]):u.add(b),T0(a,b,O)),!1;case 22:return _.flags|=65536,b===rf?_.flags|=16384:(u=_.updateQueue,u===null?(u={transitions:null,markerInstances:null,retryQueue:new Set([b])},_.updateQueue=u):(_=u.retryQueue,_===null?u.retryQueue=new Set([b]):_.add(b)),T0(a,b,O)),!1}throw Error(i(435,_.tag))}return T0(a,b,O),ci(),!1}if(Ui)return u=Mr.current,u!==null?((u.flags&65536)===0&&(u.flags|=256),u.flags|=65536,u.lanes=O,b!==Jf&&(a=Error(i(422),{cause:b}),nd(va(a,_)))):(b!==Jf&&(u=Error(i(423),{cause:b}),nd(va(u,_))),a=a.current.alternate,a.flags|=65536,O&=-O,a.lanes|=O,b=va(b,_),O=Fp(a.stateNode,b,O),sh(a,O),qi!==4&&(qi=2)),!1;var V=Error(i(520),{cause:b});if(V=va(V,_),so===null?so=[V]:so.push(V),qi!==4&&(qi=2),u===null)return!0;b=va(b,_),_=u;do{switch(_.tag){case 3:return _.flags|=65536,a=O&-O,_.lanes|=a,a=Fp(_.stateNode,b,a),sh(_,a),!1;case 1:if(u=_.type,V=_.stateNode,(_.flags&128)===0&&(typeof u.getDerivedStateFromError=="function"||V!==null&&typeof V.componentDidCatch=="function"&&(iu===null||!iu.has(V))))return _.flags|=65536,O&=-O,_.lanes|=O,O=dd(O),Oa(O,a,_,b),sh(_,O),!1}_=_.return}while(_!==null);return!1}var yh=Error(i(461)),zs=!1;function nr(a,u,_,b){u.child=a===null?lp(u,null,_,b):mc(u,a.child,_,b)}function Cu(a,u,_,b,O){_=_.render;var V=u.ref;if("ref"in b){var he={};for(var Ce in b)Ce!=="ref"&&(he[Ce]=b[Ce])}else he=b;return hc(u),b=uh(a,u,_,he,V,O),Ce=hp(),a!==null&&!zs?(pp(a,u,O),Vo(a,u,O)):(Ui&&Ce&&ef(u),u.flags|=1,nr(a,u,b,O),u.child)}function Mf(a,u,_,b,O){if(a===null){var V=_.type;return typeof V=="function"&&!ra(V)&&V.defaultProps===void 0&&_.compare===null?(u.tag=15,u.type=V,Ja(a,u,V,b,O)):(a=Zc(_.type,null,b,u,u.mode,O),a.ref=u.ref,a.return=u,u.child=a)}if(V=a.child,!Ru(a,O)){var he=V.memoizedProps;if(_=_.compare,_=_!==null?_:Fl,_(he,b)&&a.ref===u.ref)return Vo(a,u,O)}return u.flags|=1,a=ul(V,b),a.ref=u.ref,a.return=u,u.child=a}function Ja(a,u,_,b,O){if(a!==null){var V=a.memoizedProps;if(Fl(V,b)&&a.ref===u.ref)if(zs=!1,u.pendingProps=b=V,Ru(a,O))(a.flags&131072)!==0&&(zs=!0);else return u.lanes=a.lanes,Vo(a,u,O)}return fd(a,u,_,b,O)}function Qa(a,u,_,b){var O=b.children,V=a!==null?a.memoizedState:null;if(a===null&&u.stateNode===null&&(u.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),b.mode==="hidden"){if((u.flags&128)!==0){if(V=V!==null?V.baseLanes|_:_,a!==null){for(b=u.child=a.child,O=0;b!==null;)O=O|b.lanes|b.childLanes,b=b.sibling;b=O&~V}else b=0,u.child=null;return vo(a,u,V,_,b)}if((_&536870912)!==0)u.memoizedState={baseLanes:0,cachePool:null},a!==null&&rd(u,V!==null?V.cachePool:null),V!==null?uf(u,V):dp(),Tm(u);else return b=u.lanes=536870912,vo(a,u,V!==null?V.baseLanes|_:_,_,b)}else V!==null?(rd(u,V.cachePool),uf(u,V),ql(),u.memoizedState=null):(a!==null&&rd(u,null),dp(),ql());return nr(a,u,O,_),u.child}function Go(a,u){return a!==null&&a.tag===22||u.stateNode!==null||(u.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),u.sibling}function vo(a,u,_,b,O){var V=zo();return V=V===null?null:{parent:Kn._currentValue,pool:V},u.memoizedState={baseLanes:_,cachePool:V},a!==null&&rd(u,null),dp(),Tm(u),a!==null&&yu(a,u,b,!0),u.childLanes=O,null}function yo(a,u){return u=hd({mode:u.mode,children:u.children},a.mode),u.ref=a.ref,a.child=u,u.return=a,u}function Ur(a,u,_){return mc(u,a.child,null,_),a=yo(u,u.pendingProps),a.flags|=2,la(u),u.memoizedState=null,a}function bf(a,u,_){var b=u.pendingProps,O=(u.flags&128)!==0;if(u.flags&=-129,a===null){if(Ui){if(b.mode==="hidden")return a=yo(u,b),u.lanes=536870912,Go(null,a);if(rh(u),(a=Is)?(a=Gr(a,Nr),a=a!==null&&a.data==="&"?a:null,a!==null&&(u.memoizedState={dehydrated:a,treeContext:cl!==null?{id:dl,overflow:No}:null,retryLane:536870912,hydrationErrors:null},_=Xh(a),_.return=u,u.child=_,Pr=u,Is=null)):a=null,a===null)throw Ri(u);return u.lanes=536870912,null}return yo(u,b)}var V=a.memoizedState;if(V!==null){var he=V.dehydrated;if(rh(u),O)if(u.flags&256)u.flags&=-257,u=Ur(a,u,_);else if(u.memoizedState!==null)u.child=a.child,u.flags|=128,u=null;else throw Error(i(558));else if(zs||yu(a,u,_,!1),O=(_&a.childLanes)!==0,zs||O){if(b=rs,b!==null&&(he=ge(b,_),he!==0&&he!==V.retryLane))throw V.retryLane=he,Ul(a,he),m(b,a,he),yh;ci(),u=Ur(a,u,_)}else a=V.treeContext,Is=Co(he.nextSibling),Pr=u,Ui=!0,fl=null,Nr=!1,a!==null&&tf(u,a),u=yo(u,b),u.flags|=4096;return u}return a=ul(a.child,{mode:b.mode,children:b.children}),a.ref=u.ref,u.child=a,a.return=u,a}function vl(a,u){var _=u.ref;if(_===null)a!==null&&a.ref!==null&&(u.flags|=4194816);else{if(typeof _!="function"&&typeof _!="object")throw Error(i(284));(a===null||a.ref!==_)&&(u.flags|=4194816)}}function fd(a,u,_,b,O){return hc(u),_=uh(a,u,_,b,void 0,O),b=hp(),a!==null&&!zs?(pp(a,u,O),Vo(a,u,O)):(Ui&&b&&ef(u),u.flags|=1,nr(a,u,_,O),u.child)}function ua(a,u,_,b,O,V){return hc(u),u.updateQueue=null,_=Am(u,b,_,O),Sm(a),b=hp(),a!==null&&!zs?(pp(a,u,V),Vo(a,u,V)):(Ui&&b&&ef(u),u.flags|=1,nr(a,u,_,V),u.child)}function Qr(a,u,_,b,O){if(hc(u),u.stateNode===null){var V=kl,he=_.contextType;typeof he=="object"&&he!==null&&(V=Rr(he)),V=new _(b,V),u.memoizedState=V.state!==null&&V.state!==void 0?V.state:null,V.updater=ko,u.stateNode=V,V._reactInternals=u,V=u.stateNode,V.props=b,V.state=u.memoizedState,V.refs={},up(u),he=_.contextType,V.context=typeof he=="object"&&he!==null?Rr(he):kl,V.state=u.memoizedState,he=_.getDerivedStateFromProps,typeof he=="function"&&(cd(u,_,he,b),V.state=u.memoizedState),typeof _.getDerivedStateFromProps=="function"||typeof V.getSnapshotBeforeUpdate=="function"||typeof V.UNSAFE_componentWillMount!="function"&&typeof V.componentWillMount!="function"||(he=V.state,typeof V.componentWillMount=="function"&&V.componentWillMount(),typeof V.UNSAFE_componentWillMount=="function"&&V.UNSAFE_componentWillMount(),he!==V.state&&ko.enqueueReplaceState(V,V.state,null),gc(u,b,V,O),od(),V.state=u.memoizedState),typeof V.componentDidMount=="function"&&(u.flags|=4194308),b=!0}else if(a===null){V=u.stateNode;var Ce=u.memoizedProps,st=Jr(_,Ce);V.props=st;var Pt=V.context,qt=_.contextType;he=kl,typeof qt=="object"&&qt!==null&&(he=Rr(qt));var nn=_.getDerivedStateFromProps;qt=typeof nn=="function"||typeof V.getSnapshotBeforeUpdate=="function",Ce=u.pendingProps!==Ce,qt||typeof V.UNSAFE_componentWillReceiveProps!="function"&&typeof V.componentWillReceiveProps!="function"||(Ce||Pt!==he)&&jm(u,V,b,he),Tu=!1;var It=u.memoizedState;V.state=It,gc(u,b,V,O),od(),Pt=u.memoizedState,Ce||It!==Pt||Tu?(typeof nn=="function"&&(cd(u,_,nn,b),Pt=u.memoizedState),(st=Tu||Hm(u,_,st,b,It,Pt,he))?(qt||typeof V.UNSAFE_componentWillMount!="function"&&typeof V.componentWillMount!="function"||(typeof V.componentWillMount=="function"&&V.componentWillMount(),typeof V.UNSAFE_componentWillMount=="function"&&V.UNSAFE_componentWillMount()),typeof V.componentDidMount=="function"&&(u.flags|=4194308)):(typeof V.componentDidMount=="function"&&(u.flags|=4194308),u.memoizedProps=b,u.memoizedState=Pt),V.props=b,V.state=Pt,V.context=he,b=st):(typeof V.componentDidMount=="function"&&(u.flags|=4194308),b=!1)}else{V=u.stateNode,ih(a,u),he=u.memoizedProps,qt=Jr(_,he),V.props=qt,nn=u.pendingProps,It=V.context,Pt=_.contextType,st=kl,typeof Pt=="object"&&Pt!==null&&(st=Rr(Pt)),Ce=_.getDerivedStateFromProps,(Pt=typeof Ce=="function"||typeof V.getSnapshotBeforeUpdate=="function")||typeof V.UNSAFE_componentWillReceiveProps!="function"&&typeof V.componentWillReceiveProps!="function"||(he!==nn||It!==st)&&jm(u,V,b,st),Tu=!1,It=u.memoizedState,V.state=It,gc(u,b,V,O),od();var kt=u.memoizedState;he!==nn||It!==kt||Tu||a!==null&&a.dependencies!==null&&id(a.dependencies)?(typeof Ce=="function"&&(cd(u,_,Ce,b),kt=u.memoizedState),(qt=Tu||Hm(u,_,qt,b,It,kt,st)||a!==null&&a.dependencies!==null&&id(a.dependencies))?(Pt||typeof V.UNSAFE_componentWillUpdate!="function"&&typeof V.componentWillUpdate!="function"||(typeof V.componentWillUpdate=="function"&&V.componentWillUpdate(b,kt,st),typeof V.UNSAFE_componentWillUpdate=="function"&&V.UNSAFE_componentWillUpdate(b,kt,st)),typeof V.componentDidUpdate=="function"&&(u.flags|=4),typeof V.getSnapshotBeforeUpdate=="function"&&(u.flags|=1024)):(typeof V.componentDidUpdate!="function"||he===a.memoizedProps&&It===a.memoizedState||(u.flags|=4),typeof V.getSnapshotBeforeUpdate!="function"||he===a.memoizedProps&&It===a.memoizedState||(u.flags|=1024),u.memoizedProps=b,u.memoizedState=kt),V.props=b,V.state=kt,V.context=st,b=qt):(typeof V.componentDidUpdate!="function"||he===a.memoizedProps&&It===a.memoizedState||(u.flags|=4),typeof V.getSnapshotBeforeUpdate!="function"||he===a.memoizedProps&&It===a.memoizedState||(u.flags|=1024),b=!1)}return V=b,vl(a,u),b=(u.flags&128)!==0,V||b?(V=u.stateNode,_=b&&typeof _.getDerivedStateFromError!="function"?null:V.render(),u.flags|=1,a!==null&&b?(u.child=mc(u,a.child,null,O),u.child=mc(u,null,_,O)):nr(a,u,_,O),u.memoizedState=V.state,a=u.child):a=Vo(a,u,O),a}function Di(a,u,_,b){return fc(),u.flags|=256,nr(a,u,_,b),u.child}var Za={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Mo(a){return{baseLanes:a,cachePool:th()}}function xf(a,u,_){return a=a!==null?a.childLanes&~_:0,u&&(a|=Hi),a}function eo(a,u,_){var b=u.pendingProps,O=!1,V=(u.flags&128)!==0,he;if((he=V)||(he=a!==null&&a.memoizedState===null?!1:(Xs.current&2)!==0),he&&(O=!0,u.flags&=-129),he=(u.flags&32)!==0,u.flags&=-33,a===null){if(Ui){if(O?Su(u):ql(),(a=Is)?(a=Gr(a,Nr),a=a!==null&&a.data!=="&"?a:null,a!==null&&(u.memoizedState={dehydrated:a,treeContext:cl!==null?{id:dl,overflow:No}:null,retryLane:536870912,hydrationErrors:null},_=Xh(a),_.return=u,u.child=_,Pr=u,Is=null)):a=null,a===null)throw Ri(u);return Md(a)?u.lanes=32:u.lanes=536870912,null}var Ce=b.children;return b=b.fallback,O?(ql(),O=u.mode,Ce=hd({mode:"hidden",children:Ce},O),b=Gl(b,O,_,null),Ce.return=u,b.return=u,Ce.sibling=b,u.child=Ce,b=u.child,b.memoizedState=Mo(_),b.childLanes=xf(a,he,_),u.memoizedState=Za,Go(null,b)):(Su(u),Pu(u,Ce))}var st=a.memoizedState;if(st!==null&&(Ce=st.dehydrated,Ce!==null)){if(V)u.flags&256?(Su(u),u.flags&=-257,u=pd(a,u,_)):u.memoizedState!==null?(ql(),u.child=a.child,u.flags|=128,u=null):(ql(),Ce=b.fallback,O=u.mode,b=hd({mode:"visible",children:b.children},O),Ce=Gl(Ce,O,_,null),Ce.flags|=2,b.return=u,Ce.return=u,b.sibling=Ce,u.child=b,mc(u,a.child,null,_),b=u.child,b.memoizedState=Mo(_),b.childLanes=xf(a,he,_),u.memoizedState=Za,u=Go(null,b));else if(Su(u),Md(Ce)){if(he=Ce.nextSibling&&Ce.nextSibling.dataset,he)var Pt=he.dgst;he=Pt,b=Error(i(419)),b.stack="",b.digest=he,nd({value:b,source:null,stack:null}),u=pd(a,u,_)}else if(zs||yu(a,u,_,!1),he=(_&a.childLanes)!==0,zs||he){if(he=rs,he!==null&&(b=ge(he,_),b!==0&&b!==st.retryLane))throw st.retryLane=b,Ul(a,b),m(he,a,b),yh;Ac(Ce)||ci(),u=pd(a,u,_)}else Ac(Ce)?(u.flags|=192,u.child=a.child,u=null):(a=st.treeContext,Is=Co(Ce.nextSibling),Pr=u,Ui=!0,fl=null,Nr=!1,a!==null&&tf(u,a),u=Pu(u,b.children),u.flags|=4096);return u}return O?(ql(),Ce=b.fallback,O=u.mode,st=a.child,Pt=st.sibling,b=ul(st,{mode:"hidden",children:b.children}),b.subtreeFlags=st.subtreeFlags&65011712,Pt!==null?Ce=ul(Pt,Ce):(Ce=Gl(Ce,O,_,null),Ce.flags|=2),Ce.return=u,b.return=u,b.sibling=Ce,u.child=b,Go(null,b),b=u.child,Ce=a.child.memoizedState,Ce===null?Ce=Mo(_):(O=Ce.cachePool,O!==null?(st=Kn._currentValue,O=O.parent!==st?{parent:st,pool:st}:O):O=th(),Ce={baseLanes:Ce.baseLanes|_,cachePool:O}),b.memoizedState=Ce,b.childLanes=xf(a,he,_),u.memoizedState=Za,Go(a.child,b)):(Su(u),_=a.child,a=_.sibling,_=ul(_,{mode:"visible",children:b.children}),_.return=u,_.sibling=null,a!==null&&(he=u.deletions,he===null?(u.deletions=[a],u.flags|=16):he.push(a)),u.child=_,u.memoizedState=null,_)}function Pu(a,u){return u=hd({mode:"visible",children:u},a.mode),u.return=a,a.child=u}function hd(a,u){return a=_a(22,a,null,u),a.lanes=0,a}function pd(a,u,_){return mc(u,a.child,null,_),a=Pu(u,u.pendingProps.children),a.flags|=2,u.memoizedState=null,a}function Yl(a,u,_){a.lanes|=u;var b=a.alternate;b!==null&&(b.lanes|=u),hl(a.return,u,_)}function Mh(a,u,_,b,O,V){var he=a.memoizedState;he===null?a.memoizedState={isBackwards:u,rendering:null,renderingStartTime:0,last:b,tail:_,tailMode:O,treeForkCount:V}:(he.isBackwards=u,he.rendering=null,he.renderingStartTime=0,he.last=b,he.tail=_,he.tailMode=O,he.treeForkCount=V)}function wf(a,u,_){var b=u.pendingProps,O=b.revealOrder,V=b.tail;b=b.children;var he=Xs.current,Ce=(he&2)!==0;if(Ce?(he=he&1|2,u.flags|=128):he&=1,ue(Xs,he),nr(a,u,b,_),b=Ui?td:0,!Ce&&a!==null&&(a.flags&128)!==0)e:for(a=u.child;a!==null;){if(a.tag===13)a.memoizedState!==null&&Yl(a,_,u);else if(a.tag===19)Yl(a,_,u);else if(a.child!==null){a.child.return=a,a=a.child;continue}if(a===u)break e;for(;a.sibling===null;){if(a.return===null||a.return===u)break e;a=a.return}a.sibling.return=a.return,a=a.sibling}switch(O){case"forwards":for(_=u.child,O=null;_!==null;)a=_.alternate,a!==null&&ah(a)===null&&(O=_),_=_.sibling;_=O,_===null?(O=u.child,u.child=null):(O=_.sibling,_.sibling=null),Mh(u,!1,O,_,V,b);break;case"backwards":case"unstable_legacy-backwards":for(_=null,O=u.child,u.child=null;O!==null;){if(a=O.alternate,a!==null&&ah(a)===null){u.child=O;break}a=O.sibling,O.sibling=_,_=O,O=a}Mh(u,!0,_,null,V,b);break;case"together":Mh(u,!1,null,null,void 0,b);break;default:u.memoizedState=null}return u.child}function Vo(a,u,_){if(a!==null&&(u.dependencies=a.dependencies),no|=u.lanes,(_&u.childLanes)===0)if(a!==null){if(yu(a,u,_,!1),(_&u.childLanes)===0)return null}else return null;if(a!==null&&u.child!==a.child)throw Error(i(153));if(u.child!==null){for(a=u.child,_=ul(a,a.pendingProps),u.child=_,_.return=u;a.sibling!==null;)a=a.sibling,_=_.sibling=ul(a,a.pendingProps),_.return=u;_.sibling=null}return u.child}function Ru(a,u){return(a.lanes&u)!==0?!0:(a=a.dependencies,!!(a!==null&&id(a)))}function Ef(a,u,_){switch(u.tag){case 3:Xe(u,u.stateNode.containerInfo),jl(u,Kn,a.memoizedState.cache),fc();break;case 27:case 5:tt(u);break;case 4:Xe(u,u.stateNode.containerInfo);break;case 10:jl(u,u.type,u.memoizedProps.value);break;case 31:if(u.memoizedState!==null)return u.flags|=128,rh(u),null;break;case 13:var b=u.memoizedState;if(b!==null)return b.dehydrated!==null?(Su(u),u.flags|=128,null):(_&u.child.childLanes)!==0?eo(a,u,_):(Su(u),a=Vo(a,u,_),a!==null?a.sibling:null);Su(u);break;case 19:var O=(a.flags&128)!==0;if(b=(_&u.childLanes)!==0,b||(yu(a,u,_,!1),b=(_&u.childLanes)!==0),O){if(b)return wf(a,u,_);u.flags|=128}if(O=u.memoizedState,O!==null&&(O.rendering=null,O.tail=null,O.lastEffect=null),ue(Xs,Xs.current),b)break;return null;case 22:return u.lanes=0,Qa(a,u,_,u.pendingProps);case 24:jl(u,Kn,a.memoizedState.cache)}return Vo(a,u,_)}function Tf(a,u,_){if(a!==null)if(a.memoizedProps!==u.pendingProps)zs=!0;else{if(!Ru(a,_)&&(u.flags&128)===0)return zs=!1,Ef(a,u,_);zs=(a.flags&131072)!==0}else zs=!1,Ui&&(u.flags&1048576)!==0&&Jh(u,td,u.index);switch(u.lanes=0,u.tag){case 16:e:{var b=u.pendingProps;if(a=pc(u.elementType),u.type=a,typeof a=="function")ra(a)?(b=Jr(a,b),u.tag=1,u=Qr(null,u,a,b,_)):(u.tag=0,u=fd(null,u,a,b,_));else{if(a!=null){var O=a.$$typeof;if(O===x){u.tag=11,u=Cu(null,u,a,b,_);break e}else if(O===D){u.tag=14,u=Mf(null,u,a,b,_);break e}}throw u=oe(a)||a,Error(i(306,u,""))}}return u;case 0:return fd(a,u,u.type,u.pendingProps,_);case 1:return b=u.type,O=Jr(b,u.pendingProps),Qr(a,u,b,O,_);case 3:e:{if(Xe(u,u.stateNode.containerInfo),a===null)throw Error(i(387));b=u.pendingProps;var V=u.memoizedState;O=V.element,ih(a,u),gc(u,b,null,_);var he=u.memoizedState;if(b=he.cache,jl(u,Kn,b),b!==V.cache&&Zf(u,[Kn],_,!0),od(),b=he.element,V.isDehydrated)if(V={element:b,isDehydrated:!1,cache:he.cache},u.updateQueue.baseState=V,u.memoizedState=V,u.flags&256){u=Di(a,u,b,_);break e}else if(b!==O){O=va(Error(i(424)),u),nd(O),u=Di(a,u,b,_);break e}else{switch(a=u.stateNode.containerInfo,a.nodeType){case 9:a=a.body;break;default:a=a.nodeName==="HTML"?a.ownerDocument.body:a}for(Is=Co(a.firstChild),Pr=u,Ui=!0,fl=null,Nr=!0,_=lp(u,null,b,_),u.child=_;_;)_.flags=_.flags&-3|4096,_=_.sibling}else{if(fc(),b===O){u=Vo(a,u,_);break e}nr(a,u,b,_)}u=u.child}return u;case 26:return vl(a,u),a===null?(_=zS(u.type,null,u.pendingProps,null))?u.memoizedState=_:Ui||(_=u.type,a=u.pendingProps,b=Ji(Be.current).createElement(_),b[Ne]=u,b[Bt]=a,Un(b,_,a),Ot(b),u.stateNode=b):u.memoizedState=zS(u.type,a.memoizedProps,u.pendingProps,a.memoizedState),null;case 27:return tt(u),a===null&&Ui&&(b=u.stateNode=py(u.type,u.pendingProps,Be.current),Pr=u,Nr=!0,O=Is,El(u.type)?(Qm=O,Is=Co(b.firstChild)):Is=O),nr(a,u,u.pendingProps.children,_),vl(a,u),a===null&&(u.flags|=4194304),u.child;case 5:return a===null&&Ui&&((O=b=Is)&&(b=zx(b,u.type,u.pendingProps,Nr),b!==null?(u.stateNode=b,Pr=u,Is=Co(b.firstChild),Nr=!1,O=!0):O=!1),O||Ri(u)),tt(u),O=u.type,V=u.pendingProps,he=a!==null?a.memoizedProps:null,b=V.children,or(O,V)?b=null:he!==null&&or(O,he)&&(u.flags|=32),u.memoizedState!==null&&(O=uh(a,u,Cm,null,null,_),O0._currentValue=O),vl(a,u),nr(a,u,b,_),u.child;case 6:return a===null&&Ui&&((a=_=Is)&&(_=Qs(_,u.pendingProps,Nr),_!==null?(u.stateNode=_,Pr=u,Is=null,a=!0):a=!1),a||Ri(u)),null;case 13:return eo(a,u,_);case 4:return Xe(u,u.stateNode.containerInfo),b=u.pendingProps,a===null?u.child=mc(u,null,b,_):nr(a,u,b,_),u.child;case 11:return Cu(a,u,u.type,u.pendingProps,_);case 7:return nr(a,u,u.pendingProps,_),u.child;case 8:return nr(a,u,u.pendingProps.children,_),u.child;case 12:return nr(a,u,u.pendingProps.children,_),u.child;case 10:return b=u.pendingProps,jl(u,u.type,b.value),nr(a,u,b.children,_),u.child;case 9:return O=u.type._context,b=u.pendingProps.children,hc(u),O=Rr(O),b=b(O),u.flags|=1,nr(a,u,b,_),u.child;case 14:return Mf(a,u,u.type,u.pendingProps,_);case 15:return Ja(a,u,u.type,u.pendingProps,_);case 19:return wf(a,u,_);case 31:return bf(a,u,_);case 22:return Qa(a,u,_,u.pendingProps);case 24:return hc(u),b=Rr(Kn),a===null?(O=zo(),O===null&&(O=rs,V=ip(),O.pooledCache=V,V.refCount++,V!==null&&(O.pooledCacheLanes|=_),O=V),u.memoizedState={parent:b,cache:O},up(u),jl(u,Kn,O)):((a.lanes&_)!==0&&(ih(a,u),gc(u,null,null,_),od()),O=a.memoizedState,V=u.memoizedState,O.parent!==b?(O={parent:b,cache:b},u.memoizedState=O,u.lanes===0&&(u.memoizedState=u.updateQueue.baseState=O),jl(u,Kn,b)):(b=V.cache,jl(u,Kn,b),b!==O.cache&&Zf(u,[Kn],_,!0))),nr(a,u,u.pendingProps.children,_),u.child;case 29:throw u.pendingProps}throw Error(i(156,u.tag))}function La(a){a.flags|=4}function Du(a,u,_,b,O){if((u=(a.mode&32)!==0)&&(u=!1),u){if(a.flags|=16777216,(O&335544128)===O)if(a.stateNode.complete)a.flags|=8192;else if(mn())a.flags|=8192;else throw Jn=rf,sf}else a.flags&=-16777217}function yl(a,u){if(u.type!=="stylesheet"||(u.state.loading&4)!==0)a.flags&=-16777217;else if(a.flags|=16777216,!HS(u))if(mn())a.flags|=8192;else throw Jn=rf,sf}function md(a,u){u!==null&&(a.flags|=4),a.flags&16384&&(u=a.tag!==22?K():536870912,a.lanes|=u,io|=u)}function Sf(a,u){if(!Ui)switch(a.tailMode){case"hidden":u=a.tail;for(var _=null;u!==null;)u.alternate!==null&&(_=u),u=u.sibling;_===null?a.tail=null:_.sibling=null;break;case"collapsed":_=a.tail;for(var b=null;_!==null;)_.alternate!==null&&(b=_),_=_.sibling;b===null?u||a.tail===null?a.tail=null:a.tail.sibling=null:b.sibling=null}}function is(a){var u=a.alternate!==null&&a.alternate.child===a.child,_=0,b=0;if(u)for(var O=a.child;O!==null;)_|=O.lanes|O.childLanes,b|=O.subtreeFlags&65011712,b|=O.flags&65011712,O.return=a,O=O.sibling;else for(O=a.child;O!==null;)_|=O.lanes|O.childLanes,b|=O.subtreeFlags,b|=O.flags,O.return=a,O=O.sibling;return a.subtreeFlags|=b,a.childLanes=_,u}function Np(a,u,_){var b=u.pendingProps;switch(_u(u),u.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return is(u),null;case 1:return is(u),null;case 3:return _=u.stateNode,b=null,a!==null&&(b=a.memoizedState.cache),u.memoizedState.cache!==b&&(u.flags|=2048),mo(Kn),ot(),_.pendingContext&&(_.context=_.pendingContext,_.pendingContext=null),(a===null||a.child===null)&&(vu(u)?La(u):a===null||a.memoizedState.isDehydrated&&(u.flags&256)===0||(u.flags|=1024,Qh())),is(u),null;case 26:var O=u.type,V=u.memoizedState;return a===null?(La(u),V!==null?(is(u),yl(u,V)):(is(u),Du(u,O,null,b,_))):V?V!==a.memoizedState?(La(u),is(u),yl(u,V)):(is(u),u.flags&=-16777217):(a=a.memoizedProps,a!==b&&La(u),is(u),Du(u,O,a,b,_)),null;case 27:if(Ae(u),_=Be.current,O=u.type,a!==null&&u.stateNode!=null)a.memoizedProps!==b&&La(u);else{if(!b){if(u.stateNode===null)throw Error(i(166));return is(u),null}a=ae.current,vu(u)?Qf(u):(a=py(O,b,_),u.stateNode=a,La(u))}return is(u),null;case 5:if(Ae(u),O=u.type,a!==null&&u.stateNode!=null)a.memoizedProps!==b&&La(u);else{if(!b){if(u.stateNode===null)throw Error(i(166));return is(u),null}if(V=ae.current,vu(u))Qf(u);else{var he=Ji(Be.current);switch(V){case 1:V=he.createElementNS("http://www.w3.org/2000/svg",O);break;case 2:V=he.createElementNS("http://www.w3.org/1998/Math/MathML",O);break;default:switch(O){case"svg":V=he.createElementNS("http://www.w3.org/2000/svg",O);break;case"math":V=he.createElementNS("http://www.w3.org/1998/Math/MathML",O);break;case"script":V=he.createElement("div"),V.innerHTML="<script><\/script>",V=V.removeChild(V.firstChild);break;case"select":V=typeof b.is=="string"?he.createElement("select",{is:b.is}):he.createElement("select"),b.multiple?V.multiple=!0:b.size&&(V.size=b.size);break;default:V=typeof b.is=="string"?he.createElement(O,{is:b.is}):he.createElement(O)}}V[Ne]=u,V[Bt]=b;e:for(he=u.child;he!==null;){if(he.tag===5||he.tag===6)V.appendChild(he.stateNode);else if(he.tag!==4&&he.tag!==27&&he.child!==null){he.child.return=he,he=he.child;continue}if(he===u)break e;for(;he.sibling===null;){if(he.return===null||he.return===u)break e;he=he.return}he.sibling.return=he.return,he=he.sibling}u.stateNode=V;e:switch(Un(V,O,b),O){case"button":case"input":case"select":case"textarea":b=!!b.autoFocus;break e;case"img":b=!0;break e;default:b=!1}b&&La(u)}}return is(u),Du(u,u.type,a===null?null:a.memoizedProps,u.pendingProps,_),null;case 6:if(a&&u.stateNode!=null)a.memoizedProps!==b&&La(u);else{if(typeof b!="string"&&u.stateNode===null)throw Error(i(166));if(a=Be.current,vu(u)){if(a=u.stateNode,_=u.memoizedProps,b=null,O=Pr,O!==null)switch(O.tag){case 27:case 5:b=O.memoizedProps}a[Ne]=u,a=!!(a.nodeValue===_||b!==null&&b.suppressHydrationWarning===!0||In(a.nodeValue,_)),a||Ri(u,!0)}else a=Ji(a).createTextNode(b),a[Ne]=u,u.stateNode=a}return is(u),null;case 31:if(_=u.memoizedState,a===null||a.memoizedState!==null){if(b=vu(u),_!==null){if(a===null){if(!b)throw Error(i(318));if(a=u.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(i(557));a[Ne]=u}else fc(),(u.flags&128)===0&&(u.memoizedState=null),u.flags|=4;is(u),a=!1}else _=Qh(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=_),a=!0;if(!a)return u.flags&256?(la(u),u):(la(u),null);if((u.flags&128)!==0)throw Error(i(558))}return is(u),null;case 13:if(b=u.memoizedState,a===null||a.memoizedState!==null&&a.memoizedState.dehydrated!==null){if(O=vu(u),b!==null&&b.dehydrated!==null){if(a===null){if(!O)throw Error(i(318));if(O=u.memoizedState,O=O!==null?O.dehydrated:null,!O)throw Error(i(317));O[Ne]=u}else fc(),(u.flags&128)===0&&(u.memoizedState=null),u.flags|=4;is(u),O=!1}else O=Qh(),a!==null&&a.memoizedState!==null&&(a.memoizedState.hydrationErrors=O),O=!0;if(!O)return u.flags&256?(la(u),u):(la(u),null)}return la(u),(u.flags&128)!==0?(u.lanes=_,u):(_=b!==null,a=a!==null&&a.memoizedState!==null,_&&(b=u.child,O=null,b.alternate!==null&&b.alternate.memoizedState!==null&&b.alternate.memoizedState.cachePool!==null&&(O=b.alternate.memoizedState.cachePool.pool),V=null,b.memoizedState!==null&&b.memoizedState.cachePool!==null&&(V=b.memoizedState.cachePool.pool),V!==O&&(b.flags|=2048)),_!==a&&_&&(u.child.flags|=8192),md(u,u.updateQueue),is(u),null);case 4:return ot(),a===null&&f_(u.stateNode.containerInfo),is(u),null;case 10:return mo(u.type),is(u),null;case 19:if(te(Xs),b=u.memoizedState,b===null)return is(u),null;if(O=(u.flags&128)!==0,V=b.rendering,V===null)if(O)Sf(b,!1);else{if(qi!==0||a!==null&&(a.flags&128)!==0)for(a=u.child;a!==null;){if(V=ah(a),V!==null){for(u.flags|=128,Sf(b,!1),a=V.updateQueue,u.updateQueue=a,md(u,a),u.subtreeFlags=0,a=_,_=u.child;_!==null;)aa(_,a),_=_.sibling;return ue(Xs,Xs.current&1|2),Ui&&Vl(u,b.treeForkCount),u.child}a=a.sibling}b.tail!==null&&me()>Eo&&(u.flags|=128,O=!0,Sf(b,!1),u.lanes=4194304)}else{if(!O)if(a=ah(V),a!==null){if(u.flags|=128,O=!0,a=a.updateQueue,u.updateQueue=a,md(u,a),Sf(b,!0),b.tail===null&&b.tailMode==="hidden"&&!V.alternate&&!Ui)return is(u),null}else 2*me()-b.renderingStartTime>Eo&&_!==536870912&&(u.flags|=128,O=!0,Sf(b,!1),u.lanes=4194304);b.isBackwards?(V.sibling=u.child,u.child=V):(a=b.last,a!==null?a.sibling=V:u.child=V,b.last=V)}return b.tail!==null?(a=b.tail,b.rendering=a,b.tail=a.sibling,b.renderingStartTime=me(),a.sibling=null,_=Xs.current,ue(Xs,O?_&1|2:_&1),Ui&&Vl(u,b.treeForkCount),a):(is(u),null);case 22:case 23:return la(u),oa(),b=u.memoizedState!==null,a!==null?a.memoizedState!==null!==b&&(u.flags|=8192):b&&(u.flags|=8192),b?(_&536870912)!==0&&(u.flags&128)===0&&(is(u),u.subtreeFlags&6&&(u.flags|=8192)):is(u),_=u.updateQueue,_!==null&&md(u,_.retryQueue),_=null,a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(_=a.memoizedState.cachePool.pool),b=null,u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(b=u.memoizedState.cachePool.pool),b!==_&&(u.flags|=2048),a!==null&&te(bu),null;case 24:return _=null,a!==null&&(_=a.memoizedState.cache),u.memoizedState.cache!==_&&(u.flags|=2048),mo(Kn),is(u),null;case 25:return null;case 30:return null}throw Error(i(156,u.tag))}function bh(a,u){switch(_u(u),u.tag){case 1:return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 3:return mo(Kn),ot(),a=u.flags,(a&65536)!==0&&(a&128)===0?(u.flags=a&-65537|128,u):null;case 26:case 27:case 5:return Ae(u),null;case 31:if(u.memoizedState!==null){if(la(u),u.alternate===null)throw Error(i(340));fc()}return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 13:if(la(u),a=u.memoizedState,a!==null&&a.dehydrated!==null){if(u.alternate===null)throw Error(i(340));fc()}return a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 19:return te(Xs),null;case 4:return ot(),null;case 10:return mo(u.type),null;case 22:case 23:return la(u),oa(),a!==null&&te(bu),a=u.flags,a&65536?(u.flags=a&-65537|128,u):null;case 24:return mo(Kn),null;case 25:return null;default:return null}}function Bu(a,u){switch(_u(u),u.tag){case 3:mo(Kn),ot();break;case 26:case 27:case 5:Ae(u);break;case 4:ot();break;case 31:u.memoizedState!==null&&la(u);break;case 13:la(u);break;case 19:te(Xs);break;case 10:mo(u.type);break;case 22:case 23:la(u),oa(),a!==null&&te(bu);break;case 24:mo(Kn)}}function Ml(a,u){try{var _=u.updateQueue,b=_!==null?_.lastEffect:null;if(b!==null){var O=b.next;_=O;do{if((_.tag&a)===a){b=void 0;var V=_.create,he=_.inst;b=V(),he.destroy=b}_=_.next}while(_!==O)}}catch(Ce){Ls(u,u.return,Ce)}}function bo(a,u,_){try{var b=u.updateQueue,O=b!==null?b.lastEffect:null;if(O!==null){var V=O.next;b=V;do{if((b.tag&a)===a){var he=b.inst,Ce=he.destroy;if(Ce!==void 0){he.destroy=void 0,O=u;var st=_,Pt=Ce;try{Pt()}catch(qt){Ls(O,st,qt)}}}b=b.next}while(b!==V)}}catch(qt){Ls(u,u.return,qt)}}function Jl(a){var u=a.updateQueue;if(u!==null){var _=a.stateNode;try{zr(u,_)}catch(b){Ls(a,a.return,b)}}}function zp(a,u,_){_.props=Jr(a.type,a.memoizedProps),_.state=a.memoizedState;try{_.componentWillUnmount()}catch(b){Ls(a,u,b)}}function bl(a,u){try{var _=a.ref;if(_!==null){switch(a.tag){case 26:case 27:case 5:var b=a.stateNode;break;case 30:b=a.stateNode;break;default:b=a.stateNode}typeof _=="function"?a.refCleanup=_(b):_.current=b}}catch(O){Ls(a,u,O)}}function Ea(a,u){var _=a.ref,b=a.refCleanup;if(_!==null)if(typeof b=="function")try{b()}catch(O){Ls(a,u,O)}finally{a.refCleanup=null,a=a.alternate,a!=null&&(a.refCleanup=null)}else if(typeof _=="function")try{_(null)}catch(O){Ls(a,u,O)}else _.current=null}function to(a){var u=a.type,_=a.memoizedProps,b=a.stateNode;try{e:switch(u){case"button":case"input":case"select":case"textarea":_.autoFocus&&b.focus();break e;case"img":_.src?b.src=_.src:_.srcSet&&(b.srcset=_.srcSet)}}catch(O){Ls(a,a.return,O)}}function xo(a,u,_){try{var b=a.stateNode;qn(b,a.type,_,u),b[Bt]=u}catch(O){Ls(a,a.return,O)}}function xr(a){return a.tag===5||a.tag===3||a.tag===26||a.tag===27&&El(a.type)||a.tag===4}function xl(a){e:for(;;){for(;a.sibling===null;){if(a.return===null||xr(a.return))return null;a=a.return}for(a.sibling.return=a.return,a=a.sibling;a.tag!==5&&a.tag!==6&&a.tag!==18;){if(a.tag===27&&El(a.type)||a.flags&2||a.child===null||a.tag===4)continue e;a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}function gi(a,u,_){var b=a.tag;if(b===5||b===6)a=a.stateNode,u?(_.nodeType===9?_.body:_.nodeName==="HTML"?_.ownerDocument.body:_).insertBefore(a,u):(u=_.nodeType===9?_.body:_.nodeName==="HTML"?_.ownerDocument.body:_,u.appendChild(a),_=_._reactRootContainer,_!=null||u.onclick!==null||(u.onclick=Qn));else if(b!==4&&(b===27&&El(a.type)&&(_=a.stateNode,u=null),a=a.child,a!==null))for(gi(a,u,_),a=a.sibling;a!==null;)gi(a,u,_),a=a.sibling}function Wi(a,u,_){var b=a.tag;if(b===5||b===6)a=a.stateNode,u?_.insertBefore(a,u):_.appendChild(a);else if(b!==4&&(b===27&&El(a.type)&&(_=a.stateNode),a=a.child,a!==null))for(Wi(a,u,_),a=a.sibling;a!==null;)Wi(a,u,_),a=a.sibling}function wr(a){var u=a.stateNode,_=a.memoizedProps;try{for(var b=a.type,O=u.attributes;O.length;)u.removeAttributeNode(O[0]);Un(u,b,_),u[Ne]=a,u[Bt]=_}catch(V){Ls(a,a.return,V)}}var wo=!1,Us=!1,wl=!1,Af=typeof WeakSet=="function"?WeakSet:Set,ir=null;function bc(a,u){if(a=a.containerInfo,kn=by,a=uc(a),po(a)){if("selectionStart"in a)var _={start:a.selectionStart,end:a.selectionEnd};else e:{_=(_=a.ownerDocument)&&_.defaultView||window;var b=_.getSelection&&_.getSelection();if(b&&b.rangeCount!==0){_=b.anchorNode;var O=b.anchorOffset,V=b.focusNode;b=b.focusOffset;try{_.nodeType,V.nodeType}catch{_=null;break e}var he=0,Ce=-1,st=-1,Pt=0,qt=0,nn=a,It=null;t:for(;;){for(var kt;nn!==_||O!==0&&nn.nodeType!==3||(Ce=he+O),nn!==V||b!==0&&nn.nodeType!==3||(st=he+b),nn.nodeType===3&&(he+=nn.nodeValue.length),(kt=nn.firstChild)!==null;)It=nn,nn=kt;for(;;){if(nn===a)break t;if(It===_&&++Pt===O&&(Ce=he),It===V&&++qt===b&&(st=he),(kt=nn.nextSibling)!==null)break;nn=It,It=nn.parentNode}nn=kt}_=Ce===-1||st===-1?null:{start:Ce,end:st}}else _=null}_=_||{start:0,end:0}}else _=null;for(Bi={focusedElem:a,selectionRange:_},by=!1,ir=u;ir!==null;)if(u=ir,a=u.child,(u.subtreeFlags&1028)!==0&&a!==null)a.return=u,ir=a;else for(;ir!==null;){switch(u=ir,V=u.alternate,a=u.flags,u.tag){case 0:if((a&4)!==0&&(a=u.updateQueue,a=a!==null?a.events:null,a!==null))for(_=0;_<a.length;_++)O=a[_],O.ref.impl=O.nextImpl;break;case 11:case 15:break;case 1:if((a&1024)!==0&&V!==null){a=void 0,_=u,O=V.memoizedProps,V=V.memoizedState,b=_.stateNode;try{var Gn=Jr(_.type,O);a=b.getSnapshotBeforeUpdate(Gn,V),b.__reactInternalSnapshotBeforeUpdate=a}catch(ui){Ls(_,_.return,ui)}}break;case 3:if((a&1024)!==0){if(a=u.stateNode.containerInfo,_=a.nodeType,_===9)Ah(a);else if(_===1)switch(a.nodeName){case"HEAD":case"HTML":case"BODY":Ah(a);break;default:a.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((a&1024)!==0)throw Error(i(163))}if(a=u.sibling,a!==null){a.return=u.return,ir=a;break}ir=u.return}}function Km(a,u,_){var b=_.flags;switch(_.tag){case 0:case 11:case 15:Zl(a,_),b&4&&Ml(5,_);break;case 1:if(Zl(a,_),b&4)if(a=_.stateNode,u===null)try{a.componentDidMount()}catch(he){Ls(_,_.return,he)}else{var O=Jr(_.type,u.memoizedProps);u=u.memoizedState;try{a.componentDidUpdate(O,u,a.__reactInternalSnapshotBeforeUpdate)}catch(he){Ls(_,_.return,he)}}b&64&&Jl(_),b&512&&bl(_,_.return);break;case 3:if(Zl(a,_),b&64&&(a=_.updateQueue,a!==null)){if(u=null,_.child!==null)switch(_.child.tag){case 27:case 5:u=_.child.stateNode;break;case 1:u=_.child.stateNode}try{zr(a,u)}catch(he){Ls(_,_.return,he)}}break;case 27:u===null&&b&4&&wr(_);case 26:case 5:Zl(a,_),u===null&&b&4&&to(_),b&512&&bl(_,_.return);break;case 12:Zl(a,_);break;case 31:Zl(a,_),b&4&&gd(a,_);break;case 13:Zl(a,_),b&4&&Up(a,_),b&64&&(a=_.memoizedState,a!==null&&(a=a.dehydrated,a!==null&&(_=Bx.bind(null,_),Vp(a,_))));break;case 22:if(b=_.memoizedState!==null||wo,!b){u=u!==null&&u.memoizedState!==null||Us,O=wo;var V=Us;wo=b,(Us=u)&&!V?ss(a,_,(_.subtreeFlags&8772)!==0):Zl(a,_),wo=O,Us=V}break;case 30:break;default:Zl(a,_)}}function xh(a){var u=a.alternate;u!==null&&(a.alternate=null,xh(u)),a.child=null,a.deletions=null,a.sibling=null,a.tag===5&&(u=a.stateNode,u!==null&&Se(u)),a.stateNode=null,a.return=null,a.dependencies=null,a.memoizedProps=null,a.memoizedState=null,a.pendingProps=null,a.stateNode=null,a.updateQueue=null}var Gi=null,Dr=!1;function Ta(a,u,_){for(_=_.child;_!==null;)Ql(a,u,_),_=_.sibling}function Ql(a,u,_){if(Jt&&typeof Jt.onCommitFiberUnmount=="function")try{Jt.onCommitFiberUnmount(bt,_)}catch{}switch(_.tag){case 26:Us||Ea(_,u),Ta(a,u,_),_.memoizedState?_.memoizedState.count--:_.stateNode&&(_=_.stateNode,_.parentNode.removeChild(_));break;case 27:Us||Ea(_,u);var b=Gi,O=Dr;El(_.type)&&(Gi=_.stateNode,Dr=!1),Ta(a,u,_),Ch(_.stateNode),Gi=b,Dr=O;break;case 5:Us||Ea(_,u);case 6:if(b=Gi,O=Dr,Gi=null,Ta(a,u,_),Gi=b,Dr=O,Gi!==null)if(Dr)try{(Gi.nodeType===9?Gi.body:Gi.nodeName==="HTML"?Gi.ownerDocument.body:Gi).removeChild(_.stateNode)}catch(V){Ls(_,u,V)}else try{Gi.removeChild(_.stateNode)}catch(V){Ls(_,u,V)}break;case 18:Gi!==null&&(Dr?(a=Gi,Sh(a.nodeType===9?a.body:a.nodeName==="HTML"?a.ownerDocument.body:a,_.stateNode),y_(a)):Sh(Gi,_.stateNode));break;case 4:b=Gi,O=Dr,Gi=_.stateNode.containerInfo,Dr=!0,Ta(a,u,_),Gi=b,Dr=O;break;case 0:case 11:case 14:case 15:bo(2,_,u),Us||bo(4,_,u),Ta(a,u,_);break;case 1:Us||(Ea(_,u),b=_.stateNode,typeof b.componentWillUnmount=="function"&&zp(_,u,b)),Ta(a,u,_);break;case 21:Ta(a,u,_);break;case 22:Us=(b=Us)||_.memoizedState!==null,Ta(a,u,_),Us=b;break;default:Ta(a,u,_)}}function gd(a,u){if(u.memoizedState===null&&(a=u.alternate,a!==null&&(a=a.memoizedState,a!==null))){a=a.dehydrated;try{y_(a)}catch(_){Ls(u,u.return,_)}}}function Up(a,u){if(u.memoizedState===null&&(a=u.alternate,a!==null&&(a=a.memoizedState,a!==null&&(a=a.dehydrated,a!==null))))try{y_(a)}catch(_){Ls(u,u.return,_)}}function qm(a){switch(a.tag){case 31:case 13:case 19:var u=a.stateNode;return u===null&&(u=a.stateNode=new Af),u;case 22:return a=a.stateNode,u=a._retryCache,u===null&&(u=a._retryCache=new Af),u;default:throw Error(i(435,a.tag))}}function hr(a,u){var _=qm(a);u.forEach(function(b){if(!_.has(b)){_.add(b);var O=Ix.bind(null,a,b);b.then(O,O)}})}function kr(a,u){var _=u.deletions;if(_!==null)for(var b=0;b<_.length;b++){var O=_[b],V=a,he=u,Ce=he;e:for(;Ce!==null;){switch(Ce.tag){case 27:if(El(Ce.type)){Gi=Ce.stateNode,Dr=!1;break e}break;case 5:Gi=Ce.stateNode,Dr=!1;break e;case 3:case 4:Gi=Ce.stateNode.containerInfo,Dr=!0;break e}Ce=Ce.return}if(Gi===null)throw Error(i(160));Ql(V,he,O),Gi=null,Dr=!1,V=O.alternate,V!==null&&(V.return=null),O.return=null}if(u.subtreeFlags&13886)for(u=u.child;u!==null;)Iu(u,a),u=u.sibling}var Fa=null;function Iu(a,u){var _=a.alternate,b=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:kr(u,a),sr(a),b&4&&(bo(3,a,a.return),Ml(3,a),bo(5,a,a.return));break;case 1:kr(u,a),sr(a),b&512&&(Us||_===null||Ea(_,_.return)),b&64&&wo&&(a=a.updateQueue,a!==null&&(b=a.callbacks,b!==null&&(_=a.shared.hiddenCallbacks,a.shared.hiddenCallbacks=_===null?b:_.concat(b))));break;case 26:var O=Fa;if(kr(u,a),sr(a),b&512&&(Us||_===null||Ea(_,_.return)),b&4){var V=_!==null?_.memoizedState:null;if(b=a.memoizedState,_===null)if(b===null)if(a.stateNode===null){e:{b=a.type,_=a.memoizedProps,O=O.ownerDocument||O;t:switch(b){case"title":V=O.getElementsByTagName("title")[0],(!V||V[Mn]||V[Ne]||V.namespaceURI==="http://www.w3.org/2000/svg"||V.hasAttribute("itemprop"))&&(V=O.createElement(b),O.head.insertBefore(V,O.querySelector("head > title"))),Un(V,b,_),V[Ne]=a,Ot(V),b=V;break e;case"link":var he=GS("link","href",O).get(b+(_.href||""));if(he){for(var Ce=0;Ce<he.length;Ce++)if(V=he[Ce],V.getAttribute("href")===(_.href==null||_.href===""?null:_.href)&&V.getAttribute("rel")===(_.rel==null?null:_.rel)&&V.getAttribute("title")===(_.title==null?null:_.title)&&V.getAttribute("crossorigin")===(_.crossOrigin==null?null:_.crossOrigin)){he.splice(Ce,1);break t}}V=O.createElement(b),Un(V,b,_),O.head.appendChild(V);break;case"meta":if(he=GS("meta","content",O).get(b+(_.content||""))){for(Ce=0;Ce<he.length;Ce++)if(V=he[Ce],V.getAttribute("content")===(_.content==null?null:""+_.content)&&V.getAttribute("name")===(_.name==null?null:_.name)&&V.getAttribute("property")===(_.property==null?null:_.property)&&V.getAttribute("http-equiv")===(_.httpEquiv==null?null:_.httpEquiv)&&V.getAttribute("charset")===(_.charSet==null?null:_.charSet)){he.splice(Ce,1);break t}}V=O.createElement(b),Un(V,b,_),O.head.appendChild(V);break;default:throw Error(i(468,b))}V[Ne]=a,Ot(V),b=V}a.stateNode=b}else VS(O,a.type,a.stateNode);else a.stateNode=kS(O,b,a.memoizedProps);else V!==b?(V===null?_.stateNode!==null&&(_=_.stateNode,_.parentNode.removeChild(_)):V.count--,b===null?VS(O,a.type,a.stateNode):kS(O,b,a.memoizedProps)):b===null&&a.stateNode!==null&&xo(a,a.memoizedProps,_.memoizedProps)}break;case 27:kr(u,a),sr(a),b&512&&(Us||_===null||Ea(_,_.return)),_!==null&&b&4&&xo(a,a.memoizedProps,_.memoizedProps);break;case 5:if(kr(u,a),sr(a),b&512&&(Us||_===null||Ea(_,_.return)),a.flags&32){O=a.stateNode;try{Ke(O,"")}catch(Gn){Ls(a,a.return,Gn)}}b&4&&a.stateNode!=null&&(O=a.memoizedProps,xo(a,O,_!==null?_.memoizedProps:O)),b&1024&&(wl=!0);break;case 6:if(kr(u,a),sr(a),b&4){if(a.stateNode===null)throw Error(i(162));b=a.memoizedProps,_=a.stateNode;try{_.nodeValue=b}catch(Gn){Ls(a,a.return,Gn)}}break;case 3:if(_y=null,O=Fa,Fa=Zm(u.containerInfo),kr(u,a),Fa=O,sr(a),b&4&&_!==null&&_.memoizedState.isDehydrated)try{y_(u.containerInfo)}catch(Gn){Ls(a,a.return,Gn)}wl&&(wl=!1,wh(a));break;case 4:b=Fa,Fa=Zm(a.stateNode.containerInfo),kr(u,a),sr(a),Fa=b;break;case 12:kr(u,a),sr(a);break;case 31:kr(u,a),sr(a),b&4&&(b=a.updateQueue,b!==null&&(a.updateQueue=null,hr(a,b)));break;case 13:kr(u,a),sr(a),a.child.flags&8192&&a.memoizedState!==null!=(_!==null&&_.memoizedState!==null)&&(nu=me()),b&4&&(b=a.updateQueue,b!==null&&(a.updateQueue=null,hr(a,b)));break;case 22:O=a.memoizedState!==null;var st=_!==null&&_.memoizedState!==null,Pt=wo,qt=Us;if(wo=Pt||O,Us=qt||st,kr(u,a),Us=qt,wo=Pt,sr(a),b&8192)e:for(u=a.stateNode,u._visibility=O?u._visibility&-2:u._visibility|1,O&&(_===null||st||wo||Us||xc(a)),_=null,u=a;;){if(u.tag===5||u.tag===26){if(_===null){st=_=u;try{if(V=st.stateNode,O)he=V.style,typeof he.setProperty=="function"?he.setProperty("display","none","important"):he.display="none";else{Ce=st.stateNode;var nn=st.memoizedProps.style,It=nn!=null&&nn.hasOwnProperty("display")?nn.display:null;Ce.style.display=It==null||typeof It=="boolean"?"":(""+It).trim()}}catch(Gn){Ls(st,st.return,Gn)}}}else if(u.tag===6){if(_===null){st=u;try{st.stateNode.nodeValue=O?"":st.memoizedProps}catch(Gn){Ls(st,st.return,Gn)}}}else if(u.tag===18){if(_===null){st=u;try{var kt=st.stateNode;O?Jm(kt,!0):Jm(st.stateNode,!1)}catch(Gn){Ls(st,st.return,Gn)}}}else if((u.tag!==22&&u.tag!==23||u.memoizedState===null||u===a)&&u.child!==null){u.child.return=u,u=u.child;continue}if(u===a)break e;for(;u.sibling===null;){if(u.return===null||u.return===a)break e;_===u&&(_=null),u=u.return}_===u&&(_=null),u.sibling.return=u.return,u=u.sibling}b&4&&(b=a.updateQueue,b!==null&&(_=b.retryQueue,_!==null&&(b.retryQueue=null,hr(a,_))));break;case 19:kr(u,a),sr(a),b&4&&(b=a.updateQueue,b!==null&&(a.updateQueue=null,hr(a,b)));break;case 30:break;case 21:break;default:kr(u,a),sr(a)}}function sr(a){var u=a.flags;if(u&2){try{for(var _,b=a.return;b!==null;){if(xr(b)){_=b;break}b=b.return}if(_==null)throw Error(i(160));switch(_.tag){case 27:var O=_.stateNode,V=xl(a);Wi(a,V,O);break;case 5:var he=_.stateNode;_.flags&32&&(Ke(he,""),_.flags&=-33);var Ce=xl(a);Wi(a,Ce,he);break;case 3:case 4:var st=_.stateNode.containerInfo,Pt=xl(a);gi(a,Pt,st);break;default:throw Error(i(161))}}catch(qt){Ls(a,a.return,qt)}a.flags&=-3}u&4096&&(a.flags&=-4097)}function wh(a){if(a.subtreeFlags&1024)for(a=a.child;a!==null;){var u=a;wh(u),u.tag===5&&u.flags&1024&&u.stateNode.reset(),a=a.sibling}}function Zl(a,u){if(u.subtreeFlags&8772)for(u=u.child;u!==null;)Km(a,u.alternate,u),u=u.sibling}function xc(a){for(a=a.child;a!==null;){var u=a;switch(u.tag){case 0:case 11:case 14:case 15:bo(4,u,u.return),xc(u);break;case 1:Ea(u,u.return);var _=u.stateNode;typeof _.componentWillUnmount=="function"&&zp(u,u.return,_),xc(u);break;case 27:Ch(u.stateNode);case 26:case 5:Ea(u,u.return),xc(u);break;case 22:u.memoizedState===null&&xc(u);break;case 30:xc(u);break;default:xc(u)}a=a.sibling}}function ss(a,u,_){for(_=_&&(u.subtreeFlags&8772)!==0,u=u.child;u!==null;){var b=u.alternate,O=a,V=u,he=V.flags;switch(V.tag){case 0:case 11:case 15:ss(O,V,_),Ml(4,V);break;case 1:if(ss(O,V,_),b=V,O=b.stateNode,typeof O.componentDidMount=="function")try{O.componentDidMount()}catch(Pt){Ls(b,b.return,Pt)}if(b=V,O=b.updateQueue,O!==null){var Ce=b.stateNode;try{var st=O.shared.hiddenCallbacks;if(st!==null)for(O.shared.hiddenCallbacks=null,O=0;O<st.length;O++)ml(st[O],Ce)}catch(Pt){Ls(b,b.return,Pt)}}_&&he&64&&Jl(V),bl(V,V.return);break;case 27:wr(V);case 26:case 5:ss(O,V,_),_&&b===null&&he&4&&to(V),bl(V,V.return);break;case 12:ss(O,V,_);break;case 31:ss(O,V,_),_&&he&4&&gd(O,V);break;case 13:ss(O,V,_),_&&he&4&&Up(O,V);break;case 22:V.memoizedState===null&&ss(O,V,_),bl(V,V.return);break;case 30:break;default:ss(O,V,_)}u=u.sibling}}function _d(a,u){var _=null;a!==null&&a.memoizedState!==null&&a.memoizedState.cachePool!==null&&(_=a.memoizedState.cachePool.pool),a=null,u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(a=u.memoizedState.cachePool.pool),a!==_&&(a!=null&&a.refCount++,_!=null&&Xr(_))}function eu(a,u){a=null,u.alternate!==null&&(a=u.alternate.memoizedState.cache),u=u.memoizedState.cache,u!==a&&(u.refCount++,a!=null&&Xr(a))}function Br(a,u,_,b){if(u.subtreeFlags&10256)for(u=u.child;u!==null;)Ys(a,u,_,b),u=u.sibling}function Ys(a,u,_,b){var O=u.flags;switch(u.tag){case 0:case 11:case 15:Br(a,u,_,b),O&2048&&Ml(9,u);break;case 1:Br(a,u,_,b);break;case 3:Br(a,u,_,b),O&2048&&(a=null,u.alternate!==null&&(a=u.alternate.memoizedState.cache),u=u.memoizedState.cache,u!==a&&(u.refCount++,a!=null&&Xr(a)));break;case 12:if(O&2048){Br(a,u,_,b),a=u.stateNode;try{var V=u.memoizedProps,he=V.id,Ce=V.onPostCommit;typeof Ce=="function"&&Ce(he,u.alternate===null?"mount":"update",a.passiveEffectDuration,-0)}catch(st){Ls(u,u.return,st)}}else Br(a,u,_,b);break;case 31:Br(a,u,_,b);break;case 13:Br(a,u,_,b);break;case 23:break;case 22:V=u.stateNode,he=u.alternate,u.memoizedState!==null?V._visibility&2?Br(a,u,_,b):vd(a,u):V._visibility&2?Br(a,u,_,b):(V._visibility|=2,Ou(a,u,_,b,(u.subtreeFlags&10256)!==0||!1)),O&2048&&_d(he,u);break;case 24:Br(a,u,_,b),O&2048&&eu(u.alternate,u);break;default:Br(a,u,_,b)}}function Ou(a,u,_,b,O){for(O=O&&((u.subtreeFlags&10256)!==0||!1),u=u.child;u!==null;){var V=a,he=u,Ce=_,st=b,Pt=he.flags;switch(he.tag){case 0:case 11:case 15:Ou(V,he,Ce,st,O),Ml(8,he);break;case 23:break;case 22:var qt=he.stateNode;he.memoizedState!==null?qt._visibility&2?Ou(V,he,Ce,st,O):vd(V,he):(qt._visibility|=2,Ou(V,he,Ce,st,O)),O&&Pt&2048&&_d(he.alternate,he);break;case 24:Ou(V,he,Ce,st,O),O&&Pt&2048&&eu(he.alternate,he);break;default:Ou(V,he,Ce,st,O)}u=u.sibling}}function vd(a,u){if(u.subtreeFlags&10256)for(u=u.child;u!==null;){var _=a,b=u,O=b.flags;switch(b.tag){case 22:vd(_,b),O&2048&&_d(b.alternate,b);break;case 24:vd(_,b),O&2048&&eu(b.alternate,b);break;default:vd(_,b)}u=u.sibling}}var rr=8192;function wc(a,u,_){if(a.subtreeFlags&rr)for(a=a.child;a!==null;)pr(a,u,_),a=a.sibling}function pr(a,u,_){switch(a.tag){case 26:wc(a,u,_),a.flags&rr&&a.memoizedState!==null&&XN(_,Fa,a.memoizedState,a.memoizedProps);break;case 5:wc(a,u,_);break;case 3:case 4:var b=Fa;Fa=Zm(a.stateNode.containerInfo),wc(a,u,_),Fa=b;break;case 22:a.memoizedState===null&&(b=a.alternate,b!==null&&b.memoizedState!==null?(b=rr,rr=16777216,wc(a,u,_),rr=b):wc(a,u,_));break;default:wc(a,u,_)}}function Na(a){var u=a.alternate;if(u!==null&&(a=u.child,a!==null)){u.child=null;do u=a.sibling,a.sibling=null,a=u;while(a!==null)}}function Sa(a){var u=a.deletions;if((a.flags&16)!==0){if(u!==null)for(var _=0;_<u.length;_++){var b=u[_];ir=b,Cf(b,a)}Na(a)}if(a.subtreeFlags&10256)for(a=a.child;a!==null;)Lu(a),a=a.sibling}function Lu(a){switch(a.tag){case 0:case 11:case 15:Sa(a),a.flags&2048&&bo(9,a,a.return);break;case 3:Sa(a);break;case 12:Sa(a);break;case 22:var u=a.stateNode;a.memoizedState!==null&&u._visibility&2&&(a.return===null||a.return.tag!==13)?(u._visibility&=-3,Eh(a)):Sa(a);break;default:Sa(a)}}function Eh(a){var u=a.deletions;if((a.flags&16)!==0){if(u!==null)for(var _=0;_<u.length;_++){var b=u[_];ir=b,Cf(b,a)}Na(a)}for(a=a.child;a!==null;){switch(u=a,u.tag){case 0:case 11:case 15:bo(8,u,u.return),Eh(u);break;case 22:_=u.stateNode,_._visibility&2&&(_._visibility&=-3,Eh(u));break;default:Eh(u)}a=a.sibling}}function Cf(a,u){for(;ir!==null;){var _=ir;switch(_.tag){case 0:case 11:case 15:bo(8,_,u);break;case 23:case 22:if(_.memoizedState!==null&&_.memoizedState.cachePool!==null){var b=_.memoizedState.cachePool.pool;b!=null&&b.refCount++}break;case 24:Xr(_.memoizedState.cache)}if(b=_.child,b!==null)b.return=_,ir=b;else e:for(_=a;ir!==null;){b=ir;var O=b.sibling,V=b.return;if(xh(b),b===_){ir=null;break e}if(O!==null){O.return=V,ir=O;break e}ir=V}}}var Pf={getCacheForType:function(a){var u=Rr(Kn),_=u.data.get(a);return _===void 0&&(_=a(),u.data.set(a,_)),_},cacheSignal:function(){return Rr(Kn).controller.signal}},Th=typeof WeakMap=="function"?WeakMap:Map,Vi=0,rs=null,_i=null,Oi=0,jn=0,Si=null,pi=!1,wi=!1,xs=!1,mr=0,qi=0,no=0,tu=0,Ho=0,Hi=0,io=0,so=null,ca=null,za=!1,nu=0,Li=0,Eo=1/0,Rf=null,iu=null,ar=0,To=null,ro=null,So=0,su=0,Ec=null,Df=null,Fu=0,yd=null;function Aa(){return(Vi&2)!==0&&Oi!==0?Oi&-Oi:q.T!==null?C0():nt()}function f(){if(Hi===0)if((Oi&536870912)===0||Ui){var a=rn;rn<<=1,(rn&3932160)===0&&(rn=262144),Hi=a}else Hi=536870912;return a=Mr.current,a!==null&&(a.flags|=32),Hi}function m(a,u,_){(a===rs&&(jn===2||jn===9)||a.cancelPendingCommit!==null)&&(pt(a,0),ie(a,Oi,Hi,!1)),k(a,_),((Vi&2)===0||a!==rs)&&(a===rs&&((Vi&2)===0&&(tu|=_),qi===4&&ie(a,Oi,Hi,!1)),Sc(a))}function E(a,u,_){if((Vi&6)!==0)throw Error(i(327));var b=!_&&(u&127)===0&&(u&a.expiredLanes)===0||A(a,u),O=b?Tc(a,u):Ua(a,u,!0),V=b;do{if(O===0){wi&&!b&&ie(a,u,0,!1);break}else{if(_=a.current.alternate,V&&!$(_)){O=Ua(a,u,!1),V=!1;continue}if(O===2){if(V=u,a.errorRecoveryDisabledLanes&V)var he=0;else he=a.pendingLanes&-536870913,he=he!==0?he:he&536870912?536870912:0;if(he!==0){u=he;e:{var Ce=a;O=so;var st=Ce.current.memoizedState.isDehydrated;if(st&&(pt(Ce,he).flags|=256),he=Ua(Ce,he,!1),he!==2){if(xs&&!st){Ce.errorRecoveryDisabledLanes|=V,tu|=V,O=4;break e}V=ca,ca=O,V!==null&&(ca===null?ca=V:ca.push.apply(ca,V))}O=he}if(V=!1,O!==2)continue}}if(O===1){pt(a,0),ie(a,u,0,!0);break}e:{switch(b=a,V=O,V){case 0:case 1:throw Error(i(345));case 4:if((u&4194048)!==u)break;case 6:ie(b,u,Hi,!pi);break e;case 2:ca=null;break;case 3:case 5:break;default:throw Error(i(329))}if((u&62914560)===u&&(O=nu+300-me(),10<O)){if(ie(b,u,Hi,!pi),I(b,0,!0)!==0)break e;So=u,b.timeoutHandle=lr(L.bind(null,b,_,ca,Rf,za,u,Hi,tu,io,pi,V,"Throttled",-0,0),O);break e}L(b,_,ca,Rf,za,u,Hi,tu,io,pi,V,null,-0,0)}}break}while(!0);Sc(a)}function L(a,u,_,b,O,V,he,Ce,st,Pt,qt,nn,It,kt){if(a.timeoutHandle=-1,nn=u.subtreeFlags,nn&8192||(nn&16785408)===16785408){nn={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:Qn},pr(u,V,nn);var Gn=(V&62914560)===V?nu-me():(V&4194048)===V?Li-me():0;if(Gn=YN(nn,Gn),Gn!==null){So=V,a.cancelPendingCommit=Gn(ri.bind(null,a,u,V,_,b,O,he,Ce,st,qt,nn,null,It,kt)),ie(a,V,he,!Pt);return}}ri(a,u,V,_,b,O,he,Ce,st)}function $(a){for(var u=a;;){var _=u.tag;if((_===0||_===11||_===15)&&u.flags&16384&&(_=u.updateQueue,_!==null&&(_=_.stores,_!==null)))for(var b=0;b<_.length;b++){var O=_[b],V=O.getSnapshot;O=O.value;try{if(!gs(V(),O))return!1}catch{return!1}}if(_=u.child,u.subtreeFlags&16384&&_!==null)_.return=u,u=_;else{if(u===a)break;for(;u.sibling===null;){if(u.return===null||u.return===a)return!0;u=u.return}u.sibling.return=u.return,u=u.sibling}}return!0}function ie(a,u,_,b){u&=~Ho,u&=~tu,a.suspendedLanes|=u,a.pingedLanes&=~u,b&&(a.warmLanes|=u),b=a.expirationTimes;for(var O=u;0<O;){var V=31-We(O),he=1<<V;b[V]=-1,O&=~he}_!==0&&Q(a,_,u)}function De(){return(Vi&6)===0?(Xm(0),!1):!0}function it(){if(_i!==null){if(jn===0)var a=_i.return;else a=_i,qr=Hl=null,ch(a),wu=null,Eu=0,a=_i;for(;a!==null;)Bu(a.alternate,a),a=a.return;_i=null}}function pt(a,u){var _=a.timeoutHandle;_!==-1&&(a.timeoutHandle=-1,fa(_)),_=a.cancelPendingCommit,_!==null&&(a.cancelPendingCommit=null,_()),So=0,it(),rs=a,_i=_=ul(a.current,null),Oi=u,jn=0,Si=null,pi=!1,wi=A(a,u),xs=!1,io=Hi=Ho=tu=no=qi=0,ca=so=null,za=!1,(u&8)!==0&&(u|=u&32);var b=a.entangledLanes;if(b!==0)for(a=a.entanglements,b&=u;0<b;){var O=31-We(b),V=1<<O;u|=a[O],b&=~V}return mr=u,zl(),_}function Xt(a,u){si=null,q.H=_f,u===xu||u===_o?(u=nh(),jn=3):u===sf?(u=nh(),jn=4):jn=u===yh?8:u!==null&&typeof u=="object"&&typeof u.then=="function"?6:1,Si=u,_i===null&&(qi=1,yf(a,va(u,a.current)))}function mn(){var a=Mr.current;return a===null?!0:(Oi&4194048)===Oi?Xa===null:(Oi&62914560)===Oi||(Oi&536870912)!==0?a===Xa:!1}function An(){var a=q.H;return q.H=_f,a===null?_f:a}function Rn(){var a=q.A;return q.A=Pf,a}function ci(){qi=4,pi||(Oi&4194048)!==Oi&&Mr.current!==null||(wi=!0),(no&134217727)===0&&(tu&134217727)===0||rs===null||ie(rs,Oi,Hi,!1)}function Ua(a,u,_){var b=Vi;Vi|=2;var O=An(),V=Rn();(rs!==a||Oi!==u)&&(Rf=null,pt(a,u)),u=!1;var he=qi;e:do try{if(jn!==0&&_i!==null){var Ce=_i,st=Si;switch(jn){case 8:it(),he=6;break e;case 3:case 2:case 9:case 6:Mr.current===null&&(u=!0);var Pt=jn;if(jn=0,Si=null,cn(a,Ce,st,Pt),_&&wi){he=0;break e}break;default:Pt=jn,jn=0,Si=null,cn(a,Ce,st,Pt)}}Bf(),he=qi;break}catch(qt){Xt(a,qt)}while(!0);return u&&a.shellSuspendCounter++,qr=Hl=null,Vi=b,q.H=O,q.A=V,_i===null&&(rs=null,Oi=0,zl()),he}function Bf(){for(;_i!==null;)_t(_i)}function Tc(a,u){var _=Vi;Vi|=2;var b=An(),O=Rn();rs!==a||Oi!==u?(Rf=null,Eo=me()+500,pt(a,u)):wi=A(a,u);e:do try{if(jn!==0&&_i!==null){u=_i;var V=Si;t:switch(jn){case 1:jn=0,Si=null,cn(a,u,V,1);break;case 2:case 9:if(Em(V)){jn=0,Si=null,Lt(u);break}u=function(){jn!==2&&jn!==9||rs!==a||(jn=7),Sc(a)},V.then(u,u);break e;case 3:jn=7;break e;case 4:jn=5;break e;case 7:Em(V)?(jn=0,Si=null,Lt(u)):(jn=0,Si=null,cn(a,u,V,7));break;case 5:var he=null;switch(_i.tag){case 26:he=_i.memoizedState;case 5:case 27:var Ce=_i;if(he?HS(he):Ce.stateNode.complete){jn=0,Si=null;var st=Ce.sibling;if(st!==null)_i=st;else{var Pt=Ce.return;Pt!==null?(_i=Pt,$n(Pt)):_i=null}break t}}jn=0,Si=null,cn(a,u,V,5);break;case 6:jn=0,Si=null,cn(a,u,V,6);break;case 8:it(),qi=6;break e;default:throw Error(i(462))}}Rt();break}catch(qt){Xt(a,qt)}while(!0);return qr=Hl=null,q.H=b,q.A=O,Vi=_,_i!==null?0:(rs=null,Oi=0,zl(),qi)}function Rt(){for(;_i!==null&&!Tt();)_t(_i)}function _t(a){var u=Tf(a.alternate,a,mr);a.memoizedProps=a.pendingProps,u===null?$n(a):_i=u}function Lt(a){var u=a,_=u.alternate;switch(u.tag){case 15:case 0:u=ua(_,u,u.pendingProps,u.type,void 0,Oi);break;case 11:u=ua(_,u,u.pendingProps,u.type.render,u.ref,Oi);break;case 5:ch(u);default:Bu(_,u),u=_i=aa(u,mr),u=Tf(_,u,mr)}a.memoizedProps=a.pendingProps,u===null?$n(a):_i=u}function cn(a,u,_,b){qr=Hl=null,ch(u),wu=null,Eu=0;var O=u.return;try{if(wa(a,O,u,_,Oi)){qi=1,yf(a,va(_,a.current)),_i=null;return}}catch(V){if(O!==null)throw _i=O,V;qi=1,yf(a,va(_,a.current)),_i=null;return}u.flags&32768?(Ui||b===1?a=!0:wi||(Oi&536870912)!==0?a=!1:(pi=a=!0,(b===2||b===9||b===3||b===6)&&(b=Mr.current,b!==null&&b.tag===13&&(b.flags|=16384))),Os(u,a)):$n(u)}function $n(a){var u=a;do{if((u.flags&32768)!==0){Os(u,pi);return}a=u.return;var _=Np(u.alternate,u,mr);if(_!==null){_i=_;return}if(u=u.sibling,u!==null){_i=u;return}_i=u=a}while(u!==null);qi===0&&(qi=5)}function Os(a,u){do{var _=bh(a.alternate,a);if(_!==null){_.flags&=32767,_i=_;return}if(_=a.return,_!==null&&(_.flags|=32768,_.subtreeFlags=0,_.deletions=null),!u&&(a=a.sibling,a!==null)){_i=a;return}_i=a=_}while(a!==null);qi=6,_i=null}function ri(a,u,_,b,O,V,he,Ce,st){a.cancelPendingCommit=null;do kp();while(ar!==0);if((Vi&6)!==0)throw Error(i(327));if(u!==null){if(u===a.current)throw Error(i(177));if(V=u.lanes|u.childLanes,V|=qf,re(a,_,V,he,Ce,st),a===rs&&(_i=rs=null,Oi=0),ro=u,To=a,So=_,su=V,Ec=O,Df=b,(u.subtreeFlags&10256)!==0||(u.flags&10256)!==0?(a.callbackNode=null,a.callbackPriority=0,Ox(at,function(){return sy(),null})):(a.callbackNode=null,a.callbackPriority=0),b=(u.flags&13878)!==0,(u.subtreeFlags&13878)!==0||b){b=q.T,q.T=null,O=le.p,le.p=2,he=Vi,Vi|=4;try{bc(a,u,_)}finally{Vi=he,le.p=O,q.T=b}}ar=1,Xi(),Ir(),Yi()}}function Xi(){if(ar===1){ar=0;var a=To,u=ro,_=(u.flags&13878)!==0;if((u.subtreeFlags&13878)!==0||_){_=q.T,q.T=null;var b=le.p;le.p=2;var O=Vi;Vi|=4;try{Iu(u,a);var V=Bi,he=uc(a.containerInfo),Ce=V.focusedElem,st=V.selectionRange;if(he!==Ce&&Ce&&Ce.ownerDocument&&lc(Ce.ownerDocument.documentElement,Ce)){if(st!==null&&po(Ce)){var Pt=st.start,qt=st.end;if(qt===void 0&&(qt=Pt),"selectionStart"in Ce)Ce.selectionStart=Pt,Ce.selectionEnd=Math.min(qt,Ce.value.length);else{var nn=Ce.ownerDocument||document,It=nn&&nn.defaultView||window;if(It.getSelection){var kt=It.getSelection(),Gn=Ce.textContent.length,ui=Math.min(st.start,Gn),Zs=st.end===void 0?ui:Math.min(st.end,Gn);!kt.extend&&ui>Zs&&(he=Zs,Zs=ui,ui=he);var Mt=oc(Ce,ui),dt=oc(Ce,Zs);if(Mt&&dt&&(kt.rangeCount!==1||kt.anchorNode!==Mt.node||kt.anchorOffset!==Mt.offset||kt.focusNode!==dt.node||kt.focusOffset!==dt.offset)){var At=nn.createRange();At.setStart(Mt.node,Mt.offset),kt.removeAllRanges(),ui>Zs?(kt.addRange(At),kt.extend(dt.node,dt.offset)):(At.setEnd(dt.node,dt.offset),kt.addRange(At))}}}}for(nn=[],kt=Ce;kt=kt.parentNode;)kt.nodeType===1&&nn.push({element:kt,left:kt.scrollLeft,top:kt.scrollTop});for(typeof Ce.focus=="function"&&Ce.focus(),Ce=0;Ce<nn.length;Ce++){var Zt=nn[Ce];Zt.element.scrollLeft=Zt.left,Zt.element.scrollTop=Zt.top}}by=!!kn,Bi=kn=null}finally{Vi=O,le.p=b,q.T=_}}a.current=u,ar=2}}function Ir(){if(ar===2){ar=0;var a=To,u=ro,_=(u.flags&8772)!==0;if((u.subtreeFlags&8772)!==0||_){_=q.T,q.T=null;var b=le.p;le.p=2;var O=Vi;Vi|=4;try{Km(a,u.alternate,u)}finally{Vi=O,le.p=b,q.T=_}}ar=3}}function Yi(){if(ar===4||ar===3){ar=0,Me();var a=To,u=ro,_=So,b=Df;(u.subtreeFlags&10256)!==0||(u.flags&10256)!==0?ar=5:(ar=0,ro=To=null,Nu(a,a.pendingLanes));var O=a.pendingLanes;if(O===0&&(iu=null),rt(_),u=u.stateNode,Jt&&typeof Jt.onCommitFiberRoot=="function")try{Jt.onCommitFiberRoot(bt,u,void 0,(u.current.flags&128)===128)}catch{}if(b!==null){u=q.T,O=le.p,le.p=2,q.T=null;try{for(var V=a.onRecoverableError,he=0;he<b.length;he++){var Ce=b[he];V(Ce.value,{componentStack:Ce.stack})}}finally{q.T=u,le.p=O}}(So&3)!==0&&kp(),Sc(a),O=a.pendingLanes,(_&261930)!==0&&(O&42)!==0?a===yd?Fu++:(Fu=0,yd=a):Fu=0,Xm(0)}}function Nu(a,u){(a.pooledCacheLanes&=u)===0&&(u=a.pooledCache,u!=null&&(a.pooledCache=null,Xr(u)))}function kp(){return Xi(),Ir(),Yi(),sy()}function sy(){if(ar!==5)return!1;var a=To,u=su;su=0;var _=rt(So),b=q.T,O=le.p;try{le.p=32>_?32:_,q.T=null,_=Ec,Ec=null;var V=To,he=So;if(ar=0,ro=To=null,So=0,(Vi&6)!==0)throw Error(i(331));var Ce=Vi;if(Vi|=4,Lu(V.current),Ys(V,V.current,he,_),Vi=Ce,Xm(0,!1),Jt&&typeof Jt.onPostCommitFiberRoot=="function")try{Jt.onPostCommitFiberRoot(bt,V)}catch{}return!0}finally{le.p=O,q.T=b,Nu(a,u)}}function ry(a,u,_){u=va(_,u),u=Fp(a.stateNode,u,2),a=Wl(a,u,2),a!==null&&(k(a,2),Sc(a))}function Ls(a,u,_){if(a.tag===3)ry(a,a,_);else for(;u!==null;){if(u.tag===3){ry(u,a,_);break}else if(u.tag===1){var b=u.stateNode;if(typeof u.type.getDerivedStateFromError=="function"||typeof b.componentDidCatch=="function"&&(iu===null||!iu.has(b))){a=va(_,a),_=dd(2),b=Wl(u,_,2),b!==null&&(Oa(_,b,u,a),k(b,2),Sc(b));break}}u=u.return}}function T0(a,u,_){var b=a.pingCache;if(b===null){b=a.pingCache=new Th;var O=new Set;b.set(u,O)}else O=b.get(u),O===void 0&&(O=new Set,b.set(u,O));O.has(_)||(xs=!0,O.add(_),a=Dx.bind(null,a,u,_),u.then(a,a))}function Dx(a,u,_){var b=a.pingCache;b!==null&&b.delete(u),a.pingedLanes|=a.suspendedLanes&_,a.warmLanes&=~_,rs===a&&(Oi&_)===_&&(qi===4||qi===3&&(Oi&62914560)===Oi&&300>me()-nu?(Vi&2)===0&&pt(a,0):Ho|=_,io===Oi&&(io=0)),Sc(a)}function ay(a,u){u===0&&(u=K()),a=Ul(a,u),a!==null&&(k(a,u),Sc(a))}function Bx(a){var u=a.memoizedState,_=0;u!==null&&(_=u.retryLane),ay(a,_)}function Ix(a,u){var _=0;switch(a.tag){case 31:case 13:var b=a.stateNode,O=a.memoizedState;O!==null&&(_=O.retryLane);break;case 19:b=a.stateNode;break;case 22:b=a.stateNode._retryCache;break;default:throw Error(i(314))}b!==null&&b.delete(u),ay(a,_)}function Ox(a,u){return Qe(a,u)}var c_=null,Gp=null,S0=!1,d_=!1,A0=!1,If=0;function Sc(a){a!==Gp&&a.next===null&&(Gp===null?c_=Gp=a:Gp=Gp.next=a),d_=!0,S0||(S0=!0,Fx())}function Xm(a,u){if(!A0&&d_){A0=!0;do for(var _=!1,b=c_;b!==null;){if(a!==0){var O=b.pendingLanes;if(O===0)var V=0;else{var he=b.suspendedLanes,Ce=b.pingedLanes;V=(1<<31-We(42|a)+1)-1,V&=O&~(he&~Ce),V=V&201326741?V&201326741|1:V?V|2:0}V!==0&&(_=!0,cy(b,V))}else V=Oi,V=I(b,b===rs?V:0,b.cancelPendingCommit!==null||b.timeoutHandle!==-1),(V&3)===0||A(b,V)||(_=!0,cy(b,V));b=b.next}while(_);A0=!1}}function Lx(){oy()}function oy(){d_=S0=!1;var a=0;If!==0&&Ei()&&(a=If);for(var u=me(),_=null,b=c_;b!==null;){var O=b.next,V=ly(b,u);V===0?(b.next=null,_===null?c_=O:_.next=O,O===null&&(Gp=_)):(_=b,(a!==0||(V&3)!==0)&&(d_=!0)),b=O}ar!==0&&ar!==5||Xm(a),If!==0&&(If=0)}function ly(a,u){for(var _=a.suspendedLanes,b=a.pingedLanes,O=a.expirationTimes,V=a.pendingLanes&-62914561;0<V;){var he=31-We(V),Ce=1<<he,st=O[he];st===-1?((Ce&_)===0||(Ce&b)!==0)&&(O[he]=F(Ce,u)):st<=u&&(a.expiredLanes|=Ce),V&=~Ce}if(u=rs,_=Oi,_=I(a,a===u?_:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),b=a.callbackNode,_===0||a===u&&(jn===2||jn===9)||a.cancelPendingCommit!==null)return b!==null&&b!==null&&mt(b),a.callbackNode=null,a.callbackPriority=0;if((_&3)===0||A(a,_)){if(u=_&-_,u===a.callbackPriority)return u;switch(b!==null&&mt(b),rt(_)){case 2:case 8:_=ht;break;case 32:_=at;break;case 268435456:_=Dt;break;default:_=at}return b=uy.bind(null,a),_=Qe(_,b),a.callbackPriority=u,a.callbackNode=_,u}return b!==null&&b!==null&&mt(b),a.callbackPriority=2,a.callbackNode=null,2}function uy(a,u){if(ar!==0&&ar!==5)return a.callbackNode=null,a.callbackPriority=0,null;var _=a.callbackNode;if(kp()&&a.callbackNode!==_)return null;var b=Oi;return b=I(a,a===rs?b:0,a.cancelPendingCommit!==null||a.timeoutHandle!==-1),b===0?null:(E(a,b,u),ly(a,me()),a.callbackNode!=null&&a.callbackNode===_?uy.bind(null,a):null)}function cy(a,u){if(kp())return null;E(a,u,!0)}function Fx(){Ao(function(){(Vi&6)!==0?Qe(et,Lx):oy()})}function C0(){if(If===0){var a=$l;a===0&&(a=Kt,Kt<<=1,(Kt&261888)===0&&(Kt=256)),If=a}return If}function dy(a){return a==null||typeof a=="symbol"||typeof a=="boolean"?null:typeof a=="function"?a:un(""+a)}function fy(a,u){var _=u.ownerDocument.createElement("input");return _.name=u.name,_.value=u.value,a.id&&_.setAttribute("form",a.id),u.parentNode.insertBefore(_,u),a=new FormData(a),_.parentNode.removeChild(_),a}function Nx(a,u,_,b,O){if(u==="submit"&&_&&_.stateNode===O){var V=dy((O[Bt]||null).action),he=b.submitter;he&&(u=(u=he[Bt]||null)?dy(u.formAction):he.getAttribute("formAction"),u!==null&&(V=u,he=null));var Ce=new Ns("action","action",null,b,O);a.push({event:Ce,listeners:[{instance:null,listener:function(){if(b.defaultPrevented){if(If!==0){var st=he?fy(O,he):new FormData(O);Rp(_,{pending:!0,data:st,method:O.method,action:V},null,st)}}else typeof V=="function"&&(Ce.preventDefault(),st=he?fy(O,he):new FormData(O),Rp(_,{pending:!0,data:st,method:O.method,action:V},V,st))},currentTarget:O}]})}}for(var P0=0;P0<zi.length;P0++){var R0=zi[P0],di=R0.toLowerCase(),hy=R0[0].toUpperCase()+R0.slice(1);ki(di,"on"+hy)}ki(Re,"onAnimationEnd"),ki(ct,"onAnimationIteration"),ki(Nt,"onAnimationStart"),ki("dblclick","onDoubleClick"),ki("focusin","onFocus"),ki("focusout","onBlur"),ki(sn,"onTransitionRun"),ki(pn,"onTransitionStart"),ki(On,"onTransitionCancel"),ki(Zn,"onTransitionEnd"),dn("onMouseEnter",["mouseout","mouseover"]),dn("onMouseLeave",["mouseout","mouseover"]),dn("onPointerEnter",["pointerout","pointerover"]),dn("onPointerLeave",["pointerout","pointerover"]),en("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),en("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),en("onBeforeInput",["compositionend","keypress","textInput","paste"]),en("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),en("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),en("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var gr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),da=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(gr));function Ca(a,u){u=(u&4)!==0;for(var _=0;_<a.length;_++){var b=a[_],O=b.event;b=b.listeners;e:{var V=void 0;if(u)for(var he=b.length-1;0<=he;he--){var Ce=b[he],st=Ce.instance,Pt=Ce.currentTarget;if(Ce=Ce.listener,st!==V&&O.isPropagationStopped())break e;V=Ce,O.currentTarget=Pt;try{V(O)}catch(qt){ga(qt)}O.currentTarget=null,V=st}else for(he=0;he<b.length;he++){if(Ce=b[he],st=Ce.instance,Pt=Ce.currentTarget,Ce=Ce.listener,st!==V&&O.isPropagationStopped())break e;V=Ce,O.currentTarget=Pt;try{V(O)}catch(qt){ga(qt)}O.currentTarget=null,V=st}}}}function yi(a,u){var _=u[xn];_===void 0&&(_=u[xn]=new Set);var b=a+"__bubble";_.has(b)||(Y(u,a,2,!1),_.add(b))}function D0(a,u,_){var b=0;u&&(b|=4),Y(_,a,b,u)}var Ym="_reactListening"+Math.random().toString(36).slice(2);function f_(a){if(!a[Ym]){a[Ym]=!0,jt.forEach(function(_){_!=="selectionchange"&&(da.has(_)||D0(_,!1,a),D0(_,!0,a))});var u=a.nodeType===9?a:a.ownerDocument;u===null||u[Ym]||(u[Ym]=!0,D0("selectionchange",!1,u))}}function Y(a,u,_,b){switch(YS(u)){case 2:var O=ZN;break;case 8:O=ez;break;default:O=jx}_=O.bind(null,u,_,a),O=void 0,!co||u!=="touchstart"&&u!=="touchmove"&&u!=="wheel"||(O=!0),b?O!==void 0?a.addEventListener(u,_,{capture:!0,passive:O}):a.addEventListener(u,_,!0):O!==void 0?a.addEventListener(u,_,{passive:O}):a.addEventListener(u,_,!1)}function X(a,u,_,b,O){var V=b;if((u&1)===0&&(u&2)===0&&b!==null)e:for(;;){if(b===null)return;var he=b.tag;if(he===3||he===4){var Ce=b.stateNode.containerInfo;if(Ce===O)break;if(he===4)for(he=b.return;he!==null;){var st=he.tag;if((st===3||st===4)&&he.stateNode.containerInfo===O)return;he=he.return}for(;Ce!==null;){if(he=we(Ce),he===null)return;if(st=he.tag,st===5||st===6||st===26||st===27){b=V=he;continue e}Ce=Ce.parentNode}}b=b.return}Wr(function(){var Pt=V,qt=Ms(_),nn=[];e:{var It=hi.get(a);if(It!==void 0){var kt=Ns,Gn=a;switch(a){case"keypress":if(Ks(_)===0)break e;case"keydown":case"keyup":kt=Kd;break;case"focusin":Gn="focus",kt=Uc;break;case"focusout":Gn="blur",kt=Uc;break;case"beforeblur":case"afterblur":kt=Uc;break;case"click":if(_.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":kt=Vf;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":kt=Hf;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":kt=tl;break;case Re:case ct:case Nt:kt=Wf;break;case Zn:kt=Xd;break;case"scroll":case"scrollend":kt=Ba;break;case"wheel":kt=fo;break;case"copy":case"cut":case"paste":kt=Vd;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":kt=Hc;break;case"toggle":case"beforetoggle":kt=Jd}var ui=(u&4)!==0,Zs=!ui&&(a==="scroll"||a==="scrollend"),Mt=ui?It!==null?It+"Capture":null:It;ui=[];for(var dt=Pt,At;dt!==null;){var Zt=dt;if(At=Zt.stateNode,Zt=Zt.tag,Zt!==5&&Zt!==26&&Zt!==27||At===null||Mt===null||(Zt=Kr(dt,Mt),Zt!=null&&ui.push(Pe(dt,Zt,At))),Zs)break;dt=dt.return}0<ui.length&&(It=new kt(It,Gn,null,_,qt),nn.push({event:It,listeners:ui}))}}if((u&7)===0){e:{if(It=a==="mouseover"||a==="pointerover",kt=a==="mouseout"||a==="pointerout",It&&_!==ni&&(Gn=_.relatedTarget||_.fromElement)&&(we(Gn)||Gn[on]))break e;if((kt||It)&&(It=qt.window===qt?qt:(It=qt.ownerDocument)?It.defaultView||It.parentWindow:window,kt?(Gn=_.relatedTarget||_.toElement,kt=Pt,Gn=Gn?we(Gn):null,Gn!==null&&(Zs=r(Gn),ui=Gn.tag,Gn!==Zs||ui!==5&&ui!==27&&ui!==6)&&(Gn=null)):(kt=null,Gn=Pt),kt!==Gn)){if(ui=Vf,Zt="onMouseLeave",Mt="onMouseEnter",dt="mouse",(a==="pointerout"||a==="pointerover")&&(ui=Hc,Zt="onPointerLeave",Mt="onPointerEnter",dt="pointer"),Zs=kt==null?It:Je(kt),At=Gn==null?It:Je(Gn),It=new ui(Zt,dt+"leave",kt,_,qt),It.target=Zs,It.relatedTarget=At,Zt=null,we(qt)===Pt&&(ui=new ui(Mt,dt+"enter",Gn,_,qt),ui.target=At,ui.relatedTarget=Zs,Zt=ui),Zs=Zt,kt&&Gn)t:{for(ui=xt,Mt=kt,dt=Gn,At=0,Zt=Mt;Zt;Zt=ui(Zt))At++;Zt=0;for(var ei=dt;ei;ei=ui(ei))Zt++;for(;0<At-Zt;)Mt=ui(Mt),At--;for(;0<Zt-At;)dt=ui(dt),Zt--;for(;At--;){if(Mt===dt||dt!==null&&Mt===dt.alternate){ui=Mt;break t}Mt=ui(Mt),dt=ui(dt)}ui=null}else ui=null;kt!==null&&St(nn,It,kt,ui,!1),Gn!==null&&Zs!==null&&St(nn,Zs,Gn,ui,!0)}}e:{if(It=Pt?Je(Pt):window,kt=It.nodeName&&It.nodeName.toLowerCase(),kt==="select"||kt==="input"&&It.type==="file")var As=Kc;else if(jc(It))if(hu)As=Xc;else{As=Cr;var Yn=al}else kt=It.nodeName,!kt||kt.toLowerCase()!=="input"||It.type!=="checkbox"&&It.type!=="radio"?Pt&&vn(Pt.elementType)&&(As=Kc):As=pu;if(As&&(As=As(a,Pt))){$c(nn,As,_,qt);break e}Yn&&Yn(a,It,Pt),a==="focusout"&&Pt&&It.type==="number"&&Pt.memoizedProps.value!=null&&Ds(It,"number",It.value)}switch(Yn=Pt?Je(Pt):window,a){case"focusin":(jc(Yn)||Yn.contentEditable==="true")&&(ll=Yn,mu=Pt,Nl=null);break;case"focusout":Nl=mu=ll=null;break;case"mousedown":sa=!0;break;case"contextmenu":case"mouseup":case"dragend":sa=!1,gu(nn,_,qt);break;case"selectionchange":if(Yc)break;case"keydown":case"keyup":gu(nn,_,qt)}var Fi;if(Bl)e:{switch(a){case"compositionstart":var ts="onCompositionStart";break e;case"compositionend":ts="onCompositionEnd";break e;case"compositionupdate":ts="onCompositionUpdate";break e}ts=void 0}else Io?ic(a,_)&&(ts="onCompositionEnd"):a==="keydown"&&_.keyCode===229&&(ts="onCompositionStart");ts&&(Ar&&_.locale!=="ko"&&(Io||ts!=="onCompositionStart"?ts==="onCompositionEnd"&&Io&&(Fi=na()):(ms=qt,Sr="value"in ms?ms.value:ms.textContent,Io=!0)),Yn=ut(Pt,ts),0<Yn.length&&(ts=new kc(ts,a,null,_,qt),nn.push({event:ts,listeners:Yn}),Fi?ts.data=Fi:(Fi=rl(_),Fi!==null&&(ts.data=Fi)))),(Fi=Il?du(a,_):sc(a,_))&&(ts=ut(Pt,"onBeforeInput"),0<ts.length&&(Yn=new kc("onBeforeInput","beforeinput",null,_,qt),nn.push({event:Yn,listeners:ts}),Yn.data=Fi)),Nx(nn,a,Pt,_,qt)}Ca(nn,u)})}function Pe(a,u,_){return{instance:a,listener:u,currentTarget:_}}function ut(a,u){for(var _=u+"Capture",b=[];a!==null;){var O=a,V=O.stateNode;if(O=O.tag,O!==5&&O!==26&&O!==27||V===null||(O=Kr(a,_),O!=null&&b.unshift(Pe(a,O,V)),O=Kr(a,u),O!=null&&b.push(Pe(a,O,V))),a.tag===3)return b;a=a.return}return[]}function xt(a){if(a===null)return null;do a=a.return;while(a&&a.tag!==5&&a.tag!==27);return a||null}function St(a,u,_,b,O){for(var V=u._reactName,he=[];_!==null&&_!==b;){var Ce=_,st=Ce.alternate,Pt=Ce.stateNode;if(Ce=Ce.tag,st!==null&&st===b)break;Ce!==5&&Ce!==26&&Ce!==27||Pt===null||(st=Pt,O?(Pt=Kr(_,V),Pt!=null&&he.unshift(Pe(_,Pt,st))):O||(Pt=Kr(_,V),Pt!=null&&he.push(Pe(_,Pt,st)))),_=_.return}he.length!==0&&a.push({event:u,listeners:he})}var Ht=/\r\n?/g,ln=/\u0000|\uFFFD/g;function hn(a){return(typeof a=="string"?a:""+a).replace(Ht,`
`).replace(ln,"")}function In(a,u){return u=hn(u),hn(a)===u}function Cn(a,u,_,b,O,V){switch(_){case"children":typeof b=="string"?u==="body"||u==="textarea"&&b===""||Ke(a,b):(typeof b=="number"||typeof b=="bigint")&&u!=="body"&&Ke(a,""+b);break;case"className":Ln(a,"class",b);break;case"tabIndex":Ln(a,"tabindex",b);break;case"dir":case"role":case"viewBox":case"width":case"height":Ln(a,_,b);break;case"style":$t(a,b,V);break;case"data":if(u!=="object"){Ln(a,"data",b);break}case"src":case"href":if(b===""&&(u!=="a"||_!=="href")){a.removeAttribute(_);break}if(b==null||typeof b=="function"||typeof b=="symbol"||typeof b=="boolean"){a.removeAttribute(_);break}b=un(""+b),a.setAttribute(_,b);break;case"action":case"formAction":if(typeof b=="function"){a.setAttribute(_,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof V=="function"&&(_==="formAction"?(u!=="input"&&Cn(a,u,"name",O.name,O,null),Cn(a,u,"formEncType",O.formEncType,O,null),Cn(a,u,"formMethod",O.formMethod,O,null),Cn(a,u,"formTarget",O.formTarget,O,null)):(Cn(a,u,"encType",O.encType,O,null),Cn(a,u,"method",O.method,O,null),Cn(a,u,"target",O.target,O,null)));if(b==null||typeof b=="symbol"||typeof b=="boolean"){a.removeAttribute(_);break}b=un(""+b),a.setAttribute(_,b);break;case"onClick":b!=null&&(a.onclick=Qn);break;case"onScroll":b!=null&&yi("scroll",a);break;case"onScrollEnd":b!=null&&yi("scrollend",a);break;case"dangerouslySetInnerHTML":if(b!=null){if(typeof b!="object"||!("__html"in b))throw Error(i(61));if(_=b.__html,_!=null){if(O.children!=null)throw Error(i(60));a.innerHTML=_}}break;case"multiple":a.multiple=b&&typeof b!="function"&&typeof b!="symbol";break;case"muted":a.muted=b&&typeof b!="function"&&typeof b!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(b==null||typeof b=="function"||typeof b=="boolean"||typeof b=="symbol"){a.removeAttribute("xlink:href");break}_=un(""+b),a.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",_);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":b!=null&&typeof b!="function"&&typeof b!="symbol"?a.setAttribute(_,""+b):a.removeAttribute(_);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":b&&typeof b!="function"&&typeof b!="symbol"?a.setAttribute(_,""):a.removeAttribute(_);break;case"capture":case"download":b===!0?a.setAttribute(_,""):b!==!1&&b!=null&&typeof b!="function"&&typeof b!="symbol"?a.setAttribute(_,b):a.removeAttribute(_);break;case"cols":case"rows":case"size":case"span":b!=null&&typeof b!="function"&&typeof b!="symbol"&&!isNaN(b)&&1<=b?a.setAttribute(_,b):a.removeAttribute(_);break;case"rowSpan":case"start":b==null||typeof b=="function"||typeof b=="symbol"||isNaN(b)?a.removeAttribute(_):a.setAttribute(_,b);break;case"popover":yi("beforetoggle",a),yi("toggle",a),Pn(a,"popover",b);break;case"xlinkActuate":Ct(a,"http://www.w3.org/1999/xlink","xlink:actuate",b);break;case"xlinkArcrole":Ct(a,"http://www.w3.org/1999/xlink","xlink:arcrole",b);break;case"xlinkRole":Ct(a,"http://www.w3.org/1999/xlink","xlink:role",b);break;case"xlinkShow":Ct(a,"http://www.w3.org/1999/xlink","xlink:show",b);break;case"xlinkTitle":Ct(a,"http://www.w3.org/1999/xlink","xlink:title",b);break;case"xlinkType":Ct(a,"http://www.w3.org/1999/xlink","xlink:type",b);break;case"xmlBase":Ct(a,"http://www.w3.org/XML/1998/namespace","xml:base",b);break;case"xmlLang":Ct(a,"http://www.w3.org/XML/1998/namespace","xml:lang",b);break;case"xmlSpace":Ct(a,"http://www.w3.org/XML/1998/namespace","xml:space",b);break;case"is":Pn(a,"is",b);break;case"innerText":case"textContent":break;default:(!(2<_.length)||_[0]!=="o"&&_[0]!=="O"||_[1]!=="n"&&_[1]!=="N")&&(_=bn.get(_)||_,Pn(a,_,b))}}function ii(a,u,_,b,O,V){switch(_){case"style":$t(a,b,V);break;case"dangerouslySetInnerHTML":if(b!=null){if(typeof b!="object"||!("__html"in b))throw Error(i(61));if(_=b.__html,_!=null){if(O.children!=null)throw Error(i(60));a.innerHTML=_}}break;case"children":typeof b=="string"?Ke(a,b):(typeof b=="number"||typeof b=="bigint")&&Ke(a,""+b);break;case"onScroll":b!=null&&yi("scroll",a);break;case"onScrollEnd":b!=null&&yi("scrollend",a);break;case"onClick":b!=null&&(a.onclick=Qn);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!tn.hasOwnProperty(_))e:{if(_[0]==="o"&&_[1]==="n"&&(O=_.endsWith("Capture"),u=_.slice(2,O?_.length-7:void 0),V=a[Bt]||null,V=V!=null?V[_]:null,typeof V=="function"&&a.removeEventListener(u,V,O),typeof b=="function")){typeof V!="function"&&V!==null&&(_ in a?a[_]=null:a.hasAttribute(_)&&a.removeAttribute(_)),a.addEventListener(u,b,O);break e}_ in a?a[_]=b:b===!0?a.setAttribute(_,""):Pn(a,_,b)}}}function Un(a,u,_){switch(u){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":yi("error",a),yi("load",a);var b=!1,O=!1,V;for(V in _)if(_.hasOwnProperty(V)){var he=_[V];if(he!=null)switch(V){case"src":b=!0;break;case"srcSet":O=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(i(137,u));default:Cn(a,u,V,he,_,null)}}O&&Cn(a,u,"srcSet",_.srcSet,_,null),b&&Cn(a,u,"src",_.src,_,null);return;case"input":yi("invalid",a);var Ce=V=he=O=null,st=null,Pt=null;for(b in _)if(_.hasOwnProperty(b)){var qt=_[b];if(qt!=null)switch(b){case"name":O=qt;break;case"type":he=qt;break;case"checked":st=qt;break;case"defaultChecked":Pt=qt;break;case"value":V=qt;break;case"defaultValue":Ce=qt;break;case"children":case"dangerouslySetInnerHTML":if(qt!=null)throw Error(i(137,u));break;default:Cn(a,u,b,qt,_,null)}}$s(a,V,Ce,st,Pt,he,O,!1);return;case"select":yi("invalid",a),b=he=V=null;for(O in _)if(_.hasOwnProperty(O)&&(Ce=_[O],Ce!=null))switch(O){case"value":V=Ce;break;case"defaultValue":he=Ce;break;case"multiple":b=Ce;default:Cn(a,u,O,Ce,_,null)}u=V,_=he,a.multiple=!!b,u!=null?lt(a,!!b,u,!1):_!=null&&lt(a,!!b,_,!0);return;case"textarea":yi("invalid",a),V=O=b=null;for(he in _)if(_.hasOwnProperty(he)&&(Ce=_[he],Ce!=null))switch(he){case"value":b=Ce;break;case"defaultValue":O=Ce;break;case"children":V=Ce;break;case"dangerouslySetInnerHTML":if(Ce!=null)throw Error(i(91));break;default:Cn(a,u,he,Ce,_,null)}Ie(a,b,O,V);return;case"option":for(st in _)if(_.hasOwnProperty(st)&&(b=_[st],b!=null))switch(st){case"selected":a.selected=b&&typeof b!="function"&&typeof b!="symbol";break;default:Cn(a,u,st,b,_,null)}return;case"dialog":yi("beforetoggle",a),yi("toggle",a),yi("cancel",a),yi("close",a);break;case"iframe":case"object":yi("load",a);break;case"video":case"audio":for(b=0;b<gr.length;b++)yi(gr[b],a);break;case"image":yi("error",a),yi("load",a);break;case"details":yi("toggle",a);break;case"embed":case"source":case"link":yi("error",a),yi("load",a);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(Pt in _)if(_.hasOwnProperty(Pt)&&(b=_[Pt],b!=null))switch(Pt){case"children":case"dangerouslySetInnerHTML":throw Error(i(137,u));default:Cn(a,u,Pt,b,_,null)}return;default:if(vn(u)){for(qt in _)_.hasOwnProperty(qt)&&(b=_[qt],b!==void 0&&ii(a,u,qt,b,_,void 0));return}}for(Ce in _)_.hasOwnProperty(Ce)&&(b=_[Ce],b!=null&&Cn(a,u,Ce,b,_,null))}function qn(a,u,_,b){switch(u){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var O=null,V=null,he=null,Ce=null,st=null,Pt=null,qt=null;for(kt in _){var nn=_[kt];if(_.hasOwnProperty(kt)&&nn!=null)switch(kt){case"checked":break;case"value":break;case"defaultValue":st=nn;default:b.hasOwnProperty(kt)||Cn(a,u,kt,null,b,nn)}}for(var It in b){var kt=b[It];if(nn=_[It],b.hasOwnProperty(It)&&(kt!=null||nn!=null))switch(It){case"type":V=kt;break;case"name":O=kt;break;case"checked":Pt=kt;break;case"defaultChecked":qt=kt;break;case"value":he=kt;break;case"defaultValue":Ce=kt;break;case"children":case"dangerouslySetInnerHTML":if(kt!=null)throw Error(i(137,u));break;default:kt!==nn&&Cn(a,u,It,kt,b,nn)}}ks(a,he,Ce,st,Pt,qt,V,O);return;case"select":kt=he=Ce=It=null;for(V in _)if(st=_[V],_.hasOwnProperty(V)&&st!=null)switch(V){case"value":break;case"multiple":kt=st;default:b.hasOwnProperty(V)||Cn(a,u,V,null,b,st)}for(O in b)if(V=b[O],st=_[O],b.hasOwnProperty(O)&&(V!=null||st!=null))switch(O){case"value":It=V;break;case"defaultValue":Ce=V;break;case"multiple":he=V;default:V!==st&&Cn(a,u,O,V,b,st)}u=Ce,_=he,b=kt,It!=null?lt(a,!!_,It,!1):!!b!=!!_&&(u!=null?lt(a,!!_,u,!0):lt(a,!!_,_?[]:"",!1));return;case"textarea":kt=It=null;for(Ce in _)if(O=_[Ce],_.hasOwnProperty(Ce)&&O!=null&&!b.hasOwnProperty(Ce))switch(Ce){case"value":break;case"children":break;default:Cn(a,u,Ce,null,b,O)}for(he in b)if(O=b[he],V=_[he],b.hasOwnProperty(he)&&(O!=null||V!=null))switch(he){case"value":It=O;break;case"defaultValue":kt=O;break;case"children":break;case"dangerouslySetInnerHTML":if(O!=null)throw Error(i(91));break;default:O!==V&&Cn(a,u,he,O,b,V)}de(a,It,kt);return;case"option":for(var Gn in _)if(It=_[Gn],_.hasOwnProperty(Gn)&&It!=null&&!b.hasOwnProperty(Gn))switch(Gn){case"selected":a.selected=!1;break;default:Cn(a,u,Gn,null,b,It)}for(st in b)if(It=b[st],kt=_[st],b.hasOwnProperty(st)&&It!==kt&&(It!=null||kt!=null))switch(st){case"selected":a.selected=It&&typeof It!="function"&&typeof It!="symbol";break;default:Cn(a,u,st,It,b,kt)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var ui in _)It=_[ui],_.hasOwnProperty(ui)&&It!=null&&!b.hasOwnProperty(ui)&&Cn(a,u,ui,null,b,It);for(Pt in b)if(It=b[Pt],kt=_[Pt],b.hasOwnProperty(Pt)&&It!==kt&&(It!=null||kt!=null))switch(Pt){case"children":case"dangerouslySetInnerHTML":if(It!=null)throw Error(i(137,u));break;default:Cn(a,u,Pt,It,b,kt)}return;default:if(vn(u)){for(var Zs in _)It=_[Zs],_.hasOwnProperty(Zs)&&It!==void 0&&!b.hasOwnProperty(Zs)&&ii(a,u,Zs,void 0,b,It);for(qt in b)It=b[qt],kt=_[qt],!b.hasOwnProperty(qt)||It===kt||It===void 0&&kt===void 0||ii(a,u,qt,It,b,kt);return}}for(var Mt in _)It=_[Mt],_.hasOwnProperty(Mt)&&It!=null&&!b.hasOwnProperty(Mt)&&Cn(a,u,Mt,null,b,It);for(nn in b)It=b[nn],kt=_[nn],!b.hasOwnProperty(nn)||It===kt||It==null&&kt==null||Cn(a,u,nn,It,b,kt)}function Ki(a){switch(a){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function Xn(){if(typeof performance.getEntriesByType=="function"){for(var a=0,u=0,_=performance.getEntriesByType("resource"),b=0;b<_.length;b++){var O=_[b],V=O.transferSize,he=O.initiatorType,Ce=O.duration;if(V&&Ce&&Ki(he)){for(he=0,Ce=O.responseEnd,b+=1;b<_.length;b++){var st=_[b],Pt=st.startTime;if(Pt>Ce)break;var qt=st.transferSize,nn=st.initiatorType;qt&&Ki(nn)&&(st=st.responseEnd,he+=qt*(st<Ce?1:(Ce-Pt)/(st-Pt)))}if(--b,u+=8*(V+he)/(O.duration/1e3),a++,10<a)break}}if(0<a)return u/a/1e6}return navigator.connection&&(a=navigator.connection.downlink,typeof a=="number")?a:5}var kn=null,Bi=null;function Ji(a){return a.nodeType===9?a:a.ownerDocument}function Hs(a){switch(a){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function Js(a,u){if(a===0)switch(u){case"svg":return 1;case"math":return 2;default:return 0}return a===1&&u==="foreignObject"?0:a}function or(a,u){return a==="textarea"||a==="noscript"||typeof u.children=="string"||typeof u.children=="number"||typeof u.children=="bigint"||typeof u.dangerouslySetInnerHTML=="object"&&u.dangerouslySetInnerHTML!==null&&u.dangerouslySetInnerHTML.__html!=null}var _r=null;function Ei(){var a=window.event;return a&&a.type==="popstate"?a===_r?!1:(_r=a,!0):(_r=null,!1)}var lr=typeof setTimeout=="function"?setTimeout:void 0,fa=typeof clearTimeout=="function"?clearTimeout:void 0,Of=typeof Promise=="function"?Promise:void 0,Ao=typeof queueMicrotask=="function"?queueMicrotask:typeof Of<"u"?function(a){return Of.resolve(null).then(a).catch(zu)}:lr;function zu(a){setTimeout(function(){throw a})}function El(a){return a==="head"}function Sh(a,u){var _=u,b=0;do{var O=_.nextSibling;if(a.removeChild(_),O&&O.nodeType===8)if(_=O.data,_==="/$"||_==="/&"){if(b===0){a.removeChild(O),y_(u);return}b--}else if(_==="$"||_==="$?"||_==="$~"||_==="$!"||_==="&")b++;else if(_==="html")Ch(a.ownerDocument.documentElement);else if(_==="head"){_=a.ownerDocument.head,Ch(_);for(var V=_.firstChild;V;){var he=V.nextSibling,Ce=V.nodeName;V[Mn]||Ce==="SCRIPT"||Ce==="STYLE"||Ce==="LINK"&&V.rel.toLowerCase()==="stylesheet"||_.removeChild(V),V=he}}else _==="body"&&Ch(a.ownerDocument.body);_=O}while(_);y_(u)}function Jm(a,u){var _=a;a=0;do{var b=_.nextSibling;if(_.nodeType===1?u?(_._stashedDisplay=_.style.display,_.style.display="none"):(_.style.display=_._stashedDisplay||"",_.getAttribute("style")===""&&_.removeAttribute("style")):_.nodeType===3&&(u?(_._stashedText=_.nodeValue,_.nodeValue=""):_.nodeValue=_._stashedText||""),b&&b.nodeType===8)if(_=b.data,_==="/$"){if(a===0)break;a--}else _!=="$"&&_!=="$?"&&_!=="$~"&&_!=="$!"||a++;_=b}while(_)}function Ah(a){var u=a.firstChild;for(u&&u.nodeType===10&&(u=u.nextSibling);u;){var _=u;switch(u=u.nextSibling,_.nodeName){case"HTML":case"HEAD":case"BODY":Ah(_),Se(_);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(_.rel.toLowerCase()==="stylesheet")continue}a.removeChild(_)}}function zx(a,u,_,b){for(;a.nodeType===1;){var O=_;if(a.nodeName.toLowerCase()!==u.toLowerCase()){if(!b&&(a.nodeName!=="INPUT"||a.type!=="hidden"))break}else if(b){if(!a[Mn])switch(u){case"meta":if(!a.hasAttribute("itemprop"))break;return a;case"link":if(V=a.getAttribute("rel"),V==="stylesheet"&&a.hasAttribute("data-precedence"))break;if(V!==O.rel||a.getAttribute("href")!==(O.href==null||O.href===""?null:O.href)||a.getAttribute("crossorigin")!==(O.crossOrigin==null?null:O.crossOrigin)||a.getAttribute("title")!==(O.title==null?null:O.title))break;return a;case"style":if(a.hasAttribute("data-precedence"))break;return a;case"script":if(V=a.getAttribute("src"),(V!==(O.src==null?null:O.src)||a.getAttribute("type")!==(O.type==null?null:O.type)||a.getAttribute("crossorigin")!==(O.crossOrigin==null?null:O.crossOrigin))&&V&&a.hasAttribute("async")&&!a.hasAttribute("itemprop"))break;return a;default:return a}}else if(u==="input"&&a.type==="hidden"){var V=O.name==null?null:""+O.name;if(O.type==="hidden"&&a.getAttribute("name")===V)return a}else return a;if(a=Co(a.nextSibling),a===null)break}return null}function Qs(a,u,_){if(u==="")return null;for(;a.nodeType!==3;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!_||(a=Co(a.nextSibling),a===null))return null;return a}function Gr(a,u){for(;a.nodeType!==8;)if((a.nodeType!==1||a.nodeName!=="INPUT"||a.type!=="hidden")&&!u||(a=Co(a.nextSibling),a===null))return null;return a}function Ac(a){return a.data==="$?"||a.data==="$~"}function Md(a){return a.data==="$!"||a.data==="$?"&&a.ownerDocument.readyState!=="loading"}function Vp(a,u){var _=a.ownerDocument;if(a.data==="$~")a._reactRetry=u;else if(a.data!=="$?"||_.readyState!=="loading")u();else{var b=function(){u(),_.removeEventListener("DOMContentLoaded",b)};_.addEventListener("DOMContentLoaded",b),a._reactRetry=b}}function Co(a){for(;a!=null;a=a.nextSibling){var u=a.nodeType;if(u===1||u===3)break;if(u===8){if(u=a.data,u==="$"||u==="$!"||u==="$?"||u==="$~"||u==="&"||u==="F!"||u==="F")break;if(u==="/$"||u==="/&")return null}}return a}var Qm=null;function h_(a){a=a.nextSibling;for(var u=0;a;){if(a.nodeType===8){var _=a.data;if(_==="/$"||_==="/&"){if(u===0)return Co(a.nextSibling);u--}else _!=="$"&&_!=="$!"&&_!=="$?"&&_!=="$~"&&_!=="&"||u++}a=a.nextSibling}return null}function p_(a){a=a.previousSibling;for(var u=0;a;){if(a.nodeType===8){var _=a.data;if(_==="$"||_==="$!"||_==="$?"||_==="$~"||_==="&"){if(u===0)return a;u--}else _!=="/$"&&_!=="/&"||u++}a=a.previousSibling}return null}function py(a,u,_){switch(u=Ji(_),a){case"html":if(a=u.documentElement,!a)throw Error(i(452));return a;case"head":if(a=u.head,!a)throw Error(i(453));return a;case"body":if(a=u.body,!a)throw Error(i(454));return a;default:throw Error(i(451))}}function Ch(a){for(var u=a.attributes;u.length;)a.removeAttributeNode(u[0]);Se(a)}var Po=new Map,m_=new Set;function Zm(a){return typeof a.getRootNode=="function"?a.getRootNode():a.nodeType===9?a:a.ownerDocument}var Uu=le.d;le.d={f:g_,r:Ux,D:Ph,C:ku,L:VN,m:HN,X:$N,S:jN,M:WN};function g_(){var a=Uu.f(),u=De();return a||u}function Ux(a){var u=Ge(a);u!==null&&u.tag===5&&u.type==="form"?Bp(u):Uu.r(a)}var Hp=typeof document>"u"?null:document;function my(a,u,_){var b=Hp;if(b&&typeof u=="string"&&u){var O=fi(u);O='link[rel="'+a+'"][href="'+O+'"]',typeof _=="string"&&(O+='[crossorigin="'+_+'"]'),m_.has(O)||(m_.add(O),a={rel:a,crossOrigin:_,href:u},b.querySelector(O)===null&&(u=b.createElement("link"),Un(u,"link",a),Ot(u),b.head.appendChild(u)))}}function Ph(a){Uu.D(a),my("dns-prefetch",a,null)}function ku(a,u){Uu.C(a,u),my("preconnect",a,u)}function VN(a,u,_){Uu.L(a,u,_);var b=Hp;if(b&&a&&u){var O='link[rel="preload"][as="'+fi(u)+'"]';u==="image"&&_&&_.imageSrcSet?(O+='[imagesrcset="'+fi(_.imageSrcSet)+'"]',typeof _.imageSizes=="string"&&(O+='[imagesizes="'+fi(_.imageSizes)+'"]')):O+='[href="'+fi(a)+'"]';var V=O;switch(u){case"style":V=__(a);break;case"script":V=v_(a)}Po.has(V)||(a=p({rel:"preload",href:u==="image"&&_&&_.imageSrcSet?void 0:a,as:u},_),Po.set(V,a),b.querySelector(O)!==null||u==="style"&&b.querySelector(B0(V))||u==="script"&&b.querySelector(I0(V))||(u=b.createElement("link"),Un(u,"link",a),Ot(u),b.head.appendChild(u)))}}function HN(a,u){Uu.m(a,u);var _=Hp;if(_&&a){var b=u&&typeof u.as=="string"?u.as:"script",O='link[rel="modulepreload"][as="'+fi(b)+'"][href="'+fi(a)+'"]',V=O;switch(b){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":V=v_(a)}if(!Po.has(V)&&(a=p({rel:"modulepreload",href:a},u),Po.set(V,a),_.querySelector(O)===null)){switch(b){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(_.querySelector(I0(V)))return}b=_.createElement("link"),Un(b,"link",a),Ot(b),_.head.appendChild(b)}}}function jN(a,u,_){Uu.S(a,u,_);var b=Hp;if(b&&a){var O=Ue(b).hoistableStyles,V=__(a);u=u||"default";var he=O.get(V);if(!he){var Ce={loading:0,preload:null};if(he=b.querySelector(B0(V)))Ce.loading=5;else{a=p({rel:"stylesheet",href:a,"data-precedence":u},_),(_=Po.get(V))&&kx(a,_);var st=he=b.createElement("link");Ot(st),Un(st,"link",a),st._p=new Promise(function(Pt,qt){st.onload=Pt,st.onerror=qt}),st.addEventListener("load",function(){Ce.loading|=1}),st.addEventListener("error",function(){Ce.loading|=2}),Ce.loading|=4,gy(he,u,b)}he={type:"stylesheet",instance:he,count:1,state:Ce},O.set(V,he)}}}function $N(a,u){Uu.X(a,u);var _=Hp;if(_&&a){var b=Ue(_).hoistableScripts,O=v_(a),V=b.get(O);V||(V=_.querySelector(I0(O)),V||(a=p({src:a,async:!0},u),(u=Po.get(O))&&Gx(a,u),V=_.createElement("script"),Ot(V),Un(V,"link",a),_.head.appendChild(V)),V={type:"script",instance:V,count:1,state:null},b.set(O,V))}}function WN(a,u){Uu.M(a,u);var _=Hp;if(_&&a){var b=Ue(_).hoistableScripts,O=v_(a),V=b.get(O);V||(V=_.querySelector(I0(O)),V||(a=p({src:a,async:!0,type:"module"},u),(u=Po.get(O))&&Gx(a,u),V=_.createElement("script"),Ot(V),Un(V,"link",a),_.head.appendChild(V)),V={type:"script",instance:V,count:1,state:null},b.set(O,V))}}function zS(a,u,_,b){var O=(O=Be.current)?Zm(O):null;if(!O)throw Error(i(446));switch(a){case"meta":case"title":return null;case"style":return typeof _.precedence=="string"&&typeof _.href=="string"?(u=__(_.href),_=Ue(O).hoistableStyles,b=_.get(u),b||(b={type:"style",instance:null,count:0,state:null},_.set(u,b)),b):{type:"void",instance:null,count:0,state:null};case"link":if(_.rel==="stylesheet"&&typeof _.href=="string"&&typeof _.precedence=="string"){a=__(_.href);var V=Ue(O).hoistableStyles,he=V.get(a);if(he||(O=O.ownerDocument||O,he={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},V.set(a,he),(V=O.querySelector(B0(a)))&&!V._p&&(he.instance=V,he.state.loading=5),Po.has(a)||(_={rel:"preload",as:"style",href:_.href,crossOrigin:_.crossOrigin,integrity:_.integrity,media:_.media,hrefLang:_.hrefLang,referrerPolicy:_.referrerPolicy},Po.set(a,_),V||KN(O,a,_,he.state))),u&&b===null)throw Error(i(528,""));return he}if(u&&b!==null)throw Error(i(529,""));return null;case"script":return u=_.async,_=_.src,typeof _=="string"&&u&&typeof u!="function"&&typeof u!="symbol"?(u=v_(_),_=Ue(O).hoistableScripts,b=_.get(u),b||(b={type:"script",instance:null,count:0,state:null},_.set(u,b)),b):{type:"void",instance:null,count:0,state:null};default:throw Error(i(444,a))}}function __(a){return'href="'+fi(a)+'"'}function B0(a){return'link[rel="stylesheet"]['+a+"]"}function US(a){return p({},a,{"data-precedence":a.precedence,precedence:null})}function KN(a,u,_,b){a.querySelector('link[rel="preload"][as="style"]['+u+"]")?b.loading=1:(u=a.createElement("link"),b.preload=u,u.addEventListener("load",function(){return b.loading|=1}),u.addEventListener("error",function(){return b.loading|=2}),Un(u,"link",_),Ot(u),a.head.appendChild(u))}function v_(a){return'[src="'+fi(a)+'"]'}function I0(a){return"script[async]"+a}function kS(a,u,_){if(u.count++,u.instance===null)switch(u.type){case"style":var b=a.querySelector('style[data-href~="'+fi(_.href)+'"]');if(b)return u.instance=b,Ot(b),b;var O=p({},_,{"data-href":_.href,"data-precedence":_.precedence,href:null,precedence:null});return b=(a.ownerDocument||a).createElement("style"),Ot(b),Un(b,"style",O),gy(b,_.precedence,a),u.instance=b;case"stylesheet":O=__(_.href);var V=a.querySelector(B0(O));if(V)return u.state.loading|=4,u.instance=V,Ot(V),V;b=US(_),(O=Po.get(O))&&kx(b,O),V=(a.ownerDocument||a).createElement("link"),Ot(V);var he=V;return he._p=new Promise(function(Ce,st){he.onload=Ce,he.onerror=st}),Un(V,"link",b),u.state.loading|=4,gy(V,_.precedence,a),u.instance=V;case"script":return V=v_(_.src),(O=a.querySelector(I0(V)))?(u.instance=O,Ot(O),O):(b=_,(O=Po.get(V))&&(b=p({},_),Gx(b,O)),a=a.ownerDocument||a,O=a.createElement("script"),Ot(O),Un(O,"link",b),a.head.appendChild(O),u.instance=O);case"void":return null;default:throw Error(i(443,u.type))}else u.type==="stylesheet"&&(u.state.loading&4)===0&&(b=u.instance,u.state.loading|=4,gy(b,_.precedence,a));return u.instance}function gy(a,u,_){for(var b=_.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),O=b.length?b[b.length-1]:null,V=O,he=0;he<b.length;he++){var Ce=b[he];if(Ce.dataset.precedence===u)V=Ce;else if(V!==O)break}V?V.parentNode.insertBefore(a,V.nextSibling):(u=_.nodeType===9?_.head:_,u.insertBefore(a,u.firstChild))}function kx(a,u){a.crossOrigin==null&&(a.crossOrigin=u.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=u.referrerPolicy),a.title==null&&(a.title=u.title)}function Gx(a,u){a.crossOrigin==null&&(a.crossOrigin=u.crossOrigin),a.referrerPolicy==null&&(a.referrerPolicy=u.referrerPolicy),a.integrity==null&&(a.integrity=u.integrity)}var _y=null;function GS(a,u,_){if(_y===null){var b=new Map,O=_y=new Map;O.set(_,b)}else O=_y,b=O.get(_),b||(b=new Map,O.set(_,b));if(b.has(a))return b;for(b.set(a,null),_=_.getElementsByTagName(a),O=0;O<_.length;O++){var V=_[O];if(!(V[Mn]||V[Ne]||a==="link"&&V.getAttribute("rel")==="stylesheet")&&V.namespaceURI!=="http://www.w3.org/2000/svg"){var he=V.getAttribute(u)||"";he=a+he;var Ce=b.get(he);Ce?Ce.push(V):b.set(he,[V])}}return b}function VS(a,u,_){a=a.ownerDocument||a,a.head.insertBefore(_,u==="title"?a.querySelector("head > title"):null)}function qN(a,u,_){if(_===1||u.itemProp!=null)return!1;switch(a){case"meta":case"title":return!0;case"style":if(typeof u.precedence!="string"||typeof u.href!="string"||u.href==="")break;return!0;case"link":if(typeof u.rel!="string"||typeof u.href!="string"||u.href===""||u.onLoad||u.onError)break;switch(u.rel){case"stylesheet":return a=u.disabled,typeof u.precedence=="string"&&a==null;default:return!0}case"script":if(u.async&&typeof u.async!="function"&&typeof u.async!="symbol"&&!u.onLoad&&!u.onError&&u.src&&typeof u.src=="string")return!0}return!1}function HS(a){return!(a.type==="stylesheet"&&(a.state.loading&3)===0)}function XN(a,u,_,b){if(_.type==="stylesheet"&&(typeof b.media!="string"||matchMedia(b.media).matches!==!1)&&(_.state.loading&4)===0){if(_.instance===null){var O=__(b.href),V=u.querySelector(B0(O));if(V){u=V._p,u!==null&&typeof u=="object"&&typeof u.then=="function"&&(a.count++,a=vy.bind(a),u.then(a,a)),_.state.loading|=4,_.instance=V,Ot(V);return}V=u.ownerDocument||u,b=US(b),(O=Po.get(O))&&kx(b,O),V=V.createElement("link"),Ot(V);var he=V;he._p=new Promise(function(Ce,st){he.onload=Ce,he.onerror=st}),Un(V,"link",b),_.instance=V}a.stylesheets===null&&(a.stylesheets=new Map),a.stylesheets.set(_,u),(u=_.state.preload)&&(_.state.loading&3)===0&&(a.count++,_=vy.bind(a),u.addEventListener("load",_),u.addEventListener("error",_))}}var Vx=0;function YN(a,u){return a.stylesheets&&a.count===0&&My(a,a.stylesheets),0<a.count||0<a.imgCount?function(_){var b=setTimeout(function(){if(a.stylesheets&&My(a,a.stylesheets),a.unsuspend){var V=a.unsuspend;a.unsuspend=null,V()}},6e4+u);0<a.imgBytes&&Vx===0&&(Vx=62500*Xn());var O=setTimeout(function(){if(a.waitingForImages=!1,a.count===0&&(a.stylesheets&&My(a,a.stylesheets),a.unsuspend)){var V=a.unsuspend;a.unsuspend=null,V()}},(a.imgBytes>Vx?50:800)+u);return a.unsuspend=_,function(){a.unsuspend=null,clearTimeout(b),clearTimeout(O)}}:null}function vy(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)My(this,this.stylesheets);else if(this.unsuspend){var a=this.unsuspend;this.unsuspend=null,a()}}}var yy=null;function My(a,u){a.stylesheets=null,a.unsuspend!==null&&(a.count++,yy=new Map,u.forEach(JN,a),yy=null,vy.call(a))}function JN(a,u){if(!(u.state.loading&4)){var _=yy.get(a);if(_)var b=_.get(null);else{_=new Map,yy.set(a,_);for(var O=a.querySelectorAll("link[data-precedence],style[data-precedence]"),V=0;V<O.length;V++){var he=O[V];(he.nodeName==="LINK"||he.getAttribute("media")!=="not all")&&(_.set(he.dataset.precedence,he),b=he)}b&&_.set(null,b)}O=u.instance,he=O.getAttribute("data-precedence"),V=_.get(he)||b,V===b&&_.set(null,O),_.set(he,O),this.count++,b=vy.bind(this),O.addEventListener("load",b),O.addEventListener("error",b),V?V.parentNode.insertBefore(O,V.nextSibling):(a=a.nodeType===9?a.head:a,a.insertBefore(O,a.firstChild)),u.state.loading|=4}}var O0={$$typeof:C,Provider:null,Consumer:null,_currentValue:se,_currentValue2:se,_threadCount:0};function QN(a,u,_,b,O,V,he,Ce,st){this.tag=1,this.containerInfo=a,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Ee(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ee(0),this.hiddenUpdates=Ee(null),this.identifierPrefix=b,this.onUncaughtError=O,this.onCaughtError=V,this.onRecoverableError=he,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=st,this.incompleteTransitions=new Map}function jS(a,u,_,b,O,V,he,Ce,st,Pt,qt,nn){return a=new QN(a,u,_,he,st,Pt,qt,nn,Ce),u=1,V===!0&&(u|=24),V=_a(3,null,null,u),a.current=V,V.stateNode=a,u=ip(),u.refCount++,a.pooledCache=u,u.refCount++,V.memoizedState={element:b,isDehydrated:_,cache:u},up(V),a}function $S(a){return a?(a=kl,a):kl}function WS(a,u,_,b,O,V){O=$S(O),b.context===null?b.context=O:b.pendingContext=O,b=pl(u),b.payload={element:_},V=V===void 0?null:V,V!==null&&(b.callback=V),_=Wl(a,b,u),_!==null&&(m(_,a,u),Kl(_,a,u))}function KS(a,u){if(a=a.memoizedState,a!==null&&a.dehydrated!==null){var _=a.retryLane;a.retryLane=_!==0&&_<u?_:u}}function Hx(a,u){KS(a,u),(a=a.alternate)&&KS(a,u)}function qS(a){if(a.tag===13||a.tag===31){var u=Ul(a,67108864);u!==null&&m(u,a,67108864),Hx(a,67108864)}}function XS(a){if(a.tag===13||a.tag===31){var u=Aa();u=Le(u);var _=Ul(a,u);_!==null&&m(_,a,u),Hx(a,u)}}var by=!0;function ZN(a,u,_,b){var O=q.T;q.T=null;var V=le.p;try{le.p=2,jx(a,u,_,b)}finally{le.p=V,q.T=O}}function ez(a,u,_,b){var O=q.T;q.T=null;var V=le.p;try{le.p=8,jx(a,u,_,b)}finally{le.p=V,q.T=O}}function jx(a,u,_,b){if(by){var O=$x(b);if(O===null)X(a,u,b,xy,_),JS(a,b);else if(nz(O,a,u,_,b))b.stopPropagation();else if(JS(a,b),u&4&&-1<tz.indexOf(a)){for(;O!==null;){var V=Ge(O);if(V!==null)switch(V.tag){case 3:if(V=V.stateNode,V.current.memoizedState.isDehydrated){var he=B(V.pendingLanes);if(he!==0){var Ce=V;for(Ce.pendingLanes|=2,Ce.entangledLanes|=2;he;){var st=1<<31-We(he);Ce.entanglements[1]|=st,he&=~st}Sc(V),(Vi&6)===0&&(Eo=me()+500,Xm(0))}}break;case 31:case 13:Ce=Ul(V,2),Ce!==null&&m(Ce,V,2),De(),Hx(V,2)}if(V=$x(b),V===null&&X(a,u,b,xy,_),V===O)break;O=V}O!==null&&b.stopPropagation()}else X(a,u,b,null,_)}}function $x(a){return a=Ms(a),Wx(a)}var xy=null;function Wx(a){if(xy=null,a=we(a),a!==null){var u=r(a);if(u===null)a=null;else{var _=u.tag;if(_===13){if(a=o(u),a!==null)return a;a=null}else if(_===31){if(a=l(u),a!==null)return a;a=null}else if(_===3){if(u.stateNode.current.memoizedState.isDehydrated)return u.tag===3?u.stateNode.containerInfo:null;a=null}else u!==a&&(a=null)}}return xy=a,null}function YS(a){switch(a){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch($e()){case et:return 2;case ht:return 8;case at:case Et:return 32;case Dt:return 268435456;default:return 32}default:return 32}}var Kx=!1,jp=null,$p=null,Wp=null,L0=new Map,F0=new Map,Kp=[],tz="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function JS(a,u){switch(a){case"focusin":case"focusout":jp=null;break;case"dragenter":case"dragleave":$p=null;break;case"mouseover":case"mouseout":Wp=null;break;case"pointerover":case"pointerout":L0.delete(u.pointerId);break;case"gotpointercapture":case"lostpointercapture":F0.delete(u.pointerId)}}function N0(a,u,_,b,O,V){return a===null||a.nativeEvent!==V?(a={blockedOn:u,domEventName:_,eventSystemFlags:b,nativeEvent:V,targetContainers:[O]},u!==null&&(u=Ge(u),u!==null&&qS(u)),a):(a.eventSystemFlags|=b,u=a.targetContainers,O!==null&&u.indexOf(O)===-1&&u.push(O),a)}function nz(a,u,_,b,O){switch(u){case"focusin":return jp=N0(jp,a,u,_,b,O),!0;case"dragenter":return $p=N0($p,a,u,_,b,O),!0;case"mouseover":return Wp=N0(Wp,a,u,_,b,O),!0;case"pointerover":var V=O.pointerId;return L0.set(V,N0(L0.get(V)||null,a,u,_,b,O)),!0;case"gotpointercapture":return V=O.pointerId,F0.set(V,N0(F0.get(V)||null,a,u,_,b,O)),!0}return!1}function QS(a){var u=we(a.target);if(u!==null){var _=r(u);if(_!==null){if(u=_.tag,u===13){if(u=o(_),u!==null){a.blockedOn=u,ft(a.priority,function(){XS(_)});return}}else if(u===31){if(u=l(_),u!==null){a.blockedOn=u,ft(a.priority,function(){XS(_)});return}}else if(u===3&&_.stateNode.current.memoizedState.isDehydrated){a.blockedOn=_.tag===3?_.stateNode.containerInfo:null;return}}}a.blockedOn=null}function wy(a){if(a.blockedOn!==null)return!1;for(var u=a.targetContainers;0<u.length;){var _=$x(a.nativeEvent);if(_===null){_=a.nativeEvent;var b=new _.constructor(_.type,_);ni=b,_.target.dispatchEvent(b),ni=null}else return u=Ge(_),u!==null&&qS(u),a.blockedOn=_,!1;u.shift()}return!0}function ZS(a,u,_){wy(a)&&_.delete(u)}function iz(){Kx=!1,jp!==null&&wy(jp)&&(jp=null),$p!==null&&wy($p)&&($p=null),Wp!==null&&wy(Wp)&&(Wp=null),L0.forEach(ZS),F0.forEach(ZS)}function Ey(a,u){a.blockedOn===u&&(a.blockedOn=null,Kx||(Kx=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,iz)))}var Ty=null;function eA(a){Ty!==a&&(Ty=a,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Ty===a&&(Ty=null);for(var u=0;u<a.length;u+=3){var _=a[u],b=a[u+1],O=a[u+2];if(typeof b!="function"){if(Wx(b||_)===null)continue;break}var V=Ge(_);V!==null&&(a.splice(u,3),u-=3,Rp(V,{pending:!0,data:O,method:_.method,action:b},b,O))}}))}function y_(a){function u(st){return Ey(st,a)}jp!==null&&Ey(jp,a),$p!==null&&Ey($p,a),Wp!==null&&Ey(Wp,a),L0.forEach(u),F0.forEach(u);for(var _=0;_<Kp.length;_++){var b=Kp[_];b.blockedOn===a&&(b.blockedOn=null)}for(;0<Kp.length&&(_=Kp[0],_.blockedOn===null);)QS(_),_.blockedOn===null&&Kp.shift();if(_=(a.ownerDocument||a).$$reactFormReplay,_!=null)for(b=0;b<_.length;b+=3){var O=_[b],V=_[b+1],he=O[Bt]||null;if(typeof V=="function")he||eA(_);else if(he){var Ce=null;if(V&&V.hasAttribute("formAction")){if(O=V,he=V[Bt]||null)Ce=he.formAction;else if(Wx(O)!==null)continue}else Ce=he.action;typeof Ce=="function"?_[b+1]=Ce:(_.splice(b,3),b-=3),eA(_)}}}function tA(){function a(V){V.canIntercept&&V.info==="react-transition"&&V.intercept({handler:function(){return new Promise(function(he){return O=he})},focusReset:"manual",scroll:"manual"})}function u(){O!==null&&(O(),O=null),b||setTimeout(_,20)}function _(){if(!b&&!navigation.transition){var V=navigation.currentEntry;V&&V.url!=null&&navigation.navigate(V.url,{state:V.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var b=!1,O=null;return navigation.addEventListener("navigate",a),navigation.addEventListener("navigatesuccess",u),navigation.addEventListener("navigateerror",u),setTimeout(_,100),function(){b=!0,navigation.removeEventListener("navigate",a),navigation.removeEventListener("navigatesuccess",u),navigation.removeEventListener("navigateerror",u),O!==null&&(O(),O=null)}}}function qx(a){this._internalRoot=a}Sy.prototype.render=qx.prototype.render=function(a){var u=this._internalRoot;if(u===null)throw Error(i(409));var _=u.current,b=Aa();WS(_,b,a,u,null,null)},Sy.prototype.unmount=qx.prototype.unmount=function(){var a=this._internalRoot;if(a!==null){this._internalRoot=null;var u=a.containerInfo;WS(a.current,2,null,a,null,null),De(),u[on]=null}};function Sy(a){this._internalRoot=a}Sy.prototype.unstable_scheduleHydration=function(a){if(a){var u=nt();a={blockedOn:null,target:a,priority:u};for(var _=0;_<Kp.length&&u!==0&&u<Kp[_].priority;_++);Kp.splice(_,0,a),_===0&&QS(a)}};var nA=e.version;if(nA!=="19.2.0")throw Error(i(527,nA,"19.2.0"));le.findDOMNode=function(a){var u=a._reactInternals;if(u===void 0)throw typeof a.render=="function"?Error(i(188)):(a=Object.keys(a).join(","),Error(i(268,a)));return a=d(u),a=a!==null?g(a):null,a=a===null?null:a.stateNode,a};var sz={bundleType:0,version:"19.2.0",rendererPackageName:"react-dom",currentDispatcherRef:q,reconcilerVersion:"19.2.0"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Ay=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Ay.isDisabled&&Ay.supportsFiber)try{bt=Ay.inject(sz),Jt=Ay}catch{}}return U0.createRoot=function(a,u){if(!s(a))throw Error(i(299));var _=!1,b="",O=Lp,V=$m,he=vh;return u!=null&&(u.unstable_strictMode===!0&&(_=!0),u.identifierPrefix!==void 0&&(b=u.identifierPrefix),u.onUncaughtError!==void 0&&(O=u.onUncaughtError),u.onCaughtError!==void 0&&(V=u.onCaughtError),u.onRecoverableError!==void 0&&(he=u.onRecoverableError)),u=jS(a,1,!1,null,null,_,b,null,O,V,he,tA),a[on]=u.current,f_(a),new qx(u)},U0.hydrateRoot=function(a,u,_){if(!s(a))throw Error(i(299));var b=!1,O="",V=Lp,he=$m,Ce=vh,st=null;return _!=null&&(_.unstable_strictMode===!0&&(b=!0),_.identifierPrefix!==void 0&&(O=_.identifierPrefix),_.onUncaughtError!==void 0&&(V=_.onUncaughtError),_.onCaughtError!==void 0&&(he=_.onCaughtError),_.onRecoverableError!==void 0&&(Ce=_.onRecoverableError),_.formState!==void 0&&(st=_.formState)),u=jS(a,1,!0,u,_??null,b,O,st,V,he,Ce,tA),u.context=$S(null),_=u.current,b=Aa(),b=Le(b),O=pl(b),O.callback=null,Wl(_,O,b),_=b,u.current.lanes=_,k(u,_),Sc(u),a[on]=u.current,f_(a),new Sy(u)},U0.version="19.2.0",U0}var fA;function pz(){if(fA)return Jx.exports;fA=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),Jx.exports=hz(),Jx.exports}var EB=pz(),tw={exports:{}},Rh={};var hA;function mz(){return hA||(hA=1,Rh.ConcurrentRoot=1,Rh.ContinuousEventPriority=8,Rh.DefaultEventPriority=32,Rh.DiscreteEventPriority=2,Rh.IdleEventPriority=268435456,Rh.LegacyRoot=0,Rh.NoEventPriority=0),Rh}var pA;function gz(){return pA||(pA=1,tw.exports=mz()),tw.exports}var zM=gz();const Yg="179",yg={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Mg={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},TB=0,yE=1,SB=2,_z=3,AB=0,Kb=1,_v=2,Pd=3,Nd=0,Ga=1,Ro=2,Jo=0,Og=1,ME=2,bE=3,xE=4,CB=5,om=100,PB=101,RB=102,DB=103,BB=104,IB=200,OB=201,LB=202,FB=203,KM=204,qM=205,NB=206,zB=207,UB=208,kB=209,GB=210,VB=211,HB=212,jB=213,$B=214,XM=0,Pv=1,YM=2,zg=3,JM=4,QM=5,ZM=6,eb=7,$v=0,WB=1,KB=2,Ld=0,qB=1,XB=2,YB=3,dT=4,JB=5,QB=6,ZB=7,wE="attached",eI="detached",qb=300,Wh=301,dm=302,Rv=303,Dv=304,g0=306,fm=1e3,Wu=1001,t0=1002,ta=1003,Xb=1004,vz=1004,Ag=1005,yz=1005,Tr=1006,J_=1007,Mz=1007,Oc=1008,bz=1008,Ha=1009,fT=1010,hT=1011,n0=1012,Yb=1013,kf=1014,Rl=1015,Jg=1016,Jb=1017,Qb=1018,Ug=1020,pT=35902,mT=1021,gT=1022,Xo=1023,i0=1026,kg=1027,Zb=1028,Wv=1029,_T=1030,ex=1031,xz=1032,tx=1033,vv=33776,yv=33777,Mv=33778,bv=33779,tb=35840,nb=35841,ib=35842,sb=35843,rb=36196,ab=37492,ob=37496,lb=37808,ub=37809,cb=37810,db=37811,fb=37812,hb=37813,pb=37814,mb=37815,gb=37816,_b=37817,vb=37818,yb=37819,Mb=37820,bb=37821,xv=36492,xb=36494,wb=36495,vT=36283,Eb=36284,Tb=36285,Sb=36286,tI=2200,nI=2201,iI=2202,s0=2300,r0=2301,UM=2302,Cg=2400,Pg=2401,Bv=2402,nx=2500,yT=2501,sI=0,MT=1,Ab=2,mm=3200,rI=3201,wz=3202,Ez=3203,gm=0,aI=1,Bd="",Rs="srgb",Gf="srgb-linear",Iv="linear",js="srgb",Tz=0,bg=7680,Sz=7681,Az=7682,Cz=7683,Pz=34055,Rz=34056,Dz=5386,Bz=512,Iz=513,Oz=514,Lz=515,Fz=516,Nz=517,zz=518,EE=519,oI=512,lI=513,uI=514,bT=515,cI=516,dI=517,fI=518,hI=519,Ov=35044,Uz=35048,kz=35040,Gz=35045,Vz=35049,Hz=35041,jz=35046,$z=35050,Wz=35042,Kz="100",TE="300 es",Ku=2e3,a0=2001,qz={COMPUTE:"compute",RENDER:"render"},Xz={PERSPECTIVE:"perspective",LINEAR:"linear",FLAT:"flat"},Yz={NORMAL:"normal",CENTROID:"centroid",SAMPLE:"sample",FIRST:"first",EITHER:"either"};let Zu=class{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[e]===void 0&&(i[e]=[]),i[e].indexOf(t)===-1&&i[e].push(t)}hasEventListener(e,t){const i=this._listeners;return i===void 0?!1:i[e]!==void 0&&i[e].indexOf(t)!==-1}removeEventListener(e,t){const i=this._listeners;if(i===void 0)return;const s=i[e];if(s!==void 0){const r=s.indexOf(t);r!==-1&&s.splice(r,1)}}dispatchEvent(e){const t=this._listeners;if(t===void 0)return;const i=t[e.type];if(i!==void 0){e.target=this;const s=i.slice(0);for(let r=0,o=s.length;r<o;r++)s[r].call(this,e);e.target=null}}};const $o=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let mA=1234567;const Lg=Math.PI/180,o0=180/Math.PI;function Xu(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return($o[n&255]+$o[n>>8&255]+$o[n>>16&255]+$o[n>>24&255]+"-"+$o[e&255]+$o[e>>8&255]+"-"+$o[e>>16&15|64]+$o[e>>24&255]+"-"+$o[t&63|128]+$o[t>>8&255]+"-"+$o[t>>16&255]+$o[t>>24&255]+$o[i&255]+$o[i>>8&255]+$o[i>>16&255]+$o[i>>24&255]).toLowerCase()}function mi(n,e,t){return Math.max(e,Math.min(t,n))}function xT(n,e){return(n%e+e)%e}function Jz(n,e,t,i,s){return i+(n-e)*(s-i)/(t-e)}function Qz(n,e,t){return n!==e?(t-n)/(e-n):0}function wv(n,e,t){return(1-t)*n+t*e}function Zz(n,e,t,i){return wv(n,e,1-Math.exp(-t*i))}function eU(n,e=1){return e-Math.abs(xT(n,e*2)-e)}function tU(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function nU(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function iU(n,e){return n+Math.floor(Math.random()*(e-n+1))}function sU(n,e){return n+Math.random()*(e-n)}function rU(n){return n*(.5-Math.random())}function aU(n){n!==void 0&&(mA=n);let e=mA+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function oU(n){return n*Lg}function lU(n){return n*o0}function uU(n){return(n&n-1)===0&&n!==0}function cU(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function dU(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function fU(n,e,t,i,s){const r=Math.cos,o=Math.sin,l=r(t/2),c=o(t/2),d=r((e+i)/2),g=o((e+i)/2),p=r((e-i)/2),h=o((e-i)/2),v=r((i-e)/2),y=o((i-e)/2);switch(s){case"XYX":n.set(l*g,c*p,c*h,l*d);break;case"YZY":n.set(c*h,l*g,c*p,l*d);break;case"ZXZ":n.set(c*p,c*h,l*g,l*d);break;case"XZX":n.set(l*g,c*y,c*v,l*d);break;case"YXY":n.set(c*v,l*g,c*y,l*d);break;case"ZYZ":n.set(c*y,c*v,l*g,l*d);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}}function Pl(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function Ii(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}const Vh={DEG2RAD:Lg,RAD2DEG:o0,generateUUID:Xu,clamp:mi,euclideanModulo:xT,mapLinear:Jz,inverseLerp:Qz,lerp:wv,damp:Zz,pingpong:eU,smoothstep:tU,smootherstep:nU,randInt:iU,randFloat:sU,randFloatSpread:rU,seededRandom:aU,degToRad:oU,radToDeg:lU,isPowerOfTwo:uU,ceilPowerOfTwo:cU,floorPowerOfTwo:dU,setQuaternionFromProperEuler:fU,normalize:Ii,denormalize:Pl};class Gt{constructor(e=0,t=0){Gt.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,i=this.y,s=e.elements;return this.x=s[0]*t+s[3]*i+s[6],this.y=s[1]*t+s[4]*i+s[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=mi(this.x,e.x,t.x),this.y=mi(this.y,e.y,t.y),this}clampScalar(e,t){return this.x=mi(this.x,e,t),this.y=mi(this.y,e,t),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(mi(i,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(mi(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const i=Math.cos(t),s=Math.sin(t),r=this.x-e.x,o=this.y-e.y;return this.x=r*i-o*s+e.x,this.y=r*s+o*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class lo{constructor(e=0,t=0,i=0,s=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=i,this._w=s}static slerpFlat(e,t,i,s,r,o,l){let c=i[s+0],d=i[s+1],g=i[s+2],p=i[s+3];const h=r[o+0],v=r[o+1],y=r[o+2],w=r[o+3];if(l===0){e[t+0]=c,e[t+1]=d,e[t+2]=g,e[t+3]=p;return}if(l===1){e[t+0]=h,e[t+1]=v,e[t+2]=y,e[t+3]=w;return}if(p!==w||c!==h||d!==v||g!==y){let S=1-l;const M=c*h+d*v+g*y+p*w,T=M>=0?1:-1,C=1-M*M;if(C>Number.EPSILON){const R=Math.sqrt(C),P=Math.atan2(R,M*T);S=Math.sin(S*P)/R,l=Math.sin(l*P)/R}const x=l*T;if(c=c*S+h*x,d=d*S+v*x,g=g*S+y*x,p=p*S+w*x,S===1-l){const R=1/Math.sqrt(c*c+d*d+g*g+p*p);c*=R,d*=R,g*=R,p*=R}}e[t]=c,e[t+1]=d,e[t+2]=g,e[t+3]=p}static multiplyQuaternionsFlat(e,t,i,s,r,o){const l=i[s],c=i[s+1],d=i[s+2],g=i[s+3],p=r[o],h=r[o+1],v=r[o+2],y=r[o+3];return e[t]=l*y+g*p+c*v-d*h,e[t+1]=c*y+g*h+d*p-l*v,e[t+2]=d*y+g*v+l*h-c*p,e[t+3]=g*y-l*p-c*h-d*v,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,s){return this._x=e,this._y=t,this._z=i,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const i=e._x,s=e._y,r=e._z,o=e._order,l=Math.cos,c=Math.sin,d=l(i/2),g=l(s/2),p=l(r/2),h=c(i/2),v=c(s/2),y=c(r/2);switch(o){case"XYZ":this._x=h*g*p+d*v*y,this._y=d*v*p-h*g*y,this._z=d*g*y+h*v*p,this._w=d*g*p-h*v*y;break;case"YXZ":this._x=h*g*p+d*v*y,this._y=d*v*p-h*g*y,this._z=d*g*y-h*v*p,this._w=d*g*p+h*v*y;break;case"ZXY":this._x=h*g*p-d*v*y,this._y=d*v*p+h*g*y,this._z=d*g*y+h*v*p,this._w=d*g*p-h*v*y;break;case"ZYX":this._x=h*g*p-d*v*y,this._y=d*v*p+h*g*y,this._z=d*g*y-h*v*p,this._w=d*g*p+h*v*y;break;case"YZX":this._x=h*g*p+d*v*y,this._y=d*v*p+h*g*y,this._z=d*g*y-h*v*p,this._w=d*g*p-h*v*y;break;case"XZY":this._x=h*g*p-d*v*y,this._y=d*v*p-h*g*y,this._z=d*g*y+h*v*p,this._w=d*g*p+h*v*y;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const i=t/2,s=Math.sin(i);return this._x=e.x*s,this._y=e.y*s,this._z=e.z*s,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],s=t[4],r=t[8],o=t[1],l=t[5],c=t[9],d=t[2],g=t[6],p=t[10],h=i+l+p;if(h>0){const v=.5/Math.sqrt(h+1);this._w=.25/v,this._x=(g-c)*v,this._y=(r-d)*v,this._z=(o-s)*v}else if(i>l&&i>p){const v=2*Math.sqrt(1+i-l-p);this._w=(g-c)/v,this._x=.25*v,this._y=(s+o)/v,this._z=(r+d)/v}else if(l>p){const v=2*Math.sqrt(1+l-i-p);this._w=(r-d)/v,this._x=(s+o)/v,this._y=.25*v,this._z=(c+g)/v}else{const v=2*Math.sqrt(1+p-i-l);this._w=(o-s)/v,this._x=(r+d)/v,this._y=(c+g)/v,this._z=.25*v}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let i=e.dot(t)+1;return i<1e-8?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=i),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(mi(this.dot(e),-1,1)))}rotateTowards(e,t){const i=this.angleTo(e);if(i===0)return this;const s=Math.min(1,t/i);return this.slerp(e,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const i=e._x,s=e._y,r=e._z,o=e._w,l=t._x,c=t._y,d=t._z,g=t._w;return this._x=i*g+o*l+s*d-r*c,this._y=s*g+o*c+r*l-i*d,this._z=r*g+o*d+i*c-s*l,this._w=o*g-i*l-s*c-r*d,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const i=this._x,s=this._y,r=this._z,o=this._w;let l=o*e._w+i*e._x+s*e._y+r*e._z;if(l<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,l=-l):this.copy(e),l>=1)return this._w=o,this._x=i,this._y=s,this._z=r,this;const c=1-l*l;if(c<=Number.EPSILON){const v=1-t;return this._w=v*o+t*this._w,this._x=v*i+t*this._x,this._y=v*s+t*this._y,this._z=v*r+t*this._z,this.normalize(),this}const d=Math.sqrt(c),g=Math.atan2(d,l),p=Math.sin((1-t)*g)/d,h=Math.sin(t*g)/d;return this._w=o*p+this._w*h,this._x=i*p+this._x*h,this._y=s*p+this._y*h,this._z=r*p+this._z*h,this._onChangeCallback(),this}slerpQuaternions(e,t,i){return this.copy(e).slerp(t,i)}random(){const e=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),i=Math.random(),s=Math.sqrt(1-i),r=Math.sqrt(i);return this.set(s*Math.sin(e),s*Math.cos(e),r*Math.sin(t),r*Math.cos(t))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Oe{constructor(e=0,t=0,i=0){Oe.prototype.isVector3=!0,this.x=e,this.y=t,this.z=i}set(e,t,i){return i===void 0&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(gA.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(gA.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,i=this.y,s=this.z,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6]*s,this.y=r[1]*t+r[4]*i+r[7]*s,this.z=r[2]*t+r[5]*i+r[8]*s,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,i=this.y,s=this.z,r=e.elements,o=1/(r[3]*t+r[7]*i+r[11]*s+r[15]);return this.x=(r[0]*t+r[4]*i+r[8]*s+r[12])*o,this.y=(r[1]*t+r[5]*i+r[9]*s+r[13])*o,this.z=(r[2]*t+r[6]*i+r[10]*s+r[14])*o,this}applyQuaternion(e){const t=this.x,i=this.y,s=this.z,r=e.x,o=e.y,l=e.z,c=e.w,d=2*(o*s-l*i),g=2*(l*t-r*s),p=2*(r*i-o*t);return this.x=t+c*d+o*p-l*g,this.y=i+c*g+l*d-r*p,this.z=s+c*p+r*g-o*d,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,i=this.y,s=this.z,r=e.elements;return this.x=r[0]*t+r[4]*i+r[8]*s,this.y=r[1]*t+r[5]*i+r[9]*s,this.z=r[2]*t+r[6]*i+r[10]*s,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=mi(this.x,e.x,t.x),this.y=mi(this.y,e.y,t.y),this.z=mi(this.z,e.z,t.z),this}clampScalar(e,t){return this.x=mi(this.x,e,t),this.y=mi(this.y,e,t),this.z=mi(this.z,e,t),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(mi(i,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const i=e.x,s=e.y,r=e.z,o=t.x,l=t.y,c=t.z;return this.x=s*c-r*l,this.y=r*o-i*c,this.z=i*l-s*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return nw.copy(this).projectOnVector(e),this.sub(nw)}reflect(e){return this.sub(nw.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(mi(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y,s=this.z-e.z;return t*t+i*i+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){const s=Math.sin(t)*e;return this.x=s*Math.sin(i),this.y=Math.cos(t)*e,this.z=s*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),s=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=s,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,t=Math.random()*2-1,i=Math.sqrt(1-t*t);return this.x=i*Math.cos(e),this.y=t,this.z=i*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const nw=new Oe,gA=new lo;class Ai{constructor(e,t,i,s,r,o,l,c,d){Ai.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,i,s,r,o,l,c,d)}set(e,t,i,s,r,o,l,c,d){const g=this.elements;return g[0]=e,g[1]=s,g[2]=l,g[3]=t,g[4]=r,g[5]=c,g[6]=i,g[7]=o,g[8]=d,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],this}extractBasis(e,t,i){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,s=t.elements,r=this.elements,o=i[0],l=i[3],c=i[6],d=i[1],g=i[4],p=i[7],h=i[2],v=i[5],y=i[8],w=s[0],S=s[3],M=s[6],T=s[1],C=s[4],x=s[7],R=s[2],P=s[5],D=s[8];return r[0]=o*w+l*T+c*R,r[3]=o*S+l*C+c*P,r[6]=o*M+l*x+c*D,r[1]=d*w+g*T+p*R,r[4]=d*S+g*C+p*P,r[7]=d*M+g*x+p*D,r[2]=h*w+v*T+y*R,r[5]=h*S+v*C+y*P,r[8]=h*M+v*x+y*D,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[1],s=e[2],r=e[3],o=e[4],l=e[5],c=e[6],d=e[7],g=e[8];return t*o*g-t*l*d-i*r*g+i*l*c+s*r*d-s*o*c}invert(){const e=this.elements,t=e[0],i=e[1],s=e[2],r=e[3],o=e[4],l=e[5],c=e[6],d=e[7],g=e[8],p=g*o-l*d,h=l*c-g*r,v=d*r-o*c,y=t*p+i*h+s*v;if(y===0)return this.set(0,0,0,0,0,0,0,0,0);const w=1/y;return e[0]=p*w,e[1]=(s*d-g*i)*w,e[2]=(l*i-s*o)*w,e[3]=h*w,e[4]=(g*t-s*c)*w,e[5]=(s*r-l*t)*w,e[6]=v*w,e[7]=(i*c-d*t)*w,e[8]=(o*t-i*r)*w,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,i,s,r,o,l){const c=Math.cos(r),d=Math.sin(r);return this.set(i*c,i*d,-i*(c*o+d*l)+o+e,-s*d,s*c,-s*(-d*o+c*l)+l+t,0,0,1),this}scale(e,t){return this.premultiply(iw.makeScale(e,t)),this}rotate(e){return this.premultiply(iw.makeRotation(-e)),this}translate(e,t){return this.premultiply(iw.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,i,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,i=e.elements;for(let s=0;s<9;s++)if(t[s]!==i[s])return!1;return!0}fromArray(e,t=0){for(let i=0;i<9;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const iw=new Ai;function pI(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}const hU={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function K_(n,e){return new hU[n](e)}function Lv(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function mI(){const n=Lv("canvas");return n.style.display="block",n}const _A={};function Q_(n){n in _A||(_A[n]=!0,console.warn(n))}function pU(n,e,t){return new Promise(function(i,s){function r(){switch(n.clientWaitSync(e,n.SYNC_FLUSH_COMMANDS_BIT,0)){case n.WAIT_FAILED:s();break;case n.TIMEOUT_EXPIRED:setTimeout(r,t);break;default:i()}}setTimeout(r,t)})}const vA=new Ai().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),yA=new Ai().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function mU(){const n={enabled:!0,workingColorSpace:Gf,spaces:{},convert:function(s,r,o){return this.enabled===!1||r===o||!r||!o||(this.spaces[r].transfer===js&&(s.r=jh(s.r),s.g=jh(s.g),s.b=jh(s.b)),this.spaces[r].primaries!==this.spaces[o].primaries&&(s.applyMatrix3(this.spaces[r].toXYZ),s.applyMatrix3(this.spaces[o].fromXYZ)),this.spaces[o].transfer===js&&(s.r=Z_(s.r),s.g=Z_(s.g),s.b=Z_(s.b))),s},workingToColorSpace:function(s,r){return this.convert(s,this.workingColorSpace,r)},colorSpaceToWorking:function(s,r){return this.convert(s,r,this.workingColorSpace)},getPrimaries:function(s){return this.spaces[s].primaries},getTransfer:function(s){return s===Bd?Iv:this.spaces[s].transfer},getLuminanceCoefficients:function(s,r=this.workingColorSpace){return s.fromArray(this.spaces[r].luminanceCoefficients)},define:function(s){Object.assign(this.spaces,s)},_getMatrix:function(s,r,o){return s.copy(this.spaces[r].toXYZ).multiply(this.spaces[o].fromXYZ)},_getDrawingBufferColorSpace:function(s){return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(s=this.workingColorSpace){return this.spaces[s].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(s,r){return Q_("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),n.workingToColorSpace(s,r)},toWorkingColorSpace:function(s,r){return Q_("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),n.colorSpaceToWorking(s,r)}},e=[.64,.33,.3,.6,.15,.06],t=[.2126,.7152,.0722],i=[.3127,.329];return n.define({[Gf]:{primaries:e,whitePoint:i,transfer:Iv,toXYZ:vA,fromXYZ:yA,luminanceCoefficients:t,workingColorSpaceConfig:{unpackColorSpace:Rs},outputColorSpaceConfig:{drawingBufferColorSpace:Rs}},[Rs]:{primaries:e,whitePoint:i,transfer:js,toXYZ:vA,fromXYZ:yA,luminanceCoefficients:t,outputColorSpaceConfig:{drawingBufferColorSpace:Rs}}}),n}const us=mU();function jh(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function Z_(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let M_;class gI{static getDataURL(e,t="image/png"){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let i;if(e instanceof HTMLCanvasElement)i=e;else{M_===void 0&&(M_=Lv("canvas")),M_.width=e.width,M_.height=e.height;const s=M_.getContext("2d");e instanceof ImageData?s.putImageData(e,0,0):s.drawImage(e,0,0,e.width,e.height),i=M_}return i.toDataURL(t)}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=Lv("canvas");t.width=e.width,t.height=e.height;const i=t.getContext("2d");i.drawImage(e,0,0,e.width,e.height);const s=i.getImageData(0,0,e.width,e.height),r=s.data;for(let o=0;o<r.length;o++)r[o]=jh(r[o]/255)*255;return i.putImageData(s,0,0),t}else if(e.data){const t=e.data.slice(0);for(let i=0;i<t.length;i++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[i]=Math.floor(jh(t[i]/255)*255):t[i]=jh(t[i]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let gU=0;class um{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:gU++}),this.uuid=Xu(),this.data=e,this.dataReady=!0,this.version=0}getSize(e){const t=this.data;return t instanceof HTMLVideoElement?e.set(t.videoWidth,t.videoHeight,0):t instanceof VideoFrame?e.set(t.displayHeight,t.displayWidth,0):t!==null?e.set(t.width,t.height,t.depth||0):e.set(0,0,0),e}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const i={uuid:this.uuid,url:""},s=this.data;if(s!==null){let r;if(Array.isArray(s)){r=[];for(let o=0,l=s.length;o<l;o++)s[o].isDataTexture?r.push(sw(s[o].image)):r.push(sw(s[o]))}else r=sw(s);i.url=r}return t||(e.images[this.uuid]=i),i}}function sw(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?gI.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let _U=0;const rw=new Oe;class vr extends Zu{constructor(e=vr.DEFAULT_IMAGE,t=vr.DEFAULT_MAPPING,i=Wu,s=Wu,r=Tr,o=Oc,l=Xo,c=Ha,d=vr.DEFAULT_ANISOTROPY,g=Bd){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:_U++}),this.uuid=Xu(),this.name="",this.source=new um(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=i,this.wrapT=s,this.magFilter=r,this.minFilter=o,this.anisotropy=d,this.format=l,this.internalFormat=null,this.type=c,this.offset=new Gt(0,0),this.repeat=new Gt(1,1),this.center=new Gt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Ai,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=g,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(e&&e.depth&&e.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(rw).x}get height(){return this.source.getSize(rw).y}get depth(){return this.source.getSize(rw).z}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.renderTarget=e.renderTarget,this.isRenderTargetTexture=e.isRenderTargetTexture,this.isArrayTexture=e.isArrayTexture,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}setValues(e){for(const t in e){const i=e[t];if(i===void 0){console.warn(`THREE.Texture.setValues(): parameter '${t}' has value of undefined.`);continue}const s=this[t];if(s===void 0){console.warn(`THREE.Texture.setValues(): property '${t}' does not exist.`);continue}s&&i&&s.isVector2&&i.isVector2||s&&i&&s.isVector3&&i.isVector3||s&&i&&s.isMatrix3&&i.isMatrix3?s.copy(i):this[t]=i}}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const i={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(i.userData=this.userData),t||(e.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==qb)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case fm:e.x=e.x-Math.floor(e.x);break;case Wu:e.x=e.x<0?0:1;break;case t0:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case fm:e.y=e.y-Math.floor(e.y);break;case Wu:e.y=e.y<0?0:1;break;case t0:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}}vr.DEFAULT_IMAGE=null;vr.DEFAULT_MAPPING=qb;vr.DEFAULT_ANISOTROPY=1;class ds{constructor(e=0,t=0,i=0,s=1){ds.prototype.isVector4=!0,this.x=e,this.y=t,this.z=i,this.w=s}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,i,s){return this.x=e,this.y=t,this.z=i,this.w=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,i=this.y,s=this.z,r=this.w,o=e.elements;return this.x=o[0]*t+o[4]*i+o[8]*s+o[12]*r,this.y=o[1]*t+o[5]*i+o[9]*s+o[13]*r,this.z=o[2]*t+o[6]*i+o[10]*s+o[14]*r,this.w=o[3]*t+o[7]*i+o[11]*s+o[15]*r,this}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this.w/=e.w,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,i,s,r;const c=e.elements,d=c[0],g=c[4],p=c[8],h=c[1],v=c[5],y=c[9],w=c[2],S=c[6],M=c[10];if(Math.abs(g-h)<.01&&Math.abs(p-w)<.01&&Math.abs(y-S)<.01){if(Math.abs(g+h)<.1&&Math.abs(p+w)<.1&&Math.abs(y+S)<.1&&Math.abs(d+v+M-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const C=(d+1)/2,x=(v+1)/2,R=(M+1)/2,P=(g+h)/4,D=(p+w)/4,z=(y+S)/4;return C>x&&C>R?C<.01?(i=0,s=.707106781,r=.707106781):(i=Math.sqrt(C),s=P/i,r=D/i):x>R?x<.01?(i=.707106781,s=0,r=.707106781):(s=Math.sqrt(x),i=P/s,r=z/s):R<.01?(i=.707106781,s=.707106781,r=0):(r=Math.sqrt(R),i=D/r,s=z/r),this.set(i,s,r,t),this}let T=Math.sqrt((S-y)*(S-y)+(p-w)*(p-w)+(h-g)*(h-g));return Math.abs(T)<.001&&(T=1),this.x=(S-y)/T,this.y=(p-w)/T,this.z=(h-g)/T,this.w=Math.acos((d+v+M-1)/2),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this.w=t[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=mi(this.x,e.x,t.x),this.y=mi(this.y,e.y,t.y),this.z=mi(this.z,e.z,t.z),this.w=mi(this.w,e.w,t.w),this}clampScalar(e,t){return this.x=mi(this.x,e,t),this.y=mi(this.y,e,t),this.z=mi(this.z,e,t),this.w=mi(this.w,e,t),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(mi(i,e,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this.w=e.w+(t.w-e.w)*i,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class wT extends Zu{constructor(e=1,t=1,i={}){super(),i=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:Tr,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},i),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=i.depth,this.scissor=new ds(0,0,e,t),this.scissorTest=!1,this.viewport=new ds(0,0,e,t);const s={width:e,height:t,depth:i.depth},r=new vr(s);this.textures=[];const o=i.count;for(let l=0;l<o;l++)this.textures[l]=r.clone(),this.textures[l].isRenderTargetTexture=!0,this.textures[l].renderTarget=this;this._setTextureOptions(i),this.depthBuffer=i.depthBuffer,this.stencilBuffer=i.stencilBuffer,this.resolveDepthBuffer=i.resolveDepthBuffer,this.resolveStencilBuffer=i.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=i.depthTexture,this.samples=i.samples,this.multiview=i.multiview}_setTextureOptions(e={}){const t={minFilter:Tr,generateMipmaps:!1,flipY:!1,internalFormat:null};e.mapping!==void 0&&(t.mapping=e.mapping),e.wrapS!==void 0&&(t.wrapS=e.wrapS),e.wrapT!==void 0&&(t.wrapT=e.wrapT),e.wrapR!==void 0&&(t.wrapR=e.wrapR),e.magFilter!==void 0&&(t.magFilter=e.magFilter),e.minFilter!==void 0&&(t.minFilter=e.minFilter),e.format!==void 0&&(t.format=e.format),e.type!==void 0&&(t.type=e.type),e.anisotropy!==void 0&&(t.anisotropy=e.anisotropy),e.colorSpace!==void 0&&(t.colorSpace=e.colorSpace),e.flipY!==void 0&&(t.flipY=e.flipY),e.generateMipmaps!==void 0&&(t.generateMipmaps=e.generateMipmaps),e.internalFormat!==void 0&&(t.internalFormat=e.internalFormat);for(let i=0;i<this.textures.length;i++)this.textures[i].setValues(t)}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}set depthTexture(e){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),e!==null&&(e.renderTarget=this),this._depthTexture=e}get depthTexture(){return this._depthTexture}setSize(e,t,i=1){if(this.width!==e||this.height!==t||this.depth!==i){this.width=e,this.height=t,this.depth=i;for(let s=0,r=this.textures.length;s<r;s++)this.textures[s].image.width=e,this.textures[s].image.height=t,this.textures[s].image.depth=i,this.textures[s].isArrayTexture=this.textures[s].image.depth>1;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let t=0,i=e.textures.length;t<i;t++){this.textures[t]=e.textures[t].clone(),this.textures[t].isRenderTargetTexture=!0,this.textures[t].renderTarget=this;const s=Object.assign({},e.textures[t].image);this.textures[t].source=new um(s)}return this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Da extends wT{constructor(e=1,t=1,i={}){super(e,t,i),this.isWebGLRenderTarget=!0}}class ix extends vr{constructor(e=null,t=1,i=1,s=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:i,depth:s},this.magFilter=ta,this.minFilter=ta,this.wrapR=Wu,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class vU extends Da{constructor(e=1,t=1,i=1,s={}){super(e,t,s),this.isWebGLArrayRenderTarget=!0,this.depth=i,this.texture=new ix(null,e,t,i),this._setTextureOptions(s),this.texture.isRenderTargetTexture=!0}}class sx extends vr{constructor(e=null,t=1,i=1,s=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:i,depth:s},this.magFilter=ta,this.minFilter=ta,this.wrapR=Wu,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class yU extends Da{constructor(e=1,t=1,i=1,s={}){super(e,t,s),this.isWebGL3DRenderTarget=!0,this.depth=i,this.texture=new sx(null,e,t,i),this._setTextureOptions(s),this.texture.isRenderTargetTexture=!0}}class Ra{constructor(e=new Oe(1/0,1/0,1/0),t=new Oe(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t+=3)this.expandByPoint(bd.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,i=e.count;t<i;t++)this.expandByPoint(bd.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=bd.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const i=e.geometry;if(i!==void 0){const r=i.getAttribute("position");if(t===!0&&r!==void 0&&e.isInstancedMesh!==!0)for(let o=0,l=r.count;o<l;o++)e.isMesh===!0?e.getVertexPosition(o,bd):bd.fromBufferAttribute(r,o),bd.applyMatrix4(e.matrixWorld),this.expandByPoint(bd);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),Cy.copy(e.boundingBox)):(i.boundingBox===null&&i.computeBoundingBox(),Cy.copy(i.boundingBox)),Cy.applyMatrix4(e.matrixWorld),this.union(Cy)}const s=e.children;for(let r=0,o=s.length;r<o;r++)this.expandByObject(s[r],t);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,bd),bd.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,i;return e.normal.x>0?(t=e.normal.x*this.min.x,i=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,i=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,i+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,i+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,i+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,i+=e.normal.z*this.min.z),t<=-e.constant&&i>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(k0),Py.subVectors(this.max,k0),b_.subVectors(e.a,k0),x_.subVectors(e.b,k0),w_.subVectors(e.c,k0),Xp.subVectors(x_,b_),Yp.subVectors(w_,x_),eg.subVectors(b_,w_);let t=[0,-Xp.z,Xp.y,0,-Yp.z,Yp.y,0,-eg.z,eg.y,Xp.z,0,-Xp.x,Yp.z,0,-Yp.x,eg.z,0,-eg.x,-Xp.y,Xp.x,0,-Yp.y,Yp.x,0,-eg.y,eg.x,0];return!aw(t,b_,x_,w_,Py)||(t=[1,0,0,0,1,0,0,0,1],!aw(t,b_,x_,w_,Py))?!1:(Ry.crossVectors(Xp,Yp),t=[Ry.x,Ry.y,Ry.z],aw(t,b_,x_,w_,Py))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,bd).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(bd).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Dh[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Dh[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Dh[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Dh[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Dh[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Dh[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Dh[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Dh[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Dh),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(e){return this.min.fromArray(e.min),this.max.fromArray(e.max),this}}const Dh=[new Oe,new Oe,new Oe,new Oe,new Oe,new Oe,new Oe,new Oe],bd=new Oe,Cy=new Ra,b_=new Oe,x_=new Oe,w_=new Oe,Xp=new Oe,Yp=new Oe,eg=new Oe,k0=new Oe,Py=new Oe,Ry=new Oe,tg=new Oe;function aw(n,e,t,i,s){for(let r=0,o=n.length-3;r<=o;r+=3){tg.fromArray(n,r);const l=s.x*Math.abs(tg.x)+s.y*Math.abs(tg.y)+s.z*Math.abs(tg.z),c=e.dot(tg),d=t.dot(tg),g=i.dot(tg);if(Math.max(-Math.max(c,d,g),Math.min(c,d,g))>l)return!1}return!0}const MU=new Ra,G0=new Oe,ow=new Oe;class uo{constructor(e=new Oe,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const i=this.center;t!==void 0?i.copy(t):MU.setFromPoints(e).getCenter(i);let s=0;for(let r=0,o=e.length;r<o;r++)s=Math.max(s,i.distanceToSquared(e[r]));return this.radius=Math.sqrt(s),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const i=this.center.distanceToSquared(e);return t.copy(e),i>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;G0.subVectors(e,this.center);const t=G0.lengthSq();if(t>this.radius*this.radius){const i=Math.sqrt(t),s=(i-this.radius)*.5;this.center.addScaledVector(G0,s/i),this.radius+=s}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(ow.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(G0.copy(e.center).add(ow)),this.expandByPoint(G0.copy(e.center).sub(ow))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(e){return this.radius=e.radius,this.center.fromArray(e.center),this}}const Bh=new Oe,lw=new Oe,Dy=new Oe,Jp=new Oe,uw=new Oe,By=new Oe,cw=new Oe;class Qg{constructor(e=new Oe,t=new Oe(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Bh)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const i=t.dot(this.direction);return i<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,i)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Bh.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Bh.copy(this.origin).addScaledVector(this.direction,t),Bh.distanceToSquared(e))}distanceSqToSegment(e,t,i,s){lw.copy(e).add(t).multiplyScalar(.5),Dy.copy(t).sub(e).normalize(),Jp.copy(this.origin).sub(lw);const r=e.distanceTo(t)*.5,o=-this.direction.dot(Dy),l=Jp.dot(this.direction),c=-Jp.dot(Dy),d=Jp.lengthSq(),g=Math.abs(1-o*o);let p,h,v,y;if(g>0)if(p=o*c-l,h=o*l-c,y=r*g,p>=0)if(h>=-y)if(h<=y){const w=1/g;p*=w,h*=w,v=p*(p+o*h+2*l)+h*(o*p+h+2*c)+d}else h=r,p=Math.max(0,-(o*h+l)),v=-p*p+h*(h+2*c)+d;else h=-r,p=Math.max(0,-(o*h+l)),v=-p*p+h*(h+2*c)+d;else h<=-y?(p=Math.max(0,-(-o*r+l)),h=p>0?-r:Math.min(Math.max(-r,-c),r),v=-p*p+h*(h+2*c)+d):h<=y?(p=0,h=Math.min(Math.max(-r,-c),r),v=h*(h+2*c)+d):(p=Math.max(0,-(o*r+l)),h=p>0?r:Math.min(Math.max(-r,-c),r),v=-p*p+h*(h+2*c)+d);else h=o>0?-r:r,p=Math.max(0,-(o*h+l)),v=-p*p+h*(h+2*c)+d;return i&&i.copy(this.origin).addScaledVector(this.direction,p),s&&s.copy(lw).addScaledVector(Dy,h),v}intersectSphere(e,t){Bh.subVectors(e.center,this.origin);const i=Bh.dot(this.direction),s=Bh.dot(Bh)-i*i,r=e.radius*e.radius;if(s>r)return null;const o=Math.sqrt(r-s),l=i-o,c=i+o;return c<0?null:l<0?this.at(c,t):this.at(l,t)}intersectsSphere(e){return e.radius<0?!1:this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(e.normal)+e.constant)/t;return i>=0?i:null}intersectPlane(e,t){const i=this.distanceToPlane(e);return i===null?null:this.at(i,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let i,s,r,o,l,c;const d=1/this.direction.x,g=1/this.direction.y,p=1/this.direction.z,h=this.origin;return d>=0?(i=(e.min.x-h.x)*d,s=(e.max.x-h.x)*d):(i=(e.max.x-h.x)*d,s=(e.min.x-h.x)*d),g>=0?(r=(e.min.y-h.y)*g,o=(e.max.y-h.y)*g):(r=(e.max.y-h.y)*g,o=(e.min.y-h.y)*g),i>o||r>s||((r>i||isNaN(i))&&(i=r),(o<s||isNaN(s))&&(s=o),p>=0?(l=(e.min.z-h.z)*p,c=(e.max.z-h.z)*p):(l=(e.max.z-h.z)*p,c=(e.min.z-h.z)*p),i>c||l>s)||((l>i||i!==i)&&(i=l),(c<s||s!==s)&&(s=c),s<0)?null:this.at(i>=0?i:s,t)}intersectsBox(e){return this.intersectBox(e,Bh)!==null}intersectTriangle(e,t,i,s,r){uw.subVectors(t,e),By.subVectors(i,e),cw.crossVectors(uw,By);let o=this.direction.dot(cw),l;if(o>0){if(s)return null;l=1}else if(o<0)l=-1,o=-o;else return null;Jp.subVectors(this.origin,e);const c=l*this.direction.dot(By.crossVectors(Jp,By));if(c<0)return null;const d=l*this.direction.dot(uw.cross(Jp));if(d<0||c+d>o)return null;const g=-l*Jp.dot(cw);return g<0?null:this.at(g/o,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class li{constructor(e,t,i,s,r,o,l,c,d,g,p,h,v,y,w,S){li.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,i,s,r,o,l,c,d,g,p,h,v,y,w,S)}set(e,t,i,s,r,o,l,c,d,g,p,h,v,y,w,S){const M=this.elements;return M[0]=e,M[4]=t,M[8]=i,M[12]=s,M[1]=r,M[5]=o,M[9]=l,M[13]=c,M[2]=d,M[6]=g,M[10]=p,M[14]=h,M[3]=v,M[7]=y,M[11]=w,M[15]=S,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new li().fromArray(this.elements)}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15],this}copyPosition(e){const t=this.elements,i=e.elements;return t[12]=i[12],t[13]=i[13],t[14]=i[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,i){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(e,t,i){return this.set(e.x,t.x,i.x,0,e.y,t.y,i.y,0,e.z,t.z,i.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,i=e.elements,s=1/E_.setFromMatrixColumn(e,0).length(),r=1/E_.setFromMatrixColumn(e,1).length(),o=1/E_.setFromMatrixColumn(e,2).length();return t[0]=i[0]*s,t[1]=i[1]*s,t[2]=i[2]*s,t[3]=0,t[4]=i[4]*r,t[5]=i[5]*r,t[6]=i[6]*r,t[7]=0,t[8]=i[8]*o,t[9]=i[9]*o,t[10]=i[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,i=e.x,s=e.y,r=e.z,o=Math.cos(i),l=Math.sin(i),c=Math.cos(s),d=Math.sin(s),g=Math.cos(r),p=Math.sin(r);if(e.order==="XYZ"){const h=o*g,v=o*p,y=l*g,w=l*p;t[0]=c*g,t[4]=-c*p,t[8]=d,t[1]=v+y*d,t[5]=h-w*d,t[9]=-l*c,t[2]=w-h*d,t[6]=y+v*d,t[10]=o*c}else if(e.order==="YXZ"){const h=c*g,v=c*p,y=d*g,w=d*p;t[0]=h+w*l,t[4]=y*l-v,t[8]=o*d,t[1]=o*p,t[5]=o*g,t[9]=-l,t[2]=v*l-y,t[6]=w+h*l,t[10]=o*c}else if(e.order==="ZXY"){const h=c*g,v=c*p,y=d*g,w=d*p;t[0]=h-w*l,t[4]=-o*p,t[8]=y+v*l,t[1]=v+y*l,t[5]=o*g,t[9]=w-h*l,t[2]=-o*d,t[6]=l,t[10]=o*c}else if(e.order==="ZYX"){const h=o*g,v=o*p,y=l*g,w=l*p;t[0]=c*g,t[4]=y*d-v,t[8]=h*d+w,t[1]=c*p,t[5]=w*d+h,t[9]=v*d-y,t[2]=-d,t[6]=l*c,t[10]=o*c}else if(e.order==="YZX"){const h=o*c,v=o*d,y=l*c,w=l*d;t[0]=c*g,t[4]=w-h*p,t[8]=y*p+v,t[1]=p,t[5]=o*g,t[9]=-l*g,t[2]=-d*g,t[6]=v*p+y,t[10]=h-w*p}else if(e.order==="XZY"){const h=o*c,v=o*d,y=l*c,w=l*d;t[0]=c*g,t[4]=-p,t[8]=d*g,t[1]=h*p+w,t[5]=o*g,t[9]=v*p-y,t[2]=y*p-v,t[6]=l*g,t[10]=w*p+h}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(bU,e,xU)}lookAt(e,t,i){const s=this.elements;return Gu.subVectors(e,t),Gu.lengthSq()===0&&(Gu.z=1),Gu.normalize(),Qp.crossVectors(i,Gu),Qp.lengthSq()===0&&(Math.abs(i.z)===1?Gu.x+=1e-4:Gu.z+=1e-4,Gu.normalize(),Qp.crossVectors(i,Gu)),Qp.normalize(),Iy.crossVectors(Gu,Qp),s[0]=Qp.x,s[4]=Iy.x,s[8]=Gu.x,s[1]=Qp.y,s[5]=Iy.y,s[9]=Gu.y,s[2]=Qp.z,s[6]=Iy.z,s[10]=Gu.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,s=t.elements,r=this.elements,o=i[0],l=i[4],c=i[8],d=i[12],g=i[1],p=i[5],h=i[9],v=i[13],y=i[2],w=i[6],S=i[10],M=i[14],T=i[3],C=i[7],x=i[11],R=i[15],P=s[0],D=s[4],z=s[8],U=s[12],N=s[1],j=s[5],J=s[9],W=s[13],oe=s[2],ne=s[6],q=s[10],le=s[14],se=s[3],pe=s[7],be=s[11],ee=s[15];return r[0]=o*P+l*N+c*oe+d*se,r[4]=o*D+l*j+c*ne+d*pe,r[8]=o*z+l*J+c*q+d*be,r[12]=o*U+l*W+c*le+d*ee,r[1]=g*P+p*N+h*oe+v*se,r[5]=g*D+p*j+h*ne+v*pe,r[9]=g*z+p*J+h*q+v*be,r[13]=g*U+p*W+h*le+v*ee,r[2]=y*P+w*N+S*oe+M*se,r[6]=y*D+w*j+S*ne+M*pe,r[10]=y*z+w*J+S*q+M*be,r[14]=y*U+w*W+S*le+M*ee,r[3]=T*P+C*N+x*oe+R*se,r[7]=T*D+C*j+x*ne+R*pe,r[11]=T*z+C*J+x*q+R*be,r[15]=T*U+C*W+x*le+R*ee,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[4],s=e[8],r=e[12],o=e[1],l=e[5],c=e[9],d=e[13],g=e[2],p=e[6],h=e[10],v=e[14],y=e[3],w=e[7],S=e[11],M=e[15];return y*(+r*c*p-s*d*p-r*l*h+i*d*h+s*l*v-i*c*v)+w*(+t*c*v-t*d*h+r*o*h-s*o*v+s*d*g-r*c*g)+S*(+t*d*p-t*l*v-r*o*p+i*o*v+r*l*g-i*d*g)+M*(-s*l*g-t*c*p+t*l*h+s*o*p-i*o*h+i*c*g)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,i){const s=this.elements;return e.isVector3?(s[12]=e.x,s[13]=e.y,s[14]=e.z):(s[12]=e,s[13]=t,s[14]=i),this}invert(){const e=this.elements,t=e[0],i=e[1],s=e[2],r=e[3],o=e[4],l=e[5],c=e[6],d=e[7],g=e[8],p=e[9],h=e[10],v=e[11],y=e[12],w=e[13],S=e[14],M=e[15],T=p*S*d-w*h*d+w*c*v-l*S*v-p*c*M+l*h*M,C=y*h*d-g*S*d-y*c*v+o*S*v+g*c*M-o*h*M,x=g*w*d-y*p*d+y*l*v-o*w*v-g*l*M+o*p*M,R=y*p*c-g*w*c-y*l*h+o*w*h+g*l*S-o*p*S,P=t*T+i*C+s*x+r*R;if(P===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const D=1/P;return e[0]=T*D,e[1]=(w*h*r-p*S*r-w*s*v+i*S*v+p*s*M-i*h*M)*D,e[2]=(l*S*r-w*c*r+w*s*d-i*S*d-l*s*M+i*c*M)*D,e[3]=(p*c*r-l*h*r-p*s*d+i*h*d+l*s*v-i*c*v)*D,e[4]=C*D,e[5]=(g*S*r-y*h*r+y*s*v-t*S*v-g*s*M+t*h*M)*D,e[6]=(y*c*r-o*S*r-y*s*d+t*S*d+o*s*M-t*c*M)*D,e[7]=(o*h*r-g*c*r+g*s*d-t*h*d-o*s*v+t*c*v)*D,e[8]=x*D,e[9]=(y*p*r-g*w*r-y*i*v+t*w*v+g*i*M-t*p*M)*D,e[10]=(o*w*r-y*l*r+y*i*d-t*w*d-o*i*M+t*l*M)*D,e[11]=(g*l*r-o*p*r-g*i*d+t*p*d+o*i*v-t*l*v)*D,e[12]=R*D,e[13]=(g*w*s-y*p*s+y*i*h-t*w*h-g*i*S+t*p*S)*D,e[14]=(y*l*s-o*w*s-y*i*c+t*w*c+o*i*S-t*l*S)*D,e[15]=(o*p*s-g*l*s+g*i*c-t*p*c-o*i*h+t*l*h)*D,this}scale(e){const t=this.elements,i=e.x,s=e.y,r=e.z;return t[0]*=i,t[4]*=s,t[8]*=r,t[1]*=i,t[5]*=s,t[9]*=r,t[2]*=i,t[6]*=s,t[10]*=r,t[3]*=i,t[7]*=s,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],s=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,s))}makeTranslation(e,t,i){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,i,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),i=Math.sin(e);return this.set(1,0,0,0,0,t,-i,0,0,i,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,0,i,0,0,1,0,0,-i,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,0,i,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const i=Math.cos(t),s=Math.sin(t),r=1-i,o=e.x,l=e.y,c=e.z,d=r*o,g=r*l;return this.set(d*o+i,d*l-s*c,d*c+s*l,0,d*l+s*c,g*l+i,g*c-s*o,0,d*c-s*l,g*c+s*o,r*c*c+i,0,0,0,0,1),this}makeScale(e,t,i){return this.set(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1),this}makeShear(e,t,i,s,r,o){return this.set(1,i,r,0,e,1,o,0,t,s,1,0,0,0,0,1),this}compose(e,t,i){const s=this.elements,r=t._x,o=t._y,l=t._z,c=t._w,d=r+r,g=o+o,p=l+l,h=r*d,v=r*g,y=r*p,w=o*g,S=o*p,M=l*p,T=c*d,C=c*g,x=c*p,R=i.x,P=i.y,D=i.z;return s[0]=(1-(w+M))*R,s[1]=(v+x)*R,s[2]=(y-C)*R,s[3]=0,s[4]=(v-x)*P,s[5]=(1-(h+M))*P,s[6]=(S+T)*P,s[7]=0,s[8]=(y+C)*D,s[9]=(S-T)*D,s[10]=(1-(h+w))*D,s[11]=0,s[12]=e.x,s[13]=e.y,s[14]=e.z,s[15]=1,this}decompose(e,t,i){const s=this.elements;let r=E_.set(s[0],s[1],s[2]).length();const o=E_.set(s[4],s[5],s[6]).length(),l=E_.set(s[8],s[9],s[10]).length();this.determinant()<0&&(r=-r),e.x=s[12],e.y=s[13],e.z=s[14],xd.copy(this);const d=1/r,g=1/o,p=1/l;return xd.elements[0]*=d,xd.elements[1]*=d,xd.elements[2]*=d,xd.elements[4]*=g,xd.elements[5]*=g,xd.elements[6]*=g,xd.elements[8]*=p,xd.elements[9]*=p,xd.elements[10]*=p,t.setFromRotationMatrix(xd),i.x=r,i.y=o,i.z=l,this}makePerspective(e,t,i,s,r,o,l=Ku,c=!1){const d=this.elements,g=2*r/(t-e),p=2*r/(i-s),h=(t+e)/(t-e),v=(i+s)/(i-s);let y,w;if(c)y=r/(o-r),w=o*r/(o-r);else if(l===Ku)y=-(o+r)/(o-r),w=-2*o*r/(o-r);else if(l===a0)y=-o/(o-r),w=-o*r/(o-r);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+l);return d[0]=g,d[4]=0,d[8]=h,d[12]=0,d[1]=0,d[5]=p,d[9]=v,d[13]=0,d[2]=0,d[6]=0,d[10]=y,d[14]=w,d[3]=0,d[7]=0,d[11]=-1,d[15]=0,this}makeOrthographic(e,t,i,s,r,o,l=Ku,c=!1){const d=this.elements,g=2/(t-e),p=2/(i-s),h=-(t+e)/(t-e),v=-(i+s)/(i-s);let y,w;if(c)y=1/(o-r),w=o/(o-r);else if(l===Ku)y=-2/(o-r),w=-(o+r)/(o-r);else if(l===a0)y=-1/(o-r),w=-r/(o-r);else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+l);return d[0]=g,d[4]=0,d[8]=0,d[12]=h,d[1]=0,d[5]=p,d[9]=0,d[13]=v,d[2]=0,d[6]=0,d[10]=y,d[14]=w,d[3]=0,d[7]=0,d[11]=0,d[15]=1,this}equals(e){const t=this.elements,i=e.elements;for(let s=0;s<16;s++)if(t[s]!==i[s])return!1;return!0}fromArray(e,t=0){for(let i=0;i<16;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15],e}}const E_=new Oe,xd=new li,bU=new Oe(0,0,0),xU=new Oe(1,1,1),Qp=new Oe,Iy=new Oe,Gu=new Oe,MA=new li,bA=new lo;class Ju{constructor(e=0,t=0,i=0,s=Ju.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=i,this._order=s}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,i,s=this._order){return this._x=e,this._y=t,this._z=i,this._order=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,i=!0){const s=e.elements,r=s[0],o=s[4],l=s[8],c=s[1],d=s[5],g=s[9],p=s[2],h=s[6],v=s[10];switch(t){case"XYZ":this._y=Math.asin(mi(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-g,v),this._z=Math.atan2(-o,r)):(this._x=Math.atan2(h,d),this._z=0);break;case"YXZ":this._x=Math.asin(-mi(g,-1,1)),Math.abs(g)<.9999999?(this._y=Math.atan2(l,v),this._z=Math.atan2(c,d)):(this._y=Math.atan2(-p,r),this._z=0);break;case"ZXY":this._x=Math.asin(mi(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-p,v),this._z=Math.atan2(-o,d)):(this._y=0,this._z=Math.atan2(c,r));break;case"ZYX":this._y=Math.asin(-mi(p,-1,1)),Math.abs(p)<.9999999?(this._x=Math.atan2(h,v),this._z=Math.atan2(c,r)):(this._x=0,this._z=Math.atan2(-o,d));break;case"YZX":this._z=Math.asin(mi(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-g,d),this._y=Math.atan2(-p,r)):(this._x=0,this._y=Math.atan2(l,v));break;case"XZY":this._z=Math.asin(-mi(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(h,d),this._y=Math.atan2(l,r)):(this._x=Math.atan2(-g,v),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,i===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,i){return MA.makeRotationFromQuaternion(e),this.setFromRotationMatrix(MA,t,i)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return bA.setFromEuler(this),this.setFromQuaternion(bA,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Ju.DEFAULT_ORDER="XYZ";class l0{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let wU=0;const xA=new Oe,T_=new lo,Ih=new li,Oy=new Oe,V0=new Oe,EU=new Oe,TU=new lo,wA=new Oe(1,0,0),EA=new Oe(0,1,0),TA=new Oe(0,0,1),SA={type:"added"},SU={type:"removed"},S_={type:"childadded",child:null},dw={type:"childremoved",child:null};class fs extends Zu{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:wU++}),this.uuid=Xu(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=fs.DEFAULT_UP.clone();const e=new Oe,t=new Ju,i=new lo,s=new Oe(1,1,1);function r(){i.setFromEuler(t,!1)}function o(){t.setFromQuaternion(i,void 0,!1)}t._onChange(r),i._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new li},normalMatrix:{value:new Ai}}),this.matrix=new li,this.matrixWorld=new li,this.matrixAutoUpdate=fs.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=fs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new l0,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return T_.setFromAxisAngle(e,t),this.quaternion.multiply(T_),this}rotateOnWorldAxis(e,t){return T_.setFromAxisAngle(e,t),this.quaternion.premultiply(T_),this}rotateX(e){return this.rotateOnAxis(wA,e)}rotateY(e){return this.rotateOnAxis(EA,e)}rotateZ(e){return this.rotateOnAxis(TA,e)}translateOnAxis(e,t){return xA.copy(e).applyQuaternion(this.quaternion),this.position.add(xA.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(wA,e)}translateY(e){return this.translateOnAxis(EA,e)}translateZ(e){return this.translateOnAxis(TA,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(Ih.copy(this.matrixWorld).invert())}lookAt(e,t,i){e.isVector3?Oy.copy(e):Oy.set(e,t,i);const s=this.parent;this.updateWorldMatrix(!0,!1),V0.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Ih.lookAt(V0,Oy,this.up):Ih.lookAt(Oy,V0,this.up),this.quaternion.setFromRotationMatrix(Ih),s&&(Ih.extractRotation(s.matrixWorld),T_.setFromRotationMatrix(Ih),this.quaternion.premultiply(T_.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(SA),S_.child=e,this.dispatchEvent(S_),S_.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(SU),dw.child=e,this.dispatchEvent(dw),dw.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),Ih.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Ih.multiply(e.parent.matrixWorld)),e.applyMatrix4(Ih),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(SA),S_.child=e,this.dispatchEvent(S_),S_.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let i=0,s=this.children.length;i<s;i++){const o=this.children[i].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t,i=[]){this[e]===t&&i.push(this);const s=this.children;for(let r=0,o=s.length;r<o;r++)s[r].getObjectsByProperty(e,t,i);return i}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(V0,e,EU),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(V0,TU,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let i=0,s=t.length;i<s;i++)t[i].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let i=0,s=t.length;i<s;i++)t[i].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let i=0,s=t.length;i<s;i++)t[i].updateMatrixWorld(e)}updateWorldMatrix(e,t){const i=this.parent;if(e===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),t===!0){const s=this.children;for(let r=0,o=s.length;r<o;r++)s[r].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",i={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const s={};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.castShadow===!0&&(s.castShadow=!0),this.receiveShadow===!0&&(s.receiveShadow=!0),this.visible===!1&&(s.visible=!1),this.frustumCulled===!1&&(s.frustumCulled=!1),this.renderOrder!==0&&(s.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),s.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(s.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(s.type="BatchedMesh",s.perObjectFrustumCulled=this.perObjectFrustumCulled,s.sortObjects=this.sortObjects,s.drawRanges=this._drawRanges,s.reservedRanges=this._reservedRanges,s.geometryInfo=this._geometryInfo.map(l=>({...l,boundingBox:l.boundingBox?l.boundingBox.toJSON():void 0,boundingSphere:l.boundingSphere?l.boundingSphere.toJSON():void 0})),s.instanceInfo=this._instanceInfo.map(l=>({...l})),s.availableInstanceIds=this._availableInstanceIds.slice(),s.availableGeometryIds=this._availableGeometryIds.slice(),s.nextIndexStart=this._nextIndexStart,s.nextVertexStart=this._nextVertexStart,s.geometryCount=this._geometryCount,s.maxInstanceCount=this._maxInstanceCount,s.maxVertexCount=this._maxVertexCount,s.maxIndexCount=this._maxIndexCount,s.geometryInitialized=this._geometryInitialized,s.matricesTexture=this._matricesTexture.toJSON(e),s.indirectTexture=this._indirectTexture.toJSON(e),this._colorsTexture!==null&&(s.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(s.boundingSphere=this.boundingSphere.toJSON()),this.boundingBox!==null&&(s.boundingBox=this.boundingBox.toJSON()));function r(l,c){return l[c.uuid]===void 0&&(l[c.uuid]=c.toJSON(e)),c.uuid}if(this.isScene)this.background&&(this.background.isColor?s.background=this.background.toJSON():this.background.isTexture&&(s.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(s.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){s.geometry=r(e.geometries,this.geometry);const l=this.geometry.parameters;if(l!==void 0&&l.shapes!==void 0){const c=l.shapes;if(Array.isArray(c))for(let d=0,g=c.length;d<g;d++){const p=c[d];r(e.shapes,p)}else r(e.shapes,c)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const l=[];for(let c=0,d=this.material.length;c<d;c++)l.push(r(e.materials,this.material[c]));s.material=l}else s.material=r(e.materials,this.material);if(this.children.length>0){s.children=[];for(let l=0;l<this.children.length;l++)s.children.push(this.children[l].toJSON(e).object)}if(this.animations.length>0){s.animations=[];for(let l=0;l<this.animations.length;l++){const c=this.animations[l];s.animations.push(r(e.animations,c))}}if(t){const l=o(e.geometries),c=o(e.materials),d=o(e.textures),g=o(e.images),p=o(e.shapes),h=o(e.skeletons),v=o(e.animations),y=o(e.nodes);l.length>0&&(i.geometries=l),c.length>0&&(i.materials=c),d.length>0&&(i.textures=d),g.length>0&&(i.images=g),p.length>0&&(i.shapes=p),h.length>0&&(i.skeletons=h),v.length>0&&(i.animations=v),y.length>0&&(i.nodes=y)}return i.object=s,i;function o(l){const c=[];for(const d in l){const g=l[d];delete g.metadata,c.push(g)}return c}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let i=0;i<e.children.length;i++){const s=e.children[i];this.add(s.clone())}return this}}fs.DEFAULT_UP=new Oe(0,1,0);fs.DEFAULT_MATRIX_AUTO_UPDATE=!0;fs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const wd=new Oe,Oh=new Oe,fw=new Oe,Lh=new Oe,A_=new Oe,C_=new Oe,AA=new Oe,hw=new Oe,pw=new Oe,mw=new Oe,gw=new ds,_w=new ds,vw=new ds;class ou{constructor(e=new Oe,t=new Oe,i=new Oe){this.a=e,this.b=t,this.c=i}static getNormal(e,t,i,s){s.subVectors(i,t),wd.subVectors(e,t),s.cross(wd);const r=s.lengthSq();return r>0?s.multiplyScalar(1/Math.sqrt(r)):s.set(0,0,0)}static getBarycoord(e,t,i,s,r){wd.subVectors(s,t),Oh.subVectors(i,t),fw.subVectors(e,t);const o=wd.dot(wd),l=wd.dot(Oh),c=wd.dot(fw),d=Oh.dot(Oh),g=Oh.dot(fw),p=o*d-l*l;if(p===0)return r.set(0,0,0),null;const h=1/p,v=(d*c-l*g)*h,y=(o*g-l*c)*h;return r.set(1-v-y,y,v)}static containsPoint(e,t,i,s){return this.getBarycoord(e,t,i,s,Lh)===null?!1:Lh.x>=0&&Lh.y>=0&&Lh.x+Lh.y<=1}static getInterpolation(e,t,i,s,r,o,l,c){return this.getBarycoord(e,t,i,s,Lh)===null?(c.x=0,c.y=0,"z"in c&&(c.z=0),"w"in c&&(c.w=0),null):(c.setScalar(0),c.addScaledVector(r,Lh.x),c.addScaledVector(o,Lh.y),c.addScaledVector(l,Lh.z),c)}static getInterpolatedAttribute(e,t,i,s,r,o){return gw.setScalar(0),_w.setScalar(0),vw.setScalar(0),gw.fromBufferAttribute(e,t),_w.fromBufferAttribute(e,i),vw.fromBufferAttribute(e,s),o.setScalar(0),o.addScaledVector(gw,r.x),o.addScaledVector(_w,r.y),o.addScaledVector(vw,r.z),o}static isFrontFacing(e,t,i,s){return wd.subVectors(i,t),Oh.subVectors(e,t),wd.cross(Oh).dot(s)<0}set(e,t,i){return this.a.copy(e),this.b.copy(t),this.c.copy(i),this}setFromPointsAndIndices(e,t,i,s){return this.a.copy(e[t]),this.b.copy(e[i]),this.c.copy(e[s]),this}setFromAttributeAndIndices(e,t,i,s){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,i),this.c.fromBufferAttribute(e,s),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return wd.subVectors(this.c,this.b),Oh.subVectors(this.a,this.b),wd.cross(Oh).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return ou.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return ou.getBarycoord(e,this.a,this.b,this.c,t)}getInterpolation(e,t,i,s,r){return ou.getInterpolation(e,this.a,this.b,this.c,t,i,s,r)}containsPoint(e){return ou.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return ou.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const i=this.a,s=this.b,r=this.c;let o,l;A_.subVectors(s,i),C_.subVectors(r,i),hw.subVectors(e,i);const c=A_.dot(hw),d=C_.dot(hw);if(c<=0&&d<=0)return t.copy(i);pw.subVectors(e,s);const g=A_.dot(pw),p=C_.dot(pw);if(g>=0&&p<=g)return t.copy(s);const h=c*p-g*d;if(h<=0&&c>=0&&g<=0)return o=c/(c-g),t.copy(i).addScaledVector(A_,o);mw.subVectors(e,r);const v=A_.dot(mw),y=C_.dot(mw);if(y>=0&&v<=y)return t.copy(r);const w=v*d-c*y;if(w<=0&&d>=0&&y<=0)return l=d/(d-y),t.copy(i).addScaledVector(C_,l);const S=g*y-v*p;if(S<=0&&p-g>=0&&v-y>=0)return AA.subVectors(r,s),l=(p-g)/(p-g+(v-y)),t.copy(s).addScaledVector(AA,l);const M=1/(S+w+h);return o=w*M,l=h*M,t.copy(i).addScaledVector(A_,o).addScaledVector(C_,l)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const _I={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Zp={h:0,s:0,l:0},Ly={h:0,s:0,l:0};function yw(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}class Sn{constructor(e,t,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,i)}set(e,t,i){if(t===void 0&&i===void 0){const s=e;s&&s.isColor?this.copy(s):typeof s=="number"?this.setHex(s):typeof s=="string"&&this.setStyle(s)}else this.setRGB(e,t,i);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=Rs){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,us.colorSpaceToWorking(this,t),this}setRGB(e,t,i,s=us.workingColorSpace){return this.r=e,this.g=t,this.b=i,us.colorSpaceToWorking(this,s),this}setHSL(e,t,i,s=us.workingColorSpace){if(e=xT(e,1),t=mi(t,0,1),i=mi(i,0,1),t===0)this.r=this.g=this.b=i;else{const r=i<=.5?i*(1+t):i+t-i*t,o=2*i-r;this.r=yw(o,r,e+1/3),this.g=yw(o,r,e),this.b=yw(o,r,e-1/3)}return us.colorSpaceToWorking(this,s),this}setStyle(e,t=Rs){function i(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let s;if(s=/^(\w+)\(([^\)]*)\)/.exec(e)){let r;const o=s[1],l=s[2];switch(o){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return i(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,t);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return i(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,t);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return i(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(s=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=s[1],o=r.length;if(o===3)return this.setRGB(parseInt(r.charAt(0),16)/15,parseInt(r.charAt(1),16)/15,parseInt(r.charAt(2),16)/15,t);if(o===6)return this.setHex(parseInt(r,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=Rs){const i=_I[e.toLowerCase()];return i!==void 0?this.setHex(i,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=jh(e.r),this.g=jh(e.g),this.b=jh(e.b),this}copyLinearToSRGB(e){return this.r=Z_(e.r),this.g=Z_(e.g),this.b=Z_(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=Rs){return us.workingToColorSpace(Wo.copy(this),e),Math.round(mi(Wo.r*255,0,255))*65536+Math.round(mi(Wo.g*255,0,255))*256+Math.round(mi(Wo.b*255,0,255))}getHexString(e=Rs){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=us.workingColorSpace){us.workingToColorSpace(Wo.copy(this),t);const i=Wo.r,s=Wo.g,r=Wo.b,o=Math.max(i,s,r),l=Math.min(i,s,r);let c,d;const g=(l+o)/2;if(l===o)c=0,d=0;else{const p=o-l;switch(d=g<=.5?p/(o+l):p/(2-o-l),o){case i:c=(s-r)/p+(s<r?6:0);break;case s:c=(r-i)/p+2;break;case r:c=(i-s)/p+4;break}c/=6}return e.h=c,e.s=d,e.l=g,e}getRGB(e,t=us.workingColorSpace){return us.workingToColorSpace(Wo.copy(this),t),e.r=Wo.r,e.g=Wo.g,e.b=Wo.b,e}getStyle(e=Rs){us.workingToColorSpace(Wo.copy(this),e);const t=Wo.r,i=Wo.g,s=Wo.b;return e!==Rs?`color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${s.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(i*255)},${Math.round(s*255)})`}offsetHSL(e,t,i){return this.getHSL(Zp),this.setHSL(Zp.h+e,Zp.s+t,Zp.l+i)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(Zp),e.getHSL(Ly);const i=wv(Zp.h,Ly.h,t),s=wv(Zp.s,Ly.s,t),r=wv(Zp.l,Ly.l,t);return this.setHSL(i,s,r),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,i=this.g,s=this.b,r=e.elements;return this.r=r[0]*t+r[3]*i+r[6]*s,this.g=r[1]*t+r[4]*i+r[7]*s,this.b=r[2]*t+r[5]*i+r[8]*s,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Wo=new Sn;Sn.NAMES=_I;let AU=0;class pa extends Zu{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:AU++}),this.uuid=Xu(),this.name="",this.type="Material",this.blending=Og,this.side=Nd,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=KM,this.blendDst=qM,this.blendEquation=om,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Sn(0,0,0),this.blendAlpha=0,this.depthFunc=zg,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=EE,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=bg,this.stencilZFail=bg,this.stencilZPass=bg,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const i=e[t];if(i===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const s=this[t];if(s===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}s&&s.isColor?s.set(i):s&&s.isVector3&&i&&i.isVector3?s.copy(i):this[t]=i}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const i={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(i.dispersion=this.dispersion),this.iridescence!==void 0&&(i.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(i.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(i.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(i.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(i.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(e).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(e).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(e).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(e).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(e).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapRotation!==void 0&&(i.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==Og&&(i.blending=this.blending),this.side!==Nd&&(i.side=this.side),this.vertexColors===!0&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=!0),this.blendSrc!==KM&&(i.blendSrc=this.blendSrc),this.blendDst!==qM&&(i.blendDst=this.blendDst),this.blendEquation!==om&&(i.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(i.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(i.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(i.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(i.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(i.blendAlpha=this.blendAlpha),this.depthFunc!==zg&&(i.depthFunc=this.depthFunc),this.depthTest===!1&&(i.depthTest=this.depthTest),this.depthWrite===!1&&(i.depthWrite=this.depthWrite),this.colorWrite===!1&&(i.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(i.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==EE&&(i.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(i.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(i.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==bg&&(i.stencilFail=this.stencilFail),this.stencilZFail!==bg&&(i.stencilZFail=this.stencilZFail),this.stencilZPass!==bg&&(i.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(i.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaHash===!0&&(i.alphaHash=!0),this.alphaToCoverage===!0&&(i.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=!0),this.forceSinglePass===!0&&(i.forceSinglePass=!0),this.wireframe===!0&&(i.wireframe=!0),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=!0),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),Object.keys(this.userData).length>0&&(i.userData=this.userData);function s(r){const o=[];for(const l in r){const c=r[l];delete c.metadata,o.push(c)}return o}if(t){const r=s(e.textures),o=s(e.images);r.length>0&&(i.textures=r),o.length>0&&(i.images=o)}return i}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let i=null;if(t!==null){const s=t.length;i=new Array(s);for(let r=0;r!==s;++r)i[r]=t[r].clone()}return this.clippingPlanes=i,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class qu extends pa{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Sn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ju,this.combine=$v,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const kh=CU();function CU(){const n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),i=new Uint32Array(512),s=new Uint32Array(512);for(let c=0;c<256;++c){const d=c-127;d<-27?(i[c]=0,i[c|256]=32768,s[c]=24,s[c|256]=24):d<-14?(i[c]=1024>>-d-14,i[c|256]=1024>>-d-14|32768,s[c]=-d-1,s[c|256]=-d-1):d<=15?(i[c]=d+15<<10,i[c|256]=d+15<<10|32768,s[c]=13,s[c|256]=13):d<128?(i[c]=31744,i[c|256]=64512,s[c]=24,s[c|256]=24):(i[c]=31744,i[c|256]=64512,s[c]=13,s[c|256]=13)}const r=new Uint32Array(2048),o=new Uint32Array(64),l=new Uint32Array(64);for(let c=1;c<1024;++c){let d=c<<13,g=0;for(;(d&8388608)===0;)d<<=1,g-=8388608;d&=-8388609,g+=947912704,r[c]=d|g}for(let c=1024;c<2048;++c)r[c]=939524096+(c-1024<<13);for(let c=1;c<31;++c)o[c]=c<<23;o[31]=1199570944,o[32]=2147483648;for(let c=33;c<63;++c)o[c]=2147483648+(c-32<<23);o[63]=3347054592;for(let c=1;c<64;++c)c!==32&&(l[c]=1024);return{floatView:e,uint32View:t,baseTable:i,shiftTable:s,mantissaTable:r,exponentTable:o,offsetTable:l}}function au(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=mi(n,-65504,65504),kh.floatView[0]=n;const e=kh.uint32View[0],t=e>>23&511;return kh.baseTable[t]+((e&8388607)>>kh.shiftTable[t])}function cv(n){const e=n>>10;return kh.uint32View[0]=kh.mantissaTable[kh.offsetTable[e]+(n&1023)]+kh.exponentTable[e],kh.floatView[0]}class PU{static toHalfFloat(e){return au(e)}static fromHalfFloat(e){return cv(e)}}const Pa=new Oe,Fy=new Gt;let RU=0;class hs{constructor(e,t,i=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:RU++}),this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=i,this.usage=Ov,this.updateRanges=[],this.gpuType=Rl,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,i){e*=this.itemSize,i*=t.itemSize;for(let s=0,r=this.itemSize;s<r;s++)this.array[e+s]=t.array[i+s];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,i=this.count;t<i;t++)Fy.fromBufferAttribute(this,t),Fy.applyMatrix3(e),this.setXY(t,Fy.x,Fy.y);else if(this.itemSize===3)for(let t=0,i=this.count;t<i;t++)Pa.fromBufferAttribute(this,t),Pa.applyMatrix3(e),this.setXYZ(t,Pa.x,Pa.y,Pa.z);return this}applyMatrix4(e){for(let t=0,i=this.count;t<i;t++)Pa.fromBufferAttribute(this,t),Pa.applyMatrix4(e),this.setXYZ(t,Pa.x,Pa.y,Pa.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)Pa.fromBufferAttribute(this,t),Pa.applyNormalMatrix(e),this.setXYZ(t,Pa.x,Pa.y,Pa.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)Pa.fromBufferAttribute(this,t),Pa.transformDirection(e),this.setXYZ(t,Pa.x,Pa.y,Pa.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let i=this.array[e*this.itemSize+t];return this.normalized&&(i=Pl(i,this.array)),i}setComponent(e,t,i){return this.normalized&&(i=Ii(i,this.array)),this.array[e*this.itemSize+t]=i,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Pl(t,this.array)),t}setX(e,t){return this.normalized&&(t=Ii(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Pl(t,this.array)),t}setY(e,t){return this.normalized&&(t=Ii(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Pl(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Ii(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Pl(t,this.array)),t}setW(e,t){return this.normalized&&(t=Ii(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,i){return e*=this.itemSize,this.normalized&&(t=Ii(t,this.array),i=Ii(i,this.array)),this.array[e+0]=t,this.array[e+1]=i,this}setXYZ(e,t,i,s){return e*=this.itemSize,this.normalized&&(t=Ii(t,this.array),i=Ii(i,this.array),s=Ii(s,this.array)),this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=s,this}setXYZW(e,t,i,s,r){return e*=this.itemSize,this.normalized&&(t=Ii(t,this.array),i=Ii(i,this.array),s=Ii(s,this.array),r=Ii(r,this.array)),this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=s,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Ov&&(e.usage=this.usage),e}}class DU extends hs{constructor(e,t,i){super(new Int8Array(e),t,i)}}class BU extends hs{constructor(e,t,i){super(new Uint8Array(e),t,i)}}class IU extends hs{constructor(e,t,i){super(new Uint8ClampedArray(e),t,i)}}class OU extends hs{constructor(e,t,i){super(new Int16Array(e),t,i)}}class ET extends hs{constructor(e,t,i){super(new Uint16Array(e),t,i)}}class LU extends hs{constructor(e,t,i){super(new Int32Array(e),t,i)}}class TT extends hs{constructor(e,t,i){super(new Uint32Array(e),t,i)}}class FU extends hs{constructor(e,t,i){super(new Uint16Array(e),t,i),this.isFloat16BufferAttribute=!0}getX(e){let t=cv(this.array[e*this.itemSize]);return this.normalized&&(t=Pl(t,this.array)),t}setX(e,t){return this.normalized&&(t=Ii(t,this.array)),this.array[e*this.itemSize]=au(t),this}getY(e){let t=cv(this.array[e*this.itemSize+1]);return this.normalized&&(t=Pl(t,this.array)),t}setY(e,t){return this.normalized&&(t=Ii(t,this.array)),this.array[e*this.itemSize+1]=au(t),this}getZ(e){let t=cv(this.array[e*this.itemSize+2]);return this.normalized&&(t=Pl(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Ii(t,this.array)),this.array[e*this.itemSize+2]=au(t),this}getW(e){let t=cv(this.array[e*this.itemSize+3]);return this.normalized&&(t=Pl(t,this.array)),t}setW(e,t){return this.normalized&&(t=Ii(t,this.array)),this.array[e*this.itemSize+3]=au(t),this}setXY(e,t,i){return e*=this.itemSize,this.normalized&&(t=Ii(t,this.array),i=Ii(i,this.array)),this.array[e+0]=au(t),this.array[e+1]=au(i),this}setXYZ(e,t,i,s){return e*=this.itemSize,this.normalized&&(t=Ii(t,this.array),i=Ii(i,this.array),s=Ii(s,this.array)),this.array[e+0]=au(t),this.array[e+1]=au(i),this.array[e+2]=au(s),this}setXYZW(e,t,i,s,r){return e*=this.itemSize,this.normalized&&(t=Ii(t,this.array),i=Ii(i,this.array),s=Ii(s,this.array),r=Ii(r,this.array)),this.array[e+0]=au(t),this.array[e+1]=au(i),this.array[e+2]=au(s),this.array[e+3]=au(r),this}}class Hn extends hs{constructor(e,t,i){super(new Float32Array(e),t,i)}}let NU=0;const Cc=new li,Mw=new fs,P_=new Oe,Vu=new Ra,H0=new Ra,ao=new Oe;class xi extends Zu{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:NU++}),this.uuid=Xu(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(pI(e)?TT:ET)(e,1):this.index=e,this}setIndirect(e){return this.indirect=e,this}getIndirect(){return this.indirect}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,i=0){this.groups.push({start:e,count:t,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const r=new Ai().getNormalMatrix(e);i.applyNormalMatrix(r),i.needsUpdate=!0}const s=this.attributes.tangent;return s!==void 0&&(s.transformDirection(e),s.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Cc.makeRotationFromQuaternion(e),this.applyMatrix4(Cc),this}rotateX(e){return Cc.makeRotationX(e),this.applyMatrix4(Cc),this}rotateY(e){return Cc.makeRotationY(e),this.applyMatrix4(Cc),this}rotateZ(e){return Cc.makeRotationZ(e),this.applyMatrix4(Cc),this}translate(e,t,i){return Cc.makeTranslation(e,t,i),this.applyMatrix4(Cc),this}scale(e,t,i){return Cc.makeScale(e,t,i),this.applyMatrix4(Cc),this}lookAt(e){return Mw.lookAt(e),Mw.updateMatrix(),this.applyMatrix4(Mw.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(P_).negate(),this.translate(P_.x,P_.y,P_.z),this}setFromPoints(e){const t=this.getAttribute("position");if(t===void 0){const i=[];for(let s=0,r=e.length;s<r;s++){const o=e[s];i.push(o.x,o.y,o.z||0)}this.setAttribute("position",new Hn(i,3))}else{const i=Math.min(e.length,t.count);for(let s=0;s<i;s++){const r=e[s];t.setXYZ(s,r.x,r.y,r.z||0)}e.length>t.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),t.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ra);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new Oe(-1/0,-1/0,-1/0),new Oe(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let i=0,s=t.length;i<s;i++){const r=t[i];Vu.setFromBufferAttribute(r),this.morphTargetsRelative?(ao.addVectors(this.boundingBox.min,Vu.min),this.boundingBox.expandByPoint(ao),ao.addVectors(this.boundingBox.max,Vu.max),this.boundingBox.expandByPoint(ao)):(this.boundingBox.expandByPoint(Vu.min),this.boundingBox.expandByPoint(Vu.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new uo);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new Oe,1/0);return}if(e){const i=this.boundingSphere.center;if(Vu.setFromBufferAttribute(e),t)for(let r=0,o=t.length;r<o;r++){const l=t[r];H0.setFromBufferAttribute(l),this.morphTargetsRelative?(ao.addVectors(Vu.min,H0.min),Vu.expandByPoint(ao),ao.addVectors(Vu.max,H0.max),Vu.expandByPoint(ao)):(Vu.expandByPoint(H0.min),Vu.expandByPoint(H0.max))}Vu.getCenter(i);let s=0;for(let r=0,o=e.count;r<o;r++)ao.fromBufferAttribute(e,r),s=Math.max(s,i.distanceToSquared(ao));if(t)for(let r=0,o=t.length;r<o;r++){const l=t[r],c=this.morphTargetsRelative;for(let d=0,g=l.count;d<g;d++)ao.fromBufferAttribute(l,d),c&&(P_.fromBufferAttribute(e,d),ao.add(P_)),s=Math.max(s,i.distanceToSquared(ao))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=t.position,s=t.normal,r=t.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new hs(new Float32Array(4*i.count),4));const o=this.getAttribute("tangent"),l=[],c=[];for(let z=0;z<i.count;z++)l[z]=new Oe,c[z]=new Oe;const d=new Oe,g=new Oe,p=new Oe,h=new Gt,v=new Gt,y=new Gt,w=new Oe,S=new Oe;function M(z,U,N){d.fromBufferAttribute(i,z),g.fromBufferAttribute(i,U),p.fromBufferAttribute(i,N),h.fromBufferAttribute(r,z),v.fromBufferAttribute(r,U),y.fromBufferAttribute(r,N),g.sub(d),p.sub(d),v.sub(h),y.sub(h);const j=1/(v.x*y.y-y.x*v.y);isFinite(j)&&(w.copy(g).multiplyScalar(y.y).addScaledVector(p,-v.y).multiplyScalar(j),S.copy(p).multiplyScalar(v.x).addScaledVector(g,-y.x).multiplyScalar(j),l[z].add(w),l[U].add(w),l[N].add(w),c[z].add(S),c[U].add(S),c[N].add(S))}let T=this.groups;T.length===0&&(T=[{start:0,count:e.count}]);for(let z=0,U=T.length;z<U;++z){const N=T[z],j=N.start,J=N.count;for(let W=j,oe=j+J;W<oe;W+=3)M(e.getX(W+0),e.getX(W+1),e.getX(W+2))}const C=new Oe,x=new Oe,R=new Oe,P=new Oe;function D(z){R.fromBufferAttribute(s,z),P.copy(R);const U=l[z];C.copy(U),C.sub(R.multiplyScalar(R.dot(U))).normalize(),x.crossVectors(P,U);const j=x.dot(c[z])<0?-1:1;o.setXYZW(z,C.x,C.y,C.z,j)}for(let z=0,U=T.length;z<U;++z){const N=T[z],j=N.start,J=N.count;for(let W=j,oe=j+J;W<oe;W+=3)D(e.getX(W+0)),D(e.getX(W+1)),D(e.getX(W+2))}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new hs(new Float32Array(t.count*3),3),this.setAttribute("normal",i);else for(let h=0,v=i.count;h<v;h++)i.setXYZ(h,0,0,0);const s=new Oe,r=new Oe,o=new Oe,l=new Oe,c=new Oe,d=new Oe,g=new Oe,p=new Oe;if(e)for(let h=0,v=e.count;h<v;h+=3){const y=e.getX(h+0),w=e.getX(h+1),S=e.getX(h+2);s.fromBufferAttribute(t,y),r.fromBufferAttribute(t,w),o.fromBufferAttribute(t,S),g.subVectors(o,r),p.subVectors(s,r),g.cross(p),l.fromBufferAttribute(i,y),c.fromBufferAttribute(i,w),d.fromBufferAttribute(i,S),l.add(g),c.add(g),d.add(g),i.setXYZ(y,l.x,l.y,l.z),i.setXYZ(w,c.x,c.y,c.z),i.setXYZ(S,d.x,d.y,d.z)}else for(let h=0,v=t.count;h<v;h+=3)s.fromBufferAttribute(t,h+0),r.fromBufferAttribute(t,h+1),o.fromBufferAttribute(t,h+2),g.subVectors(o,r),p.subVectors(s,r),g.cross(p),i.setXYZ(h+0,g.x,g.y,g.z),i.setXYZ(h+1,g.x,g.y,g.z),i.setXYZ(h+2,g.x,g.y,g.z);this.normalizeNormals(),i.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,i=e.count;t<i;t++)ao.fromBufferAttribute(e,t),ao.normalize(),e.setXYZ(t,ao.x,ao.y,ao.z)}toNonIndexed(){function e(l,c){const d=l.array,g=l.itemSize,p=l.normalized,h=new d.constructor(c.length*g);let v=0,y=0;for(let w=0,S=c.length;w<S;w++){l.isInterleavedBufferAttribute?v=c[w]*l.data.stride+l.offset:v=c[w]*g;for(let M=0;M<g;M++)h[y++]=d[v++]}return new hs(h,g,p)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new xi,i=this.index.array,s=this.attributes;for(const l in s){const c=s[l],d=e(c,i);t.setAttribute(l,d)}const r=this.morphAttributes;for(const l in r){const c=[],d=r[l];for(let g=0,p=d.length;g<p;g++){const h=d[g],v=e(h,i);c.push(v)}t.morphAttributes[l]=c}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let l=0,c=o.length;l<c;l++){const d=o[l];t.addGroup(d.start,d.count,d.materialIndex)}return t}toJSON(){const e={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const d in c)c[d]!==void 0&&(e[d]=c[d]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const i=this.attributes;for(const c in i){const d=i[c];e.data.attributes[c]=d.toJSON(e.data)}const s={};let r=!1;for(const c in this.morphAttributes){const d=this.morphAttributes[c],g=[];for(let p=0,h=d.length;p<h;p++){const v=d[p];g.push(v.toJSON(e.data))}g.length>0&&(s[c]=g,r=!0)}r&&(e.data.morphAttributes=s,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const l=this.boundingSphere;return l!==null&&(e.data.boundingSphere=l.toJSON()),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const i=e.index;i!==null&&this.setIndex(i.clone());const s=e.attributes;for(const d in s){const g=s[d];this.setAttribute(d,g.clone(t))}const r=e.morphAttributes;for(const d in r){const g=[],p=r[d];for(let h=0,v=p.length;h<v;h++)g.push(p[h].clone(t));this.morphAttributes[d]=g}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let d=0,g=o.length;d<g;d++){const p=o[d];this.addGroup(p.start,p.count,p.materialIndex)}const l=e.boundingBox;l!==null&&(this.boundingBox=l.clone());const c=e.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const CA=new li,ng=new Qg,Ny=new uo,PA=new Oe,zy=new Oe,Uy=new Oe,ky=new Oe,bw=new Oe,Gy=new Oe,RA=new Oe,Vy=new Oe;class ea extends fs{constructor(e=new xi,t=new qu){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const s=t[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=s.length;r<o;r++){const l=s[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=r}}}}getVertexPosition(e,t){const i=this.geometry,s=i.attributes.position,r=i.morphAttributes.position,o=i.morphTargetsRelative;t.fromBufferAttribute(s,e);const l=this.morphTargetInfluences;if(r&&l){Gy.set(0,0,0);for(let c=0,d=r.length;c<d;c++){const g=l[c],p=r[c];g!==0&&(bw.fromBufferAttribute(p,e),o?Gy.addScaledVector(bw,g):Gy.addScaledVector(bw.sub(t),g))}t.add(Gy)}return t}raycast(e,t){const i=this.geometry,s=this.material,r=this.matrixWorld;s!==void 0&&(i.boundingSphere===null&&i.computeBoundingSphere(),Ny.copy(i.boundingSphere),Ny.applyMatrix4(r),ng.copy(e.ray).recast(e.near),!(Ny.containsPoint(ng.origin)===!1&&(ng.intersectSphere(Ny,PA)===null||ng.origin.distanceToSquared(PA)>(e.far-e.near)**2))&&(CA.copy(r).invert(),ng.copy(e.ray).applyMatrix4(CA),!(i.boundingBox!==null&&ng.intersectsBox(i.boundingBox)===!1)&&this._computeIntersections(e,t,ng)))}_computeIntersections(e,t,i){let s;const r=this.geometry,o=this.material,l=r.index,c=r.attributes.position,d=r.attributes.uv,g=r.attributes.uv1,p=r.attributes.normal,h=r.groups,v=r.drawRange;if(l!==null)if(Array.isArray(o))for(let y=0,w=h.length;y<w;y++){const S=h[y],M=o[S.materialIndex],T=Math.max(S.start,v.start),C=Math.min(l.count,Math.min(S.start+S.count,v.start+v.count));for(let x=T,R=C;x<R;x+=3){const P=l.getX(x),D=l.getX(x+1),z=l.getX(x+2);s=Hy(this,M,e,i,d,g,p,P,D,z),s&&(s.faceIndex=Math.floor(x/3),s.face.materialIndex=S.materialIndex,t.push(s))}}else{const y=Math.max(0,v.start),w=Math.min(l.count,v.start+v.count);for(let S=y,M=w;S<M;S+=3){const T=l.getX(S),C=l.getX(S+1),x=l.getX(S+2);s=Hy(this,o,e,i,d,g,p,T,C,x),s&&(s.faceIndex=Math.floor(S/3),t.push(s))}}else if(c!==void 0)if(Array.isArray(o))for(let y=0,w=h.length;y<w;y++){const S=h[y],M=o[S.materialIndex],T=Math.max(S.start,v.start),C=Math.min(c.count,Math.min(S.start+S.count,v.start+v.count));for(let x=T,R=C;x<R;x+=3){const P=x,D=x+1,z=x+2;s=Hy(this,M,e,i,d,g,p,P,D,z),s&&(s.faceIndex=Math.floor(x/3),s.face.materialIndex=S.materialIndex,t.push(s))}}else{const y=Math.max(0,v.start),w=Math.min(c.count,v.start+v.count);for(let S=y,M=w;S<M;S+=3){const T=S,C=S+1,x=S+2;s=Hy(this,o,e,i,d,g,p,T,C,x),s&&(s.faceIndex=Math.floor(S/3),t.push(s))}}}}function zU(n,e,t,i,s,r,o,l){let c;if(e.side===Ga?c=i.intersectTriangle(o,r,s,!0,l):c=i.intersectTriangle(s,r,o,e.side===Nd,l),c===null)return null;Vy.copy(l),Vy.applyMatrix4(n.matrixWorld);const d=t.ray.origin.distanceTo(Vy);return d<t.near||d>t.far?null:{distance:d,point:Vy.clone(),object:n}}function Hy(n,e,t,i,s,r,o,l,c,d){n.getVertexPosition(l,zy),n.getVertexPosition(c,Uy),n.getVertexPosition(d,ky);const g=zU(n,e,t,i,zy,Uy,ky,RA);if(g){const p=new Oe;ou.getBarycoord(RA,zy,Uy,ky,p),s&&(g.uv=ou.getInterpolatedAttribute(s,l,c,d,p,new Gt)),r&&(g.uv1=ou.getInterpolatedAttribute(r,l,c,d,p,new Gt)),o&&(g.normal=ou.getInterpolatedAttribute(o,l,c,d,p,new Oe),g.normal.dot(i.direction)>0&&g.normal.multiplyScalar(-1));const h={a:l,b:c,c:d,normal:new Oe,materialIndex:0};ou.getNormal(zy,Uy,ky,h.normal),g.face=h,g.barycoord=p}return g}class Zg extends xi{constructor(e=1,t=1,i=1,s=1,r=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:i,widthSegments:s,heightSegments:r,depthSegments:o};const l=this;s=Math.floor(s),r=Math.floor(r),o=Math.floor(o);const c=[],d=[],g=[],p=[];let h=0,v=0;y("z","y","x",-1,-1,i,t,e,o,r,0),y("z","y","x",1,-1,i,t,-e,o,r,1),y("x","z","y",1,1,e,i,t,s,o,2),y("x","z","y",1,-1,e,i,-t,s,o,3),y("x","y","z",1,-1,e,t,i,s,r,4),y("x","y","z",-1,-1,e,t,-i,s,r,5),this.setIndex(c),this.setAttribute("position",new Hn(d,3)),this.setAttribute("normal",new Hn(g,3)),this.setAttribute("uv",new Hn(p,2));function y(w,S,M,T,C,x,R,P,D,z,U){const N=x/D,j=R/z,J=x/2,W=R/2,oe=P/2,ne=D+1,q=z+1;let le=0,se=0;const pe=new Oe;for(let be=0;be<q;be++){const ee=be*j-W;for(let te=0;te<ne;te++){const ue=te*N-J;pe[w]=ue*T,pe[S]=ee*C,pe[M]=oe,d.push(pe.x,pe.y,pe.z),pe[w]=0,pe[S]=0,pe[M]=P>0?1:-1,g.push(pe.x,pe.y,pe.z),p.push(te/D),p.push(1-be/z),le+=1}}for(let be=0;be<z;be++)for(let ee=0;ee<D;ee++){const te=h+ee+ne*be,ue=h+ee+ne*(be+1),ae=h+(ee+1)+ne*(be+1),ce=h+(ee+1)+ne*be;c.push(te,ue,ce),c.push(ue,ae,ce),se+=6}l.addGroup(v,se,U),v+=se,h+=le}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Zg(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function u0(n){const e={};for(const t in n){e[t]={};for(const i in n[t]){const s=n[t][i];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?s.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][i]=null):e[t][i]=s.clone():Array.isArray(s)?e[t][i]=s.slice():e[t][i]=s}}return e}function Al(n){const e={};for(let t=0;t<n.length;t++){const i=u0(n[t]);for(const s in i)e[s]=i[s]}return e}function UU(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function vI(n){const e=n.getRenderTarget();return e===null?n.outputColorSpace:e.isXRRenderTarget===!0?e.texture.colorSpace:us.workingColorSpace}const yI={clone:u0,merge:Al};var kU=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,GU=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ja extends pa{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=kU,this.fragmentShader=GU,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=u0(e.uniforms),this.uniformsGroups=UU(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const s in this.uniforms){const o=this.uniforms[s].value;o&&o.isTexture?t.uniforms[s]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[s]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[s]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[s]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[s]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[s]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[s]={type:"m4",value:o.toArray()}:t.uniforms[s]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const i={};for(const s in this.extensions)this.extensions[s]===!0&&(i[s]=!0);return Object.keys(i).length>0&&(t.extensions=i),t}}class rx extends fs{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new li,this.projectionMatrix=new li,this.projectionMatrixInverse=new li,this.coordinateSystem=Ku,this._reversedDepth=!1}get reversedDepth(){return this._reversedDepth}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const em=new Oe,DA=new Gt,BA=new Gt;class Er extends rx{constructor(e=50,t=1,i=.1,s=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=i,this.far=s,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=o0*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Lg*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return o0*2*Math.atan(Math.tan(Lg*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,t,i){em.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),t.set(em.x,em.y).multiplyScalar(-e/em.z),em.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),i.set(em.x,em.y).multiplyScalar(-e/em.z)}getViewSize(e,t){return this.getViewBounds(e,DA,BA),t.subVectors(BA,DA)}setViewOffset(e,t,i,s,r,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=s,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Lg*.5*this.fov)/this.zoom,i=2*t,s=this.aspect*i,r=-.5*s;const o=this.view;if(this.view!==null&&this.view.enabled){const c=o.fullWidth,d=o.fullHeight;r+=o.offsetX*s/c,t-=o.offsetY*i/d,s*=o.width/c,i*=o.height/d}const l=this.filmOffset;l!==0&&(r+=e*l/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+s,t,t-i,e,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const R_=-90,D_=1;class MI extends fs{constructor(e,t,i){super(),this.type="CubeCamera",this.renderTarget=i,this.coordinateSystem=null,this.activeMipmapLevel=0;const s=new Er(R_,D_,e,t);s.layers=this.layers,this.add(s);const r=new Er(R_,D_,e,t);r.layers=this.layers,this.add(r);const o=new Er(R_,D_,e,t);o.layers=this.layers,this.add(o);const l=new Er(R_,D_,e,t);l.layers=this.layers,this.add(l);const c=new Er(R_,D_,e,t);c.layers=this.layers,this.add(c);const d=new Er(R_,D_,e,t);d.layers=this.layers,this.add(d)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[i,s,r,o,l,c]=t;for(const d of t)this.remove(d);if(e===Ku)i.up.set(0,1,0),i.lookAt(1,0,0),s.up.set(0,1,0),s.lookAt(-1,0,0),r.up.set(0,0,-1),r.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),l.up.set(0,1,0),l.lookAt(0,0,1),c.up.set(0,1,0),c.lookAt(0,0,-1);else if(e===a0)i.up.set(0,-1,0),i.lookAt(-1,0,0),s.up.set(0,-1,0),s.lookAt(1,0,0),r.up.set(0,0,1),r.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),l.up.set(0,-1,0),l.lookAt(0,0,1),c.up.set(0,-1,0),c.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const d of t)this.add(d),d.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:i,activeMipmapLevel:s}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[r,o,l,c,d,g]=this.children,p=e.getRenderTarget(),h=e.getActiveCubeFace(),v=e.getActiveMipmapLevel(),y=e.xr.enabled;e.xr.enabled=!1;const w=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,e.setRenderTarget(i,0,s),e.render(t,r),e.setRenderTarget(i,1,s),e.render(t,o),e.setRenderTarget(i,2,s),e.render(t,l),e.setRenderTarget(i,3,s),e.render(t,c),e.setRenderTarget(i,4,s),e.render(t,d),i.texture.generateMipmaps=w,e.setRenderTarget(i,5,s),e.render(t,g),e.setRenderTarget(p,h,v),e.xr.enabled=y,i.texture.needsPMREMUpdate=!0}}class Kv extends vr{constructor(e=[],t=Wh,i,s,r,o,l,c,d,g){super(e,t,i,s,r,o,l,c,d,g),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class bI extends Da{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const i={width:e,height:e,depth:1},s=[i,i,i,i,i,i];this.texture=new Kv(s),this._setTextureOptions(t),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},s=new Zg(5,5,5),r=new ja({name:"CubemapFromEquirect",uniforms:u0(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:Ga,blending:Jo});r.uniforms.tEquirect.value=t;const o=new ea(s,r),l=t.minFilter;return t.minFilter===Oc&&(t.minFilter=Tr),new MI(1,10,this).update(e,o),t.minFilter=l,o.geometry.dispose(),o.material.dispose(),this}clear(e,t=!0,i=!0,s=!0){const r=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,i,s);e.setRenderTarget(r)}}class Hh extends fs{constructor(){super(),this.isGroup=!0,this.type="Group"}}const VU={type:"move"};class kM{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Hh,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Hh,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Oe,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Oe),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Hh,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Oe,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Oe),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const i of e.hand.values())this._getHandJoint(t,i)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,i){let s=null,r=null,o=null;const l=this._targetRay,c=this._grip,d=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(d&&e.hand){o=!0;for(const w of e.hand.values()){const S=t.getJointPose(w,i),M=this._getHandJoint(d,w);S!==null&&(M.matrix.fromArray(S.transform.matrix),M.matrix.decompose(M.position,M.rotation,M.scale),M.matrixWorldNeedsUpdate=!0,M.jointRadius=S.radius),M.visible=S!==null}const g=d.joints["index-finger-tip"],p=d.joints["thumb-tip"],h=g.position.distanceTo(p.position),v=.02,y=.005;d.inputState.pinching&&h>v+y?(d.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!d.inputState.pinching&&h<=v-y&&(d.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else c!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,i),r!==null&&(c.matrix.fromArray(r.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),c.matrixWorldNeedsUpdate=!0,r.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(r.linearVelocity)):c.hasLinearVelocity=!1,r.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(r.angularVelocity)):c.hasAngularVelocity=!1));l!==null&&(s=t.getPose(e.targetRaySpace,i),s===null&&r!==null&&(s=r),s!==null&&(l.matrix.fromArray(s.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,s.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(s.linearVelocity)):l.hasLinearVelocity=!1,s.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(s.angularVelocity)):l.hasAngularVelocity=!1,this.dispatchEvent(VU)))}return l!==null&&(l.visible=s!==null),c!==null&&(c.visible=r!==null),d!==null&&(d.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const i=new Hh;i.matrixAutoUpdate=!1,i.visible=!1,e.joints[t.jointName]=i,e.add(i)}return e.joints[t.jointName]}}class ax{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new Sn(e),this.density=t}clone(){return new ax(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class ox{constructor(e,t=1,i=1e3){this.isFog=!0,this.name="",this.color=new Sn(e),this.near=t,this.far=i}clone(){return new ox(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}let Fv=class extends fs{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Ju,this.environmentIntensity=1,this.environmentRotation=new Ju,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(t.object.environmentIntensity=this.environmentIntensity),t.object.environmentRotation=this.environmentRotation.toArray(),t}};class qv{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Ov,this.updateRanges=[],this.version=0,this.uuid=Xu()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,i){e*=this.stride,i*=t.stride;for(let s=0,r=this.stride;s<r;s++)this.array[e+s]=t.array[i+s];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Xu()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(t,this.stride);return i.setUsage(this.usage),i}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Xu()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Tl=new Oe;class hm{constructor(e,t,i,s=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=i,this.normalized=s}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,i=this.data.count;t<i;t++)Tl.fromBufferAttribute(this,t),Tl.applyMatrix4(e),this.setXYZ(t,Tl.x,Tl.y,Tl.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)Tl.fromBufferAttribute(this,t),Tl.applyNormalMatrix(e),this.setXYZ(t,Tl.x,Tl.y,Tl.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)Tl.fromBufferAttribute(this,t),Tl.transformDirection(e),this.setXYZ(t,Tl.x,Tl.y,Tl.z);return this}getComponent(e,t){let i=this.array[e*this.data.stride+this.offset+t];return this.normalized&&(i=Pl(i,this.array)),i}setComponent(e,t,i){return this.normalized&&(i=Ii(i,this.array)),this.data.array[e*this.data.stride+this.offset+t]=i,this}setX(e,t){return this.normalized&&(t=Ii(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=Ii(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=Ii(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=Ii(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=Pl(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=Pl(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=Pl(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=Pl(t,this.array)),t}setXY(e,t,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=Ii(t,this.array),i=Ii(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=i,this}setXYZ(e,t,i,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=Ii(t,this.array),i=Ii(i,this.array),s=Ii(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=s,this}setXYZW(e,t,i,s,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=Ii(t,this.array),i=Ii(i,this.array),s=Ii(s,this.array),r=Ii(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=s,this.data.array[e+3]=r,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[s+r])}return new hs(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new hm(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[s+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class ST extends pa{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Sn(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let B_;const j0=new Oe,I_=new Oe,O_=new Oe,L_=new Gt,$0=new Gt,xI=new li,jy=new Oe,W0=new Oe,$y=new Oe,IA=new Gt,xw=new Gt,OA=new Gt;class wI extends fs{constructor(e=new ST){if(super(),this.isSprite=!0,this.type="Sprite",B_===void 0){B_=new xi;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),i=new qv(t,5);B_.setIndex([0,1,2,0,2,3]),B_.setAttribute("position",new hm(i,3,0,!1)),B_.setAttribute("uv",new hm(i,2,3,!1))}this.geometry=B_,this.material=e,this.center=new Gt(.5,.5),this.count=1}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),I_.setFromMatrixScale(this.matrixWorld),xI.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),O_.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&I_.multiplyScalar(-O_.z);const i=this.material.rotation;let s,r;i!==0&&(r=Math.cos(i),s=Math.sin(i));const o=this.center;Wy(jy.set(-.5,-.5,0),O_,o,I_,s,r),Wy(W0.set(.5,-.5,0),O_,o,I_,s,r),Wy($y.set(.5,.5,0),O_,o,I_,s,r),IA.set(0,0),xw.set(1,0),OA.set(1,1);let l=e.ray.intersectTriangle(jy,W0,$y,!1,j0);if(l===null&&(Wy(W0.set(-.5,.5,0),O_,o,I_,s,r),xw.set(0,1),l=e.ray.intersectTriangle(jy,$y,W0,!1,j0),l===null))return;const c=e.ray.origin.distanceTo(j0);c<e.near||c>e.far||t.push({distance:c,point:j0.clone(),uv:ou.getInterpolation(j0,jy,W0,$y,IA,xw,OA,new Gt),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function Wy(n,e,t,i,s,r){L_.subVectors(n,t).addScalar(.5).multiply(i),s!==void 0?($0.x=r*L_.x-s*L_.y,$0.y=s*L_.x+r*L_.y):$0.copy(L_),n.copy(e),n.x+=$0.x,n.y+=$0.y,n.applyMatrix4(xI)}const Ky=new Oe,LA=new Oe;class EI extends fs{constructor(){super(),this.isLOD=!0,this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let i=0,s=t.length;i<s;i++){const r=t[i];this.addLevel(r.object.clone(),r.distance,r.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,i=0){t=Math.abs(t);const s=this.levels;let r;for(r=0;r<s.length&&!(t<s[r].distance);r++);return s.splice(r,0,{distance:t,hysteresis:i,object:e}),this.add(e),this}removeLevel(e){const t=this.levels;for(let i=0;i<t.length;i++)if(t[i].distance===e){const s=t.splice(i,1);return this.remove(s[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let i,s;for(i=1,s=t.length;i<s;i++){let r=t[i].distance;if(t[i].object.visible&&(r-=r*t[i].hysteresis),e<r)break}return t[i-1].object}return null}raycast(e,t){if(this.levels.length>0){Ky.setFromMatrixPosition(this.matrixWorld);const s=e.ray.origin.distanceTo(Ky);this.getObjectForDistance(s).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){Ky.setFromMatrixPosition(e.matrixWorld),LA.setFromMatrixPosition(this.matrixWorld);const i=Ky.distanceTo(LA)/e.zoom;t[0].object.visible=!0;let s,r;for(s=1,r=t.length;s<r;s++){let o=t[s].distance;if(t[s].object.visible&&(o-=o*t[s].hysteresis),i>=o)t[s-1].object.visible=!1,t[s].object.visible=!0;else break}for(this._currentLevel=s-1;s<r;s++)t[s].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const i=this.levels;for(let s=0,r=i.length;s<r;s++){const o=i[s];t.object.levels.push({object:o.object.uuid,distance:o.distance,hysteresis:o.hysteresis})}return t}}const FA=new Oe,NA=new ds,zA=new ds,HU=new Oe,UA=new li,qy=new Oe,ww=new uo,kA=new li,Ew=new Qg;class AT extends ea{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=wE,this.bindMatrix=new li,this.bindMatrixInverse=new li,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new Ra),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let i=0;i<t.count;i++)this.getVertexPosition(i,qy),this.boundingBox.expandByPoint(qy)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new uo),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let i=0;i<t.count;i++)this.getVertexPosition(i,qy),this.boundingSphere.expandByPoint(qy)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const i=this.material,s=this.matrixWorld;i!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),ww.copy(this.boundingSphere),ww.applyMatrix4(s),e.ray.intersectsSphere(ww)!==!1&&(kA.copy(s).invert(),Ew.copy(e.ray).applyMatrix4(kA),!(this.boundingBox!==null&&Ew.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,Ew)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new ds,t=this.geometry.attributes.skinWeight;for(let i=0,s=t.count;i<s;i++){e.fromBufferAttribute(t,i);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(i,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===wE?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===eI?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const i=this.skeleton,s=this.geometry;NA.fromBufferAttribute(s.attributes.skinIndex,e),zA.fromBufferAttribute(s.attributes.skinWeight,e),FA.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const o=zA.getComponent(r);if(o!==0){const l=NA.getComponent(r);UA.multiplyMatrices(i.bones[l].matrixWorld,i.boneInverses[l]),t.addScaledVector(HU.copy(FA).applyMatrix4(UA),o)}}return t.applyMatrix4(this.bindMatrixInverse)}}class lx extends fs{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Uf extends vr{constructor(e=null,t=1,i=1,s,r,o,l,c,d=ta,g=ta,p,h){super(null,o,l,c,d,g,s,r,p,h),this.isDataTexture=!0,this.image={data:e,width:t,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const GA=new li,jU=new li;class Xv{constructor(e=[],t=[]){this.uuid=Xu(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let i=0,s=this.bones.length;i<s;i++)this.boneInverses.push(new li)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const i=new li;this.bones[e]&&i.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(i)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const i=this.bones[e];i&&i.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const i=this.bones[e];i&&(i.parent&&i.parent.isBone?(i.matrix.copy(i.parent.matrixWorld).invert(),i.matrix.multiply(i.matrixWorld)):i.matrix.copy(i.matrixWorld),i.matrix.decompose(i.position,i.quaternion,i.scale))}}update(){const e=this.bones,t=this.boneInverses,i=this.boneMatrices,s=this.boneTexture;for(let r=0,o=e.length;r<o;r++){const l=e[r]?e[r].matrixWorld:jU;GA.multiplyMatrices(l,t[r]),GA.toArray(i,r*16)}s!==null&&(s.needsUpdate=!0)}clone(){return new Xv(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const i=new Uf(t,e,e,Xo,Rl);return i.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=i,this}getBoneByName(e){for(let t=0,i=this.bones.length;t<i;t++){const s=this.bones[t];if(s.name===e)return s}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let i=0,s=e.bones.length;i<s;i++){const r=e.bones[i];let o=t[r];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),o=new lx),this.bones.push(o),this.boneInverses.push(new li().fromArray(e.boneInverses[i]))}return this.init(),this}toJSON(){const e={metadata:{version:4.7,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,i=this.boneInverses;for(let s=0,r=t.length;s<r;s++){const o=t[s];e.bones.push(o.uuid);const l=i[s];e.boneInverses.push(l.toArray())}return e}}class Gg extends hs{constructor(e,t,i,s=1){super(e,t,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=s}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const F_=new li,VA=new li,Xy=[],HA=new Ra,$U=new li,K0=new ea,q0=new uo;class CT extends ea{constructor(e,t,i){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new Gg(new Float32Array(i*16),16),this.instanceColor=null,this.morphTexture=null,this.count=i,this.boundingBox=null,this.boundingSphere=null;for(let s=0;s<i;s++)this.setMatrixAt(s,$U)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new Ra),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let i=0;i<t;i++)this.getMatrixAt(i,F_),HA.copy(e.boundingBox).applyMatrix4(F_),this.boundingBox.union(HA)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new uo),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let i=0;i<t;i++)this.getMatrixAt(i,F_),q0.copy(e.boundingSphere).applyMatrix4(F_),this.boundingSphere.union(q0)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.morphTexture!==null&&(this.morphTexture=e.morphTexture.clone()),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}getMorphAt(e,t){const i=t.morphTargetInfluences,s=this.morphTexture.source.data.data,r=i.length+1,o=e*r+1;for(let l=0;l<i.length;l++)i[l]=s[o+l]}raycast(e,t){const i=this.matrixWorld,s=this.count;if(K0.geometry=this.geometry,K0.material=this.material,K0.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),q0.copy(this.boundingSphere),q0.applyMatrix4(i),e.ray.intersectsSphere(q0)!==!1))for(let r=0;r<s;r++){this.getMatrixAt(r,F_),VA.multiplyMatrices(i,F_),K0.matrixWorld=VA,K0.raycast(e,Xy);for(let o=0,l=Xy.length;o<l;o++){const c=Xy[o];c.instanceId=r,c.object=this,t.push(c)}Xy.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Gg(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}setMorphAt(e,t){const i=t.morphTargetInfluences,s=i.length+1;this.morphTexture===null&&(this.morphTexture=new Uf(new Float32Array(s*this.count),s,this.count,Zb,Rl));const r=this.morphTexture.source.data.data;let o=0;for(let d=0;d<i.length;d++)o+=i[d];const l=this.geometry.morphTargetsRelative?1:1-o,c=s*e;r[c]=l,r.set(i,c+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null)}}const Tw=new Oe,WU=new Oe,KU=new Ai;class Uh{constructor(e=new Oe(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,i,s){return this.normal.set(e,t,i),this.constant=s,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,i){const s=Tw.subVectors(i,t).cross(WU.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(s,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const i=e.delta(Tw),s=this.normal.dot(i);if(s===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/s;return r<0||r>1?null:t.copy(e.start).addScaledVector(i,r)}intersectsLine(e){const t=this.distanceToPoint(e.start),i=this.distanceToPoint(e.end);return t<0&&i>0||i<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const i=t||KU.getNormalMatrix(e),s=this.coplanarPoint(Tw).applyMatrix4(e),r=this.normal.applyMatrix3(i).normalize();return this.constant=-s.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const ig=new uo,qU=new Gt(.5,.5),Yy=new Oe;class _0{constructor(e=new Uh,t=new Uh,i=new Uh,s=new Uh,r=new Uh,o=new Uh){this.planes=[e,t,i,s,r,o]}set(e,t,i,s,r,o){const l=this.planes;return l[0].copy(e),l[1].copy(t),l[2].copy(i),l[3].copy(s),l[4].copy(r),l[5].copy(o),this}copy(e){const t=this.planes;for(let i=0;i<6;i++)t[i].copy(e.planes[i]);return this}setFromProjectionMatrix(e,t=Ku,i=!1){const s=this.planes,r=e.elements,o=r[0],l=r[1],c=r[2],d=r[3],g=r[4],p=r[5],h=r[6],v=r[7],y=r[8],w=r[9],S=r[10],M=r[11],T=r[12],C=r[13],x=r[14],R=r[15];if(s[0].setComponents(d-o,v-g,M-y,R-T).normalize(),s[1].setComponents(d+o,v+g,M+y,R+T).normalize(),s[2].setComponents(d+l,v+p,M+w,R+C).normalize(),s[3].setComponents(d-l,v-p,M-w,R-C).normalize(),i)s[4].setComponents(c,h,S,x).normalize(),s[5].setComponents(d-c,v-h,M-S,R-x).normalize();else if(s[4].setComponents(d-c,v-h,M-S,R-x).normalize(),t===Ku)s[5].setComponents(d+c,v+h,M+S,R+x).normalize();else if(t===a0)s[5].setComponents(c,h,S,x).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),ig.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),ig.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(ig)}intersectsSprite(e){ig.center.set(0,0,0);const t=qU.distanceTo(e.center);return ig.radius=.7071067811865476+t,ig.applyMatrix4(e.matrixWorld),this.intersectsSphere(ig)}intersectsSphere(e){const t=this.planes,i=e.center,s=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(i)<s)return!1;return!0}intersectsBox(e){const t=this.planes;for(let i=0;i<6;i++){const s=t[i];if(Yy.x=s.normal.x>0?e.max.x:e.min.x,Yy.y=s.normal.y>0?e.max.y:e.min.y,Yy.z=s.normal.z>0?e.max.z:e.min.z,s.distanceToPoint(Yy)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let i=0;i<6;i++)if(t[i].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}const Lf=new li,Ff=new _0;class ux{constructor(){this.coordinateSystem=Ku}intersectsObject(e,t){if(!t.isArrayCamera||t.cameras.length===0)return!1;for(let i=0;i<t.cameras.length;i++){const s=t.cameras[i];if(Lf.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),Ff.setFromProjectionMatrix(Lf,s.coordinateSystem,s.reversedDepth),Ff.intersectsObject(e))return!0}return!1}intersectsSprite(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let i=0;i<t.cameras.length;i++){const s=t.cameras[i];if(Lf.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),Ff.setFromProjectionMatrix(Lf,s.coordinateSystem,s.reversedDepth),Ff.intersectsSprite(e))return!0}return!1}intersectsSphere(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let i=0;i<t.cameras.length;i++){const s=t.cameras[i];if(Lf.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),Ff.setFromProjectionMatrix(Lf,s.coordinateSystem,s.reversedDepth),Ff.intersectsSphere(e))return!0}return!1}intersectsBox(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let i=0;i<t.cameras.length;i++){const s=t.cameras[i];if(Lf.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),Ff.setFromProjectionMatrix(Lf,s.coordinateSystem,s.reversedDepth),Ff.intersectsBox(e))return!0}return!1}containsPoint(e,t){if(!t||!t.cameras||t.cameras.length===0)return!1;for(let i=0;i<t.cameras.length;i++){const s=t.cameras[i];if(Lf.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),Ff.setFromProjectionMatrix(Lf,s.coordinateSystem,s.reversedDepth),Ff.containsPoint(e))return!0}return!1}clone(){return new ux}}function Sw(n,e){return n-e}function XU(n,e){return n.z-e.z}function YU(n,e){return e.z-n.z}class JU{constructor(){this.index=0,this.pool=[],this.list=[]}push(e,t,i,s){const r=this.pool,o=this.list;this.index>=r.length&&r.push({start:-1,count:-1,z:-1,index:-1});const l=r[this.index];o.push(l),this.index++,l.start=e,l.count=t,l.z=i,l.index=s}reset(){this.list.length=0,this.index=0}}const ru=new li,QU=new Sn(1,1,1),jA=new _0,ZU=new ux,Jy=new Ra,sg=new uo,X0=new Oe,$A=new Oe,ek=new Oe,Aw=new JU,Ko=new ea,Qy=[];function tk(n,e,t=0){const i=e.itemSize;if(n.isInterleavedBufferAttribute||n.array.constructor!==e.array.constructor){const s=n.count;for(let r=0;r<s;r++)for(let o=0;o<i;o++)e.setComponent(r+t,o,n.getComponent(r,o))}else e.array.set(n.array,t*i);e.needsUpdate=!0}function rg(n,e){if(n.constructor!==e.constructor){const t=Math.min(n.length,e.length);for(let i=0;i<t;i++)e[i]=n[i]}else{const t=Math.min(n.length,e.length);e.set(new n.constructor(n.buffer,0,t))}}class TI extends ea{constructor(e,t,i=t*2,s){super(new xi,s),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=e,this._maxVertexCount=t,this._maxIndexCount=i,this._multiDrawCounts=new Int32Array(e),this._multiDrawStarts=new Int32Array(e),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}_initMatricesTexture(){let e=Math.sqrt(this._maxInstanceCount*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4),i=new Uf(t,e,e,Xo,Rl);this._matricesTexture=i}_initIndirectTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const t=new Uint32Array(e*e),i=new Uf(t,e,e,Wv,kf);this._indirectTexture=i}_initColorsTexture(){let e=Math.sqrt(this._maxInstanceCount);e=Math.ceil(e);const t=new Float32Array(e*e*4).fill(1),i=new Uf(t,e,e,Xo,Rl);i.colorSpace=us.workingColorSpace,this._colorsTexture=i}_initializeGeometry(e){const t=this.geometry,i=this._maxVertexCount,s=this._maxIndexCount;if(this._geometryInitialized===!1){for(const r in e.attributes){const o=e.getAttribute(r),{array:l,itemSize:c,normalized:d}=o,g=new l.constructor(i*c),p=new hs(g,c,d);t.setAttribute(r,p)}if(e.getIndex()!==null){const r=i>65535?new Uint32Array(s):new Uint16Array(s);t.setIndex(new hs(r,1))}this._geometryInitialized=!0}}_validateGeometry(e){const t=this.geometry;if(!!e.getIndex()!=!!t.getIndex())throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const i in t.attributes){if(!e.hasAttribute(i))throw new Error(`THREE.BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);const s=e.getAttribute(i),r=t.getAttribute(i);if(s.itemSize!==r.itemSize||s.normalized!==r.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(e){const t=this._instanceInfo;if(e<0||e>=t.length||t[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)}validateGeometryId(e){const t=this._geometryInfo;if(e<0||e>=t.length||t[e].active===!1)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)}setCustomSort(e){return this.customSort=e,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ra);const e=this.boundingBox,t=this._instanceInfo;e.makeEmpty();for(let i=0,s=t.length;i<s;i++){if(t[i].active===!1)continue;const r=t[i].geometryIndex;this.getMatrixAt(i,ru),this.getBoundingBoxAt(r,Jy).applyMatrix4(ru),e.union(Jy)}}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new uo);const e=this.boundingSphere,t=this._instanceInfo;e.makeEmpty();for(let i=0,s=t.length;i<s;i++){if(t[i].active===!1)continue;const r=t[i].geometryIndex;this.getMatrixAt(i,ru),this.getBoundingSphereAt(r,sg).applyMatrix4(ru),e.union(sg)}}addInstance(e){if(this._instanceInfo.length>=this.maxInstanceCount&&this._availableInstanceIds.length===0)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const i={visible:!0,active:!0,geometryIndex:e};let s=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(Sw),s=this._availableInstanceIds.shift(),this._instanceInfo[s]=i):(s=this._instanceInfo.length,this._instanceInfo.push(i));const r=this._matricesTexture;ru.identity().toArray(r.image.data,s*16),r.needsUpdate=!0;const o=this._colorsTexture;return o&&(QU.toArray(o.image.data,s*4),o.needsUpdate=!0),this._visibilityChanged=!0,s}addGeometry(e,t=-1,i=-1){this._initializeGeometry(e),this._validateGeometry(e);const s={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},r=this._geometryInfo;s.vertexStart=this._nextVertexStart,s.reservedVertexCount=t===-1?e.getAttribute("position").count:t;const o=e.getIndex();if(o!==null&&(s.indexStart=this._nextIndexStart,s.reservedIndexCount=i===-1?o.count:i),s.indexStart!==-1&&s.indexStart+s.reservedIndexCount>this._maxIndexCount||s.vertexStart+s.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let c;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(Sw),c=this._availableGeometryIds.shift(),r[c]=s):(c=this._geometryCount,this._geometryCount++,r.push(s)),this.setGeometryAt(c,e),this._nextIndexStart=s.indexStart+s.reservedIndexCount,this._nextVertexStart=s.vertexStart+s.reservedVertexCount,c}setGeometryAt(e,t){if(e>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(t);const i=this.geometry,s=i.getIndex()!==null,r=i.getIndex(),o=t.getIndex(),l=this._geometryInfo[e];if(s&&o.count>l.reservedIndexCount||t.attributes.position.count>l.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const c=l.vertexStart,d=l.reservedVertexCount;l.vertexCount=t.getAttribute("position").count;for(const g in i.attributes){const p=t.getAttribute(g),h=i.getAttribute(g);tk(p,h,c);const v=p.itemSize;for(let y=p.count,w=d;y<w;y++){const S=c+y;for(let M=0;M<v;M++)h.setComponent(S,M,0)}h.needsUpdate=!0,h.addUpdateRange(c*v,d*v)}if(s){const g=l.indexStart,p=l.reservedIndexCount;l.indexCount=t.getIndex().count;for(let h=0;h<o.count;h++)r.setX(g+h,c+o.getX(h));for(let h=o.count,v=p;h<v;h++)r.setX(g+h,c);r.needsUpdate=!0,r.addUpdateRange(g,l.reservedIndexCount)}return l.start=s?l.indexStart:l.vertexStart,l.count=s?l.indexCount:l.vertexCount,l.boundingBox=null,t.boundingBox!==null&&(l.boundingBox=t.boundingBox.clone()),l.boundingSphere=null,t.boundingSphere!==null&&(l.boundingSphere=t.boundingSphere.clone()),this._visibilityChanged=!0,e}deleteGeometry(e){const t=this._geometryInfo;if(e>=t.length||t[e].active===!1)return this;const i=this._instanceInfo;for(let s=0,r=i.length;s<r;s++)i[s].active&&i[s].geometryIndex===e&&this.deleteInstance(s);return t[e].active=!1,this._availableGeometryIds.push(e),this._visibilityChanged=!0,this}deleteInstance(e){return this.validateInstanceId(e),this._instanceInfo[e].active=!1,this._availableInstanceIds.push(e),this._visibilityChanged=!0,this}optimize(){let e=0,t=0;const i=this._geometryInfo,s=i.map((o,l)=>l).sort((o,l)=>i[o].vertexStart-i[l].vertexStart),r=this.geometry;for(let o=0,l=i.length;o<l;o++){const c=s[o],d=i[c];if(d.active!==!1){if(r.index!==null){if(d.indexStart!==t){const{indexStart:g,vertexStart:p,reservedIndexCount:h}=d,v=r.index,y=v.array,w=e-p;for(let S=g;S<g+h;S++)y[S]=y[S]+w;v.array.copyWithin(t,g,g+h),v.addUpdateRange(t,h),d.indexStart=t}t+=d.reservedIndexCount}if(d.vertexStart!==e){const{vertexStart:g,reservedVertexCount:p}=d,h=r.attributes;for(const v in h){const y=h[v],{array:w,itemSize:S}=y;w.copyWithin(e*S,g*S,(g+p)*S),y.addUpdateRange(e*S,p*S)}d.vertexStart=e}e+=d.reservedVertexCount,d.start=r.index?d.indexStart:d.vertexStart,this._nextIndexStart=r.index?d.indexStart+d.reservedIndexCount:0,this._nextVertexStart=d.vertexStart+d.reservedVertexCount}}return this}getBoundingBoxAt(e,t){if(e>=this._geometryCount)return null;const i=this.geometry,s=this._geometryInfo[e];if(s.boundingBox===null){const r=new Ra,o=i.index,l=i.attributes.position;for(let c=s.start,d=s.start+s.count;c<d;c++){let g=c;o&&(g=o.getX(g)),r.expandByPoint(X0.fromBufferAttribute(l,g))}s.boundingBox=r}return t.copy(s.boundingBox),t}getBoundingSphereAt(e,t){if(e>=this._geometryCount)return null;const i=this.geometry,s=this._geometryInfo[e];if(s.boundingSphere===null){const r=new uo;this.getBoundingBoxAt(e,Jy),Jy.getCenter(r.center);const o=i.index,l=i.attributes.position;let c=0;for(let d=s.start,g=s.start+s.count;d<g;d++){let p=d;o&&(p=o.getX(p)),X0.fromBufferAttribute(l,p),c=Math.max(c,r.center.distanceToSquared(X0))}r.radius=Math.sqrt(c),s.boundingSphere=r}return t.copy(s.boundingSphere),t}setMatrixAt(e,t){this.validateInstanceId(e);const i=this._matricesTexture,s=this._matricesTexture.image.data;return t.toArray(s,e*16),i.needsUpdate=!0,this}getMatrixAt(e,t){return this.validateInstanceId(e),t.fromArray(this._matricesTexture.image.data,e*16)}setColorAt(e,t){return this.validateInstanceId(e),this._colorsTexture===null&&this._initColorsTexture(),t.toArray(this._colorsTexture.image.data,e*4),this._colorsTexture.needsUpdate=!0,this}getColorAt(e,t){return this.validateInstanceId(e),t.fromArray(this._colorsTexture.image.data,e*4)}setVisibleAt(e,t){return this.validateInstanceId(e),this._instanceInfo[e].visible===t?this:(this._instanceInfo[e].visible=t,this._visibilityChanged=!0,this)}getVisibleAt(e){return this.validateInstanceId(e),this._instanceInfo[e].visible}setGeometryIdAt(e,t){return this.validateInstanceId(e),this.validateGeometryId(t),this._instanceInfo[e].geometryIndex=t,this}getGeometryIdAt(e){return this.validateInstanceId(e),this._instanceInfo[e].geometryIndex}getGeometryRangeAt(e,t={}){this.validateGeometryId(e);const i=this._geometryInfo[e];return t.vertexStart=i.vertexStart,t.vertexCount=i.vertexCount,t.reservedVertexCount=i.reservedVertexCount,t.indexStart=i.indexStart,t.indexCount=i.indexCount,t.reservedIndexCount=i.reservedIndexCount,t.start=i.start,t.count=i.count,t}setInstanceCount(e){const t=this._availableInstanceIds,i=this._instanceInfo;for(t.sort(Sw);t[t.length-1]===i.length-1;)i.pop(),t.pop();if(e<i.length)throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);const s=new Int32Array(e),r=new Int32Array(e);rg(this._multiDrawCounts,s),rg(this._multiDrawStarts,r),this._multiDrawCounts=s,this._multiDrawStarts=r,this._maxInstanceCount=e;const o=this._indirectTexture,l=this._matricesTexture,c=this._colorsTexture;o.dispose(),this._initIndirectTexture(),rg(o.image.data,this._indirectTexture.image.data),l.dispose(),this._initMatricesTexture(),rg(l.image.data,this._matricesTexture.image.data),c&&(c.dispose(),this._initColorsTexture(),rg(c.image.data,this._colorsTexture.image.data))}setGeometrySize(e,t){const i=[...this._geometryInfo].filter(l=>l.active);if(Math.max(...i.map(l=>l.vertexStart+l.reservedVertexCount))>e)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);if(this.geometry.index&&Math.max(...i.map(c=>c.indexStart+c.reservedIndexCount))>t)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);const r=this.geometry;r.dispose(),this._maxVertexCount=e,this._maxIndexCount=t,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new xi,this._initializeGeometry(r));const o=this.geometry;r.index&&rg(r.index.array,o.index.array);for(const l in r.attributes)rg(r.attributes[l].array,o.attributes[l].array)}raycast(e,t){const i=this._instanceInfo,s=this._geometryInfo,r=this.matrixWorld,o=this.geometry;Ko.material=this.material,Ko.geometry.index=o.index,Ko.geometry.attributes=o.attributes,Ko.geometry.boundingBox===null&&(Ko.geometry.boundingBox=new Ra),Ko.geometry.boundingSphere===null&&(Ko.geometry.boundingSphere=new uo);for(let l=0,c=i.length;l<c;l++){if(!i[l].visible||!i[l].active)continue;const d=i[l].geometryIndex,g=s[d];Ko.geometry.setDrawRange(g.start,g.count),this.getMatrixAt(l,Ko.matrixWorld).premultiply(r),this.getBoundingBoxAt(d,Ko.geometry.boundingBox),this.getBoundingSphereAt(d,Ko.geometry.boundingSphere),Ko.raycast(e,Qy);for(let p=0,h=Qy.length;p<h;p++){const v=Qy[p];v.object=this,v.batchId=l,t.push(v)}Qy.length=0}Ko.material=null,Ko.geometry.index=null,Ko.geometry.attributes={},Ko.geometry.setDrawRange(0,1/0)}copy(e){return super.copy(e),this.geometry=e.geometry.clone(),this.perObjectFrustumCulled=e.perObjectFrustumCulled,this.sortObjects=e.sortObjects,this.boundingBox=e.boundingBox!==null?e.boundingBox.clone():null,this.boundingSphere=e.boundingSphere!==null?e.boundingSphere.clone():null,this._geometryInfo=e._geometryInfo.map(t=>({...t,boundingBox:t.boundingBox!==null?t.boundingBox.clone():null,boundingSphere:t.boundingSphere!==null?t.boundingSphere.clone():null})),this._instanceInfo=e._instanceInfo.map(t=>({...t})),this._availableInstanceIds=e._availableInstanceIds.slice(),this._availableGeometryIds=e._availableGeometryIds.slice(),this._nextIndexStart=e._nextIndexStart,this._nextVertexStart=e._nextVertexStart,this._geometryCount=e._geometryCount,this._maxInstanceCount=e._maxInstanceCount,this._maxVertexCount=e._maxVertexCount,this._maxIndexCount=e._maxIndexCount,this._geometryInitialized=e._geometryInitialized,this._multiDrawCounts=e._multiDrawCounts.slice(),this._multiDrawStarts=e._multiDrawStarts.slice(),this._indirectTexture=e._indirectTexture.clone(),this._indirectTexture.image.data=this._indirectTexture.image.data.slice(),this._matricesTexture=e._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),this._colorsTexture!==null&&(this._colorsTexture=e._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,this._colorsTexture!==null&&(this._colorsTexture.dispose(),this._colorsTexture=null)}onBeforeRender(e,t,i,s,r){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const o=s.getIndex(),l=o===null?1:o.array.BYTES_PER_ELEMENT,c=this._instanceInfo,d=this._multiDrawStarts,g=this._multiDrawCounts,p=this._geometryInfo,h=this.perObjectFrustumCulled,v=this._indirectTexture,y=v.image.data,w=i.isArrayCamera?ZU:jA;h&&!i.isArrayCamera&&(ru.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse).multiply(this.matrixWorld),jA.setFromProjectionMatrix(ru,i.coordinateSystem,i.reversedDepth));let S=0;if(this.sortObjects){ru.copy(this.matrixWorld).invert(),X0.setFromMatrixPosition(i.matrixWorld).applyMatrix4(ru),$A.set(0,0,-1).transformDirection(i.matrixWorld).transformDirection(ru);for(let C=0,x=c.length;C<x;C++)if(c[C].visible&&c[C].active){const R=c[C].geometryIndex;this.getMatrixAt(C,ru),this.getBoundingSphereAt(R,sg).applyMatrix4(ru);let P=!1;if(h&&(P=!w.intersectsSphere(sg,i)),!P){const D=p[R],z=ek.subVectors(sg.center,X0).dot($A);Aw.push(D.start,D.count,z,C)}}const M=Aw.list,T=this.customSort;T===null?M.sort(r.transparent?YU:XU):T.call(this,M,i);for(let C=0,x=M.length;C<x;C++){const R=M[C];d[S]=R.start*l,g[S]=R.count,y[S]=R.index,S++}Aw.reset()}else for(let M=0,T=c.length;M<T;M++)if(c[M].visible&&c[M].active){const C=c[M].geometryIndex;let x=!1;if(h&&(this.getMatrixAt(M,ru),this.getBoundingSphereAt(C,sg).applyMatrix4(ru),x=!w.intersectsSphere(sg,i)),!x){const R=p[C];d[S]=R.start*l,g[S]=R.count,y[S]=M,S++}}v.needsUpdate=!0,this._multiDrawCount=S,this._visibilityChanged=!1}onBeforeShadow(e,t,i,s,r,o){this.onBeforeRender(e,null,s,r,o)}}class Qo extends pa{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Sn(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const Cb=new Oe,Pb=new Oe,WA=new li,Y0=new Qg,Zy=new uo,Cw=new Oe,KA=new Oe;class Kh extends fs{constructor(e=new xi,t=new Qo){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,i=[0];for(let s=1,r=t.count;s<r;s++)Cb.fromBufferAttribute(t,s-1),Pb.fromBufferAttribute(t,s),i[s]=i[s-1],i[s]+=Cb.distanceTo(Pb);e.setAttribute("lineDistance",new Hn(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const i=this.geometry,s=this.matrixWorld,r=e.params.Line.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),Zy.copy(i.boundingSphere),Zy.applyMatrix4(s),Zy.radius+=r,e.ray.intersectsSphere(Zy)===!1)return;WA.copy(s).invert(),Y0.copy(e.ray).applyMatrix4(WA);const l=r/((this.scale.x+this.scale.y+this.scale.z)/3),c=l*l,d=this.isLineSegments?2:1,g=i.index,h=i.attributes.position;if(g!==null){const v=Math.max(0,o.start),y=Math.min(g.count,o.start+o.count);for(let w=v,S=y-1;w<S;w+=d){const M=g.getX(w),T=g.getX(w+1),C=eM(this,e,Y0,c,M,T,w);C&&t.push(C)}if(this.isLineLoop){const w=g.getX(y-1),S=g.getX(v),M=eM(this,e,Y0,c,w,S,y-1);M&&t.push(M)}}else{const v=Math.max(0,o.start),y=Math.min(h.count,o.start+o.count);for(let w=v,S=y-1;w<S;w+=d){const M=eM(this,e,Y0,c,w,w+1,w);M&&t.push(M)}if(this.isLineLoop){const w=eM(this,e,Y0,c,y-1,v,y-1);w&&t.push(w)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const s=t[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=s.length;r<o;r++){const l=s[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=r}}}}}function eM(n,e,t,i,s,r,o){const l=n.geometry.attributes.position;if(Cb.fromBufferAttribute(l,s),Pb.fromBufferAttribute(l,r),t.distanceSqToSegment(Cb,Pb,Cw,KA)>i)return;Cw.applyMatrix4(n.matrixWorld);const d=e.ray.origin.distanceTo(Cw);if(!(d<e.near||d>e.far))return{distance:d,point:KA.clone().applyMatrix4(n.matrixWorld),index:o,face:null,faceIndex:null,barycoord:null,object:n}}const qA=new Oe,XA=new Oe;class Ud extends Kh{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,i=[];for(let s=0,r=t.count;s<r;s+=2)qA.fromBufferAttribute(t,s),XA.fromBufferAttribute(t,s+1),i[s]=s===0?0:i[s-1],i[s+1]=i[s]+qA.distanceTo(XA);e.setAttribute("lineDistance",new Hn(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class PT extends Kh{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class cx extends pa{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Sn(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const YA=new li,SE=new Qg,tM=new uo,nM=new Oe;class RT extends fs{constructor(e=new xi,t=new cx){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const i=this.geometry,s=this.matrixWorld,r=e.params.Points.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),tM.copy(i.boundingSphere),tM.applyMatrix4(s),tM.radius+=r,e.ray.intersectsSphere(tM)===!1)return;YA.copy(s).invert(),SE.copy(e.ray).applyMatrix4(YA);const l=r/((this.scale.x+this.scale.y+this.scale.z)/3),c=l*l,d=i.index,p=i.attributes.position;if(d!==null){const h=Math.max(0,o.start),v=Math.min(d.count,o.start+o.count);for(let y=h,w=v;y<w;y++){const S=d.getX(y);nM.fromBufferAttribute(p,S),JA(nM,S,c,s,e,t,this)}}else{const h=Math.max(0,o.start),v=Math.min(p.count,o.start+o.count);for(let y=h,w=v;y<w;y++)nM.fromBufferAttribute(p,y),JA(nM,y,c,s,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const s=t[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=s.length;r<o;r++){const l=s[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=r}}}}}function JA(n,e,t,i,s,r,o){const l=SE.distanceSqToPoint(n);if(l<t){const c=new Oe;SE.closestPointToPoint(n,c),c.applyMatrix4(i);const d=s.ray.origin.distanceTo(c);if(d<s.near||d>s.far)return;r.push({distance:d,distanceToRay:Math.sqrt(l),point:c,index:e,face:null,faceIndex:null,barycoord:null,object:o})}}class SI extends vr{constructor(e,t,i,s,r=Tr,o=Tr,l,c,d){super(e,t,i,s,r,o,l,c,d),this.isVideoTexture=!0,this.generateMipmaps=!1,this._requestVideoFrameCallbackId=0;const g=this;function p(){g.needsUpdate=!0,g._requestVideoFrameCallbackId=e.requestVideoFrameCallback(p)}"requestVideoFrameCallback"in e&&(this._requestVideoFrameCallbackId=e.requestVideoFrameCallback(p))}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}dispose(){this._requestVideoFrameCallbackId!==0&&this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId),super.dispose()}}class nk extends SI{constructor(e,t,i,s,r,o,l,c){super({},e,t,i,s,r,o,l,c),this.isVideoFrameTexture=!0}update(){}clone(){return new this.constructor().copy(this)}setFrame(e){this.image=e,this.needsUpdate=!0}}class ik extends vr{constructor(e,t){super({width:e,height:t}),this.isFramebufferTexture=!0,this.magFilter=ta,this.minFilter=ta,this.generateMipmaps=!1,this.needsUpdate=!0}}class dx extends vr{constructor(e,t,i,s,r,o,l,c,d,g,p,h){super(null,o,l,c,d,g,s,r,p,h),this.isCompressedTexture=!0,this.image={width:t,height:i},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class sk extends dx{constructor(e,t,i,s,r,o){super(e,t,i,r,o),this.isCompressedArrayTexture=!0,this.image.depth=s,this.wrapR=Wu,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class rk extends dx{constructor(e,t,i){super(void 0,e[0].width,e[0].height,t,i,Wh),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class ak extends vr{constructor(e,t,i,s,r,o,l,c,d){super(e,t,i,s,r,o,l,c,d),this.isCanvasTexture=!0,this.needsUpdate=!0}}class fx extends vr{constructor(e,t,i=kf,s,r,o,l=ta,c=ta,d,g=i0,p=1){if(g!==i0&&g!==kg)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");const h={width:e,height:t,depth:p};super(h,s,r,o,l,c,g,i,d),this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.source=new um(Object.assign({},e.image)),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}class hx extends xi{constructor(e=1,t=1,i=4,s=8,r=1){super(),this.type="CapsuleGeometry",this.parameters={radius:e,height:t,capSegments:i,radialSegments:s,heightSegments:r},t=Math.max(0,t),i=Math.max(1,Math.floor(i)),s=Math.max(3,Math.floor(s)),r=Math.max(1,Math.floor(r));const o=[],l=[],c=[],d=[],g=t/2,p=Math.PI/2*e,h=t,v=2*p+h,y=i*2+r,w=s+1,S=new Oe,M=new Oe;for(let T=0;T<=y;T++){let C=0,x=0,R=0,P=0;if(T<=i){const U=T/i,N=U*Math.PI/2;x=-g-e*Math.cos(N),R=e*Math.sin(N),P=-e*Math.cos(N),C=U*p}else if(T<=i+r){const U=(T-i)/r;x=-g+U*t,R=e,P=0,C=p+U*h}else{const U=(T-i-r)/i,N=U*Math.PI/2;x=g+e*Math.sin(N),R=e*Math.cos(N),P=e*Math.sin(N),C=p+h+U*p}const D=Math.max(0,Math.min(1,C/v));let z=0;T===0?z=.5/s:T===y&&(z=-.5/s);for(let U=0;U<=s;U++){const N=U/s,j=N*Math.PI*2,J=Math.sin(j),W=Math.cos(j);M.x=-R*W,M.y=x,M.z=R*J,l.push(M.x,M.y,M.z),S.set(-R*W,P,R*J),S.normalize(),c.push(S.x,S.y,S.z),d.push(N+z,D)}if(T>0){const U=(T-1)*w;for(let N=0;N<s;N++){const j=U+N,J=U+N+1,W=T*w+N,oe=T*w+N+1;o.push(j,J,W),o.push(J,oe,W)}}}this.setIndex(o),this.setAttribute("position",new Hn(l,3)),this.setAttribute("normal",new Hn(c,3)),this.setAttribute("uv",new Hn(d,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new hx(e.radius,e.height,e.capSegments,e.radialSegments,e.heightSegments)}}class px extends xi{constructor(e=1,t=32,i=0,s=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:i,thetaLength:s},t=Math.max(3,t);const r=[],o=[],l=[],c=[],d=new Oe,g=new Gt;o.push(0,0,0),l.push(0,0,1),c.push(.5,.5);for(let p=0,h=3;p<=t;p++,h+=3){const v=i+p/t*s;d.x=e*Math.cos(v),d.y=e*Math.sin(v),o.push(d.x,d.y,d.z),l.push(0,0,1),g.x=(o[h]/e+1)/2,g.y=(o[h+1]/e+1)/2,c.push(g.x,g.y)}for(let p=1;p<=t;p++)r.push(p,p+1,0);this.setIndex(r),this.setAttribute("position",new Hn(o,3)),this.setAttribute("normal",new Hn(l,3)),this.setAttribute("uv",new Hn(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new px(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class Yv extends xi{constructor(e=1,t=1,i=1,s=32,r=1,o=!1,l=0,c=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:i,radialSegments:s,heightSegments:r,openEnded:o,thetaStart:l,thetaLength:c};const d=this;s=Math.floor(s),r=Math.floor(r);const g=[],p=[],h=[],v=[];let y=0;const w=[],S=i/2;let M=0;T(),o===!1&&(e>0&&C(!0),t>0&&C(!1)),this.setIndex(g),this.setAttribute("position",new Hn(p,3)),this.setAttribute("normal",new Hn(h,3)),this.setAttribute("uv",new Hn(v,2));function T(){const x=new Oe,R=new Oe;let P=0;const D=(t-e)/i;for(let z=0;z<=r;z++){const U=[],N=z/r,j=N*(t-e)+e;for(let J=0;J<=s;J++){const W=J/s,oe=W*c+l,ne=Math.sin(oe),q=Math.cos(oe);R.x=j*ne,R.y=-N*i+S,R.z=j*q,p.push(R.x,R.y,R.z),x.set(ne,D,q).normalize(),h.push(x.x,x.y,x.z),v.push(W,1-N),U.push(y++)}w.push(U)}for(let z=0;z<s;z++)for(let U=0;U<r;U++){const N=w[U][z],j=w[U+1][z],J=w[U+1][z+1],W=w[U][z+1];(e>0||U!==0)&&(g.push(N,j,W),P+=3),(t>0||U!==r-1)&&(g.push(j,J,W),P+=3)}d.addGroup(M,P,0),M+=P}function C(x){const R=y,P=new Gt,D=new Oe;let z=0;const U=x===!0?e:t,N=x===!0?1:-1;for(let J=1;J<=s;J++)p.push(0,S*N,0),h.push(0,N,0),v.push(.5,.5),y++;const j=y;for(let J=0;J<=s;J++){const oe=J/s*c+l,ne=Math.cos(oe),q=Math.sin(oe);D.x=U*q,D.y=S*N,D.z=U*ne,p.push(D.x,D.y,D.z),h.push(0,N,0),P.x=ne*.5+.5,P.y=q*.5*N+.5,v.push(P.x,P.y),y++}for(let J=0;J<s;J++){const W=R+J,oe=j+J;x===!0?g.push(oe,oe+1,W):g.push(oe+1,oe,W),z+=3}d.addGroup(M,z,x===!0?1:2),M+=z}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Yv(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Jv extends Yv{constructor(e=1,t=1,i=32,s=1,r=!1,o=0,l=Math.PI*2){super(0,e,t,i,s,r,o,l),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:i,heightSegments:s,openEnded:r,thetaStart:o,thetaLength:l}}static fromJSON(e){return new Jv(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class _m extends xi{constructor(e=[],t=[],i=1,s=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:i,detail:s};const r=[],o=[];l(s),d(i),g(),this.setAttribute("position",new Hn(r,3)),this.setAttribute("normal",new Hn(r.slice(),3)),this.setAttribute("uv",new Hn(o,2)),s===0?this.computeVertexNormals():this.normalizeNormals();function l(T){const C=new Oe,x=new Oe,R=new Oe;for(let P=0;P<t.length;P+=3)v(t[P+0],C),v(t[P+1],x),v(t[P+2],R),c(C,x,R,T)}function c(T,C,x,R){const P=R+1,D=[];for(let z=0;z<=P;z++){D[z]=[];const U=T.clone().lerp(x,z/P),N=C.clone().lerp(x,z/P),j=P-z;for(let J=0;J<=j;J++)J===0&&z===P?D[z][J]=U:D[z][J]=U.clone().lerp(N,J/j)}for(let z=0;z<P;z++)for(let U=0;U<2*(P-z)-1;U++){const N=Math.floor(U/2);U%2===0?(h(D[z][N+1]),h(D[z+1][N]),h(D[z][N])):(h(D[z][N+1]),h(D[z+1][N+1]),h(D[z+1][N]))}}function d(T){const C=new Oe;for(let x=0;x<r.length;x+=3)C.x=r[x+0],C.y=r[x+1],C.z=r[x+2],C.normalize().multiplyScalar(T),r[x+0]=C.x,r[x+1]=C.y,r[x+2]=C.z}function g(){const T=new Oe;for(let C=0;C<r.length;C+=3){T.x=r[C+0],T.y=r[C+1],T.z=r[C+2];const x=S(T)/2/Math.PI+.5,R=M(T)/Math.PI+.5;o.push(x,1-R)}y(),p()}function p(){for(let T=0;T<o.length;T+=6){const C=o[T+0],x=o[T+2],R=o[T+4],P=Math.max(C,x,R),D=Math.min(C,x,R);P>.9&&D<.1&&(C<.2&&(o[T+0]+=1),x<.2&&(o[T+2]+=1),R<.2&&(o[T+4]+=1))}}function h(T){r.push(T.x,T.y,T.z)}function v(T,C){const x=T*3;C.x=e[x+0],C.y=e[x+1],C.z=e[x+2]}function y(){const T=new Oe,C=new Oe,x=new Oe,R=new Oe,P=new Gt,D=new Gt,z=new Gt;for(let U=0,N=0;U<r.length;U+=9,N+=6){T.set(r[U+0],r[U+1],r[U+2]),C.set(r[U+3],r[U+4],r[U+5]),x.set(r[U+6],r[U+7],r[U+8]),P.set(o[N+0],o[N+1]),D.set(o[N+2],o[N+3]),z.set(o[N+4],o[N+5]),R.copy(T).add(C).add(x).divideScalar(3);const j=S(R);w(P,N+0,T,j),w(D,N+2,C,j),w(z,N+4,x,j)}}function w(T,C,x,R){R<0&&T.x===1&&(o[C]=T.x-1),x.x===0&&x.z===0&&(o[C]=R/2/Math.PI+.5)}function S(T){return Math.atan2(T.z,-T.x)}function M(T){return Math.atan2(-T.y,Math.sqrt(T.x*T.x+T.z*T.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new _m(e.vertices,e.indices,e.radius,e.details)}}class mx extends _m{constructor(e=1,t=0){const i=(1+Math.sqrt(5))/2,s=1/i,r=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-s,-i,0,-s,i,0,s,-i,0,s,i,-s,-i,0,-s,i,0,s,-i,0,s,i,0,-i,0,-s,i,0,-s,-i,0,s,i,0,s],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(r,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new mx(e.radius,e.detail)}}const iM=new Oe,sM=new Oe,Pw=new Oe,rM=new ou;class DT extends xi{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const s=Math.pow(10,4),r=Math.cos(Lg*t),o=e.getIndex(),l=e.getAttribute("position"),c=o?o.count:l.count,d=[0,0,0],g=["a","b","c"],p=new Array(3),h={},v=[];for(let y=0;y<c;y+=3){o?(d[0]=o.getX(y),d[1]=o.getX(y+1),d[2]=o.getX(y+2)):(d[0]=y,d[1]=y+1,d[2]=y+2);const{a:w,b:S,c:M}=rM;if(w.fromBufferAttribute(l,d[0]),S.fromBufferAttribute(l,d[1]),M.fromBufferAttribute(l,d[2]),rM.getNormal(Pw),p[0]=`${Math.round(w.x*s)},${Math.round(w.y*s)},${Math.round(w.z*s)}`,p[1]=`${Math.round(S.x*s)},${Math.round(S.y*s)},${Math.round(S.z*s)}`,p[2]=`${Math.round(M.x*s)},${Math.round(M.y*s)},${Math.round(M.z*s)}`,!(p[0]===p[1]||p[1]===p[2]||p[2]===p[0]))for(let T=0;T<3;T++){const C=(T+1)%3,x=p[T],R=p[C],P=rM[g[T]],D=rM[g[C]],z=`${x}_${R}`,U=`${R}_${x}`;U in h&&h[U]?(Pw.dot(h[U].normal)<=r&&(v.push(P.x,P.y,P.z),v.push(D.x,D.y,D.z)),h[U]=null):z in h||(h[z]={index0:d[T],index1:d[C],normal:Pw.clone()})}}for(const y in h)if(h[y]){const{index0:w,index1:S}=h[y];iM.fromBufferAttribute(l,w),sM.fromBufferAttribute(l,S),v.push(iM.x,iM.y,iM.z),v.push(sM.x,sM.y,sM.z)}this.setAttribute("position",new Hn(v,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class kd{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){console.warn("THREE.Curve: .getPoint() not implemented.")}getPointAt(e,t){const i=this.getUtoTmapping(e);return this.getPoint(i,t)}getPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return t}getSpacedPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPointAt(i/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let i,s=this.getPoint(0),r=0;t.push(0);for(let o=1;o<=e;o++)i=this.getPoint(o/e),r+=i.distanceTo(s),t.push(r),s=i;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t=null){const i=this.getLengths();let s=0;const r=i.length;let o;t?o=t:o=e*i[r-1];let l=0,c=r-1,d;for(;l<=c;)if(s=Math.floor(l+(c-l)/2),d=i[s]-o,d<0)l=s+1;else if(d>0)c=s-1;else{c=s;break}if(s=c,i[s]===o)return s/(r-1);const g=i[s],h=i[s+1]-g,v=(o-g)/h;return(s+v)/(r-1)}getTangent(e,t){let s=e-1e-4,r=e+1e-4;s<0&&(s=0),r>1&&(r=1);const o=this.getPoint(s),l=this.getPoint(r),c=t||(o.isVector2?new Gt:new Oe);return c.copy(l).sub(o).normalize(),c}getTangentAt(e,t){const i=this.getUtoTmapping(e);return this.getTangent(i,t)}computeFrenetFrames(e,t=!1){const i=new Oe,s=[],r=[],o=[],l=new Oe,c=new li;for(let v=0;v<=e;v++){const y=v/e;s[v]=this.getTangentAt(y,new Oe)}r[0]=new Oe,o[0]=new Oe;let d=Number.MAX_VALUE;const g=Math.abs(s[0].x),p=Math.abs(s[0].y),h=Math.abs(s[0].z);g<=d&&(d=g,i.set(1,0,0)),p<=d&&(d=p,i.set(0,1,0)),h<=d&&i.set(0,0,1),l.crossVectors(s[0],i).normalize(),r[0].crossVectors(s[0],l),o[0].crossVectors(s[0],r[0]);for(let v=1;v<=e;v++){if(r[v]=r[v-1].clone(),o[v]=o[v-1].clone(),l.crossVectors(s[v-1],s[v]),l.length()>Number.EPSILON){l.normalize();const y=Math.acos(mi(s[v-1].dot(s[v]),-1,1));r[v].applyMatrix4(c.makeRotationAxis(l,y))}o[v].crossVectors(s[v],r[v])}if(t===!0){let v=Math.acos(mi(r[0].dot(r[e]),-1,1));v/=e,s[0].dot(l.crossVectors(r[0],r[e]))>0&&(v=-v);for(let y=1;y<=e;y++)r[y].applyMatrix4(c.makeRotationAxis(s[y],v*y)),o[y].crossVectors(s[y],r[y])}return{tangents:s,normals:r,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.7,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class gx extends kd{constructor(e=0,t=0,i=1,s=1,r=0,o=Math.PI*2,l=!1,c=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=i,this.yRadius=s,this.aStartAngle=r,this.aEndAngle=o,this.aClockwise=l,this.aRotation=c}getPoint(e,t=new Gt){const i=t,s=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const o=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=s;for(;r>s;)r-=s;r<Number.EPSILON&&(o?r=0:r=s),this.aClockwise===!0&&!o&&(r===s?r=-s:r=r-s);const l=this.aStartAngle+e*r;let c=this.aX+this.xRadius*Math.cos(l),d=this.aY+this.yRadius*Math.sin(l);if(this.aRotation!==0){const g=Math.cos(this.aRotation),p=Math.sin(this.aRotation),h=c-this.aX,v=d-this.aY;c=h*g-v*p+this.aX,d=h*p+v*g+this.aY}return i.set(c,d)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class AI extends gx{constructor(e,t,i,s,r,o){super(e,t,i,i,s,r,o),this.isArcCurve=!0,this.type="ArcCurve"}}function BT(){let n=0,e=0,t=0,i=0;function s(r,o,l,c){n=r,e=l,t=-3*r+3*o-2*l-c,i=2*r-2*o+l+c}return{initCatmullRom:function(r,o,l,c,d){s(o,l,d*(l-r),d*(c-o))},initNonuniformCatmullRom:function(r,o,l,c,d,g,p){let h=(o-r)/d-(l-r)/(d+g)+(l-o)/g,v=(l-o)/g-(c-o)/(g+p)+(c-l)/p;h*=g,v*=g,s(o,l,h,v)},calc:function(r){const o=r*r,l=o*r;return n+e*r+t*o+i*l}}}const aM=new Oe,Rw=new BT,Dw=new BT,Bw=new BT;class CI extends kd{constructor(e=[],t=!1,i="centripetal",s=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=i,this.tension=s}getPoint(e,t=new Oe){const i=t,s=this.points,r=s.length,o=(r-(this.closed?0:1))*e;let l=Math.floor(o),c=o-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/r)+1)*r:c===0&&l===r-1&&(l=r-2,c=1);let d,g;this.closed||l>0?d=s[(l-1)%r]:(aM.subVectors(s[0],s[1]).add(s[0]),d=aM);const p=s[l%r],h=s[(l+1)%r];if(this.closed||l+2<r?g=s[(l+2)%r]:(aM.subVectors(s[r-1],s[r-2]).add(s[r-1]),g=aM),this.curveType==="centripetal"||this.curveType==="chordal"){const v=this.curveType==="chordal"?.5:.25;let y=Math.pow(d.distanceToSquared(p),v),w=Math.pow(p.distanceToSquared(h),v),S=Math.pow(h.distanceToSquared(g),v);w<1e-4&&(w=1),y<1e-4&&(y=w),S<1e-4&&(S=w),Rw.initNonuniformCatmullRom(d.x,p.x,h.x,g.x,y,w,S),Dw.initNonuniformCatmullRom(d.y,p.y,h.y,g.y,y,w,S),Bw.initNonuniformCatmullRom(d.z,p.z,h.z,g.z,y,w,S)}else this.curveType==="catmullrom"&&(Rw.initCatmullRom(d.x,p.x,h.x,g.x,this.tension),Dw.initCatmullRom(d.y,p.y,h.y,g.y,this.tension),Bw.initCatmullRom(d.z,p.z,h.z,g.z,this.tension));return i.set(Rw.calc(c),Dw.calc(c),Bw.calc(c)),i}copy(e){super.copy(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const s=e.points[t];this.points.push(s.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,i=this.points.length;t<i;t++){const s=this.points[t];e.points.push(s.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const s=e.points[t];this.points.push(new Oe().fromArray(s))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function QA(n,e,t,i,s){const r=(i-e)*.5,o=(s-t)*.5,l=n*n,c=n*l;return(2*t-2*i+r+o)*c+(-3*t+3*i-2*r-o)*l+r*n+t}function ok(n,e){const t=1-n;return t*t*e}function lk(n,e){return 2*(1-n)*n*e}function uk(n,e){return n*n*e}function Ev(n,e,t,i){return ok(n,e)+lk(n,t)+uk(n,i)}function ck(n,e){const t=1-n;return t*t*t*e}function dk(n,e){const t=1-n;return 3*t*t*n*e}function fk(n,e){return 3*(1-n)*n*n*e}function hk(n,e){return n*n*n*e}function Tv(n,e,t,i,s){return ck(n,e)+dk(n,t)+fk(n,i)+hk(n,s)}class IT extends kd{constructor(e=new Gt,t=new Gt,i=new Gt,s=new Gt){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=i,this.v3=s}getPoint(e,t=new Gt){const i=t,s=this.v0,r=this.v1,o=this.v2,l=this.v3;return i.set(Tv(e,s.x,r.x,o.x,l.x),Tv(e,s.y,r.y,o.y,l.y)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class PI extends kd{constructor(e=new Oe,t=new Oe,i=new Oe,s=new Oe){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=i,this.v3=s}getPoint(e,t=new Oe){const i=t,s=this.v0,r=this.v1,o=this.v2,l=this.v3;return i.set(Tv(e,s.x,r.x,o.x,l.x),Tv(e,s.y,r.y,o.y,l.y),Tv(e,s.z,r.z,o.z,l.z)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class OT extends kd{constructor(e=new Gt,t=new Gt){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Gt){const i=t;return e===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(e).add(this.v1)),i}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new Gt){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class RI extends kd{constructor(e=new Oe,t=new Oe){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new Oe){const i=t;return e===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(e).add(this.v1)),i}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new Oe){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class LT extends kd{constructor(e=new Gt,t=new Gt,i=new Gt){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=i}getPoint(e,t=new Gt){const i=t,s=this.v0,r=this.v1,o=this.v2;return i.set(Ev(e,s.x,r.x,o.x),Ev(e,s.y,r.y,o.y)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class FT extends kd{constructor(e=new Oe,t=new Oe,i=new Oe){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=i}getPoint(e,t=new Oe){const i=t,s=this.v0,r=this.v1,o=this.v2;return i.set(Ev(e,s.x,r.x,o.x),Ev(e,s.y,r.y,o.y),Ev(e,s.z,r.z,o.z)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class NT extends kd{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new Gt){const i=t,s=this.points,r=(s.length-1)*e,o=Math.floor(r),l=r-o,c=s[o===0?o:o-1],d=s[o],g=s[o>s.length-2?s.length-1:o+1],p=s[o>s.length-3?s.length-1:o+2];return i.set(QA(l,c.x,d.x,g.x,p.x),QA(l,c.y,d.y,g.y,p.y)),i}copy(e){super.copy(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const s=e.points[t];this.points.push(s.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,i=this.points.length;t<i;t++){const s=this.points[t];e.points.push(s.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const s=e.points[t];this.points.push(new Gt().fromArray(s))}return this}}var Rb=Object.freeze({__proto__:null,ArcCurve:AI,CatmullRomCurve3:CI,CubicBezierCurve:IT,CubicBezierCurve3:PI,EllipseCurve:gx,LineCurve:OT,LineCurve3:RI,QuadraticBezierCurve:LT,QuadraticBezierCurve3:FT,SplineCurve:NT});class DI extends kd{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(t)){const i=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new Rb[i](t,e))}return this}getPoint(e,t){const i=e*this.getLength(),s=this.getCurveLengths();let r=0;for(;r<s.length;){if(s[r]>=i){const o=s[r]-i,l=this.curves[r],c=l.getLength(),d=c===0?0:1-o/c;return l.getPointAt(d,t)}r++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let i=0,s=this.curves.length;i<s;i++)t+=this.curves[i].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let i;for(let s=0,r=this.curves;s<r.length;s++){const o=r[s],l=o.isEllipseCurve?e*2:o.isLineCurve||o.isLineCurve3?1:o.isSplineCurve?e*o.points.length:e,c=o.getPoints(l);for(let d=0;d<c.length;d++){const g=c[d];i&&i.equals(g)||(t.push(g),i=g)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,i=e.curves.length;t<i;t++){const s=e.curves[t];this.curves.push(s.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,i=this.curves.length;t<i;t++){const s=this.curves[t];e.curves.push(s.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,i=e.curves.length;t<i;t++){const s=e.curves[t];this.curves.push(new Rb[s.type]().fromJSON(s))}return this}}class Db extends DI{constructor(e){super(),this.type="Path",this.currentPoint=new Gt,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,i=e.length;t<i;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const i=new OT(this.currentPoint.clone(),new Gt(e,t));return this.curves.push(i),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,i,s){const r=new LT(this.currentPoint.clone(),new Gt(e,t),new Gt(i,s));return this.curves.push(r),this.currentPoint.set(i,s),this}bezierCurveTo(e,t,i,s,r,o){const l=new IT(this.currentPoint.clone(),new Gt(e,t),new Gt(i,s),new Gt(r,o));return this.curves.push(l),this.currentPoint.set(r,o),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),i=new NT(t);return this.curves.push(i),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,i,s,r,o){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absarc(e+l,t+c,i,s,r,o),this}absarc(e,t,i,s,r,o){return this.absellipse(e,t,i,i,s,r,o),this}ellipse(e,t,i,s,r,o,l,c){const d=this.currentPoint.x,g=this.currentPoint.y;return this.absellipse(e+d,t+g,i,s,r,o,l,c),this}absellipse(e,t,i,s,r,o,l,c){const d=new gx(e,t,i,s,r,o,l,c);if(this.curves.length>0){const p=d.getPoint(0);p.equals(this.currentPoint)||this.lineTo(p.x,p.y)}this.curves.push(d);const g=d.getPoint(1);return this.currentPoint.copy(g),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Fg extends Db{constructor(e){super(e),this.uuid=Xu(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let i=0,s=this.holes.length;i<s;i++)t[i]=this.holes[i].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,i=e.holes.length;t<i;t++){const s=e.holes[t];this.holes.push(s.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,i=this.holes.length;t<i;t++){const s=this.holes[t];e.holes.push(s.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,i=e.holes.length;t<i;t++){const s=e.holes[t];this.holes.push(new Db().fromJSON(s))}return this}}function pk(n,e,t=2){const i=e&&e.length,s=i?e[0]*t:n.length;let r=BI(n,0,s,t,!0);const o=[];if(!r||r.next===r.prev)return o;let l,c,d;if(i&&(r=yk(n,e,r,t)),n.length>80*t){l=1/0,c=1/0;let g=-1/0,p=-1/0;for(let h=t;h<s;h+=t){const v=n[h],y=n[h+1];v<l&&(l=v),y<c&&(c=y),v>g&&(g=v),y>p&&(p=y)}d=Math.max(g-l,p-c),d=d!==0?32767/d:0}return Nv(r,o,t,l,c,d,0),o}function BI(n,e,t,i,s){let r;if(s===Rk(n,e,t,i)>0)for(let o=e;o<t;o+=i)r=ZA(o/i|0,n[o],n[o+1],r);else for(let o=t-i;o>=e;o-=i)r=ZA(o/i|0,n[o],n[o+1],r);return r&&c0(r,r.next)&&(Uv(r),r=r.next),r}function Vg(n,e){if(!n)return n;e||(e=n);let t=n,i;do if(i=!1,!t.steiner&&(c0(t,t.next)||jr(t.prev,t,t.next)===0)){if(Uv(t),t=e=t.prev,t===t.next)break;i=!0}else t=t.next;while(i||t!==e);return e}function Nv(n,e,t,i,s,r,o){if(!n)return;!o&&r&&Ek(n,i,s,r);let l=n;for(;n.prev!==n.next;){const c=n.prev,d=n.next;if(r?gk(n,i,s,r):mk(n)){e.push(c.i,n.i,d.i),Uv(n),n=d.next,l=d.next;continue}if(n=d,n===l){o?o===1?(n=_k(Vg(n),e),Nv(n,e,t,i,s,r,2)):o===2&&vk(n,e,t,i,s,r):Nv(Vg(n),e,t,i,s,r,1);break}}}function mk(n){const e=n.prev,t=n,i=n.next;if(jr(e,t,i)>=0)return!1;const s=e.x,r=t.x,o=i.x,l=e.y,c=t.y,d=i.y,g=Math.min(s,r,o),p=Math.min(l,c,d),h=Math.max(s,r,o),v=Math.max(l,c,d);let y=i.next;for(;y!==e;){if(y.x>=g&&y.x<=h&&y.y>=p&&y.y<=v&&dv(s,l,r,c,o,d,y.x,y.y)&&jr(y.prev,y,y.next)>=0)return!1;y=y.next}return!0}function gk(n,e,t,i){const s=n.prev,r=n,o=n.next;if(jr(s,r,o)>=0)return!1;const l=s.x,c=r.x,d=o.x,g=s.y,p=r.y,h=o.y,v=Math.min(l,c,d),y=Math.min(g,p,h),w=Math.max(l,c,d),S=Math.max(g,p,h),M=AE(v,y,e,t,i),T=AE(w,S,e,t,i);let C=n.prevZ,x=n.nextZ;for(;C&&C.z>=M&&x&&x.z<=T;){if(C.x>=v&&C.x<=w&&C.y>=y&&C.y<=S&&C!==s&&C!==o&&dv(l,g,c,p,d,h,C.x,C.y)&&jr(C.prev,C,C.next)>=0||(C=C.prevZ,x.x>=v&&x.x<=w&&x.y>=y&&x.y<=S&&x!==s&&x!==o&&dv(l,g,c,p,d,h,x.x,x.y)&&jr(x.prev,x,x.next)>=0))return!1;x=x.nextZ}for(;C&&C.z>=M;){if(C.x>=v&&C.x<=w&&C.y>=y&&C.y<=S&&C!==s&&C!==o&&dv(l,g,c,p,d,h,C.x,C.y)&&jr(C.prev,C,C.next)>=0)return!1;C=C.prevZ}for(;x&&x.z<=T;){if(x.x>=v&&x.x<=w&&x.y>=y&&x.y<=S&&x!==s&&x!==o&&dv(l,g,c,p,d,h,x.x,x.y)&&jr(x.prev,x,x.next)>=0)return!1;x=x.nextZ}return!0}function _k(n,e){let t=n;do{const i=t.prev,s=t.next.next;!c0(i,s)&&OI(i,t,t.next,s)&&zv(i,s)&&zv(s,i)&&(e.push(i.i,t.i,s.i),Uv(t),Uv(t.next),t=n=s),t=t.next}while(t!==n);return Vg(t)}function vk(n,e,t,i,s,r){let o=n;do{let l=o.next.next;for(;l!==o.prev;){if(o.i!==l.i&&Ak(o,l)){let c=LI(o,l);o=Vg(o,o.next),c=Vg(c,c.next),Nv(o,e,t,i,s,r,0),Nv(c,e,t,i,s,r,0);return}l=l.next}o=o.next}while(o!==n)}function yk(n,e,t,i){const s=[];for(let r=0,o=e.length;r<o;r++){const l=e[r]*i,c=r<o-1?e[r+1]*i:n.length,d=BI(n,l,c,i,!1);d===d.next&&(d.steiner=!0),s.push(Sk(d))}s.sort(Mk);for(let r=0;r<s.length;r++)t=bk(s[r],t);return t}function Mk(n,e){let t=n.x-e.x;if(t===0&&(t=n.y-e.y,t===0)){const i=(n.next.y-n.y)/(n.next.x-n.x),s=(e.next.y-e.y)/(e.next.x-e.x);t=i-s}return t}function bk(n,e){const t=xk(n,e);if(!t)return e;const i=LI(t,n);return Vg(i,i.next),Vg(t,t.next)}function xk(n,e){let t=e;const i=n.x,s=n.y;let r=-1/0,o;if(c0(n,t))return t;do{if(c0(n,t.next))return t.next;if(s<=t.y&&s>=t.next.y&&t.next.y!==t.y){const p=t.x+(s-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(p<=i&&p>r&&(r=p,o=t.x<t.next.x?t:t.next,p===i))return o}t=t.next}while(t!==e);if(!o)return null;const l=o,c=o.x,d=o.y;let g=1/0;t=o;do{if(i>=t.x&&t.x>=c&&i!==t.x&&II(s<d?i:r,s,c,d,s<d?r:i,s,t.x,t.y)){const p=Math.abs(s-t.y)/(i-t.x);zv(t,n)&&(p<g||p===g&&(t.x>o.x||t.x===o.x&&wk(o,t)))&&(o=t,g=p)}t=t.next}while(t!==l);return o}function wk(n,e){return jr(n.prev,n,e.prev)<0&&jr(e.next,n,n.next)<0}function Ek(n,e,t,i){let s=n;do s.z===0&&(s.z=AE(s.x,s.y,e,t,i)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==n);s.prevZ.nextZ=null,s.prevZ=null,Tk(s)}function Tk(n){let e,t=1;do{let i=n,s;n=null;let r=null;for(e=0;i;){e++;let o=i,l=0;for(let d=0;d<t&&(l++,o=o.nextZ,!!o);d++);let c=t;for(;l>0||c>0&&o;)l!==0&&(c===0||!o||i.z<=o.z)?(s=i,i=i.nextZ,l--):(s=o,o=o.nextZ,c--),r?r.nextZ=s:n=s,s.prevZ=r,r=s;i=o}r.nextZ=null,t*=2}while(e>1);return n}function AE(n,e,t,i,s){return n=(n-t)*s|0,e=(e-i)*s|0,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function Sk(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function II(n,e,t,i,s,r,o,l){return(s-o)*(e-l)>=(n-o)*(r-l)&&(n-o)*(i-l)>=(t-o)*(e-l)&&(t-o)*(r-l)>=(s-o)*(i-l)}function dv(n,e,t,i,s,r,o,l){return!(n===o&&e===l)&&II(n,e,t,i,s,r,o,l)}function Ak(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!Ck(n,e)&&(zv(n,e)&&zv(e,n)&&Pk(n,e)&&(jr(n.prev,n,e.prev)||jr(n,e.prev,e))||c0(n,e)&&jr(n.prev,n,n.next)>0&&jr(e.prev,e,e.next)>0)}function jr(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function c0(n,e){return n.x===e.x&&n.y===e.y}function OI(n,e,t,i){const s=lM(jr(n,e,t)),r=lM(jr(n,e,i)),o=lM(jr(t,i,n)),l=lM(jr(t,i,e));return!!(s!==r&&o!==l||s===0&&oM(n,t,e)||r===0&&oM(n,i,e)||o===0&&oM(t,n,i)||l===0&&oM(t,e,i))}function oM(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function lM(n){return n>0?1:n<0?-1:0}function Ck(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&OI(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function zv(n,e){return jr(n.prev,n,n.next)<0?jr(n,e,n.next)>=0&&jr(n,n.prev,e)>=0:jr(n,e,n.prev)<0||jr(n,n.next,e)<0}function Pk(n,e){let t=n,i=!1;const s=(n.x+e.x)/2,r=(n.y+e.y)/2;do t.y>r!=t.next.y>r&&t.next.y!==t.y&&s<(t.next.x-t.x)*(r-t.y)/(t.next.y-t.y)+t.x&&(i=!i),t=t.next;while(t!==n);return i}function LI(n,e){const t=CE(n.i,n.x,n.y),i=CE(e.i,e.x,e.y),s=n.next,r=e.prev;return n.next=e,e.prev=n,t.next=s,s.prev=t,i.next=t,t.prev=i,r.next=i,i.prev=r,i}function ZA(n,e,t,i){const s=CE(n,e,t);return i?(s.next=i.next,s.prev=i,i.next.prev=s,i.next=s):(s.prev=s,s.next=s),s}function Uv(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function CE(n,e,t){return{i:n,x:e,y:t,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function Rk(n,e,t,i){let s=0;for(let r=e,o=t-i;r<t;r+=i)s+=(n[o]-n[r])*(n[r+1]+n[o+1]),o=r;return s}class Dk{static triangulate(e,t,i=2){return pk(e,t,i)}}class Od{static area(e){const t=e.length;let i=0;for(let s=t-1,r=0;r<t;s=r++)i+=e[s].x*e[r].y-e[r].x*e[s].y;return i*.5}static isClockWise(e){return Od.area(e)<0}static triangulateShape(e,t){const i=[],s=[],r=[];eC(e),tC(i,e);let o=e.length;t.forEach(eC);for(let c=0;c<t.length;c++)s.push(o),o+=t[c].length,tC(i,t[c]);const l=Dk.triangulate(i,s);for(let c=0;c<l.length;c+=3)r.push(l.slice(c,c+3));return r}}function eC(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function tC(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class _x extends xi{constructor(e=new Fg([new Gt(.5,.5),new Gt(-.5,.5),new Gt(-.5,-.5),new Gt(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const i=this,s=[],r=[];for(let l=0,c=e.length;l<c;l++){const d=e[l];o(d)}this.setAttribute("position",new Hn(s,3)),this.setAttribute("uv",new Hn(r,2)),this.computeVertexNormals();function o(l){const c=[],d=t.curveSegments!==void 0?t.curveSegments:12,g=t.steps!==void 0?t.steps:1,p=t.depth!==void 0?t.depth:1;let h=t.bevelEnabled!==void 0?t.bevelEnabled:!0,v=t.bevelThickness!==void 0?t.bevelThickness:.2,y=t.bevelSize!==void 0?t.bevelSize:v-.1,w=t.bevelOffset!==void 0?t.bevelOffset:0,S=t.bevelSegments!==void 0?t.bevelSegments:3;const M=t.extrudePath,T=t.UVGenerator!==void 0?t.UVGenerator:Bk;let C,x=!1,R,P,D,z;M&&(C=M.getSpacedPoints(g),x=!0,h=!1,R=M.computeFrenetFrames(g,!1),P=new Oe,D=new Oe,z=new Oe),h||(S=0,v=0,y=0,w=0);const U=l.extractPoints(d);let N=U.shape;const j=U.holes;if(!Od.isClockWise(N)){N=N.reverse();for(let ke=0,ze=j.length;ke<ze;ke++){const je=j[ke];Od.isClockWise(je)&&(j[ke]=je.reverse())}}function W(ke){const je=10000000000000001e-36;let Fe=ke[0];for(let Ye=1;Ye<=ke.length;Ye++){const Ve=Ye%ke.length,Qe=ke[Ve],mt=Qe.x-Fe.x,Tt=Qe.y-Fe.y,Me=mt*mt+Tt*Tt,me=Math.max(Math.abs(Qe.x),Math.abs(Qe.y),Math.abs(Fe.x),Math.abs(Fe.y)),$e=je*me*me;if(Me<=$e){ke.splice(Ve,1),Ye--;continue}Fe=Qe}}W(N),j.forEach(W);const oe=j.length,ne=N;for(let ke=0;ke<oe;ke++){const ze=j[ke];N=N.concat(ze)}function q(ke,ze,je){return ze||console.error("THREE.ExtrudeGeometry: vec does not exist"),ke.clone().addScaledVector(ze,je)}const le=N.length;function se(ke,ze,je){let Fe,Ye,Ve;const Qe=ke.x-ze.x,mt=ke.y-ze.y,Tt=je.x-ke.x,Me=je.y-ke.y,me=Qe*Qe+mt*mt,$e=Qe*Me-mt*Tt;if(Math.abs($e)>Number.EPSILON){const et=Math.sqrt(me),ht=Math.sqrt(Tt*Tt+Me*Me),at=ze.x-mt/et,Et=ze.y+Qe/et,Dt=je.x-Me/ht,Vt=je.y+Tt/ht,an=((Dt-at)*Me-(Vt-Et)*Tt)/(Qe*Me-mt*Tt);Fe=at+Qe*an-ke.x,Ye=Et+mt*an-ke.y;const bt=Fe*Fe+Ye*Ye;if(bt<=2)return new Gt(Fe,Ye);Ve=Math.sqrt(bt/2)}else{let et=!1;Qe>Number.EPSILON?Tt>Number.EPSILON&&(et=!0):Qe<-Number.EPSILON?Tt<-Number.EPSILON&&(et=!0):Math.sign(mt)===Math.sign(Me)&&(et=!0),et?(Fe=-mt,Ye=Qe,Ve=Math.sqrt(me)):(Fe=Qe,Ye=mt,Ve=Math.sqrt(me/2))}return new Gt(Fe/Ve,Ye/Ve)}const pe=[];for(let ke=0,ze=ne.length,je=ze-1,Fe=ke+1;ke<ze;ke++,je++,Fe++)je===ze&&(je=0),Fe===ze&&(Fe=0),pe[ke]=se(ne[ke],ne[je],ne[Fe]);const be=[];let ee,te=pe.concat();for(let ke=0,ze=oe;ke<ze;ke++){const je=j[ke];ee=[];for(let Fe=0,Ye=je.length,Ve=Ye-1,Qe=Fe+1;Fe<Ye;Fe++,Ve++,Qe++)Ve===Ye&&(Ve=0),Qe===Ye&&(Qe=0),ee[Fe]=se(je[Fe],je[Ve],je[Qe]);be.push(ee),te=te.concat(ee)}let ue;if(S===0)ue=Od.triangulateShape(ne,j);else{const ke=[],ze=[];for(let je=0;je<S;je++){const Fe=je/S,Ye=v*Math.cos(Fe*Math.PI/2),Ve=y*Math.sin(Fe*Math.PI/2)+w;for(let Qe=0,mt=ne.length;Qe<mt;Qe++){const Tt=q(ne[Qe],pe[Qe],Ve);ot(Tt.x,Tt.y,-Ye),Fe===0&&ke.push(Tt)}for(let Qe=0,mt=oe;Qe<mt;Qe++){const Tt=j[Qe];ee=be[Qe];const Me=[];for(let me=0,$e=Tt.length;me<$e;me++){const et=q(Tt[me],ee[me],Ve);ot(et.x,et.y,-Ye),Fe===0&&Me.push(et)}Fe===0&&ze.push(Me)}}ue=Od.triangulateShape(ke,ze)}const ae=ue.length,ce=y+w;for(let ke=0;ke<le;ke++){const ze=h?q(N[ke],te[ke],ce):N[ke];x?(D.copy(R.normals[0]).multiplyScalar(ze.x),P.copy(R.binormals[0]).multiplyScalar(ze.y),z.copy(C[0]).add(D).add(P),ot(z.x,z.y,z.z)):ot(ze.x,ze.y,0)}for(let ke=1;ke<=g;ke++)for(let ze=0;ze<le;ze++){const je=h?q(N[ze],te[ze],ce):N[ze];x?(D.copy(R.normals[ke]).multiplyScalar(je.x),P.copy(R.binormals[ke]).multiplyScalar(je.y),z.copy(C[ke]).add(D).add(P),ot(z.x,z.y,z.z)):ot(je.x,je.y,p/g*ke)}for(let ke=S-1;ke>=0;ke--){const ze=ke/S,je=v*Math.cos(ze*Math.PI/2),Fe=y*Math.sin(ze*Math.PI/2)+w;for(let Ye=0,Ve=ne.length;Ye<Ve;Ye++){const Qe=q(ne[Ye],pe[Ye],Fe);ot(Qe.x,Qe.y,p+je)}for(let Ye=0,Ve=j.length;Ye<Ve;Ye++){const Qe=j[Ye];ee=be[Ye];for(let mt=0,Tt=Qe.length;mt<Tt;mt++){const Me=q(Qe[mt],ee[mt],Fe);x?ot(Me.x,Me.y+C[g-1].y,C[g-1].x+je):ot(Me.x,Me.y,p+je)}}}Be(),He();function Be(){const ke=s.length/3;if(h){let ze=0,je=le*ze;for(let Fe=0;Fe<ae;Fe++){const Ye=ue[Fe];tt(Ye[2]+je,Ye[1]+je,Ye[0]+je)}ze=g+S*2,je=le*ze;for(let Fe=0;Fe<ae;Fe++){const Ye=ue[Fe];tt(Ye[0]+je,Ye[1]+je,Ye[2]+je)}}else{for(let ze=0;ze<ae;ze++){const je=ue[ze];tt(je[2],je[1],je[0])}for(let ze=0;ze<ae;ze++){const je=ue[ze];tt(je[0]+le*g,je[1]+le*g,je[2]+le*g)}}i.addGroup(ke,s.length/3-ke,0)}function He(){const ke=s.length/3;let ze=0;Xe(ne,ze),ze+=ne.length;for(let je=0,Fe=j.length;je<Fe;je++){const Ye=j[je];Xe(Ye,ze),ze+=Ye.length}i.addGroup(ke,s.length/3-ke,1)}function Xe(ke,ze){let je=ke.length;for(;--je>=0;){const Fe=je;let Ye=je-1;Ye<0&&(Ye=ke.length-1);for(let Ve=0,Qe=g+S*2;Ve<Qe;Ve++){const mt=le*Ve,Tt=le*(Ve+1),Me=ze+Fe+mt,me=ze+Ye+mt,$e=ze+Ye+Tt,et=ze+Fe+Tt;Ae(Me,me,$e,et)}}}function ot(ke,ze,je){c.push(ke),c.push(ze),c.push(je)}function tt(ke,ze,je){ye(ke),ye(ze),ye(je);const Fe=s.length/3,Ye=T.generateTopUV(i,s,Fe-3,Fe-2,Fe-1);xe(Ye[0]),xe(Ye[1]),xe(Ye[2])}function Ae(ke,ze,je,Fe){ye(ke),ye(ze),ye(Fe),ye(ze),ye(je),ye(Fe);const Ye=s.length/3,Ve=T.generateSideWallUV(i,s,Ye-6,Ye-3,Ye-2,Ye-1);xe(Ve[0]),xe(Ve[1]),xe(Ve[3]),xe(Ve[1]),xe(Ve[2]),xe(Ve[3])}function ye(ke){s.push(c[ke*3+0]),s.push(c[ke*3+1]),s.push(c[ke*3+2])}function xe(ke){r.push(ke.x),r.push(ke.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,i=this.parameters.options;return Ik(t,i,e)}static fromJSON(e,t){const i=[];for(let r=0,o=e.shapes.length;r<o;r++){const l=t[e.shapes[r]];i.push(l)}const s=e.options.extrudePath;return s!==void 0&&(e.options.extrudePath=new Rb[s.type]().fromJSON(s)),new _x(i,e.options)}}const Bk={generateTopUV:function(n,e,t,i,s){const r=e[t*3],o=e[t*3+1],l=e[i*3],c=e[i*3+1],d=e[s*3],g=e[s*3+1];return[new Gt(r,o),new Gt(l,c),new Gt(d,g)]},generateSideWallUV:function(n,e,t,i,s,r){const o=e[t*3],l=e[t*3+1],c=e[t*3+2],d=e[i*3],g=e[i*3+1],p=e[i*3+2],h=e[s*3],v=e[s*3+1],y=e[s*3+2],w=e[r*3],S=e[r*3+1],M=e[r*3+2];return Math.abs(l-g)<Math.abs(o-d)?[new Gt(o,1-c),new Gt(d,1-p),new Gt(h,1-y),new Gt(w,1-M)]:[new Gt(l,1-c),new Gt(g,1-p),new Gt(v,1-y),new Gt(S,1-M)]}};function Ik(n,e,t){if(t.shapes=[],Array.isArray(n))for(let i=0,s=n.length;i<s;i++){const r=n[i];t.shapes.push(r.uuid)}else t.shapes.push(n.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class vx extends _m{constructor(e=1,t=0){const i=(1+Math.sqrt(5))/2,s=[-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1],r=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(s,r,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new vx(e.radius,e.detail)}}class yx extends xi{constructor(e=[new Gt(0,-.5),new Gt(.5,0),new Gt(0,.5)],t=12,i=0,s=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:i,phiLength:s},t=Math.floor(t),s=mi(s,0,Math.PI*2);const r=[],o=[],l=[],c=[],d=[],g=1/t,p=new Oe,h=new Gt,v=new Oe,y=new Oe,w=new Oe;let S=0,M=0;for(let T=0;T<=e.length-1;T++)switch(T){case 0:S=e[T+1].x-e[T].x,M=e[T+1].y-e[T].y,v.x=M*1,v.y=-S,v.z=M*0,w.copy(v),v.normalize(),c.push(v.x,v.y,v.z);break;case e.length-1:c.push(w.x,w.y,w.z);break;default:S=e[T+1].x-e[T].x,M=e[T+1].y-e[T].y,v.x=M*1,v.y=-S,v.z=M*0,y.copy(v),v.x+=w.x,v.y+=w.y,v.z+=w.z,v.normalize(),c.push(v.x,v.y,v.z),w.copy(y)}for(let T=0;T<=t;T++){const C=i+T*g*s,x=Math.sin(C),R=Math.cos(C);for(let P=0;P<=e.length-1;P++){p.x=e[P].x*x,p.y=e[P].y,p.z=e[P].x*R,o.push(p.x,p.y,p.z),h.x=T/t,h.y=P/(e.length-1),l.push(h.x,h.y);const D=c[3*P+0]*x,z=c[3*P+1],U=c[3*P+0]*R;d.push(D,z,U)}}for(let T=0;T<t;T++)for(let C=0;C<e.length-1;C++){const x=C+T*e.length,R=x,P=x+e.length,D=x+e.length+1,z=x+1;r.push(R,P,z),r.push(D,z,P)}this.setIndex(r),this.setAttribute("position",new Hn(o,3)),this.setAttribute("uv",new Hn(l,2)),this.setAttribute("normal",new Hn(d,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new yx(e.points,e.segments,e.phiStart,e.phiLength)}}class Qv extends _m{constructor(e=1,t=0){const i=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],s=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(i,s,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Qv(e.radius,e.detail)}}class v0 extends xi{constructor(e=1,t=1,i=1,s=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:i,heightSegments:s};const r=e/2,o=t/2,l=Math.floor(i),c=Math.floor(s),d=l+1,g=c+1,p=e/l,h=t/c,v=[],y=[],w=[],S=[];for(let M=0;M<g;M++){const T=M*h-o;for(let C=0;C<d;C++){const x=C*p-r;y.push(x,-T,0),w.push(0,0,1),S.push(C/l),S.push(1-M/c)}}for(let M=0;M<c;M++)for(let T=0;T<l;T++){const C=T+d*M,x=T+d*(M+1),R=T+1+d*(M+1),P=T+1+d*M;v.push(C,x,P),v.push(x,R,P)}this.setIndex(v),this.setAttribute("position",new Hn(y,3)),this.setAttribute("normal",new Hn(w,3)),this.setAttribute("uv",new Hn(S,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new v0(e.width,e.height,e.widthSegments,e.heightSegments)}}class Mx extends xi{constructor(e=.5,t=1,i=32,s=1,r=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:i,phiSegments:s,thetaStart:r,thetaLength:o},i=Math.max(3,i),s=Math.max(1,s);const l=[],c=[],d=[],g=[];let p=e;const h=(t-e)/s,v=new Oe,y=new Gt;for(let w=0;w<=s;w++){for(let S=0;S<=i;S++){const M=r+S/i*o;v.x=p*Math.cos(M),v.y=p*Math.sin(M),c.push(v.x,v.y,v.z),d.push(0,0,1),y.x=(v.x/t+1)/2,y.y=(v.y/t+1)/2,g.push(y.x,y.y)}p+=h}for(let w=0;w<s;w++){const S=w*(i+1);for(let M=0;M<i;M++){const T=M+S,C=T,x=T+i+1,R=T+i+2,P=T+1;l.push(C,x,P),l.push(x,R,P)}}this.setIndex(l),this.setAttribute("position",new Hn(c,3)),this.setAttribute("normal",new Hn(d,3)),this.setAttribute("uv",new Hn(g,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Mx(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class bx extends xi{constructor(e=new Fg([new Gt(0,.5),new Gt(-.5,-.5),new Gt(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const i=[],s=[],r=[],o=[];let l=0,c=0;if(Array.isArray(e)===!1)d(e);else for(let g=0;g<e.length;g++)d(e[g]),this.addGroup(l,c,g),l+=c,c=0;this.setIndex(i),this.setAttribute("position",new Hn(s,3)),this.setAttribute("normal",new Hn(r,3)),this.setAttribute("uv",new Hn(o,2));function d(g){const p=s.length/3,h=g.extractPoints(t);let v=h.shape;const y=h.holes;Od.isClockWise(v)===!1&&(v=v.reverse());for(let S=0,M=y.length;S<M;S++){const T=y[S];Od.isClockWise(T)===!0&&(y[S]=T.reverse())}const w=Od.triangulateShape(v,y);for(let S=0,M=y.length;S<M;S++){const T=y[S];v=v.concat(T)}for(let S=0,M=v.length;S<M;S++){const T=v[S];s.push(T.x,T.y,0),r.push(0,0,1),o.push(T.x,T.y)}for(let S=0,M=w.length;S<M;S++){const T=w[S],C=T[0]+p,x=T[1]+p,R=T[2]+p;i.push(C,x,R),c+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return Ok(t,e)}static fromJSON(e,t){const i=[];for(let s=0,r=e.shapes.length;s<r;s++){const o=t[e.shapes[s]];i.push(o)}return new bx(i,e.curveSegments)}}function Ok(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,i=n.length;t<i;t++){const s=n[t];e.shapes.push(s.uuid)}else e.shapes.push(n.uuid);return e}class y0 extends xi{constructor(e=1,t=32,i=16,s=0,r=Math.PI*2,o=0,l=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:i,phiStart:s,phiLength:r,thetaStart:o,thetaLength:l},t=Math.max(3,Math.floor(t)),i=Math.max(2,Math.floor(i));const c=Math.min(o+l,Math.PI);let d=0;const g=[],p=new Oe,h=new Oe,v=[],y=[],w=[],S=[];for(let M=0;M<=i;M++){const T=[],C=M/i;let x=0;M===0&&o===0?x=.5/t:M===i&&c===Math.PI&&(x=-.5/t);for(let R=0;R<=t;R++){const P=R/t;p.x=-e*Math.cos(s+P*r)*Math.sin(o+C*l),p.y=e*Math.cos(o+C*l),p.z=e*Math.sin(s+P*r)*Math.sin(o+C*l),y.push(p.x,p.y,p.z),h.copy(p).normalize(),w.push(h.x,h.y,h.z),S.push(P+x,1-C),T.push(d++)}g.push(T)}for(let M=0;M<i;M++)for(let T=0;T<t;T++){const C=g[M][T+1],x=g[M][T],R=g[M+1][T],P=g[M+1][T+1];(M!==0||o>0)&&v.push(C,x,P),(M!==i-1||c<Math.PI)&&v.push(x,R,P)}this.setIndex(v),this.setAttribute("position",new Hn(y,3)),this.setAttribute("normal",new Hn(w,3)),this.setAttribute("uv",new Hn(S,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new y0(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class xx extends _m{constructor(e=1,t=0){const i=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],s=[2,1,0,0,3,2,1,3,0,2,3,1];super(i,s,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new xx(e.radius,e.detail)}}class wx extends xi{constructor(e=1,t=.4,i=12,s=48,r=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:i,tubularSegments:s,arc:r},i=Math.floor(i),s=Math.floor(s);const o=[],l=[],c=[],d=[],g=new Oe,p=new Oe,h=new Oe;for(let v=0;v<=i;v++)for(let y=0;y<=s;y++){const w=y/s*r,S=v/i*Math.PI*2;p.x=(e+t*Math.cos(S))*Math.cos(w),p.y=(e+t*Math.cos(S))*Math.sin(w),p.z=t*Math.sin(S),l.push(p.x,p.y,p.z),g.x=e*Math.cos(w),g.y=e*Math.sin(w),h.subVectors(p,g).normalize(),c.push(h.x,h.y,h.z),d.push(y/s),d.push(v/i)}for(let v=1;v<=i;v++)for(let y=1;y<=s;y++){const w=(s+1)*v+y-1,S=(s+1)*(v-1)+y-1,M=(s+1)*(v-1)+y,T=(s+1)*v+y;o.push(w,S,T),o.push(S,M,T)}this.setIndex(o),this.setAttribute("position",new Hn(l,3)),this.setAttribute("normal",new Hn(c,3)),this.setAttribute("uv",new Hn(d,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new wx(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class Ex extends xi{constructor(e=1,t=.4,i=64,s=8,r=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:i,radialSegments:s,p:r,q:o},i=Math.floor(i),s=Math.floor(s);const l=[],c=[],d=[],g=[],p=new Oe,h=new Oe,v=new Oe,y=new Oe,w=new Oe,S=new Oe,M=new Oe;for(let C=0;C<=i;++C){const x=C/i*r*Math.PI*2;T(x,r,o,e,v),T(x+.01,r,o,e,y),S.subVectors(y,v),M.addVectors(y,v),w.crossVectors(S,M),M.crossVectors(w,S),w.normalize(),M.normalize();for(let R=0;R<=s;++R){const P=R/s*Math.PI*2,D=-t*Math.cos(P),z=t*Math.sin(P);p.x=v.x+(D*M.x+z*w.x),p.y=v.y+(D*M.y+z*w.y),p.z=v.z+(D*M.z+z*w.z),c.push(p.x,p.y,p.z),h.subVectors(p,v).normalize(),d.push(h.x,h.y,h.z),g.push(C/i),g.push(R/s)}}for(let C=1;C<=i;C++)for(let x=1;x<=s;x++){const R=(s+1)*(C-1)+(x-1),P=(s+1)*C+(x-1),D=(s+1)*C+x,z=(s+1)*(C-1)+x;l.push(R,P,z),l.push(P,D,z)}this.setIndex(l),this.setAttribute("position",new Hn(c,3)),this.setAttribute("normal",new Hn(d,3)),this.setAttribute("uv",new Hn(g,2));function T(C,x,R,P,D){const z=Math.cos(C),U=Math.sin(C),N=R/x*C,j=Math.cos(N);D.x=P*(2+j)*.5*z,D.y=P*(2+j)*U*.5,D.z=P*Math.sin(N)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Ex(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class Tx extends xi{constructor(e=new FT(new Oe(-1,-1,0),new Oe(-1,1,0),new Oe(1,1,0)),t=64,i=1,s=8,r=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:i,radialSegments:s,closed:r};const o=e.computeFrenetFrames(t,r);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const l=new Oe,c=new Oe,d=new Gt;let g=new Oe;const p=[],h=[],v=[],y=[];w(),this.setIndex(y),this.setAttribute("position",new Hn(p,3)),this.setAttribute("normal",new Hn(h,3)),this.setAttribute("uv",new Hn(v,2));function w(){for(let C=0;C<t;C++)S(C);S(r===!1?t:0),T(),M()}function S(C){g=e.getPointAt(C/t,g);const x=o.normals[C],R=o.binormals[C];for(let P=0;P<=s;P++){const D=P/s*Math.PI*2,z=Math.sin(D),U=-Math.cos(D);c.x=U*x.x+z*R.x,c.y=U*x.y+z*R.y,c.z=U*x.z+z*R.z,c.normalize(),h.push(c.x,c.y,c.z),l.x=g.x+i*c.x,l.y=g.y+i*c.y,l.z=g.z+i*c.z,p.push(l.x,l.y,l.z)}}function M(){for(let C=1;C<=t;C++)for(let x=1;x<=s;x++){const R=(s+1)*(C-1)+(x-1),P=(s+1)*C+(x-1),D=(s+1)*C+x,z=(s+1)*(C-1)+x;y.push(R,P,z),y.push(P,D,z)}}function T(){for(let C=0;C<=t;C++)for(let x=0;x<=s;x++)d.x=C/t,d.y=x/s,v.push(d.x,d.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new Tx(new Rb[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class FI extends xi{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],i=new Set,s=new Oe,r=new Oe;if(e.index!==null){const o=e.attributes.position,l=e.index;let c=e.groups;c.length===0&&(c=[{start:0,count:l.count,materialIndex:0}]);for(let d=0,g=c.length;d<g;++d){const p=c[d],h=p.start,v=p.count;for(let y=h,w=h+v;y<w;y+=3)for(let S=0;S<3;S++){const M=l.getX(y+S),T=l.getX(y+(S+1)%3);s.fromBufferAttribute(o,M),r.fromBufferAttribute(o,T),nC(s,r,i)===!0&&(t.push(s.x,s.y,s.z),t.push(r.x,r.y,r.z))}}}else{const o=e.attributes.position;for(let l=0,c=o.count/3;l<c;l++)for(let d=0;d<3;d++){const g=3*l+d,p=3*l+(d+1)%3;s.fromBufferAttribute(o,g),r.fromBufferAttribute(o,p),nC(s,r,i)===!0&&(t.push(s.x,s.y,s.z),t.push(r.x,r.y,r.z))}}this.setAttribute("position",new Hn(t,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function nC(n,e,t){const i=`${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,s=`${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;return t.has(i)===!0||t.has(s)===!0?!1:(t.add(i),t.add(s),!0)}var iC=Object.freeze({__proto__:null,BoxGeometry:Zg,CapsuleGeometry:hx,CircleGeometry:px,ConeGeometry:Jv,CylinderGeometry:Yv,DodecahedronGeometry:mx,EdgesGeometry:DT,ExtrudeGeometry:_x,IcosahedronGeometry:vx,LatheGeometry:yx,OctahedronGeometry:Qv,PlaneGeometry:v0,PolyhedronGeometry:_m,RingGeometry:Mx,ShapeGeometry:bx,SphereGeometry:y0,TetrahedronGeometry:xx,TorusGeometry:wx,TorusKnotGeometry:Ex,TubeGeometry:Tx,WireframeGeometry:FI});class NI extends pa{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Sn(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class zI extends ja{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class M0 extends pa{constructor(e){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new Sn(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Sn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gm,this.normalScale=new Gt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ju,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Nc extends M0{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Gt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return mi(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Sn(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Sn(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Sn(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class UI extends pa{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Sn(16777215),this.specular=new Sn(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Sn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gm,this.normalScale=new Gt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ju,this.combine=$v,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class kI extends pa{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Sn(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Sn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gm,this.normalScale=new Gt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class zT extends pa{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gm,this.normalScale=new Gt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class GI extends pa{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Sn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Sn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gm,this.normalScale=new Gt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ju,this.combine=$v,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class UT extends pa{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=mm,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class kT extends pa{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}class VI extends pa{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Sn(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=gm,this.normalScale=new Gt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class HI extends Qo{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function Rg(n,e){return!n||n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)}function jI(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function $I(n){function e(s,r){return n[s]-n[r]}const t=n.length,i=new Array(t);for(let s=0;s!==t;++s)i[s]=s;return i.sort(e),i}function PE(n,e,t){const i=n.length,s=new n.constructor(i);for(let r=0,o=0;o!==i;++r){const l=t[r]*e;for(let c=0;c!==e;++c)s[o++]=n[l+c]}return s}function GT(n,e,t,i){let s=1,r=n[0];for(;r!==void 0&&r[i]===void 0;)r=n[s++];if(r===void 0)return;let o=r[i];if(o!==void 0)if(Array.isArray(o))do o=r[i],o!==void 0&&(e.push(r.time),t.push(...o)),r=n[s++];while(r!==void 0);else if(o.toArray!==void 0)do o=r[i],o!==void 0&&(e.push(r.time),o.toArray(t,t.length)),r=n[s++];while(r!==void 0);else do o=r[i],o!==void 0&&(e.push(r.time),t.push(o)),r=n[s++];while(r!==void 0)}function Lk(n,e,t,i,s=30){const r=n.clone();r.name=e;const o=[];for(let c=0;c<r.tracks.length;++c){const d=r.tracks[c],g=d.getValueSize(),p=[],h=[];for(let v=0;v<d.times.length;++v){const y=d.times[v]*s;if(!(y<t||y>=i)){p.push(d.times[v]);for(let w=0;w<g;++w)h.push(d.values[v*g+w])}}p.length!==0&&(d.times=Rg(p,d.times.constructor),d.values=Rg(h,d.values.constructor),o.push(d))}r.tracks=o;let l=1/0;for(let c=0;c<r.tracks.length;++c)l>r.tracks[c].times[0]&&(l=r.tracks[c].times[0]);for(let c=0;c<r.tracks.length;++c)r.tracks[c].shift(-1*l);return r.resetDuration(),r}function Fk(n,e=0,t=n,i=30){i<=0&&(i=30);const s=t.tracks.length,r=e/i;for(let o=0;o<s;++o){const l=t.tracks[o],c=l.ValueTypeName;if(c==="bool"||c==="string")continue;const d=n.tracks.find(function(M){return M.name===l.name&&M.ValueTypeName===c});if(d===void 0)continue;let g=0;const p=l.getValueSize();l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(g=p/3);let h=0;const v=d.getValueSize();d.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=v/3);const y=l.times.length-1;let w;if(r<=l.times[0]){const M=g,T=p-g;w=l.values.slice(M,T)}else if(r>=l.times[y]){const M=y*p+g,T=M+p-g;w=l.values.slice(M,T)}else{const M=l.createInterpolant(),T=g,C=p-g;M.evaluate(r),w=M.resultBuffer.slice(T,C)}c==="quaternion"&&new lo().fromArray(w).normalize().conjugate().toArray(w);const S=d.times.length;for(let M=0;M<S;++M){const T=M*v+h;if(c==="quaternion")lo.multiplyQuaternionsFlat(d.values,T,w,0,d.values,T);else{const C=v-h*2;for(let x=0;x<C;++x)d.values[T+x]-=w[x]}}}return n.blendMode=yT,n}class Nk{static convertArray(e,t){return Rg(e,t)}static isTypedArray(e){return jI(e)}static getKeyframeOrder(e){return $I(e)}static sortedArray(e,t,i){return PE(e,t,i)}static flattenJSON(e,t,i,s){GT(e,t,i,s)}static subclip(e,t,i,s,r=30){return Lk(e,t,i,s,r)}static makeClipAdditive(e,t=0,i=e,s=30){return Fk(e,t,i,s)}}class b0{constructor(e,t,i,s){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=s!==void 0?s:new t.constructor(i),this.sampleValues=t,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let i=this._cachedIndex,s=t[i],r=t[i-1];e:{t:{let o;n:{i:if(!(e<s)){for(let l=i+2;;){if(s===void 0){if(e<r)break i;return i=t.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===l)break;if(r=s,s=t[++i],e<s)break t}o=t.length;break n}if(!(e>=r)){const l=t[1];e<l&&(i=2,r=l);for(let c=i-2;;){if(r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===c)break;if(s=r,r=t[--i-1],e>=r)break t}o=i,i=0;break n}break e}for(;i<o;){const l=i+o>>>1;e<t[l]?o=l:i=l+1}if(s=t[i],r=t[i-1],r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===void 0)return i=t.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,r,s)}return this.interpolate_(i,r,e,s)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,s=this.valueSize,r=e*s;for(let o=0;o!==s;++o)t[o]=i[r+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class WI extends b0{constructor(e,t,i,s){super(e,t,i,s),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Cg,endingEnd:Cg}}intervalChanged_(e,t,i){const s=this.parameterPositions;let r=e-2,o=e+1,l=s[r],c=s[o];if(l===void 0)switch(this.getSettings_().endingStart){case Pg:r=e,l=2*t-i;break;case Bv:r=s.length-2,l=t+s[r]-s[r+1];break;default:r=e,l=i}if(c===void 0)switch(this.getSettings_().endingEnd){case Pg:o=e,c=2*i-t;break;case Bv:o=1,c=i+s[1]-s[0];break;default:o=e-1,c=t}const d=(i-t)*.5,g=this.valueSize;this._weightPrev=d/(t-l),this._weightNext=d/(c-i),this._offsetPrev=r*g,this._offsetNext=o*g}interpolate_(e,t,i,s){const r=this.resultBuffer,o=this.sampleValues,l=this.valueSize,c=e*l,d=c-l,g=this._offsetPrev,p=this._offsetNext,h=this._weightPrev,v=this._weightNext,y=(i-t)/(s-t),w=y*y,S=w*y,M=-h*S+2*h*w-h*y,T=(1+h)*S+(-1.5-2*h)*w+(-.5+h)*y+1,C=(-1-v)*S+(1.5+v)*w+.5*y,x=v*S-v*w;for(let R=0;R!==l;++R)r[R]=M*o[g+R]+T*o[d+R]+C*o[c+R]+x*o[p+R];return r}}class VT extends b0{constructor(e,t,i,s){super(e,t,i,s)}interpolate_(e,t,i,s){const r=this.resultBuffer,o=this.sampleValues,l=this.valueSize,c=e*l,d=c-l,g=(i-t)/(s-t),p=1-g;for(let h=0;h!==l;++h)r[h]=o[d+h]*p+o[c+h]*g;return r}}class KI extends b0{constructor(e,t,i,s){super(e,t,i,s)}interpolate_(e){return this.copySampleValue_(e-1)}}class zc{constructor(e,t,i,s){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Rg(t,this.TimeBufferType),this.values=Rg(i,this.ValueBufferType),this.setInterpolation(s||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let i;if(t.toJSON!==this.toJSON)i=t.toJSON(e);else{i={name:e.name,times:Rg(e.times,Array),values:Rg(e.values,Array)};const s=e.getInterpolation();s!==e.DefaultInterpolation&&(i.interpolation=s)}return i.type=e.ValueTypeName,i}InterpolantFactoryMethodDiscrete(e){return new KI(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new VT(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new WI(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case s0:t=this.InterpolantFactoryMethodDiscrete;break;case r0:t=this.InterpolantFactoryMethodLinear;break;case UM:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(i);return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return s0;case this.InterpolantFactoryMethodLinear:return r0;case this.InterpolantFactoryMethodSmooth:return UM}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let i=0,s=t.length;i!==s;++i)t[i]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let i=0,s=t.length;i!==s;++i)t[i]*=e}return this}trim(e,t){const i=this.times,s=i.length;let r=0,o=s-1;for(;r!==s&&i[r]<e;)++r;for(;o!==-1&&i[o]>t;)--o;if(++o,r!==0||o!==s){r>=o&&(o=Math.max(o,1),r=o-1);const l=this.getValueSize();this.times=i.slice(r,o),this.values=this.values.slice(r*l,o*l)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const i=this.times,s=this.values,r=i.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let l=0;l!==r;l++){const c=i[l];if(typeof c=="number"&&isNaN(c)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,l,c),e=!1;break}if(o!==null&&o>c){console.error("THREE.KeyframeTrack: Out of order keys.",this,l,c,o),e=!1;break}o=c}if(s!==void 0&&jI(s))for(let l=0,c=s.length;l!==c;++l){const d=s[l];if(isNaN(d)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,l,d),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),i=this.getValueSize(),s=this.getInterpolation()===UM,r=e.length-1;let o=1;for(let l=1;l<r;++l){let c=!1;const d=e[l],g=e[l+1];if(d!==g&&(l!==1||d!==e[0]))if(s)c=!0;else{const p=l*i,h=p-i,v=p+i;for(let y=0;y!==i;++y){const w=t[p+y];if(w!==t[h+y]||w!==t[v+y]){c=!0;break}}}if(c){if(l!==o){e[o]=e[l];const p=l*i,h=o*i;for(let v=0;v!==i;++v)t[h+v]=t[p+v]}++o}}if(r>0){e[o]=e[r];for(let l=r*i,c=o*i,d=0;d!==i;++d)t[c+d]=t[l+d];++o}return o!==e.length?(this.times=e.slice(0,o),this.values=t.slice(0,o*i)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),i=this.constructor,s=new i(this.name,e,t);return s.createInterpolant=this.createInterpolant,s}}zc.prototype.ValueTypeName="";zc.prototype.TimeBufferType=Float32Array;zc.prototype.ValueBufferType=Float32Array;zc.prototype.DefaultInterpolation=r0;class e_ extends zc{constructor(e,t,i){super(e,t,i)}}e_.prototype.ValueTypeName="bool";e_.prototype.ValueBufferType=Array;e_.prototype.DefaultInterpolation=s0;e_.prototype.InterpolantFactoryMethodLinear=void 0;e_.prototype.InterpolantFactoryMethodSmooth=void 0;class HT extends zc{constructor(e,t,i,s){super(e,t,i,s)}}HT.prototype.ValueTypeName="color";class Hg extends zc{constructor(e,t,i,s){super(e,t,i,s)}}Hg.prototype.ValueTypeName="number";class qI extends b0{constructor(e,t,i,s){super(e,t,i,s)}interpolate_(e,t,i,s){const r=this.resultBuffer,o=this.sampleValues,l=this.valueSize,c=(i-t)/(s-t);let d=e*l;for(let g=d+l;d!==g;d+=4)lo.slerpFlat(r,0,o,d-l,o,d,c);return r}}class jg extends zc{constructor(e,t,i,s){super(e,t,i,s)}InterpolantFactoryMethodLinear(e){return new qI(this.times,this.values,this.getValueSize(),e)}}jg.prototype.ValueTypeName="quaternion";jg.prototype.InterpolantFactoryMethodSmooth=void 0;class t_ extends zc{constructor(e,t,i){super(e,t,i)}}t_.prototype.ValueTypeName="string";t_.prototype.ValueBufferType=Array;t_.prototype.DefaultInterpolation=s0;t_.prototype.InterpolantFactoryMethodLinear=void 0;t_.prototype.InterpolantFactoryMethodSmooth=void 0;class $g extends zc{constructor(e,t,i,s){super(e,t,i,s)}}$g.prototype.ValueTypeName="vector";class d0{constructor(e="",t=-1,i=[],s=nx){this.name=e,this.tracks=i,this.duration=t,this.blendMode=s,this.uuid=Xu(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],i=e.tracks,s=1/(e.fps||1);for(let o=0,l=i.length;o!==l;++o)t.push(Uk(i[o]).scale(s));const r=new this(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r}static toJSON(e){const t=[],i=e.tracks,s={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,o=i.length;r!==o;++r)t.push(zc.toJSON(i[r]));return s}static CreateFromMorphTargetSequence(e,t,i,s){const r=t.length,o=[];for(let l=0;l<r;l++){let c=[],d=[];c.push((l+r-1)%r,l,(l+1)%r),d.push(0,1,0);const g=$I(c);c=PE(c,1,g),d=PE(d,1,g),!s&&c[0]===0&&(c.push(r),d.push(d[0])),o.push(new Hg(".morphTargetInfluences["+t[l].name+"]",c,d).scale(1/i))}return new this(e,-1,o)}static findByName(e,t){let i=e;if(!Array.isArray(e)){const s=e;i=s.geometry&&s.geometry.animations||s.animations}for(let s=0;s<i.length;s++)if(i[s].name===t)return i[s];return null}static CreateClipsFromMorphTargetSequences(e,t,i){const s={},r=/^([\w-]*?)([\d]+)$/;for(let l=0,c=e.length;l<c;l++){const d=e[l],g=d.name.match(r);if(g&&g.length>1){const p=g[1];let h=s[p];h||(s[p]=h=[]),h.push(d)}}const o=[];for(const l in s)o.push(this.CreateFromMorphTargetSequence(l,s[l],t,i));return o}static parseAnimation(e,t){if(console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"),!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(p,h,v,y,w){if(v.length!==0){const S=[],M=[];GT(v,S,M,y),S.length!==0&&w.push(new p(h,S,M))}},s=[],r=e.name||"default",o=e.fps||30,l=e.blendMode;let c=e.length||-1;const d=e.hierarchy||[];for(let p=0;p<d.length;p++){const h=d[p].keys;if(!(!h||h.length===0))if(h[0].morphTargets){const v={};let y;for(y=0;y<h.length;y++)if(h[y].morphTargets)for(let w=0;w<h[y].morphTargets.length;w++)v[h[y].morphTargets[w]]=-1;for(const w in v){const S=[],M=[];for(let T=0;T!==h[y].morphTargets.length;++T){const C=h[y];S.push(C.time),M.push(C.morphTarget===w?1:0)}s.push(new Hg(".morphTargetInfluence["+w+"]",S,M))}c=v.length*o}else{const v=".bones["+t[p].name+"]";i($g,v+".position",h,"pos",s),i(jg,v+".quaternion",h,"rot",s),i($g,v+".scale",h,"scl",s)}}return s.length===0?null:new this(r,c,s,l)}resetDuration(){const e=this.tracks;let t=0;for(let i=0,s=e.length;i!==s;++i){const r=this.tracks[i];t=Math.max(t,r.times[r.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function zk(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Hg;case"vector":case"vector2":case"vector3":case"vector4":return $g;case"color":return HT;case"quaternion":return jg;case"bool":case"boolean":return e_;case"string":return t_}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function Uk(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=zk(n.type);if(n.times===void 0){const t=[],i=[];GT(n.keys,t,i,"value"),n.times=t,n.values=i}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}const zf={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class jT{constructor(e,t,i){const s=this;let r=!1,o=0,l=0,c;const d=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=i,this.abortController=new AbortController,this.itemStart=function(g){l++,r===!1&&s.onStart!==void 0&&s.onStart(g,o,l),r=!0},this.itemEnd=function(g){o++,s.onProgress!==void 0&&s.onProgress(g,o,l),o===l&&(r=!1,s.onLoad!==void 0&&s.onLoad())},this.itemError=function(g){s.onError!==void 0&&s.onError(g)},this.resolveURL=function(g){return c?c(g):g},this.setURLModifier=function(g){return c=g,this},this.addHandler=function(g,p){return d.push(g,p),this},this.removeHandler=function(g){const p=d.indexOf(g);return p!==-1&&d.splice(p,2),this},this.getHandler=function(g){for(let p=0,h=d.length;p<h;p+=2){const v=d[p],y=d[p+1];if(v.global&&(v.lastIndex=0),v.test(g))return y}return null},this.abort=function(){return this.abortController.abort(),this.abortController=new AbortController,this}}}const XI=new jT;class Zo{constructor(e){this.manager=e!==void 0?e:XI,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const i=this;return new Promise(function(s,r){i.load(e,s,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}abort(){return this}}Zo.DEFAULT_MATERIAL_NAME="__DEFAULT";const Fh={};class kk extends Error{constructor(e,t){super(e),this.response=t}}class Qu extends Zo{constructor(e){super(e),this.mimeType="",this.responseType="",this._abortController=new AbortController}load(e,t,i,s){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=zf.get(`file:${e}`);if(r!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(r),this.manager.itemEnd(e)},0),r;if(Fh[e]!==void 0){Fh[e].push({onLoad:t,onProgress:i,onError:s});return}Fh[e]=[],Fh[e].push({onLoad:t,onProgress:i,onError:s});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin",signal:typeof AbortSignal.any=="function"?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal}),l=this.mimeType,c=this.responseType;fetch(o).then(d=>{if(d.status===200||d.status===0){if(d.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||d.body===void 0||d.body.getReader===void 0)return d;const g=Fh[e],p=d.body.getReader(),h=d.headers.get("X-File-Size")||d.headers.get("Content-Length"),v=h?parseInt(h):0,y=v!==0;let w=0;const S=new ReadableStream({start(M){T();function T(){p.read().then(({done:C,value:x})=>{if(C)M.close();else{w+=x.byteLength;const R=new ProgressEvent("progress",{lengthComputable:y,loaded:w,total:v});for(let P=0,D=g.length;P<D;P++){const z=g[P];z.onProgress&&z.onProgress(R)}M.enqueue(x),T()}},C=>{M.error(C)})}}});return new Response(S)}else throw new kk(`fetch for "${d.url}" responded with ${d.status}: ${d.statusText}`,d)}).then(d=>{switch(c){case"arraybuffer":return d.arrayBuffer();case"blob":return d.blob();case"document":return d.text().then(g=>new DOMParser().parseFromString(g,l));case"json":return d.json();default:if(l==="")return d.text();{const p=/charset="?([^;"\s]*)"?/i.exec(l),h=p&&p[1]?p[1].toLowerCase():void 0,v=new TextDecoder(h);return d.arrayBuffer().then(y=>v.decode(y))}}}).then(d=>{zf.add(`file:${e}`,d);const g=Fh[e];delete Fh[e];for(let p=0,h=g.length;p<h;p++){const v=g[p];v.onLoad&&v.onLoad(d)}}).catch(d=>{const g=Fh[e];if(g===void 0)throw this.manager.itemError(e),d;delete Fh[e];for(let p=0,h=g.length;p<h;p++){const v=g[p];v.onError&&v.onError(d)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}class Gk extends Zo{constructor(e){super(e)}load(e,t,i,s){const r=this,o=new Qu(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(l){try{t(r.parse(JSON.parse(l)))}catch(c){s?s(c):console.error(c),r.manager.itemError(e)}},i,s)}parse(e){const t=[];for(let i=0;i<e.length;i++){const s=d0.parse(e[i]);t.push(s)}return t}}class Vk extends Zo{constructor(e){super(e)}load(e,t,i,s){const r=this,o=[],l=new dx,c=new Qu(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(r.withCredentials);let d=0;function g(p){c.load(e[p],function(h){const v=r.parse(h,!0);o[p]={width:v.width,height:v.height,format:v.format,mipmaps:v.mipmaps},d+=1,d===6&&(v.mipmapCount===1&&(l.minFilter=Tr),l.image=o,l.format=v.format,l.needsUpdate=!0,t&&t(l))},i,s)}if(Array.isArray(e))for(let p=0,h=e.length;p<h;++p)g(p);else c.load(e,function(p){const h=r.parse(p,!0);if(h.isCubemap){const v=h.mipmaps.length/h.mipmapCount;for(let y=0;y<v;y++){o[y]={mipmaps:[]};for(let w=0;w<h.mipmapCount;w++)o[y].mipmaps.push(h.mipmaps[y*h.mipmapCount+w]),o[y].format=h.format,o[y].width=h.width,o[y].height=h.height}l.image=o}else l.image.width=h.width,l.image.height=h.height,l.mipmaps=h.mipmaps;h.mipmapCount===1&&(l.minFilter=Tr),l.format=h.format,l.needsUpdate=!0,t&&t(l)},i,s);return l}}const N_=new WeakMap;class kv extends Zo{constructor(e){super(e)}load(e,t,i,s){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,o=zf.get(`image:${e}`);if(o!==void 0){if(o.complete===!0)r.manager.itemStart(e),setTimeout(function(){t&&t(o),r.manager.itemEnd(e)},0);else{let p=N_.get(o);p===void 0&&(p=[],N_.set(o,p)),p.push({onLoad:t,onError:s})}return o}const l=Lv("img");function c(){g(),t&&t(this);const p=N_.get(this)||[];for(let h=0;h<p.length;h++){const v=p[h];v.onLoad&&v.onLoad(this)}N_.delete(this),r.manager.itemEnd(e)}function d(p){g(),s&&s(p),zf.remove(`image:${e}`);const h=N_.get(this)||[];for(let v=0;v<h.length;v++){const y=h[v];y.onError&&y.onError(p)}N_.delete(this),r.manager.itemError(e),r.manager.itemEnd(e)}function g(){l.removeEventListener("load",c,!1),l.removeEventListener("error",d,!1)}return l.addEventListener("load",c,!1),l.addEventListener("error",d,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(l.crossOrigin=this.crossOrigin),zf.add(`image:${e}`,l),r.manager.itemStart(e),l.src=e,l}}class Hk extends Zo{constructor(e){super(e)}load(e,t,i,s){const r=new Kv;r.colorSpace=Rs;const o=new kv(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let l=0;function c(d){o.load(e[d],function(g){r.images[d]=g,l++,l===6&&(r.needsUpdate=!0,t&&t(r))},void 0,s)}for(let d=0;d<e.length;++d)c(d);return r}}class jk extends Zo{constructor(e){super(e)}load(e,t,i,s){const r=this,o=new Uf,l=new Qu(this.manager);return l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setPath(this.path),l.setWithCredentials(r.withCredentials),l.load(e,function(c){let d;try{d=r.parse(c)}catch(g){if(s!==void 0)s(g);else{console.error(g);return}}d.image!==void 0?o.image=d.image:d.data!==void 0&&(o.image.width=d.width,o.image.height=d.height,o.image.data=d.data),o.wrapS=d.wrapS!==void 0?d.wrapS:Wu,o.wrapT=d.wrapT!==void 0?d.wrapT:Wu,o.magFilter=d.magFilter!==void 0?d.magFilter:Tr,o.minFilter=d.minFilter!==void 0?d.minFilter:Tr,o.anisotropy=d.anisotropy!==void 0?d.anisotropy:1,d.colorSpace!==void 0&&(o.colorSpace=d.colorSpace),d.flipY!==void 0&&(o.flipY=d.flipY),d.format!==void 0&&(o.format=d.format),d.type!==void 0&&(o.type=d.type),d.mipmaps!==void 0&&(o.mipmaps=d.mipmaps,o.minFilter=Oc),d.mipmapCount===1&&(o.minFilter=Tr),d.generateMipmaps!==void 0&&(o.generateMipmaps=d.generateMipmaps),o.needsUpdate=!0,t&&t(o,d)},i,s),o}}class YI extends Zo{constructor(e){super(e)}load(e,t,i,s){const r=new vr,o=new kv(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(l){r.image=l,r.needsUpdate=!0,t!==void 0&&t(r)},i,s),r}}class vm extends fs{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new Sn(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(t.object.target=this.target.uuid),t}}class JI extends vm{constructor(e,t,i){super(e,i),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(fs.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Sn(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const Iw=new li,sC=new Oe,rC=new Oe;class $T{constructor(e){this.camera=e,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Gt(512,512),this.mapType=Ha,this.map=null,this.mapPass=null,this.matrix=new li,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new _0,this._frameExtents=new Gt(1,1),this._viewportCount=1,this._viewports=[new ds(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,i=this.matrix;sC.setFromMatrixPosition(e.matrixWorld),t.position.copy(sC),rC.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(rC),t.updateMatrixWorld(),Iw.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Iw,t.coordinateSystem,t.reversedDepth),t.reversedDepth?i.set(.5,0,0,.5,0,.5,0,.5,0,0,1,0,0,0,0,1):i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(Iw)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.intensity=e.intensity,this.bias=e.bias,this.radius=e.radius,this.autoUpdate=e.autoUpdate,this.needsUpdate=e.needsUpdate,this.normalBias=e.normalBias,this.blurSamples=e.blurSamples,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.intensity!==1&&(e.intensity=this.intensity),this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class $k extends $T{constructor(){super(new Er(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.aspect=1}updateMatrices(e){const t=this.camera,i=o0*2*e.angle*this.focus,s=this.mapSize.width/this.mapSize.height*this.aspect,r=e.distance||t.far;(i!==t.fov||s!==t.aspect||r!==t.far)&&(t.fov=i,t.aspect=s,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class WT extends vm{constructor(e,t,i=0,s=Math.PI/3,r=0,o=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(fs.DEFAULT_UP),this.updateMatrix(),this.target=new fs,this.distance=i,this.angle=s,this.penumbra=r,this.decay=o,this.map=null,this.shadow=new $k}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const aC=new li,J0=new Oe,Ow=new Oe;class Wk extends $T{constructor(){super(new Er(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Gt(4,2),this._viewportCount=6,this._viewports=[new ds(2,1,1,1),new ds(0,1,1,1),new ds(3,1,1,1),new ds(1,1,1,1),new ds(3,0,1,1),new ds(1,0,1,1)],this._cubeDirections=[new Oe(1,0,0),new Oe(-1,0,0),new Oe(0,0,1),new Oe(0,0,-1),new Oe(0,1,0),new Oe(0,-1,0)],this._cubeUps=[new Oe(0,1,0),new Oe(0,1,0),new Oe(0,1,0),new Oe(0,1,0),new Oe(0,0,1),new Oe(0,0,-1)]}updateMatrices(e,t=0){const i=this.camera,s=this.matrix,r=e.distance||i.far;r!==i.far&&(i.far=r,i.updateProjectionMatrix()),J0.setFromMatrixPosition(e.matrixWorld),i.position.copy(J0),Ow.copy(i.position),Ow.add(this._cubeDirections[t]),i.up.copy(this._cubeUps[t]),i.lookAt(Ow),i.updateMatrixWorld(),s.makeTranslation(-J0.x,-J0.y,-J0.z),aC.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(aC,i.coordinateSystem,i.reversedDepth)}}class KT extends vm{constructor(e,t,i=0,s=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=s,this.shadow=new Wk}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class Lc extends rx{constructor(e=-1,t=1,i=1,s=-1,r=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=i,this.bottom=s,this.near=r,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,i,s,r,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=s,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,s=(this.top+this.bottom)/2;let r=i-e,o=i+e,l=s+t,c=s-t;if(this.view!==null&&this.view.enabled){const d=(this.right-this.left)/this.view.fullWidth/this.zoom,g=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=d*this.view.offsetX,o=r+d*this.view.width,l-=g*this.view.offsetY,c=l-g*this.view.height}this.projectionMatrix.makeOrthographic(r,o,l,c,this.near,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}class Kk extends $T{constructor(){super(new Lc(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class qT extends vm{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(fs.DEFAULT_UP),this.updateMatrix(),this.target=new fs,this.shadow=new Kk}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class QI extends vm{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class ZI extends vm{constructor(e,t,i=10,s=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=i,this.height=s}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class eO{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Oe)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const i=e.x,s=e.y,r=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*s),t.addScaledVector(o[2],.488603*r),t.addScaledVector(o[3],.488603*i),t.addScaledVector(o[4],1.092548*(i*s)),t.addScaledVector(o[5],1.092548*(s*r)),t.addScaledVector(o[6],.315392*(3*r*r-1)),t.addScaledVector(o[7],1.092548*(i*r)),t.addScaledVector(o[8],.546274*(i*i-s*s)),t}getIrradianceAt(e,t){const i=e.x,s=e.y,r=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*s),t.addScaledVector(o[2],2*.511664*r),t.addScaledVector(o[3],2*.511664*i),t.addScaledVector(o[4],2*.429043*i*s),t.addScaledVector(o[5],2*.429043*s*r),t.addScaledVector(o[6],.743125*r*r-.247708),t.addScaledVector(o[7],2*.429043*i*r),t.addScaledVector(o[8],.429043*(i*i-s*s)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(e.coefficients[i],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let i=0;i<9;i++)this.coefficients[i].lerp(e.coefficients[i],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const i=this.coefficients;for(let s=0;s<9;s++)i[s].fromArray(e,t+s*3);return this}toArray(e=[],t=0){const i=this.coefficients;for(let s=0;s<9;s++)i[s].toArray(e,t+s*3);return e}static getBasisAt(e,t){const i=e.x,s=e.y,r=e.z;t[0]=.282095,t[1]=.488603*s,t[2]=.488603*r,t[3]=.488603*i,t[4]=1.092548*i*s,t[5]=1.092548*s*r,t[6]=.315392*(3*r*r-1),t[7]=1.092548*i*r,t[8]=.546274*(i*i-s*s)}}class tO extends vm{constructor(e=new eO,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class Sx extends Zo{constructor(e){super(e),this.textures={}}load(e,t,i,s){const r=this,o=new Qu(r.manager);o.setPath(r.path),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(l){try{t(r.parse(JSON.parse(l)))}catch(c){s?s(c):console.error(c),r.manager.itemError(e)}},i,s)}parse(e){const t=this.textures;function i(r){return t[r]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",r),t[r]}const s=this.createMaterialFromType(e.type);if(e.uuid!==void 0&&(s.uuid=e.uuid),e.name!==void 0&&(s.name=e.name),e.color!==void 0&&s.color!==void 0&&s.color.setHex(e.color),e.roughness!==void 0&&(s.roughness=e.roughness),e.metalness!==void 0&&(s.metalness=e.metalness),e.sheen!==void 0&&(s.sheen=e.sheen),e.sheenColor!==void 0&&(s.sheenColor=new Sn().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(s.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&s.emissive!==void 0&&s.emissive.setHex(e.emissive),e.specular!==void 0&&s.specular!==void 0&&s.specular.setHex(e.specular),e.specularIntensity!==void 0&&(s.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&s.specularColor!==void 0&&s.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(s.shininess=e.shininess),e.clearcoat!==void 0&&(s.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=e.clearcoatRoughness),e.dispersion!==void 0&&(s.dispersion=e.dispersion),e.iridescence!==void 0&&(s.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(s.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(s.transmission=e.transmission),e.thickness!==void 0&&(s.thickness=e.thickness),e.attenuationDistance!==void 0&&(s.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&s.attenuationColor!==void 0&&s.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(s.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(s.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(s.fog=e.fog),e.flatShading!==void 0&&(s.flatShading=e.flatShading),e.blending!==void 0&&(s.blending=e.blending),e.combine!==void 0&&(s.combine=e.combine),e.side!==void 0&&(s.side=e.side),e.shadowSide!==void 0&&(s.shadowSide=e.shadowSide),e.opacity!==void 0&&(s.opacity=e.opacity),e.transparent!==void 0&&(s.transparent=e.transparent),e.alphaTest!==void 0&&(s.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(s.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(s.depthFunc=e.depthFunc),e.depthTest!==void 0&&(s.depthTest=e.depthTest),e.depthWrite!==void 0&&(s.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(s.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(s.blendSrc=e.blendSrc),e.blendDst!==void 0&&(s.blendDst=e.blendDst),e.blendEquation!==void 0&&(s.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(s.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(s.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(s.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&s.blendColor!==void 0&&s.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(s.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(s.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(s.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(s.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(s.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(s.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(s.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(s.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(s.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(s.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(s.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(s.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(s.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(s.rotation=e.rotation),e.linewidth!==void 0&&(s.linewidth=e.linewidth),e.dashSize!==void 0&&(s.dashSize=e.dashSize),e.gapSize!==void 0&&(s.gapSize=e.gapSize),e.scale!==void 0&&(s.scale=e.scale),e.polygonOffset!==void 0&&(s.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(s.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(s.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(s.dithering=e.dithering),e.alphaToCoverage!==void 0&&(s.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(s.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(s.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(s.visible=e.visible),e.toneMapped!==void 0&&(s.toneMapped=e.toneMapped),e.userData!==void 0&&(s.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?s.vertexColors=e.vertexColors>0:s.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const r in e.uniforms){const o=e.uniforms[r];switch(s.uniforms[r]={},o.type){case"t":s.uniforms[r].value=i(o.value);break;case"c":s.uniforms[r].value=new Sn().setHex(o.value);break;case"v2":s.uniforms[r].value=new Gt().fromArray(o.value);break;case"v3":s.uniforms[r].value=new Oe().fromArray(o.value);break;case"v4":s.uniforms[r].value=new ds().fromArray(o.value);break;case"m3":s.uniforms[r].value=new Ai().fromArray(o.value);break;case"m4":s.uniforms[r].value=new li().fromArray(o.value);break;default:s.uniforms[r].value=o.value}}if(e.defines!==void 0&&(s.defines=e.defines),e.vertexShader!==void 0&&(s.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(s.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(s.glslVersion=e.glslVersion),e.extensions!==void 0)for(const r in e.extensions)s.extensions[r]=e.extensions[r];if(e.lights!==void 0&&(s.lights=e.lights),e.clipping!==void 0&&(s.clipping=e.clipping),e.size!==void 0&&(s.size=e.size),e.sizeAttenuation!==void 0&&(s.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(s.map=i(e.map)),e.matcap!==void 0&&(s.matcap=i(e.matcap)),e.alphaMap!==void 0&&(s.alphaMap=i(e.alphaMap)),e.bumpMap!==void 0&&(s.bumpMap=i(e.bumpMap)),e.bumpScale!==void 0&&(s.bumpScale=e.bumpScale),e.normalMap!==void 0&&(s.normalMap=i(e.normalMap)),e.normalMapType!==void 0&&(s.normalMapType=e.normalMapType),e.normalScale!==void 0){let r=e.normalScale;Array.isArray(r)===!1&&(r=[r,r]),s.normalScale=new Gt().fromArray(r)}return e.displacementMap!==void 0&&(s.displacementMap=i(e.displacementMap)),e.displacementScale!==void 0&&(s.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(s.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(s.roughnessMap=i(e.roughnessMap)),e.metalnessMap!==void 0&&(s.metalnessMap=i(e.metalnessMap)),e.emissiveMap!==void 0&&(s.emissiveMap=i(e.emissiveMap)),e.emissiveIntensity!==void 0&&(s.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(s.specularMap=i(e.specularMap)),e.specularIntensityMap!==void 0&&(s.specularIntensityMap=i(e.specularIntensityMap)),e.specularColorMap!==void 0&&(s.specularColorMap=i(e.specularColorMap)),e.envMap!==void 0&&(s.envMap=i(e.envMap)),e.envMapRotation!==void 0&&s.envMapRotation.fromArray(e.envMapRotation),e.envMapIntensity!==void 0&&(s.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(s.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(s.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(s.lightMap=i(e.lightMap)),e.lightMapIntensity!==void 0&&(s.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(s.aoMap=i(e.aoMap)),e.aoMapIntensity!==void 0&&(s.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(s.gradientMap=i(e.gradientMap)),e.clearcoatMap!==void 0&&(s.clearcoatMap=i(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(s.clearcoatRoughnessMap=i(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(s.clearcoatNormalMap=i(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(s.clearcoatNormalScale=new Gt().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(s.iridescenceMap=i(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(s.iridescenceThicknessMap=i(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(s.transmissionMap=i(e.transmissionMap)),e.thicknessMap!==void 0&&(s.thicknessMap=i(e.thicknessMap)),e.anisotropyMap!==void 0&&(s.anisotropyMap=i(e.anisotropyMap)),e.sheenColorMap!==void 0&&(s.sheenColorMap=i(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(s.sheenRoughnessMap=i(e.sheenRoughnessMap)),s}setTextures(e){return this.textures=e,this}createMaterialFromType(e){return Sx.createMaterialFromType(e)}static createMaterialFromType(e){const t={ShadowMaterial:NI,SpriteMaterial:ST,RawShaderMaterial:zI,ShaderMaterial:ja,PointsMaterial:cx,MeshPhysicalMaterial:Nc,MeshStandardMaterial:M0,MeshPhongMaterial:UI,MeshToonMaterial:kI,MeshNormalMaterial:zT,MeshLambertMaterial:GI,MeshDepthMaterial:UT,MeshDistanceMaterial:kT,MeshBasicMaterial:qu,MeshMatcapMaterial:VI,LineDashedMaterial:HI,LineBasicMaterial:Qo,Material:pa};return new t[e]}}class cm{static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class nO extends xi{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class iO extends Zo{constructor(e){super(e)}load(e,t,i,s){const r=this,o=new Qu(r.manager);o.setPath(r.path),o.setRequestHeader(r.requestHeader),o.setWithCredentials(r.withCredentials),o.load(e,function(l){try{t(r.parse(JSON.parse(l)))}catch(c){s?s(c):console.error(c),r.manager.itemError(e)}},i,s)}parse(e){const t={},i={};function s(v,y){if(t[y]!==void 0)return t[y];const S=v.interleavedBuffers[y],M=r(v,S.buffer),T=K_(S.type,M),C=new qv(T,S.stride);return C.uuid=S.uuid,t[y]=C,C}function r(v,y){if(i[y]!==void 0)return i[y];const S=v.arrayBuffers[y],M=new Uint32Array(S).buffer;return i[y]=M,M}const o=e.isInstancedBufferGeometry?new nO:new xi,l=e.data.index;if(l!==void 0){const v=K_(l.type,l.array);o.setIndex(new hs(v,1))}const c=e.data.attributes;for(const v in c){const y=c[v];let w;if(y.isInterleavedBufferAttribute){const S=s(e.data,y.data);w=new hm(S,y.itemSize,y.offset,y.normalized)}else{const S=K_(y.type,y.array),M=y.isInstancedBufferAttribute?Gg:hs;w=new M(S,y.itemSize,y.normalized)}y.name!==void 0&&(w.name=y.name),y.usage!==void 0&&w.setUsage(y.usage),o.setAttribute(v,w)}const d=e.data.morphAttributes;if(d)for(const v in d){const y=d[v],w=[];for(let S=0,M=y.length;S<M;S++){const T=y[S];let C;if(T.isInterleavedBufferAttribute){const x=s(e.data,T.data);C=new hm(x,T.itemSize,T.offset,T.normalized)}else{const x=K_(T.type,T.array);C=new hs(x,T.itemSize,T.normalized)}T.name!==void 0&&(C.name=T.name),w.push(C)}o.morphAttributes[v]=w}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const p=e.data.groups||e.data.drawcalls||e.data.offsets;if(p!==void 0)for(let v=0,y=p.length;v!==y;++v){const w=p[v];o.addGroup(w.start,w.count,w.materialIndex)}const h=e.data.boundingSphere;return h!==void 0&&(o.boundingSphere=new uo().fromJSON(h)),e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}}class qk extends Zo{constructor(e){super(e)}load(e,t,i,s){const r=this,o=this.path===""?cm.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const l=new Qu(this.manager);l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(c){let d=null;try{d=JSON.parse(c)}catch(p){s!==void 0&&s(p),console.error("THREE:ObjectLoader: Can't parse "+e+".",p.message);return}const g=d.metadata;if(g===void 0||g.type===void 0||g.type.toLowerCase()==="geometry"){s!==void 0&&s(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}r.parse(d,t)},i,s)}async loadAsync(e,t){const i=this,s=this.path===""?cm.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||s;const r=new Qu(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const o=await r.loadAsync(e,t),l=JSON.parse(o),c=l.metadata;if(c===void 0||c.type===void 0||c.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await i.parseAsync(l)}parse(e,t){const i=this.parseAnimations(e.animations),s=this.parseShapes(e.shapes),r=this.parseGeometries(e.geometries,s),o=this.parseImages(e.images,function(){t!==void 0&&t(d)}),l=this.parseTextures(e.textures,o),c=this.parseMaterials(e.materials,l),d=this.parseObject(e.object,r,c,l,i),g=this.parseSkeletons(e.skeletons,d);if(this.bindSkeletons(d,g),this.bindLightTargets(d),t!==void 0){let p=!1;for(const h in o)if(o[h].data instanceof HTMLImageElement){p=!0;break}p===!1&&t(d)}return d}async parseAsync(e){const t=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),s=this.parseGeometries(e.geometries,i),r=await this.parseImagesAsync(e.images),o=this.parseTextures(e.textures,r),l=this.parseMaterials(e.materials,o),c=this.parseObject(e.object,s,l,o,t),d=this.parseSkeletons(e.skeletons,c);return this.bindSkeletons(c,d),this.bindLightTargets(c),c}parseShapes(e){const t={};if(e!==void 0)for(let i=0,s=e.length;i<s;i++){const r=new Fg().fromJSON(e[i]);t[r.uuid]=r}return t}parseSkeletons(e,t){const i={},s={};if(t.traverse(function(r){r.isBone&&(s[r.uuid]=r)}),e!==void 0)for(let r=0,o=e.length;r<o;r++){const l=new Xv().fromJSON(e[r],s);i[l.uuid]=l}return i}parseGeometries(e,t){const i={};if(e!==void 0){const s=new iO;for(let r=0,o=e.length;r<o;r++){let l;const c=e[r];switch(c.type){case"BufferGeometry":case"InstancedBufferGeometry":l=s.parse(c);break;default:c.type in iC?l=iC[c.type].fromJSON(c,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${c.type}"`)}l.uuid=c.uuid,c.name!==void 0&&(l.name=c.name),c.userData!==void 0&&(l.userData=c.userData),i[c.uuid]=l}}return i}parseMaterials(e,t){const i={},s={};if(e!==void 0){const r=new Sx;r.setTextures(t);for(let o=0,l=e.length;o<l;o++){const c=e[o];i[c.uuid]===void 0&&(i[c.uuid]=r.parse(c)),s[c.uuid]=i[c.uuid]}}return s}parseAnimations(e){const t={};if(e!==void 0)for(let i=0;i<e.length;i++){const s=e[i],r=d0.parse(s);t[r.uuid]=r}return t}parseImages(e,t){const i=this,s={};let r;function o(c){return i.manager.itemStart(c),r.load(c,function(){i.manager.itemEnd(c)},void 0,function(){i.manager.itemError(c),i.manager.itemEnd(c)})}function l(c){if(typeof c=="string"){const d=c,g=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(d)?d:i.resourcePath+d;return o(g)}else return c.data?{data:K_(c.type,c.data),width:c.width,height:c.height}:null}if(e!==void 0&&e.length>0){const c=new jT(t);r=new kv(c),r.setCrossOrigin(this.crossOrigin);for(let d=0,g=e.length;d<g;d++){const p=e[d],h=p.url;if(Array.isArray(h)){const v=[];for(let y=0,w=h.length;y<w;y++){const S=h[y],M=l(S);M!==null&&(M instanceof HTMLImageElement?v.push(M):v.push(new Uf(M.data,M.width,M.height)))}s[p.uuid]=new um(v)}else{const v=l(p.url);s[p.uuid]=new um(v)}}}return s}async parseImagesAsync(e){const t=this,i={};let s;async function r(o){if(typeof o=="string"){const l=o,c=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(l)?l:t.resourcePath+l;return await s.loadAsync(c)}else return o.data?{data:K_(o.type,o.data),width:o.width,height:o.height}:null}if(e!==void 0&&e.length>0){s=new kv(this.manager),s.setCrossOrigin(this.crossOrigin);for(let o=0,l=e.length;o<l;o++){const c=e[o],d=c.url;if(Array.isArray(d)){const g=[];for(let p=0,h=d.length;p<h;p++){const v=d[p],y=await r(v);y!==null&&(y instanceof HTMLImageElement?g.push(y):g.push(new Uf(y.data,y.width,y.height)))}i[c.uuid]=new um(g)}else{const g=await r(c.url);i[c.uuid]=new um(g)}}}return i}parseTextures(e,t){function i(r,o){return typeof r=="number"?r:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",r),o[r])}const s={};if(e!==void 0)for(let r=0,o=e.length;r<o;r++){const l=e[r];l.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',l.uuid),t[l.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",l.image);const c=t[l.image],d=c.data;let g;Array.isArray(d)?(g=new Kv,d.length===6&&(g.needsUpdate=!0)):(d&&d.data?g=new Uf:g=new vr,d&&(g.needsUpdate=!0)),g.source=c,g.uuid=l.uuid,l.name!==void 0&&(g.name=l.name),l.mapping!==void 0&&(g.mapping=i(l.mapping,Xk)),l.channel!==void 0&&(g.channel=l.channel),l.offset!==void 0&&g.offset.fromArray(l.offset),l.repeat!==void 0&&g.repeat.fromArray(l.repeat),l.center!==void 0&&g.center.fromArray(l.center),l.rotation!==void 0&&(g.rotation=l.rotation),l.wrap!==void 0&&(g.wrapS=i(l.wrap[0],oC),g.wrapT=i(l.wrap[1],oC)),l.format!==void 0&&(g.format=l.format),l.internalFormat!==void 0&&(g.internalFormat=l.internalFormat),l.type!==void 0&&(g.type=l.type),l.colorSpace!==void 0&&(g.colorSpace=l.colorSpace),l.minFilter!==void 0&&(g.minFilter=i(l.minFilter,lC)),l.magFilter!==void 0&&(g.magFilter=i(l.magFilter,lC)),l.anisotropy!==void 0&&(g.anisotropy=l.anisotropy),l.flipY!==void 0&&(g.flipY=l.flipY),l.generateMipmaps!==void 0&&(g.generateMipmaps=l.generateMipmaps),l.premultiplyAlpha!==void 0&&(g.premultiplyAlpha=l.premultiplyAlpha),l.unpackAlignment!==void 0&&(g.unpackAlignment=l.unpackAlignment),l.compareFunction!==void 0&&(g.compareFunction=l.compareFunction),l.userData!==void 0&&(g.userData=l.userData),s[l.uuid]=g}return s}parseObject(e,t,i,s,r){let o;function l(h){return t[h]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",h),t[h]}function c(h){if(h!==void 0){if(Array.isArray(h)){const v=[];for(let y=0,w=h.length;y<w;y++){const S=h[y];i[S]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",S),v.push(i[S])}return v}return i[h]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",h),i[h]}}function d(h){return s[h]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",h),s[h]}let g,p;switch(e.type){case"Scene":o=new Fv,e.background!==void 0&&(Number.isInteger(e.background)?o.background=new Sn(e.background):o.background=d(e.background)),e.environment!==void 0&&(o.environment=d(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?o.fog=new ox(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(o.fog=new ax(e.fog.color,e.fog.density)),e.fog.name!==""&&(o.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(o.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(o.backgroundIntensity=e.backgroundIntensity),e.backgroundRotation!==void 0&&o.backgroundRotation.fromArray(e.backgroundRotation),e.environmentIntensity!==void 0&&(o.environmentIntensity=e.environmentIntensity),e.environmentRotation!==void 0&&o.environmentRotation.fromArray(e.environmentRotation);break;case"PerspectiveCamera":o=new Er(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(o.focus=e.focus),e.zoom!==void 0&&(o.zoom=e.zoom),e.filmGauge!==void 0&&(o.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(o.filmOffset=e.filmOffset),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"OrthographicCamera":o=new Lc(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(o.zoom=e.zoom),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"AmbientLight":o=new QI(e.color,e.intensity);break;case"DirectionalLight":o=new qT(e.color,e.intensity),o.target=e.target||"";break;case"PointLight":o=new KT(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":o=new ZI(e.color,e.intensity,e.width,e.height);break;case"SpotLight":o=new WT(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),o.target=e.target||"";break;case"HemisphereLight":o=new JI(e.color,e.groundColor,e.intensity);break;case"LightProbe":o=new tO().fromJSON(e);break;case"SkinnedMesh":g=l(e.geometry),p=c(e.material),o=new AT(g,p),e.bindMode!==void 0&&(o.bindMode=e.bindMode),e.bindMatrix!==void 0&&o.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(o.skeleton=e.skeleton);break;case"Mesh":g=l(e.geometry),p=c(e.material),o=new ea(g,p);break;case"InstancedMesh":g=l(e.geometry),p=c(e.material);const h=e.count,v=e.instanceMatrix,y=e.instanceColor;o=new CT(g,p,h),o.instanceMatrix=new Gg(new Float32Array(v.array),16),y!==void 0&&(o.instanceColor=new Gg(new Float32Array(y.array),y.itemSize));break;case"BatchedMesh":g=l(e.geometry),p=c(e.material),o=new TI(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,p),o.geometry=g,o.perObjectFrustumCulled=e.perObjectFrustumCulled,o.sortObjects=e.sortObjects,o._drawRanges=e.drawRanges,o._reservedRanges=e.reservedRanges,o._geometryInfo=e.geometryInfo.map(w=>{let S=null,M=null;return w.boundingBox!==void 0&&(S=new Ra().fromJSON(w.boundingBox)),w.boundingSphere!==void 0&&(M=new uo().fromJSON(w.boundingSphere)),{...w,boundingBox:S,boundingSphere:M}}),o._instanceInfo=e.instanceInfo,o._availableInstanceIds=e._availableInstanceIds,o._availableGeometryIds=e._availableGeometryIds,o._nextIndexStart=e.nextIndexStart,o._nextVertexStart=e.nextVertexStart,o._geometryCount=e.geometryCount,o._maxInstanceCount=e.maxInstanceCount,o._maxVertexCount=e.maxVertexCount,o._maxIndexCount=e.maxIndexCount,o._geometryInitialized=e.geometryInitialized,o._matricesTexture=d(e.matricesTexture.uuid),o._indirectTexture=d(e.indirectTexture.uuid),e.colorsTexture!==void 0&&(o._colorsTexture=d(e.colorsTexture.uuid)),e.boundingSphere!==void 0&&(o.boundingSphere=new uo().fromJSON(e.boundingSphere)),e.boundingBox!==void 0&&(o.boundingBox=new Ra().fromJSON(e.boundingBox));break;case"LOD":o=new EI;break;case"Line":o=new Kh(l(e.geometry),c(e.material));break;case"LineLoop":o=new PT(l(e.geometry),c(e.material));break;case"LineSegments":o=new Ud(l(e.geometry),c(e.material));break;case"PointCloud":case"Points":o=new RT(l(e.geometry),c(e.material));break;case"Sprite":o=new wI(c(e.material));break;case"Group":o=new Hh;break;case"Bone":o=new lx;break;default:o=new fs}if(o.uuid=e.uuid,e.name!==void 0&&(o.name=e.name),e.matrix!==void 0?(o.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(o.matrixAutoUpdate=e.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(e.position!==void 0&&o.position.fromArray(e.position),e.rotation!==void 0&&o.rotation.fromArray(e.rotation),e.quaternion!==void 0&&o.quaternion.fromArray(e.quaternion),e.scale!==void 0&&o.scale.fromArray(e.scale)),e.up!==void 0&&o.up.fromArray(e.up),e.castShadow!==void 0&&(o.castShadow=e.castShadow),e.receiveShadow!==void 0&&(o.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.intensity!==void 0&&(o.shadow.intensity=e.shadow.intensity),e.shadow.bias!==void 0&&(o.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(o.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(o.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&o.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(o.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(o.visible=e.visible),e.frustumCulled!==void 0&&(o.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(o.renderOrder=e.renderOrder),e.userData!==void 0&&(o.userData=e.userData),e.layers!==void 0&&(o.layers.mask=e.layers),e.children!==void 0){const h=e.children;for(let v=0;v<h.length;v++)o.add(this.parseObject(h[v],t,i,s,r))}if(e.animations!==void 0){const h=e.animations;for(let v=0;v<h.length;v++){const y=h[v];o.animations.push(r[y])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(o.autoUpdate=e.autoUpdate);const h=e.levels;for(let v=0;v<h.length;v++){const y=h[v],w=o.getObjectByProperty("uuid",y.object);w!==void 0&&o.addLevel(w,y.distance,y.hysteresis)}}return o}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(i){if(i.isSkinnedMesh===!0&&i.skeleton!==void 0){const s=t[i.skeleton];s===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",i.skeleton):i.bind(s,i.bindMatrix)}})}bindLightTargets(e){e.traverse(function(t){if(t.isDirectionalLight||t.isSpotLight){const i=t.target,s=e.getObjectByProperty("uuid",i);s!==void 0?t.target=s:t.target=new fs}})}}const Xk={UVMapping:qb,CubeReflectionMapping:Wh,CubeRefractionMapping:dm,EquirectangularReflectionMapping:Rv,EquirectangularRefractionMapping:Dv,CubeUVReflectionMapping:g0},oC={RepeatWrapping:fm,ClampToEdgeWrapping:Wu,MirroredRepeatWrapping:t0},lC={NearestFilter:ta,NearestMipmapNearestFilter:Xb,NearestMipmapLinearFilter:Ag,LinearFilter:Tr,LinearMipmapNearestFilter:J_,LinearMipmapLinearFilter:Oc},Lw=new WeakMap;class sO extends Zo{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"},this._abortController=new AbortController}setOptions(e){return this.options=e,this}load(e,t,i,s){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,o=zf.get(`image-bitmap:${e}`);if(o!==void 0){if(r.manager.itemStart(e),o.then){o.then(d=>{if(Lw.has(o)===!0)s&&s(Lw.get(o)),r.manager.itemError(e),r.manager.itemEnd(e);else return t&&t(d),r.manager.itemEnd(e),d});return}return setTimeout(function(){t&&t(o),r.manager.itemEnd(e)},0),o}const l={};l.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",l.headers=this.requestHeader,l.signal=typeof AbortSignal.any=="function"?AbortSignal.any([this._abortController.signal,this.manager.abortController.signal]):this._abortController.signal;const c=fetch(e,l).then(function(d){return d.blob()}).then(function(d){return createImageBitmap(d,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(d){return zf.add(`image-bitmap:${e}`,d),t&&t(d),r.manager.itemEnd(e),d}).catch(function(d){s&&s(d),Lw.set(c,d),zf.remove(`image-bitmap:${e}`),r.manager.itemError(e),r.manager.itemEnd(e)});zf.add(`image-bitmap:${e}`,c),r.manager.itemStart(e)}abort(){return this._abortController.abort(),this._abortController=new AbortController,this}}let uM,XT=class{static getContext(){return uM===void 0&&(uM=new(window.AudioContext||window.webkitAudioContext)),uM}static setContext(e){uM=e}};class Yk extends Zo{constructor(e){super(e)}load(e,t,i,s){const r=this,o=new Qu(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(c){try{const d=c.slice(0);XT.getContext().decodeAudioData(d,function(p){t(p)}).catch(l)}catch(d){l(d)}},i,s);function l(c){s?s(c):console.error(c),r.manager.itemError(e)}}}const uC=new li,cC=new li,ag=new li;class Jk{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Er,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Er,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,ag.copy(e.projectionMatrix);const s=t.eyeSep/2,r=s*t.near/t.focus,o=t.near*Math.tan(Lg*t.fov*.5)/t.zoom;let l,c;cC.elements[12]=-s,uC.elements[12]=s,l=-o*t.aspect+r,c=o*t.aspect+r,ag.elements[0]=2*t.near/(c-l),ag.elements[8]=(c+l)/(c-l),this.cameraL.projectionMatrix.copy(ag),l=-o*t.aspect-r,c=o*t.aspect-r,ag.elements[0]=2*t.near/(c-l),ag.elements[8]=(c+l)/(c-l),this.cameraR.projectionMatrix.copy(ag)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(cC),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(uC)}}class rO extends Er{constructor(e=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=e}}class YT{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=performance.now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=performance.now();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}const og=new Oe,Fw=new lo,Qk=new Oe,lg=new Oe,ug=new Oe;class Zk extends fs{constructor(){super(),this.type="AudioListener",this.context=XT.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new YT}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(og,Fw,Qk),lg.set(0,0,-1).applyQuaternion(Fw),ug.set(0,1,0).applyQuaternion(Fw),t.positionX){const i=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(og.x,i),t.positionY.linearRampToValueAtTime(og.y,i),t.positionZ.linearRampToValueAtTime(og.z,i),t.forwardX.linearRampToValueAtTime(lg.x,i),t.forwardY.linearRampToValueAtTime(lg.y,i),t.forwardZ.linearRampToValueAtTime(lg.z,i),t.upX.linearRampToValueAtTime(ug.x,i),t.upY.linearRampToValueAtTime(ug.y,i),t.upZ.linearRampToValueAtTime(ug.z,i)}else t.setPosition(og.x,og.y,og.z),t.setOrientation(lg.x,lg.y,lg.z,ug.x,ug.y,ug.z)}}class aO extends fs{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(e=0){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(this.context.currentTime+e),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){return this.detune=e,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}copy(e,t){return super.copy(e,t),e.sourceType!=="buffer"?(console.warn("THREE.Audio: Audio source type cannot be copied."),this):(this.autoplay=e.autoplay,this.buffer=e.buffer,this.detune=e.detune,this.loop=e.loop,this.loopStart=e.loopStart,this.loopEnd=e.loopEnd,this.offset=e.offset,this.duration=e.duration,this.playbackRate=e.playbackRate,this.hasPlaybackControl=e.hasPlaybackControl,this.sourceType=e.sourceType,this.filters=e.filters.slice(),this)}clone(e){return new this.constructor(this.listener).copy(this,e)}}const cg=new Oe,dC=new lo,e4=new Oe,dg=new Oe;class t4 extends aO{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){return super.connect(),this.panner.connect(this.gain),this}disconnect(){return super.disconnect(),this.panner.disconnect(this.gain),this}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,i){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=i,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(cg,dC,e4),dg.set(0,0,1).applyQuaternion(dC);const t=this.panner;if(t.positionX){const i=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(cg.x,i),t.positionY.linearRampToValueAtTime(cg.y,i),t.positionZ.linearRampToValueAtTime(cg.z,i),t.orientationX.linearRampToValueAtTime(dg.x,i),t.orientationY.linearRampToValueAtTime(dg.y,i),t.orientationZ.linearRampToValueAtTime(dg.z,i)}else t.setPosition(cg.x,cg.y,cg.z),t.setOrientation(dg.x,dg.y,dg.z)}}class n4{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let i=0;i<t.length;i++)e+=t[i];return e/t.length}}class oO{constructor(e,t,i){this.binding=e,this.valueSize=i;let s,r,o;switch(t){case"quaternion":s=this._slerp,r=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(i*6),this._workIndex=5;break;case"string":case"bool":s=this._select,r=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(i*5);break;default:s=this._lerp,r=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(i*5)}this._mixBufferRegion=s,this._mixBufferRegionAdditive=r,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const i=this.buffer,s=this.valueSize,r=e*s+s;let o=this.cumulativeWeight;if(o===0){for(let l=0;l!==s;++l)i[r+l]=i[l];o=t}else{o+=t;const l=t/o;this._mixBufferRegion(i,r,0,l,s)}this.cumulativeWeight=o}accumulateAdditive(e){const t=this.buffer,i=this.valueSize,s=i*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,s,0,e,i),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,i=this.buffer,s=e*t+t,r=this.cumulativeWeight,o=this.cumulativeWeightAdditive,l=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const c=t*this._origIndex;this._mixBufferRegion(i,s,c,1-r,t)}o>0&&this._mixBufferRegionAdditive(i,s,this._addIndex*t,1,t);for(let c=t,d=t+t;c!==d;++c)if(i[c]!==i[c+t]){l.setValue(i,s);break}}saveOriginalState(){const e=this.binding,t=this.buffer,i=this.valueSize,s=i*this._origIndex;e.getValue(t,s);for(let r=i,o=s;r!==o;++r)t[r]=t[s+r%i];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let i=e;i<t;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[t+i]=this.buffer[e+i]}_select(e,t,i,s,r){if(s>=.5)for(let o=0;o!==r;++o)e[t+o]=e[i+o]}_slerp(e,t,i,s){lo.slerpFlat(e,t,e,t,e,i,s)}_slerpAdditive(e,t,i,s,r){const o=this._workIndex*r;lo.multiplyQuaternionsFlat(e,o,e,t,e,i),lo.slerpFlat(e,t,e,t,e,o,s)}_lerp(e,t,i,s,r){const o=1-s;for(let l=0;l!==r;++l){const c=t+l;e[c]=e[c]*o+e[i+l]*s}}_lerpAdditive(e,t,i,s,r){for(let o=0;o!==r;++o){const l=t+o;e[l]=e[l]+e[i+o]*s}}}const JT="\\[\\]\\.:\\/",i4=new RegExp("["+JT+"]","g"),QT="[^"+JT+"]",s4="[^"+JT.replace("\\.","")+"]",r4=/((?:WC+[\/:])*)/.source.replace("WC",QT),a4=/(WCOD+)?/.source.replace("WCOD",s4),o4=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",QT),l4=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",QT),u4=new RegExp("^"+r4+a4+o4+l4+"$"),c4=["material","materials","bones","map"];class d4{constructor(e,t,i){const s=i||ys.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,s)}getValue(e,t){this.bind();const i=this._targetGroup.nCachedObjects_,s=this._bindings[i];s!==void 0&&s.getValue(e,t)}setValue(e,t){const i=this._bindings;for(let s=this._targetGroup.nCachedObjects_,r=i.length;s!==r;++s)i[s].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].unbind()}}class ys{constructor(e,t,i){this.path=t,this.parsedPath=i||ys.parseTrackName(t),this.node=ys.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,i){return e&&e.isAnimationObjectGroup?new ys.Composite(e,t,i):new ys(e,t,i)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(i4,"")}static parseTrackName(e){const t=u4.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const i={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},s=i.nodeName&&i.nodeName.lastIndexOf(".");if(s!==void 0&&s!==-1){const r=i.nodeName.substring(s+1);c4.indexOf(r)!==-1&&(i.nodeName=i.nodeName.substring(0,s),i.objectName=r)}if(i.propertyName===null||i.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return i}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const i=e.skeleton.getBoneByName(t);if(i!==void 0)return i}if(e.children){const i=function(r){for(let o=0;o<r.length;o++){const l=r[o];if(l.name===t||l.uuid===t)return l;const c=i(l.children);if(c)return c}return null},s=i(e.children);if(s)return s}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)e[t++]=i[s]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)i[s]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)i[s]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)i[s]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,i=t.objectName,s=t.propertyName;let r=t.propertyIndex;if(e||(e=ys.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(i){let d=t.objectIndex;switch(i){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let g=0;g<e.length;g++)if(e[g].name===d){d=g;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[i]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[i]}if(d!==void 0){if(e[d]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[d]}}const o=e[s];if(o===void 0){const d=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+d+"."+s+" but it wasn't found.",e);return}let l=this.Versioning.None;this.targetObject=e,e.isMaterial===!0?l=this.Versioning.NeedsUpdate:e.isObject3D===!0&&(l=this.Versioning.MatrixWorldNeedsUpdate);let c=this.BindingType.Direct;if(r!==void 0){if(s==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}c=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=r}else o.fromArray!==void 0&&o.toArray!==void 0?(c=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(c=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=s;this.getValue=this.GetterByBindingType[c],this.setValue=this.SetterByBindingTypeAndVersioning[c][l]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}ys.Composite=d4;ys.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};ys.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};ys.prototype.GetterByBindingType=[ys.prototype._getValue_direct,ys.prototype._getValue_array,ys.prototype._getValue_arrayElement,ys.prototype._getValue_toArray];ys.prototype.SetterByBindingTypeAndVersioning=[[ys.prototype._setValue_direct,ys.prototype._setValue_direct_setNeedsUpdate,ys.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[ys.prototype._setValue_array,ys.prototype._setValue_array_setNeedsUpdate,ys.prototype._setValue_array_setMatrixWorldNeedsUpdate],[ys.prototype._setValue_arrayElement,ys.prototype._setValue_arrayElement_setNeedsUpdate,ys.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[ys.prototype._setValue_fromArray,ys.prototype._setValue_fromArray_setNeedsUpdate,ys.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class f4{constructor(){this.isAnimationObjectGroup=!0,this.uuid=Xu(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let i=0,s=arguments.length;i!==s;++i)e[arguments[i].uuid]=i;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,i=this._paths,s=this._parsedPaths,r=this._bindings,o=r.length;let l,c=e.length,d=this.nCachedObjects_;for(let g=0,p=arguments.length;g!==p;++g){const h=arguments[g],v=h.uuid;let y=t[v];if(y===void 0){y=c++,t[v]=y,e.push(h);for(let w=0,S=o;w!==S;++w)r[w].push(new ys(h,i[w],s[w]))}else if(y<d){l=e[y];const w=--d,S=e[w];t[S.uuid]=y,e[y]=S,t[v]=w,e[w]=h;for(let M=0,T=o;M!==T;++M){const C=r[M],x=C[w];let R=C[y];C[y]=x,R===void 0&&(R=new ys(h,i[M],s[M])),C[w]=R}}else e[y]!==l&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=d}remove(){const e=this._objects,t=this._indicesByUUID,i=this._bindings,s=i.length;let r=this.nCachedObjects_;for(let o=0,l=arguments.length;o!==l;++o){const c=arguments[o],d=c.uuid,g=t[d];if(g!==void 0&&g>=r){const p=r++,h=e[p];t[h.uuid]=g,e[g]=h,t[d]=p,e[p]=c;for(let v=0,y=s;v!==y;++v){const w=i[v],S=w[p],M=w[g];w[g]=S,w[p]=M}}}this.nCachedObjects_=r}uncache(){const e=this._objects,t=this._indicesByUUID,i=this._bindings,s=i.length;let r=this.nCachedObjects_,o=e.length;for(let l=0,c=arguments.length;l!==c;++l){const d=arguments[l],g=d.uuid,p=t[g];if(p!==void 0)if(delete t[g],p<r){const h=--r,v=e[h],y=--o,w=e[y];t[v.uuid]=p,e[p]=v,t[w.uuid]=h,e[h]=w,e.pop();for(let S=0,M=s;S!==M;++S){const T=i[S],C=T[h],x=T[y];T[p]=C,T[h]=x,T.pop()}}else{const h=--o,v=e[h];h>0&&(t[v.uuid]=p),e[p]=v,e.pop();for(let y=0,w=s;y!==w;++y){const S=i[y];S[p]=S[h],S.pop()}}}this.nCachedObjects_=r}subscribe_(e,t){const i=this._bindingsIndicesByPath;let s=i[e];const r=this._bindings;if(s!==void 0)return r[s];const o=this._paths,l=this._parsedPaths,c=this._objects,d=c.length,g=this.nCachedObjects_,p=new Array(d);s=r.length,i[e]=s,o.push(e),l.push(t),r.push(p);for(let h=g,v=c.length;h!==v;++h){const y=c[h];p[h]=new ys(y,e,t)}return p}unsubscribe_(e){const t=this._bindingsIndicesByPath,i=t[e];if(i!==void 0){const s=this._paths,r=this._parsedPaths,o=this._bindings,l=o.length-1,c=o[l],d=e[l];t[d]=i,o[i]=c,o.pop(),r[i]=r[l],r.pop(),s[i]=s[l],s.pop()}}}class lO{constructor(e,t,i=null,s=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=i,this.blendMode=s;const r=t.tracks,o=r.length,l=new Array(o),c={endingStart:Cg,endingEnd:Cg};for(let d=0;d!==o;++d){const g=r[d].createInterpolant(null);l[d]=g,g.settings=c}this._interpolantSettings=c,this._interpolants=l,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=nI,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,i=!1){if(e.fadeOut(t),this.fadeIn(t),i===!0){const s=this._clip.duration,r=e._clip.duration,o=r/s,l=s/r;e.warp(1,o,t),this.warp(l,1,t)}return this}crossFadeTo(e,t,i=!1){return e.crossFadeFrom(this,t,i)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,i){const s=this._mixer,r=s.time,o=this.timeScale;let l=this._timeScaleInterpolant;l===null&&(l=s._lendControlInterpolant(),this._timeScaleInterpolant=l);const c=l.parameterPositions,d=l.sampleValues;return c[0]=r,c[1]=r+i,d[0]=e/o,d[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,i,s){if(!this.enabled){this._updateWeight(e);return}const r=this._startTime;if(r!==null){const c=(e-r)*i;c<0||i===0?t=0:(this._startTime=null,t=i*c)}t*=this._updateTimeScale(e);const o=this._updateTime(t),l=this._updateWeight(e);if(l>0){const c=this._interpolants,d=this._propertyBindings;switch(this.blendMode){case yT:for(let g=0,p=c.length;g!==p;++g)c[g].evaluate(o),d[g].accumulateAdditive(l);break;case nx:default:for(let g=0,p=c.length;g!==p;++g)c[g].evaluate(o),d[g].accumulate(s,l)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const i=this._weightInterpolant;if(i!==null){const s=i.evaluate(e)[0];t*=s,e>i.parameterPositions[1]&&(this.stopFading(),s===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const i=this._timeScaleInterpolant;if(i!==null){const s=i.evaluate(e)[0];t*=s,e>i.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,i=this.loop;let s=this.time+e,r=this._loopCount;const o=i===iI;if(e===0)return r===-1?s:o&&(r&1)===1?t-s:s;if(i===tI){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(s>=t)s=t;else if(s<0)s=0;else{this.time=s;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(r===-1&&(e>=0?(r=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),s>=t||s<0){const l=Math.floor(s/t);s-=t*l,r+=Math.abs(l);const c=this.repetitions-r;if(c<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,s=e>0?t:0,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(c===1){const d=e<0;this._setEndings(d,!d,o)}else this._setEndings(!1,!1,o);this._loopCount=r,this.time=s,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:l})}}else this.time=s;if(o&&(r&1)===1)return t-s}return s}_setEndings(e,t,i){const s=this._interpolantSettings;i?(s.endingStart=Pg,s.endingEnd=Pg):(e?s.endingStart=this.zeroSlopeAtStart?Pg:Cg:s.endingStart=Bv,t?s.endingEnd=this.zeroSlopeAtEnd?Pg:Cg:s.endingEnd=Bv)}_scheduleFading(e,t,i){const s=this._mixer,r=s.time;let o=this._weightInterpolant;o===null&&(o=s._lendControlInterpolant(),this._weightInterpolant=o);const l=o.parameterPositions,c=o.sampleValues;return l[0]=r,c[0]=t,l[1]=r+e,c[1]=i,this}}const h4=new Float32Array(1);class p4 extends Zu{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const i=e._localRoot||this._root,s=e._clip.tracks,r=s.length,o=e._propertyBindings,l=e._interpolants,c=i.uuid,d=this._bindingsByRootAndName;let g=d[c];g===void 0&&(g={},d[c]=g);for(let p=0;p!==r;++p){const h=s[p],v=h.name;let y=g[v];if(y!==void 0)++y.referenceCount,o[p]=y;else{if(y=o[p],y!==void 0){y._cacheIndex===null&&(++y.referenceCount,this._addInactiveBinding(y,c,v));continue}const w=t&&t._propertyBindings[p].binding.parsedPath;y=new oO(ys.create(i,v,w),h.ValueTypeName,h.getValueSize()),++y.referenceCount,this._addInactiveBinding(y,c,v),o[p]=y}l[p].resultBuffer=y.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const i=(e._localRoot||this._root).uuid,s=e._clip.uuid,r=this._actionsByClip[s];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,s,i)}const t=e._propertyBindings;for(let i=0,s=t.length;i!==s;++i){const r=t[i];r.useCount++===0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let i=0,s=t.length;i!==s;++i){const r=t[i];--r.useCount===0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,i){const s=this._actions,r=this._actionsByClip;let o=r[t];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,r[t]=o;else{const l=o.knownActions;e._byClipCacheIndex=l.length,l.push(e)}e._cacheIndex=s.length,s.push(e),o.actionByRoot[i]=e}_removeInactiveAction(e){const t=this._actions,i=t[t.length-1],s=e._cacheIndex;i._cacheIndex=s,t[s]=i,t.pop(),e._cacheIndex=null;const r=e._clip.uuid,o=this._actionsByClip,l=o[r],c=l.knownActions,d=c[c.length-1],g=e._byClipCacheIndex;d._byClipCacheIndex=g,c[g]=d,c.pop(),e._byClipCacheIndex=null;const p=l.actionByRoot,h=(e._localRoot||this._root).uuid;delete p[h],c.length===0&&delete o[r],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let i=0,s=t.length;i!==s;++i){const r=t[i];--r.referenceCount===0&&this._removeInactiveBinding(r)}}_lendAction(e){const t=this._actions,i=e._cacheIndex,s=this._nActiveActions++,r=t[s];e._cacheIndex=s,t[s]=e,r._cacheIndex=i,t[i]=r}_takeBackAction(e){const t=this._actions,i=e._cacheIndex,s=--this._nActiveActions,r=t[s];e._cacheIndex=s,t[s]=e,r._cacheIndex=i,t[i]=r}_addInactiveBinding(e,t,i){const s=this._bindingsByRootAndName,r=this._bindings;let o=s[t];o===void 0&&(o={},s[t]=o),o[i]=e,e._cacheIndex=r.length,r.push(e)}_removeInactiveBinding(e){const t=this._bindings,i=e.binding,s=i.rootNode.uuid,r=i.path,o=this._bindingsByRootAndName,l=o[s],c=t[t.length-1],d=e._cacheIndex;c._cacheIndex=d,t[d]=c,t.pop(),delete l[r],Object.keys(l).length===0&&delete o[s]}_lendBinding(e){const t=this._bindings,i=e._cacheIndex,s=this._nActiveBindings++,r=t[s];e._cacheIndex=s,t[s]=e,r._cacheIndex=i,t[i]=r}_takeBackBinding(e){const t=this._bindings,i=e._cacheIndex,s=--this._nActiveBindings,r=t[s];e._cacheIndex=s,t[s]=e,r._cacheIndex=i,t[i]=r}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let i=e[t];return i===void 0&&(i=new VT(new Float32Array(2),new Float32Array(2),1,h4),i.__cacheIndex=t,e[t]=i),i}_takeBackControlInterpolant(e){const t=this._controlInterpolants,i=e.__cacheIndex,s=--this._nActiveControlInterpolants,r=t[s];e.__cacheIndex=s,t[s]=e,r.__cacheIndex=i,t[i]=r}clipAction(e,t,i){const s=t||this._root,r=s.uuid;let o=typeof e=="string"?d0.findByName(s,e):e;const l=o!==null?o.uuid:e,c=this._actionsByClip[l];let d=null;if(i===void 0&&(o!==null?i=o.blendMode:i=nx),c!==void 0){const p=c.actionByRoot[r];if(p!==void 0&&p.blendMode===i)return p;d=c.knownActions[0],o===null&&(o=d._clip)}if(o===null)return null;const g=new lO(this,o,t,i);return this._bindAction(g,d),this._addInactiveAction(g,l,r),g}existingAction(e,t){const i=t||this._root,s=i.uuid,r=typeof e=="string"?d0.findByName(i,e):e,o=r?r.uuid:e,l=this._actionsByClip[o];return l!==void 0&&l.actionByRoot[s]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let i=t-1;i>=0;--i)e[i].stop();return this}update(e){e*=this.timeScale;const t=this._actions,i=this._nActiveActions,s=this.time+=e,r=Math.sign(e),o=this._accuIndex^=1;for(let d=0;d!==i;++d)t[d]._update(s,e,r,o);const l=this._bindings,c=this._nActiveBindings;for(let d=0;d!==c;++d)l[d].apply(o);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,i=e.uuid,s=this._actionsByClip,r=s[i];if(r!==void 0){const o=r.knownActions;for(let l=0,c=o.length;l!==c;++l){const d=o[l];this._deactivateAction(d);const g=d._cacheIndex,p=t[t.length-1];d._cacheIndex=null,d._byClipCacheIndex=null,p._cacheIndex=g,t[g]=p,t.pop(),this._removeInactiveBindingsForAction(d)}delete s[i]}}uncacheRoot(e){const t=e.uuid,i=this._actionsByClip;for(const o in i){const l=i[o].actionByRoot,c=l[t];c!==void 0&&(this._deactivateAction(c),this._removeInactiveAction(c))}const s=this._bindingsByRootAndName,r=s[t];if(r!==void 0)for(const o in r){const l=r[o];l.restoreOriginalState(),this._removeInactiveBinding(l)}}uncacheAction(e,t){const i=this.existingAction(e,t);i!==null&&(this._deactivateAction(i),this._removeInactiveAction(i))}}class m4 extends wT{constructor(e=1,t=1,i=1,s={}){super(e,t,s),this.isRenderTarget3D=!0,this.depth=i,this.texture=new sx(null,e,t,i),this._setTextureOptions(s),this.texture.isRenderTargetTexture=!0}}class cs{constructor(e){this.value=e}clone(){return new cs(this.value.clone===void 0?this.value:this.value.clone())}}let g4=0;class _4 extends Zu{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:g4++}),this.name="",this.usage=Ov,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){this.dispatchEvent({type:"dispose"})}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let i=0,s=t.length;i<s;i++){const r=Array.isArray(t[i])?t[i]:[t[i]];for(let o=0;o<r.length;o++)this.uniforms.push(r[o].clone())}return this}clone(){return new this.constructor().copy(this)}}class v4 extends qv{constructor(e,t,i=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class y4{constructor(e,t,i,s,r,o=!1){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=t,this.itemSize=i,this.elementSize=s,this.count=r,this.normalized=o,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}const fC=new li;class uO{constructor(e,t,i=0,s=1/0){this.ray=new Qg(e,t),this.near=i,this.far=s,this.camera=null,this.layers=new l0,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}setFromXRController(e){return fC.identity().extractRotation(e.matrixWorld),this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(fC),this}intersectObject(e,t=!0,i=[]){return RE(e,this,i,t),i.sort(hC),i}intersectObjects(e,t=!0,i=[]){for(let s=0,r=e.length;s<r;s++)RE(e[s],this,i,t);return i.sort(hC),i}}function hC(n,e){return n.distance-e.distance}function RE(n,e,t,i){let s=!0;if(n.layers.test(e.layers)&&n.raycast(e,t)===!1&&(s=!1),s===!0&&i===!0){const r=n.children;for(let o=0,l=r.length;o<l;o++)RE(r[o],e,t,!0)}}let M4=class{constructor(){this._previousTime=0,this._currentTime=0,this._startTime=performance.now(),this._delta=0,this._elapsed=0,this._timescale=1,this._document=null,this._pageVisibilityHandler=null}connect(e){this._document=e,e.hidden!==void 0&&(this._pageVisibilityHandler=b4.bind(this),e.addEventListener("visibilitychange",this._pageVisibilityHandler,!1))}disconnect(){this._pageVisibilityHandler!==null&&(this._document.removeEventListener("visibilitychange",this._pageVisibilityHandler),this._pageVisibilityHandler=null),this._document=null}getDelta(){return this._delta/1e3}getElapsed(){return this._elapsed/1e3}getTimescale(){return this._timescale}setTimescale(e){return this._timescale=e,this}reset(){return this._currentTime=performance.now()-this._startTime,this}dispose(){this.disconnect()}update(e){return this._pageVisibilityHandler!==null&&this._document.hidden===!0?this._delta=0:(this._previousTime=this._currentTime,this._currentTime=(e!==void 0?e:performance.now())-this._startTime,this._delta=(this._currentTime-this._previousTime)*this._timescale,this._elapsed+=this._delta),this}};function b4(){this._document.hidden===!1&&this.reset()}class DE{constructor(e=1,t=0,i=0){this.radius=e,this.phi=t,this.theta=i}set(e,t,i){return this.radius=e,this.phi=t,this.theta=i,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=mi(this.phi,1e-6,Math.PI-1e-6),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,i){return this.radius=Math.sqrt(e*e+t*t+i*i),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,i),this.phi=Math.acos(mi(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class x4{constructor(e=1,t=0,i=0){this.radius=e,this.theta=t,this.y=i}set(e,t,i){return this.radius=e,this.theta=t,this.y=i,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,i){return this.radius=Math.sqrt(e*e+i*i),this.theta=Math.atan2(e,i),this.y=t,this}clone(){return new this.constructor().copy(this)}}class ZT{constructor(e,t,i,s){ZT.prototype.isMatrix2=!0,this.elements=[1,0,0,1],e!==void 0&&this.set(e,t,i,s)}identity(){return this.set(1,0,0,1),this}fromArray(e,t=0){for(let i=0;i<4;i++)this.elements[i]=e[i+t];return this}set(e,t,i,s){const r=this.elements;return r[0]=e,r[2]=t,r[1]=i,r[3]=s,this}}const pC=new Gt;class w4{constructor(e=new Gt(1/0,1/0),t=new Gt(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=pC.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,pC).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const mC=new Oe,cM=new Oe,z_=new Oe,U_=new Oe,Nw=new Oe,E4=new Oe,T4=new Oe;class S4{constructor(e=new Oe,t=new Oe){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){mC.subVectors(e,this.start),cM.subVectors(this.end,this.start);const i=cM.dot(cM);let r=cM.dot(mC)/i;return t&&(r=mi(r,0,1)),r}closestPointToPoint(e,t,i){const s=this.closestPointToPointParameter(e,t);return this.delta(i).multiplyScalar(s).add(this.start)}distanceSqToLine3(e,t=E4,i=T4){const s=10000000000000001e-32;let r,o;const l=this.start,c=e.start,d=this.end,g=e.end;z_.subVectors(d,l),U_.subVectors(g,c),Nw.subVectors(l,c);const p=z_.dot(z_),h=U_.dot(U_),v=U_.dot(Nw);if(p<=s&&h<=s)return t.copy(l),i.copy(c),t.sub(i),t.dot(t);if(p<=s)r=0,o=v/h,o=mi(o,0,1);else{const y=z_.dot(Nw);if(h<=s)o=0,r=mi(-y/p,0,1);else{const w=z_.dot(U_),S=p*h-w*w;S!==0?r=mi((w*v-y*h)/S,0,1):r=0,o=(w*r+v)/h,o<0?(o=0,r=mi(-y/p,0,1)):o>1&&(o=1,r=mi((w-y)/p,0,1))}}return t.copy(l).add(z_.multiplyScalar(r)),i.copy(c).add(U_.multiplyScalar(o)),t.sub(i),t.dot(t)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const gC=new Oe;class A4 extends fs{constructor(e,t){super(),this.light=e,this.matrixAutoUpdate=!1,this.color=t,this.type="SpotLightHelper";const i=new xi,s=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,l=1,c=32;o<c;o++,l++){const d=o/c*Math.PI*2,g=l/c*Math.PI*2;s.push(Math.cos(d),Math.sin(d),1,Math.cos(g),Math.sin(g),1)}i.setAttribute("position",new Hn(s,3));const r=new Qo({fog:!1,toneMapped:!1});this.cone=new Ud(i,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),gC.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(gC),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const tm=new Oe,dM=new li,zw=new li;class C4 extends Ud{constructor(e){const t=cO(e),i=new xi,s=[],r=[];for(let d=0;d<t.length;d++){const g=t[d];g.parent&&g.parent.isBone&&(s.push(0,0,0),s.push(0,0,0),r.push(0,0,0),r.push(0,0,0))}i.setAttribute("position",new Hn(s,3)),i.setAttribute("color",new Hn(r,3));const o=new Qo({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(i,o),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1;const l=new Sn(255),c=new Sn(65280);this.setColors(l,c)}updateMatrixWorld(e){const t=this.bones,i=this.geometry,s=i.getAttribute("position");zw.copy(this.root.matrixWorld).invert();for(let r=0,o=0;r<t.length;r++){const l=t[r];l.parent&&l.parent.isBone&&(dM.multiplyMatrices(zw,l.matrixWorld),tm.setFromMatrixPosition(dM),s.setXYZ(o,tm.x,tm.y,tm.z),dM.multiplyMatrices(zw,l.parent.matrixWorld),tm.setFromMatrixPosition(dM),s.setXYZ(o+1,tm.x,tm.y,tm.z),o+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}setColors(e,t){const s=this.geometry.getAttribute("color");for(let r=0;r<s.count;r+=2)s.setXYZ(r,e.r,e.g,e.b),s.setXYZ(r+1,t.r,t.g,t.b);return s.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}function cO(n){const e=[];n.isBone===!0&&e.push(n);for(let t=0;t<n.children.length;t++)e.push(...cO(n.children[t]));return e}class P4 extends ea{constructor(e,t,i){const s=new y0(t,4,2),r=new qu({wireframe:!0,fog:!1,toneMapped:!1});super(s,r),this.light=e,this.color=i,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const R4=new Oe,_C=new Sn,vC=new Sn;class D4 extends fs{constructor(e,t,i){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,this.type="HemisphereLightHelper";const s=new Qv(t);s.rotateY(Math.PI*.5),this.material=new qu({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const r=s.getAttribute("position"),o=new Float32Array(r.count*3);s.setAttribute("color",new hs(o,3)),this.add(new ea(s,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");_C.copy(this.light.color),vC.copy(this.light.groundColor);for(let i=0,s=t.count;i<s;i++){const r=i<s/2?_C:vC;t.setXYZ(i,r.r,r.g,r.b)}t.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(R4.setFromMatrixPosition(this.light.matrixWorld).negate())}}class B4 extends Ud{constructor(e=10,t=10,i=4473924,s=8947848){i=new Sn(i),s=new Sn(s);const r=t/2,o=e/t,l=e/2,c=[],d=[];for(let h=0,v=0,y=-l;h<=t;h++,y+=o){c.push(-l,0,y,l,0,y),c.push(y,0,-l,y,0,l);const w=h===r?i:s;w.toArray(d,v),v+=3,w.toArray(d,v),v+=3,w.toArray(d,v),v+=3,w.toArray(d,v),v+=3}const g=new xi;g.setAttribute("position",new Hn(c,3)),g.setAttribute("color",new Hn(d,3));const p=new Qo({vertexColors:!0,toneMapped:!1});super(g,p),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class I4 extends Ud{constructor(e=10,t=16,i=8,s=64,r=4473924,o=8947848){r=new Sn(r),o=new Sn(o);const l=[],c=[];if(t>1)for(let p=0;p<t;p++){const h=p/t*(Math.PI*2),v=Math.sin(h)*e,y=Math.cos(h)*e;l.push(0,0,0),l.push(v,0,y);const w=p&1?r:o;c.push(w.r,w.g,w.b),c.push(w.r,w.g,w.b)}for(let p=0;p<i;p++){const h=p&1?r:o,v=e-e/i*p;for(let y=0;y<s;y++){let w=y/s*(Math.PI*2),S=Math.sin(w)*v,M=Math.cos(w)*v;l.push(S,0,M),c.push(h.r,h.g,h.b),w=(y+1)/s*(Math.PI*2),S=Math.sin(w)*v,M=Math.cos(w)*v,l.push(S,0,M),c.push(h.r,h.g,h.b)}}const d=new xi;d.setAttribute("position",new Hn(l,3)),d.setAttribute("color",new Hn(c,3));const g=new Qo({vertexColors:!0,toneMapped:!1});super(d,g),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const yC=new Oe,fM=new Oe,MC=new Oe;class O4 extends fs{constructor(e,t,i){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,this.type="DirectionalLightHelper",t===void 0&&(t=1);let s=new xi;s.setAttribute("position",new Hn([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const r=new Qo({fog:!1,toneMapped:!1});this.lightPlane=new Kh(s,r),this.add(this.lightPlane),s=new xi,s.setAttribute("position",new Hn([0,0,0,0,0,1],3)),this.targetLine=new Kh(s,r),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),yC.setFromMatrixPosition(this.light.matrixWorld),fM.setFromMatrixPosition(this.light.target.matrixWorld),MC.subVectors(fM,yC),this.lightPlane.lookAt(fM),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(fM),this.targetLine.scale.z=MC.length()}}const hM=new Oe,Zr=new rx;class L4 extends Ud{constructor(e){const t=new xi,i=new Qo({color:16777215,vertexColors:!0,toneMapped:!1}),s=[],r=[],o={};l("n1","n2"),l("n2","n4"),l("n4","n3"),l("n3","n1"),l("f1","f2"),l("f2","f4"),l("f4","f3"),l("f3","f1"),l("n1","f1"),l("n2","f2"),l("n3","f3"),l("n4","f4"),l("p","n1"),l("p","n2"),l("p","n3"),l("p","n4"),l("u1","u2"),l("u2","u3"),l("u3","u1"),l("c","t"),l("p","c"),l("cn1","cn2"),l("cn3","cn4"),l("cf1","cf2"),l("cf3","cf4");function l(y,w){c(y),c(w)}function c(y){s.push(0,0,0),r.push(0,0,0),o[y]===void 0&&(o[y]=[]),o[y].push(s.length/3-1)}t.setAttribute("position",new Hn(s,3)),t.setAttribute("color",new Hn(r,3)),super(t,i),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update();const d=new Sn(16755200),g=new Sn(16711680),p=new Sn(43775),h=new Sn(16777215),v=new Sn(3355443);this.setColors(d,g,p,h,v)}setColors(e,t,i,s,r){const l=this.geometry.getAttribute("color");return l.setXYZ(0,e.r,e.g,e.b),l.setXYZ(1,e.r,e.g,e.b),l.setXYZ(2,e.r,e.g,e.b),l.setXYZ(3,e.r,e.g,e.b),l.setXYZ(4,e.r,e.g,e.b),l.setXYZ(5,e.r,e.g,e.b),l.setXYZ(6,e.r,e.g,e.b),l.setXYZ(7,e.r,e.g,e.b),l.setXYZ(8,e.r,e.g,e.b),l.setXYZ(9,e.r,e.g,e.b),l.setXYZ(10,e.r,e.g,e.b),l.setXYZ(11,e.r,e.g,e.b),l.setXYZ(12,e.r,e.g,e.b),l.setXYZ(13,e.r,e.g,e.b),l.setXYZ(14,e.r,e.g,e.b),l.setXYZ(15,e.r,e.g,e.b),l.setXYZ(16,e.r,e.g,e.b),l.setXYZ(17,e.r,e.g,e.b),l.setXYZ(18,e.r,e.g,e.b),l.setXYZ(19,e.r,e.g,e.b),l.setXYZ(20,e.r,e.g,e.b),l.setXYZ(21,e.r,e.g,e.b),l.setXYZ(22,e.r,e.g,e.b),l.setXYZ(23,e.r,e.g,e.b),l.setXYZ(24,t.r,t.g,t.b),l.setXYZ(25,t.r,t.g,t.b),l.setXYZ(26,t.r,t.g,t.b),l.setXYZ(27,t.r,t.g,t.b),l.setXYZ(28,t.r,t.g,t.b),l.setXYZ(29,t.r,t.g,t.b),l.setXYZ(30,t.r,t.g,t.b),l.setXYZ(31,t.r,t.g,t.b),l.setXYZ(32,i.r,i.g,i.b),l.setXYZ(33,i.r,i.g,i.b),l.setXYZ(34,i.r,i.g,i.b),l.setXYZ(35,i.r,i.g,i.b),l.setXYZ(36,i.r,i.g,i.b),l.setXYZ(37,i.r,i.g,i.b),l.setXYZ(38,s.r,s.g,s.b),l.setXYZ(39,s.r,s.g,s.b),l.setXYZ(40,r.r,r.g,r.b),l.setXYZ(41,r.r,r.g,r.b),l.setXYZ(42,r.r,r.g,r.b),l.setXYZ(43,r.r,r.g,r.b),l.setXYZ(44,r.r,r.g,r.b),l.setXYZ(45,r.r,r.g,r.b),l.setXYZ(46,r.r,r.g,r.b),l.setXYZ(47,r.r,r.g,r.b),l.setXYZ(48,r.r,r.g,r.b),l.setXYZ(49,r.r,r.g,r.b),l.needsUpdate=!0,this}update(){const e=this.geometry,t=this.pointMap,i=1,s=1;let r,o;if(Zr.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),this.camera.reversedDepth===!0)r=1,o=0;else if(this.camera.coordinateSystem===Ku)r=-1,o=1;else if(this.camera.coordinateSystem===a0)r=0,o=1;else throw new Error("THREE.CameraHelper.update(): Invalid coordinate system: "+this.camera.coordinateSystem);ha("c",t,e,Zr,0,0,r),ha("t",t,e,Zr,0,0,o),ha("n1",t,e,Zr,-i,-s,r),ha("n2",t,e,Zr,i,-s,r),ha("n3",t,e,Zr,-i,s,r),ha("n4",t,e,Zr,i,s,r),ha("f1",t,e,Zr,-i,-s,o),ha("f2",t,e,Zr,i,-s,o),ha("f3",t,e,Zr,-i,s,o),ha("f4",t,e,Zr,i,s,o),ha("u1",t,e,Zr,i*.7,s*1.1,r),ha("u2",t,e,Zr,-i*.7,s*1.1,r),ha("u3",t,e,Zr,0,s*2,r),ha("cf1",t,e,Zr,-i,0,o),ha("cf2",t,e,Zr,i,0,o),ha("cf3",t,e,Zr,0,-s,o),ha("cf4",t,e,Zr,0,s,o),ha("cn1",t,e,Zr,-i,0,r),ha("cn2",t,e,Zr,i,0,r),ha("cn3",t,e,Zr,0,-s,r),ha("cn4",t,e,Zr,0,s,r),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function ha(n,e,t,i,s,r,o){hM.set(s,r,o).unproject(i);const l=e[n];if(l!==void 0){const c=t.getAttribute("position");for(let d=0,g=l.length;d<g;d++)c.setXYZ(l[d],hM.x,hM.y,hM.z)}}const pM=new Ra;class F4 extends Ud{constructor(e,t=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=new Float32Array(24),r=new xi;r.setIndex(new hs(i,1)),r.setAttribute("position",new hs(s,3)),super(r,new Qo({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(){if(this.object!==void 0&&pM.setFromObject(this.object),pM.isEmpty())return;const e=pM.min,t=pM.max,i=this.geometry.attributes.position,s=i.array;s[0]=t.x,s[1]=t.y,s[2]=t.z,s[3]=e.x,s[4]=t.y,s[5]=t.z,s[6]=e.x,s[7]=e.y,s[8]=t.z,s[9]=t.x,s[10]=e.y,s[11]=t.z,s[12]=t.x,s[13]=t.y,s[14]=e.z,s[15]=e.x,s[16]=t.y,s[17]=e.z,s[18]=e.x,s[19]=e.y,s[20]=e.z,s[21]=t.x,s[22]=e.y,s[23]=e.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class N4 extends Ud{constructor(e,t=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],r=new xi;r.setIndex(new hs(i,1)),r.setAttribute("position",new Hn(s,3)),super(r,new Qo({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class z4 extends Kh{constructor(e,t=1,i=16776960){const s=i,r=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],o=new xi;o.setAttribute("position",new Hn(r,3)),o.computeBoundingSphere(),super(o,new Qo({color:s,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const l=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],c=new xi;c.setAttribute("position",new Hn(l,3)),c.computeBoundingSphere(),this.add(new ea(c,new qu({color:s,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const bC=new Oe;let mM,Uw;class U4 extends fs{constructor(e=new Oe(0,0,1),t=new Oe(0,0,0),i=1,s=16776960,r=i*.2,o=r*.2){super(),this.type="ArrowHelper",mM===void 0&&(mM=new xi,mM.setAttribute("position",new Hn([0,0,0,0,1,0],3)),Uw=new Jv(.5,1,5,1),Uw.translate(0,-.5,0)),this.position.copy(t),this.line=new Kh(mM,new Qo({color:s,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new ea(Uw,new qu({color:s,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(i,r,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{bC.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(bC,t)}}setLength(e,t=e*.2,i=t*.2){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(i,t,i),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class k4 extends Ud{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],i=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],s=new xi;s.setAttribute("position",new Hn(t,3)),s.setAttribute("color",new Hn(i,3));const r=new Qo({vertexColors:!0,toneMapped:!1});super(s,r),this.type="AxesHelper"}setColors(e,t,i){const s=new Sn,r=this.geometry.attributes.color.array;return s.set(e),s.toArray(r,0),s.toArray(r,3),s.set(t),s.toArray(r,6),s.toArray(r,9),s.set(i),s.toArray(r,12),s.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class G4{constructor(){this.type="ShapePath",this.color=new Sn,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new Db,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,i,s){return this.currentPath.quadraticCurveTo(e,t,i,s),this}bezierCurveTo(e,t,i,s,r,o){return this.currentPath.bezierCurveTo(e,t,i,s,r,o),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(M){const T=[];for(let C=0,x=M.length;C<x;C++){const R=M[C],P=new Fg;P.curves=R.curves,T.push(P)}return T}function i(M,T){const C=T.length;let x=!1;for(let R=C-1,P=0;P<C;R=P++){let D=T[R],z=T[P],U=z.x-D.x,N=z.y-D.y;if(Math.abs(N)>Number.EPSILON){if(N<0&&(D=T[P],U=-U,z=T[R],N=-N),M.y<D.y||M.y>z.y)continue;if(M.y===D.y){if(M.x===D.x)return!0}else{const j=N*(M.x-D.x)-U*(M.y-D.y);if(j===0)return!0;if(j<0)continue;x=!x}}else{if(M.y!==D.y)continue;if(z.x<=M.x&&M.x<=D.x||D.x<=M.x&&M.x<=z.x)return!0}}return x}const s=Od.isClockWise,r=this.subPaths;if(r.length===0)return[];let o,l,c;const d=[];if(r.length===1)return l=r[0],c=new Fg,c.curves=l.curves,d.push(c),d;let g=!s(r[0].getPoints());g=e?!g:g;const p=[],h=[];let v=[],y=0,w;h[y]=void 0,v[y]=[];for(let M=0,T=r.length;M<T;M++)l=r[M],w=l.getPoints(),o=s(w),o=e?!o:o,o?(!g&&h[y]&&y++,h[y]={s:new Fg,p:w},h[y].s.curves=l.curves,g&&y++,v[y]=[]):v[y].push({h:l,p:w[0]});if(!h[0])return t(r);if(h.length>1){let M=!1,T=0;for(let C=0,x=h.length;C<x;C++)p[C]=[];for(let C=0,x=h.length;C<x;C++){const R=v[C];for(let P=0;P<R.length;P++){const D=R[P];let z=!0;for(let U=0;U<h.length;U++)i(D.p,h[U].p)&&(C!==U&&T++,z?(z=!1,p[U].push(D)):M=!0);z&&p[C].push(D)}}T>0&&M===!1&&(v=p)}let S;for(let M=0,T=h.length;M<T;M++){c=h[M].s,d.push(c),S=v[M];for(let C=0,x=S.length;C<x;C++)c.holes.push(S[C].h)}return d}}class V4 extends Zu{constructor(e,t=null){super(),this.object=e,this.domElement=t,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(e){if(e===void 0){console.warn("THREE.Controls: connect() now requires an element.");return}this.domElement!==null&&this.disconnect(),this.domElement=e}disconnect(){}dispose(){}update(){}}function H4(n,e){const t=n.image&&n.image.width?n.image.width/n.image.height:1;return t>e?(n.repeat.x=1,n.repeat.y=t/e,n.offset.x=0,n.offset.y=(1-n.repeat.y)/2):(n.repeat.x=e/t,n.repeat.y=1,n.offset.x=(1-n.repeat.x)/2,n.offset.y=0),n}function j4(n,e){const t=n.image&&n.image.width?n.image.width/n.image.height:1;return t>e?(n.repeat.x=e/t,n.repeat.y=1,n.offset.x=(1-n.repeat.x)/2,n.offset.y=0):(n.repeat.x=1,n.repeat.y=t/e,n.offset.x=0,n.offset.y=(1-n.repeat.y)/2),n}function $4(n){return n.repeat.x=1,n.repeat.y=1,n.offset.x=0,n.offset.y=0,n}function BE(n,e,t,i){const s=W4(i);switch(t){case mT:return n*e;case Zb:return n*e/s.components*s.byteLength;case Wv:return n*e/s.components*s.byteLength;case _T:return n*e*2/s.components*s.byteLength;case ex:return n*e*2/s.components*s.byteLength;case gT:return n*e*3/s.components*s.byteLength;case Xo:return n*e*4/s.components*s.byteLength;case tx:return n*e*4/s.components*s.byteLength;case vv:case yv:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case Mv:case bv:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case nb:case sb:return Math.max(n,16)*Math.max(e,8)/4;case tb:case ib:return Math.max(n,8)*Math.max(e,8)/2;case rb:case ab:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case ob:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case lb:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case ub:return Math.floor((n+4)/5)*Math.floor((e+3)/4)*16;case cb:return Math.floor((n+4)/5)*Math.floor((e+4)/5)*16;case db:return Math.floor((n+5)/6)*Math.floor((e+4)/5)*16;case fb:return Math.floor((n+5)/6)*Math.floor((e+5)/6)*16;case hb:return Math.floor((n+7)/8)*Math.floor((e+4)/5)*16;case pb:return Math.floor((n+7)/8)*Math.floor((e+5)/6)*16;case mb:return Math.floor((n+7)/8)*Math.floor((e+7)/8)*16;case gb:return Math.floor((n+9)/10)*Math.floor((e+4)/5)*16;case _b:return Math.floor((n+9)/10)*Math.floor((e+5)/6)*16;case vb:return Math.floor((n+9)/10)*Math.floor((e+7)/8)*16;case yb:return Math.floor((n+9)/10)*Math.floor((e+9)/10)*16;case Mb:return Math.floor((n+11)/12)*Math.floor((e+9)/10)*16;case bb:return Math.floor((n+11)/12)*Math.floor((e+11)/12)*16;case xv:case xb:case wb:return Math.ceil(n/4)*Math.ceil(e/4)*16;case vT:case Eb:return Math.ceil(n/4)*Math.ceil(e/4)*8;case Tb:case Sb:return Math.ceil(n/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${t} format.`)}function W4(n){switch(n){case Ha:case fT:return{byteLength:1,components:1};case n0:case hT:case Jg:return{byteLength:2,components:1};case Jb:case Qb:return{byteLength:2,components:4};case kf:case Yb:case Rl:return{byteLength:4,components:1};case pT:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${n}.`)}class K4{static contain(e,t){return H4(e,t)}static cover(e,t){return j4(e,t)}static fill(e){return $4(e)}static getByteLength(e,t,i,s){return BE(e,t,i,s)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Yg}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Yg);function dO(){let n=null,e=!1,t=null,i=null;function s(r,o){t(r,o),i=n.requestAnimationFrame(s)}return{start:function(){e!==!0&&t!==null&&(i=n.requestAnimationFrame(s),e=!0)},stop:function(){n.cancelAnimationFrame(i),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){n=r}}}function q4(n){const e=new WeakMap;function t(l,c){const d=l.array,g=l.usage,p=d.byteLength,h=n.createBuffer();n.bindBuffer(c,h),n.bufferData(c,d,g),l.onUploadCallback();let v;if(d instanceof Float32Array)v=n.FLOAT;else if(typeof Float16Array<"u"&&d instanceof Float16Array)v=n.HALF_FLOAT;else if(d instanceof Uint16Array)l.isFloat16BufferAttribute?v=n.HALF_FLOAT:v=n.UNSIGNED_SHORT;else if(d instanceof Int16Array)v=n.SHORT;else if(d instanceof Uint32Array)v=n.UNSIGNED_INT;else if(d instanceof Int32Array)v=n.INT;else if(d instanceof Int8Array)v=n.BYTE;else if(d instanceof Uint8Array)v=n.UNSIGNED_BYTE;else if(d instanceof Uint8ClampedArray)v=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+d);return{buffer:h,type:v,bytesPerElement:d.BYTES_PER_ELEMENT,version:l.version,size:p}}function i(l,c,d){const g=c.array,p=c.updateRanges;if(n.bindBuffer(d,l),p.length===0)n.bufferSubData(d,0,g);else{p.sort((v,y)=>v.start-y.start);let h=0;for(let v=1;v<p.length;v++){const y=p[h],w=p[v];w.start<=y.start+y.count+1?y.count=Math.max(y.count,w.start+w.count-y.start):(++h,p[h]=w)}p.length=h+1;for(let v=0,y=p.length;v<y;v++){const w=p[v];n.bufferSubData(d,w.start*g.BYTES_PER_ELEMENT,g,w.start,w.count)}c.clearUpdateRanges()}c.onUploadCallback()}function s(l){return l.isInterleavedBufferAttribute&&(l=l.data),e.get(l)}function r(l){l.isInterleavedBufferAttribute&&(l=l.data);const c=e.get(l);c&&(n.deleteBuffer(c.buffer),e.delete(l))}function o(l,c){if(l.isInterleavedBufferAttribute&&(l=l.data),l.isGLBufferAttribute){const g=e.get(l);(!g||g.version<l.version)&&e.set(l,{buffer:l.buffer,type:l.type,bytesPerElement:l.elementSize,version:l.version});return}const d=e.get(l);if(d===void 0)e.set(l,t(l,c));else if(d.version<l.version){if(d.size!==l.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");i(d.buffer,l,c),d.version=l.version}}return{get:s,remove:r,update:o}}var X4=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,Y4=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,J4=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,Q4=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Z4=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,eG=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,tG=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,nG=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,iG=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,sG=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,rG=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,aG=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,oG=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,lG=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,uG=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,cG=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,dG=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,fG=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,hG=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,pG=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,mG=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,gG=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,_G=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,vG=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,yG=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,MG=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,bG=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,xG=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,wG=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,EG=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,TG="gl_FragColor = linearToOutputTexel( gl_FragColor );",SG=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,AG=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,CG=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,PG=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,RG=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,DG=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,BG=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,IG=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,OG=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,LG=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,FG=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,NG=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,zG=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,UG=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,kG=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,GG=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,VG=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,HG=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,jG=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,$G=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,WG=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,KG=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,qG=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,XG=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,YG=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,JG=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,QG=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,ZG=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,eV=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,tV=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,nV=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,iV=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,sV=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,rV=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,aV=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,oV=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,lV=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,uV=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,cV=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,dV=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,fV=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,hV=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,pV=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,mV=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,gV=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,_V=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,vV=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,yV=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,MV=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,bV=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,xV=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,wV=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,EV=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,TV=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,SV=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,AV=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,CV=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,PV=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,RV=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSEDEPTHBUF
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSEDEPTHBUF
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare , distribution.x );
		#endif
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,DV=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,BV=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,IV=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,OV=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,LV=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,FV=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,NV=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,zV=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,UV=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,kV=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,GV=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,VV=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,HV=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,jV=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,$V=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,WV=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,KV=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const qV=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,XV=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,YV=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,JV=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,QV=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,ZV=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,eH=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,tH=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSEDEPTHBUF
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,nH=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,iH=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,sH=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,rH=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,aH=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,oH=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,lH=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,uH=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,cH=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,dH=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,fH=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,hH=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,pH=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,mH=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,gH=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,_H=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vH=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,yH=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,MH=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,bH=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,xH=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,wH=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,EH=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,TH=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,SH=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,AH=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Ni={alphahash_fragment:X4,alphahash_pars_fragment:Y4,alphamap_fragment:J4,alphamap_pars_fragment:Q4,alphatest_fragment:Z4,alphatest_pars_fragment:eG,aomap_fragment:tG,aomap_pars_fragment:nG,batching_pars_vertex:iG,batching_vertex:sG,begin_vertex:rG,beginnormal_vertex:aG,bsdfs:oG,iridescence_fragment:lG,bumpmap_pars_fragment:uG,clipping_planes_fragment:cG,clipping_planes_pars_fragment:dG,clipping_planes_pars_vertex:fG,clipping_planes_vertex:hG,color_fragment:pG,color_pars_fragment:mG,color_pars_vertex:gG,color_vertex:_G,common:vG,cube_uv_reflection_fragment:yG,defaultnormal_vertex:MG,displacementmap_pars_vertex:bG,displacementmap_vertex:xG,emissivemap_fragment:wG,emissivemap_pars_fragment:EG,colorspace_fragment:TG,colorspace_pars_fragment:SG,envmap_fragment:AG,envmap_common_pars_fragment:CG,envmap_pars_fragment:PG,envmap_pars_vertex:RG,envmap_physical_pars_fragment:GG,envmap_vertex:DG,fog_vertex:BG,fog_pars_vertex:IG,fog_fragment:OG,fog_pars_fragment:LG,gradientmap_pars_fragment:FG,lightmap_pars_fragment:NG,lights_lambert_fragment:zG,lights_lambert_pars_fragment:UG,lights_pars_begin:kG,lights_toon_fragment:VG,lights_toon_pars_fragment:HG,lights_phong_fragment:jG,lights_phong_pars_fragment:$G,lights_physical_fragment:WG,lights_physical_pars_fragment:KG,lights_fragment_begin:qG,lights_fragment_maps:XG,lights_fragment_end:YG,logdepthbuf_fragment:JG,logdepthbuf_pars_fragment:QG,logdepthbuf_pars_vertex:ZG,logdepthbuf_vertex:eV,map_fragment:tV,map_pars_fragment:nV,map_particle_fragment:iV,map_particle_pars_fragment:sV,metalnessmap_fragment:rV,metalnessmap_pars_fragment:aV,morphinstance_vertex:oV,morphcolor_vertex:lV,morphnormal_vertex:uV,morphtarget_pars_vertex:cV,morphtarget_vertex:dV,normal_fragment_begin:fV,normal_fragment_maps:hV,normal_pars_fragment:pV,normal_pars_vertex:mV,normal_vertex:gV,normalmap_pars_fragment:_V,clearcoat_normal_fragment_begin:vV,clearcoat_normal_fragment_maps:yV,clearcoat_pars_fragment:MV,iridescence_pars_fragment:bV,opaque_fragment:xV,packing:wV,premultiplied_alpha_fragment:EV,project_vertex:TV,dithering_fragment:SV,dithering_pars_fragment:AV,roughnessmap_fragment:CV,roughnessmap_pars_fragment:PV,shadowmap_pars_fragment:RV,shadowmap_pars_vertex:DV,shadowmap_vertex:BV,shadowmask_pars_fragment:IV,skinbase_vertex:OV,skinning_pars_vertex:LV,skinning_vertex:FV,skinnormal_vertex:NV,specularmap_fragment:zV,specularmap_pars_fragment:UV,tonemapping_fragment:kV,tonemapping_pars_fragment:GV,transmission_fragment:VV,transmission_pars_fragment:HV,uv_pars_fragment:jV,uv_pars_vertex:$V,uv_vertex:WV,worldpos_vertex:KV,background_vert:qV,background_frag:XV,backgroundCube_vert:YV,backgroundCube_frag:JV,cube_vert:QV,cube_frag:ZV,depth_vert:eH,depth_frag:tH,distanceRGBA_vert:nH,distanceRGBA_frag:iH,equirect_vert:sH,equirect_frag:rH,linedashed_vert:aH,linedashed_frag:oH,meshbasic_vert:lH,meshbasic_frag:uH,meshlambert_vert:cH,meshlambert_frag:dH,meshmatcap_vert:fH,meshmatcap_frag:hH,meshnormal_vert:pH,meshnormal_frag:mH,meshphong_vert:gH,meshphong_frag:_H,meshphysical_vert:vH,meshphysical_frag:yH,meshtoon_vert:MH,meshtoon_frag:bH,points_vert:xH,points_frag:wH,shadow_vert:EH,shadow_frag:TH,sprite_vert:SH,sprite_frag:AH},Dn={common:{diffuse:{value:new Sn(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Ai},alphaMap:{value:null},alphaMapTransform:{value:new Ai},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Ai}},envmap:{envMap:{value:null},envMapRotation:{value:new Ai},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Ai}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Ai}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Ai},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Ai},normalScale:{value:new Gt(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Ai},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Ai}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Ai}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Ai}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Sn(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Sn(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Ai},alphaTest:{value:0},uvTransform:{value:new Ai}},sprite:{diffuse:{value:new Sn(16777215)},opacity:{value:1},center:{value:new Gt(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Ai},alphaMap:{value:null},alphaMapTransform:{value:new Ai},alphaTest:{value:0}}},Rd={basic:{uniforms:Al([Dn.common,Dn.specularmap,Dn.envmap,Dn.aomap,Dn.lightmap,Dn.fog]),vertexShader:Ni.meshbasic_vert,fragmentShader:Ni.meshbasic_frag},lambert:{uniforms:Al([Dn.common,Dn.specularmap,Dn.envmap,Dn.aomap,Dn.lightmap,Dn.emissivemap,Dn.bumpmap,Dn.normalmap,Dn.displacementmap,Dn.fog,Dn.lights,{emissive:{value:new Sn(0)}}]),vertexShader:Ni.meshlambert_vert,fragmentShader:Ni.meshlambert_frag},phong:{uniforms:Al([Dn.common,Dn.specularmap,Dn.envmap,Dn.aomap,Dn.lightmap,Dn.emissivemap,Dn.bumpmap,Dn.normalmap,Dn.displacementmap,Dn.fog,Dn.lights,{emissive:{value:new Sn(0)},specular:{value:new Sn(1118481)},shininess:{value:30}}]),vertexShader:Ni.meshphong_vert,fragmentShader:Ni.meshphong_frag},standard:{uniforms:Al([Dn.common,Dn.envmap,Dn.aomap,Dn.lightmap,Dn.emissivemap,Dn.bumpmap,Dn.normalmap,Dn.displacementmap,Dn.roughnessmap,Dn.metalnessmap,Dn.fog,Dn.lights,{emissive:{value:new Sn(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ni.meshphysical_vert,fragmentShader:Ni.meshphysical_frag},toon:{uniforms:Al([Dn.common,Dn.aomap,Dn.lightmap,Dn.emissivemap,Dn.bumpmap,Dn.normalmap,Dn.displacementmap,Dn.gradientmap,Dn.fog,Dn.lights,{emissive:{value:new Sn(0)}}]),vertexShader:Ni.meshtoon_vert,fragmentShader:Ni.meshtoon_frag},matcap:{uniforms:Al([Dn.common,Dn.bumpmap,Dn.normalmap,Dn.displacementmap,Dn.fog,{matcap:{value:null}}]),vertexShader:Ni.meshmatcap_vert,fragmentShader:Ni.meshmatcap_frag},points:{uniforms:Al([Dn.points,Dn.fog]),vertexShader:Ni.points_vert,fragmentShader:Ni.points_frag},dashed:{uniforms:Al([Dn.common,Dn.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ni.linedashed_vert,fragmentShader:Ni.linedashed_frag},depth:{uniforms:Al([Dn.common,Dn.displacementmap]),vertexShader:Ni.depth_vert,fragmentShader:Ni.depth_frag},normal:{uniforms:Al([Dn.common,Dn.bumpmap,Dn.normalmap,Dn.displacementmap,{opacity:{value:1}}]),vertexShader:Ni.meshnormal_vert,fragmentShader:Ni.meshnormal_frag},sprite:{uniforms:Al([Dn.sprite,Dn.fog]),vertexShader:Ni.sprite_vert,fragmentShader:Ni.sprite_frag},background:{uniforms:{uvTransform:{value:new Ai},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Ni.background_vert,fragmentShader:Ni.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Ai}},vertexShader:Ni.backgroundCube_vert,fragmentShader:Ni.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Ni.cube_vert,fragmentShader:Ni.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ni.equirect_vert,fragmentShader:Ni.equirect_frag},distanceRGBA:{uniforms:Al([Dn.common,Dn.displacementmap,{referencePosition:{value:new Oe},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ni.distanceRGBA_vert,fragmentShader:Ni.distanceRGBA_frag},shadow:{uniforms:Al([Dn.lights,Dn.fog,{color:{value:new Sn(0)},opacity:{value:1}}]),vertexShader:Ni.shadow_vert,fragmentShader:Ni.shadow_frag}};Rd.physical={uniforms:Al([Rd.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Ai},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Ai},clearcoatNormalScale:{value:new Gt(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Ai},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Ai},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Ai},sheen:{value:0},sheenColor:{value:new Sn(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Ai},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Ai},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Ai},transmissionSamplerSize:{value:new Gt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Ai},attenuationDistance:{value:0},attenuationColor:{value:new Sn(0)},specularColor:{value:new Sn(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Ai},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Ai},anisotropyVector:{value:new Gt},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Ai}}]),vertexShader:Ni.meshphysical_vert,fragmentShader:Ni.meshphysical_frag};const gM={r:0,b:0,g:0},fg=new Ju,CH=new li;function PH(n,e,t,i,s,r,o){const l=new Sn(0);let c=r===!0?0:1,d,g,p=null,h=0,v=null;function y(C){let x=C.isScene===!0?C.background:null;return x&&x.isTexture&&(x=(C.backgroundBlurriness>0?t:e).get(x)),x}function w(C){let x=!1;const R=y(C);R===null?M(l,c):R&&R.isColor&&(M(R,1),x=!0);const P=n.xr.getEnvironmentBlendMode();P==="additive"?i.buffers.color.setClear(0,0,0,1,o):P==="alpha-blend"&&i.buffers.color.setClear(0,0,0,0,o),(n.autoClear||x)&&(i.buffers.depth.setTest(!0),i.buffers.depth.setMask(!0),i.buffers.color.setMask(!0),n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil))}function S(C,x){const R=y(x);R&&(R.isCubeTexture||R.mapping===g0)?(g===void 0&&(g=new ea(new Zg(1,1,1),new ja({name:"BackgroundCubeMaterial",uniforms:u0(Rd.backgroundCube.uniforms),vertexShader:Rd.backgroundCube.vertexShader,fragmentShader:Rd.backgroundCube.fragmentShader,side:Ga,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),g.geometry.deleteAttribute("normal"),g.geometry.deleteAttribute("uv"),g.onBeforeRender=function(P,D,z){this.matrixWorld.copyPosition(z.matrixWorld)},Object.defineProperty(g.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),s.update(g)),fg.copy(x.backgroundRotation),fg.x*=-1,fg.y*=-1,fg.z*=-1,R.isCubeTexture&&R.isRenderTargetTexture===!1&&(fg.y*=-1,fg.z*=-1),g.material.uniforms.envMap.value=R,g.material.uniforms.flipEnvMap.value=R.isCubeTexture&&R.isRenderTargetTexture===!1?-1:1,g.material.uniforms.backgroundBlurriness.value=x.backgroundBlurriness,g.material.uniforms.backgroundIntensity.value=x.backgroundIntensity,g.material.uniforms.backgroundRotation.value.setFromMatrix4(CH.makeRotationFromEuler(fg)),g.material.toneMapped=us.getTransfer(R.colorSpace)!==js,(p!==R||h!==R.version||v!==n.toneMapping)&&(g.material.needsUpdate=!0,p=R,h=R.version,v=n.toneMapping),g.layers.enableAll(),C.unshift(g,g.geometry,g.material,0,0,null)):R&&R.isTexture&&(d===void 0&&(d=new ea(new v0(2,2),new ja({name:"BackgroundMaterial",uniforms:u0(Rd.background.uniforms),vertexShader:Rd.background.vertexShader,fragmentShader:Rd.background.fragmentShader,side:Nd,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),d.geometry.deleteAttribute("normal"),Object.defineProperty(d.material,"map",{get:function(){return this.uniforms.t2D.value}}),s.update(d)),d.material.uniforms.t2D.value=R,d.material.uniforms.backgroundIntensity.value=x.backgroundIntensity,d.material.toneMapped=us.getTransfer(R.colorSpace)!==js,R.matrixAutoUpdate===!0&&R.updateMatrix(),d.material.uniforms.uvTransform.value.copy(R.matrix),(p!==R||h!==R.version||v!==n.toneMapping)&&(d.material.needsUpdate=!0,p=R,h=R.version,v=n.toneMapping),d.layers.enableAll(),C.unshift(d,d.geometry,d.material,0,0,null))}function M(C,x){C.getRGB(gM,vI(n)),i.buffers.color.setClear(gM.r,gM.g,gM.b,x,o)}function T(){g!==void 0&&(g.geometry.dispose(),g.material.dispose(),g=void 0),d!==void 0&&(d.geometry.dispose(),d.material.dispose(),d=void 0)}return{getClearColor:function(){return l},setClearColor:function(C,x=1){l.set(C),c=x,M(l,c)},getClearAlpha:function(){return c},setClearAlpha:function(C){c=C,M(l,c)},render:w,addToRenderList:S,dispose:T}}function RH(n,e){const t=n.getParameter(n.MAX_VERTEX_ATTRIBS),i={},s=h(null);let r=s,o=!1;function l(N,j,J,W,oe){let ne=!1;const q=p(W,J,j);r!==q&&(r=q,d(r.object)),ne=v(N,W,J,oe),ne&&y(N,W,J,oe),oe!==null&&e.update(oe,n.ELEMENT_ARRAY_BUFFER),(ne||o)&&(o=!1,x(N,j,J,W),oe!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e.get(oe).buffer))}function c(){return n.createVertexArray()}function d(N){return n.bindVertexArray(N)}function g(N){return n.deleteVertexArray(N)}function p(N,j,J){const W=J.wireframe===!0;let oe=i[N.id];oe===void 0&&(oe={},i[N.id]=oe);let ne=oe[j.id];ne===void 0&&(ne={},oe[j.id]=ne);let q=ne[W];return q===void 0&&(q=h(c()),ne[W]=q),q}function h(N){const j=[],J=[],W=[];for(let oe=0;oe<t;oe++)j[oe]=0,J[oe]=0,W[oe]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:j,enabledAttributes:J,attributeDivisors:W,object:N,attributes:{},index:null}}function v(N,j,J,W){const oe=r.attributes,ne=j.attributes;let q=0;const le=J.getAttributes();for(const se in le)if(le[se].location>=0){const be=oe[se];let ee=ne[se];if(ee===void 0&&(se==="instanceMatrix"&&N.instanceMatrix&&(ee=N.instanceMatrix),se==="instanceColor"&&N.instanceColor&&(ee=N.instanceColor)),be===void 0||be.attribute!==ee||ee&&be.data!==ee.data)return!0;q++}return r.attributesNum!==q||r.index!==W}function y(N,j,J,W){const oe={},ne=j.attributes;let q=0;const le=J.getAttributes();for(const se in le)if(le[se].location>=0){let be=ne[se];be===void 0&&(se==="instanceMatrix"&&N.instanceMatrix&&(be=N.instanceMatrix),se==="instanceColor"&&N.instanceColor&&(be=N.instanceColor));const ee={};ee.attribute=be,be&&be.data&&(ee.data=be.data),oe[se]=ee,q++}r.attributes=oe,r.attributesNum=q,r.index=W}function w(){const N=r.newAttributes;for(let j=0,J=N.length;j<J;j++)N[j]=0}function S(N){M(N,0)}function M(N,j){const J=r.newAttributes,W=r.enabledAttributes,oe=r.attributeDivisors;J[N]=1,W[N]===0&&(n.enableVertexAttribArray(N),W[N]=1),oe[N]!==j&&(n.vertexAttribDivisor(N,j),oe[N]=j)}function T(){const N=r.newAttributes,j=r.enabledAttributes;for(let J=0,W=j.length;J<W;J++)j[J]!==N[J]&&(n.disableVertexAttribArray(J),j[J]=0)}function C(N,j,J,W,oe,ne,q){q===!0?n.vertexAttribIPointer(N,j,J,oe,ne):n.vertexAttribPointer(N,j,J,W,oe,ne)}function x(N,j,J,W){w();const oe=W.attributes,ne=J.getAttributes(),q=j.defaultAttributeValues;for(const le in ne){const se=ne[le];if(se.location>=0){let pe=oe[le];if(pe===void 0&&(le==="instanceMatrix"&&N.instanceMatrix&&(pe=N.instanceMatrix),le==="instanceColor"&&N.instanceColor&&(pe=N.instanceColor)),pe!==void 0){const be=pe.normalized,ee=pe.itemSize,te=e.get(pe);if(te===void 0)continue;const ue=te.buffer,ae=te.type,ce=te.bytesPerElement,Be=ae===n.INT||ae===n.UNSIGNED_INT||pe.gpuType===Yb;if(pe.isInterleavedBufferAttribute){const He=pe.data,Xe=He.stride,ot=pe.offset;if(He.isInstancedInterleavedBuffer){for(let tt=0;tt<se.locationSize;tt++)M(se.location+tt,He.meshPerAttribute);N.isInstancedMesh!==!0&&W._maxInstanceCount===void 0&&(W._maxInstanceCount=He.meshPerAttribute*He.count)}else for(let tt=0;tt<se.locationSize;tt++)S(se.location+tt);n.bindBuffer(n.ARRAY_BUFFER,ue);for(let tt=0;tt<se.locationSize;tt++)C(se.location+tt,ee/se.locationSize,ae,be,Xe*ce,(ot+ee/se.locationSize*tt)*ce,Be)}else{if(pe.isInstancedBufferAttribute){for(let He=0;He<se.locationSize;He++)M(se.location+He,pe.meshPerAttribute);N.isInstancedMesh!==!0&&W._maxInstanceCount===void 0&&(W._maxInstanceCount=pe.meshPerAttribute*pe.count)}else for(let He=0;He<se.locationSize;He++)S(se.location+He);n.bindBuffer(n.ARRAY_BUFFER,ue);for(let He=0;He<se.locationSize;He++)C(se.location+He,ee/se.locationSize,ae,be,ee*ce,ee/se.locationSize*He*ce,Be)}}else if(q!==void 0){const be=q[le];if(be!==void 0)switch(be.length){case 2:n.vertexAttrib2fv(se.location,be);break;case 3:n.vertexAttrib3fv(se.location,be);break;case 4:n.vertexAttrib4fv(se.location,be);break;default:n.vertexAttrib1fv(se.location,be)}}}}T()}function R(){z();for(const N in i){const j=i[N];for(const J in j){const W=j[J];for(const oe in W)g(W[oe].object),delete W[oe];delete j[J]}delete i[N]}}function P(N){if(i[N.id]===void 0)return;const j=i[N.id];for(const J in j){const W=j[J];for(const oe in W)g(W[oe].object),delete W[oe];delete j[J]}delete i[N.id]}function D(N){for(const j in i){const J=i[j];if(J[N.id]===void 0)continue;const W=J[N.id];for(const oe in W)g(W[oe].object),delete W[oe];delete J[N.id]}}function z(){U(),o=!0,r!==s&&(r=s,d(r.object))}function U(){s.geometry=null,s.program=null,s.wireframe=!1}return{setup:l,reset:z,resetDefaultState:U,dispose:R,releaseStatesOfGeometry:P,releaseStatesOfProgram:D,initAttributes:w,enableAttribute:S,disableUnusedAttributes:T}}function DH(n,e,t){let i;function s(d){i=d}function r(d,g){n.drawArrays(i,d,g),t.update(g,i,1)}function o(d,g,p){p!==0&&(n.drawArraysInstanced(i,d,g,p),t.update(g,i,p))}function l(d,g,p){if(p===0)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i,d,0,g,0,p);let v=0;for(let y=0;y<p;y++)v+=g[y];t.update(v,i,1)}function c(d,g,p,h){if(p===0)return;const v=e.get("WEBGL_multi_draw");if(v===null)for(let y=0;y<d.length;y++)o(d[y],g[y],h[y]);else{v.multiDrawArraysInstancedWEBGL(i,d,0,g,0,h,0,p);let y=0;for(let w=0;w<p;w++)y+=g[w]*h[w];t.update(y,i,1)}}this.setMode=s,this.render=r,this.renderInstances=o,this.renderMultiDraw=l,this.renderMultiDrawInstances=c}function BH(n,e,t,i){let s;function r(){if(s!==void 0)return s;if(e.has("EXT_texture_filter_anisotropic")===!0){const D=e.get("EXT_texture_filter_anisotropic");s=n.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s}function o(D){return!(D!==Xo&&i.convert(D)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))}function l(D){const z=D===Jg&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(D!==Ha&&i.convert(D)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE)&&D!==Rl&&!z)}function c(D){if(D==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";D="mediump"}return D==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let d=t.precision!==void 0?t.precision:"highp";const g=c(d);g!==d&&(console.warn("THREE.WebGLRenderer:",d,"not supported, using",g,"instead."),d=g);const p=t.logarithmicDepthBuffer===!0,h=t.reversedDepthBuffer===!0&&e.has("EXT_clip_control"),v=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),y=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),w=n.getParameter(n.MAX_TEXTURE_SIZE),S=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),M=n.getParameter(n.MAX_VERTEX_ATTRIBS),T=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),C=n.getParameter(n.MAX_VARYING_VECTORS),x=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),R=y>0,P=n.getParameter(n.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:r,getMaxPrecision:c,textureFormatReadable:o,textureTypeReadable:l,precision:d,logarithmicDepthBuffer:p,reversedDepthBuffer:h,maxTextures:v,maxVertexTextures:y,maxTextureSize:w,maxCubemapSize:S,maxAttributes:M,maxVertexUniforms:T,maxVaryings:C,maxFragmentUniforms:x,vertexTextures:R,maxSamples:P}}function IH(n){const e=this;let t=null,i=0,s=!1,r=!1;const o=new Uh,l=new Ai,c={value:null,needsUpdate:!1};this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(p,h){const v=p.length!==0||h||i!==0||s;return s=h,i=p.length,v},this.beginShadows=function(){r=!0,g(null)},this.endShadows=function(){r=!1},this.setGlobalState=function(p,h){t=g(p,h,0)},this.setState=function(p,h,v){const y=p.clippingPlanes,w=p.clipIntersection,S=p.clipShadows,M=n.get(p);if(!s||y===null||y.length===0||r&&!S)r?g(null):d();else{const T=r?0:i,C=T*4;let x=M.clippingState||null;c.value=x,x=g(y,h,C,v);for(let R=0;R!==C;++R)x[R]=t[R];M.clippingState=x,this.numIntersection=w?this.numPlanes:0,this.numPlanes+=T}};function d(){c.value!==t&&(c.value=t,c.needsUpdate=i>0),e.numPlanes=i,e.numIntersection=0}function g(p,h,v,y){const w=p!==null?p.length:0;let S=null;if(w!==0){if(S=c.value,y!==!0||S===null){const M=v+w*4,T=h.matrixWorldInverse;l.getNormalMatrix(T),(S===null||S.length<M)&&(S=new Float32Array(M));for(let C=0,x=v;C!==w;++C,x+=4)o.copy(p[C]).applyMatrix4(T,l),o.normal.toArray(S,x),S[x+3]=o.constant}c.value=S,c.needsUpdate=!0}return e.numPlanes=w,e.numIntersection=0,S}}function OH(n){let e=new WeakMap;function t(o,l){return l===Rv?o.mapping=Wh:l===Dv&&(o.mapping=dm),o}function i(o){if(o&&o.isTexture){const l=o.mapping;if(l===Rv||l===Dv)if(e.has(o)){const c=e.get(o).texture;return t(c,o.mapping)}else{const c=o.image;if(c&&c.height>0){const d=new bI(c.height);return d.fromEquirectangularTexture(n,o),e.set(o,d),o.addEventListener("dispose",s),t(d.texture,o.mapping)}else return null}}return o}function s(o){const l=o.target;l.removeEventListener("dispose",s);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function r(){e=new WeakMap}return{get:i,dispose:r}}const q_=4,xC=[.125,.215,.35,.446,.526,.582],Eg=20,kw=new Lc,wC=new Sn;let Gw=null,Vw=0,Hw=0,jw=!1;const xg=(1+Math.sqrt(5))/2,k_=1/xg,EC=[new Oe(-xg,k_,0),new Oe(xg,k_,0),new Oe(-k_,0,xg),new Oe(k_,0,xg),new Oe(0,xg,-k_),new Oe(0,xg,k_),new Oe(-1,1,-1),new Oe(1,1,-1),new Oe(-1,1,1),new Oe(1,1,1)],LH=new Oe;class IE{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,i=.1,s=100,r={}){const{size:o=256,position:l=LH}=r;Gw=this._renderer.getRenderTarget(),Vw=this._renderer.getActiveCubeFace(),Hw=this._renderer.getActiveMipmapLevel(),jw=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(o);const c=this._allocateTargets();return c.depthBuffer=!0,this._sceneToCubeUV(e,i,s,c,l),t>0&&this._blur(c,0,0,t),this._applyPMREM(c),this._cleanup(c),c}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=AC(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=SC(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(Gw,Vw,Hw),this._renderer.xr.enabled=jw,e.scissorTest=!1,_M(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===Wh||e.mapping===dm?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),Gw=this._renderer.getRenderTarget(),Vw=this._renderer.getActiveCubeFace(),Hw=this._renderer.getActiveMipmapLevel(),jw=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const i=t||this._allocateTargets();return this._textureToCubeUV(e,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,i={magFilter:Tr,minFilter:Tr,generateMipmaps:!1,type:Jg,format:Xo,colorSpace:Gf,depthBuffer:!1},s=TC(e,t,i);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=TC(e,t,i);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=FH(r)),this._blurMaterial=NH(r,e,t)}return s}_compileMaterial(e){const t=new ea(this._lodPlanes[0],e);this._renderer.compile(t,kw)}_sceneToCubeUV(e,t,i,s,r){const c=new Er(90,1,t,i),d=[1,-1,1,1,1,1],g=[1,1,1,-1,-1,-1],p=this._renderer,h=p.autoClear,v=p.toneMapping;p.getClearColor(wC),p.toneMapping=Ld,p.autoClear=!1,p.state.buffers.depth.getReversed()&&(p.setRenderTarget(s),p.clearDepth(),p.setRenderTarget(null));const w=new qu({name:"PMREM.Background",side:Ga,depthWrite:!1,depthTest:!1}),S=new ea(new Zg,w);let M=!1;const T=e.background;T?T.isColor&&(w.color.copy(T),e.background=null,M=!0):(w.color.copy(wC),M=!0);for(let C=0;C<6;C++){const x=C%3;x===0?(c.up.set(0,d[C],0),c.position.set(r.x,r.y,r.z),c.lookAt(r.x+g[C],r.y,r.z)):x===1?(c.up.set(0,0,d[C]),c.position.set(r.x,r.y,r.z),c.lookAt(r.x,r.y+g[C],r.z)):(c.up.set(0,d[C],0),c.position.set(r.x,r.y,r.z),c.lookAt(r.x,r.y,r.z+g[C]));const R=this._cubeSize;_M(s,x*R,C>2?R:0,R,R),p.setRenderTarget(s),M&&p.render(S,c),p.render(e,c)}S.geometry.dispose(),S.material.dispose(),p.toneMapping=v,p.autoClear=h,e.background=T}_textureToCubeUV(e,t){const i=this._renderer,s=e.mapping===Wh||e.mapping===dm;s?(this._cubemapMaterial===null&&(this._cubemapMaterial=AC()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=SC());const r=s?this._cubemapMaterial:this._equirectMaterial,o=new ea(this._lodPlanes[0],r),l=r.uniforms;l.envMap.value=e;const c=this._cubeSize;_M(t,0,0,3*c,2*c),i.setRenderTarget(t),i.render(o,kw)}_applyPMREM(e){const t=this._renderer,i=t.autoClear;t.autoClear=!1;const s=this._lodPlanes.length;for(let r=1;r<s;r++){const o=Math.sqrt(this._sigmas[r]*this._sigmas[r]-this._sigmas[r-1]*this._sigmas[r-1]),l=EC[(s-r-1)%EC.length];this._blur(e,r-1,r,o,l)}t.autoClear=i}_blur(e,t,i,s,r){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,i,s,"latitudinal",r),this._halfBlur(o,e,i,i,s,"longitudinal",r)}_halfBlur(e,t,i,s,r,o,l){const c=this._renderer,d=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const g=3,p=new ea(this._lodPlanes[s],d),h=d.uniforms,v=this._sizeLods[i]-1,y=isFinite(r)?Math.PI/(2*v):2*Math.PI/(2*Eg-1),w=r/y,S=isFinite(r)?1+Math.floor(g*w):Eg;S>Eg&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${S} samples when the maximum is set to ${Eg}`);const M=[];let T=0;for(let D=0;D<Eg;++D){const z=D/w,U=Math.exp(-z*z/2);M.push(U),D===0?T+=U:D<S&&(T+=2*U)}for(let D=0;D<M.length;D++)M[D]=M[D]/T;h.envMap.value=e.texture,h.samples.value=S,h.weights.value=M,h.latitudinal.value=o==="latitudinal",l&&(h.poleAxis.value=l);const{_lodMax:C}=this;h.dTheta.value=y,h.mipInt.value=C-i;const x=this._sizeLods[s],R=3*x*(s>C-q_?s-C+q_:0),P=4*(this._cubeSize-x);_M(t,R,P,3*x,2*x),c.setRenderTarget(t),c.render(p,kw)}}function FH(n){const e=[],t=[],i=[];let s=n;const r=n-q_+1+xC.length;for(let o=0;o<r;o++){const l=Math.pow(2,s);t.push(l);let c=1/l;o>n-q_?c=xC[o-n+q_-1]:o===0&&(c=0),i.push(c);const d=1/(l-2),g=-d,p=1+d,h=[g,g,p,g,p,p,g,g,p,p,g,p],v=6,y=6,w=3,S=2,M=1,T=new Float32Array(w*y*v),C=new Float32Array(S*y*v),x=new Float32Array(M*y*v);for(let P=0;P<v;P++){const D=P%3*2/3-1,z=P>2?0:-1,U=[D,z,0,D+2/3,z,0,D+2/3,z+1,0,D,z,0,D+2/3,z+1,0,D,z+1,0];T.set(U,w*y*P),C.set(h,S*y*P);const N=[P,P,P,P,P,P];x.set(N,M*y*P)}const R=new xi;R.setAttribute("position",new hs(T,w)),R.setAttribute("uv",new hs(C,S)),R.setAttribute("faceIndex",new hs(x,M)),e.push(R),s>q_&&s--}return{lodPlanes:e,sizeLods:t,sigmas:i}}function TC(n,e,t){const i=new Da(n,e,t);return i.texture.mapping=g0,i.texture.name="PMREM.cubeUv",i.scissorTest=!0,i}function _M(n,e,t,i,s){n.viewport.set(e,t,i,s),n.scissor.set(e,t,i,s)}function NH(n,e,t){const i=new Float32Array(Eg),s=new Oe(0,1,0);return new ja({name:"SphericalGaussianBlur",defines:{n:Eg,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:i},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:s}},vertexShader:eS(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Jo,depthTest:!1,depthWrite:!1})}function SC(){return new ja({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:eS(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Jo,depthTest:!1,depthWrite:!1})}function AC(){return new ja({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:eS(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Jo,depthTest:!1,depthWrite:!1})}function eS(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function zH(n){let e=new WeakMap,t=null;function i(l){if(l&&l.isTexture){const c=l.mapping,d=c===Rv||c===Dv,g=c===Wh||c===dm;if(d||g){let p=e.get(l);const h=p!==void 0?p.texture.pmremVersion:0;if(l.isRenderTargetTexture&&l.pmremVersion!==h)return t===null&&(t=new IE(n)),p=d?t.fromEquirectangular(l,p):t.fromCubemap(l,p),p.texture.pmremVersion=l.pmremVersion,e.set(l,p),p.texture;if(p!==void 0)return p.texture;{const v=l.image;return d&&v&&v.height>0||g&&v&&s(v)?(t===null&&(t=new IE(n)),p=d?t.fromEquirectangular(l):t.fromCubemap(l),p.texture.pmremVersion=l.pmremVersion,e.set(l,p),l.addEventListener("dispose",r),p.texture):null}}}return l}function s(l){let c=0;const d=6;for(let g=0;g<d;g++)l[g]!==void 0&&c++;return c===d}function r(l){const c=l.target;c.removeEventListener("dispose",r);const d=e.get(c);d!==void 0&&(e.delete(c),d.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:i,dispose:o}}function UH(n){const e={};function t(i){if(e[i]!==void 0)return e[i];let s;switch(i){case"WEBGL_depth_texture":s=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=n.getExtension(i)}return e[i]=s,s}return{has:function(i){return t(i)!==null},init:function(){t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance"),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture"),t("WEBGL_render_shared_exponent")},get:function(i){const s=t(i);return s===null&&Q_("THREE.WebGLRenderer: "+i+" extension not supported."),s}}}function kH(n,e,t,i){const s={},r=new WeakMap;function o(p){const h=p.target;h.index!==null&&e.remove(h.index);for(const y in h.attributes)e.remove(h.attributes[y]);h.removeEventListener("dispose",o),delete s[h.id];const v=r.get(h);v&&(e.remove(v),r.delete(h)),i.releaseStatesOfGeometry(h),h.isInstancedBufferGeometry===!0&&delete h._maxInstanceCount,t.memory.geometries--}function l(p,h){return s[h.id]===!0||(h.addEventListener("dispose",o),s[h.id]=!0,t.memory.geometries++),h}function c(p){const h=p.attributes;for(const v in h)e.update(h[v],n.ARRAY_BUFFER)}function d(p){const h=[],v=p.index,y=p.attributes.position;let w=0;if(v!==null){const T=v.array;w=v.version;for(let C=0,x=T.length;C<x;C+=3){const R=T[C+0],P=T[C+1],D=T[C+2];h.push(R,P,P,D,D,R)}}else if(y!==void 0){const T=y.array;w=y.version;for(let C=0,x=T.length/3-1;C<x;C+=3){const R=C+0,P=C+1,D=C+2;h.push(R,P,P,D,D,R)}}else return;const S=new(pI(h)?TT:ET)(h,1);S.version=w;const M=r.get(p);M&&e.remove(M),r.set(p,S)}function g(p){const h=r.get(p);if(h){const v=p.index;v!==null&&h.version<v.version&&d(p)}else d(p);return r.get(p)}return{get:l,update:c,getWireframeAttribute:g}}function GH(n,e,t){let i;function s(h){i=h}let r,o;function l(h){r=h.type,o=h.bytesPerElement}function c(h,v){n.drawElements(i,v,r,h*o),t.update(v,i,1)}function d(h,v,y){y!==0&&(n.drawElementsInstanced(i,v,r,h*o,y),t.update(v,i,y))}function g(h,v,y){if(y===0)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i,v,0,r,h,0,y);let S=0;for(let M=0;M<y;M++)S+=v[M];t.update(S,i,1)}function p(h,v,y,w){if(y===0)return;const S=e.get("WEBGL_multi_draw");if(S===null)for(let M=0;M<h.length;M++)d(h[M]/o,v[M],w[M]);else{S.multiDrawElementsInstancedWEBGL(i,v,0,r,h,0,w,0,y);let M=0;for(let T=0;T<y;T++)M+=v[T]*w[T];t.update(M,i,1)}}this.setMode=s,this.setIndex=l,this.render=c,this.renderInstances=d,this.renderMultiDraw=g,this.renderMultiDrawInstances=p}function VH(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function i(r,o,l){switch(t.calls++,o){case n.TRIANGLES:t.triangles+=l*(r/3);break;case n.LINES:t.lines+=l*(r/2);break;case n.LINE_STRIP:t.lines+=l*(r-1);break;case n.LINE_LOOP:t.lines+=l*r;break;case n.POINTS:t.points+=l*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function s(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:s,update:i}}function HH(n,e,t){const i=new WeakMap,s=new ds;function r(o,l,c){const d=o.morphTargetInfluences,g=l.morphAttributes.position||l.morphAttributes.normal||l.morphAttributes.color,p=g!==void 0?g.length:0;let h=i.get(l);if(h===void 0||h.count!==p){let U=function(){D.dispose(),i.delete(l),l.removeEventListener("dispose",U)};h!==void 0&&h.texture.dispose();const v=l.morphAttributes.position!==void 0,y=l.morphAttributes.normal!==void 0,w=l.morphAttributes.color!==void 0,S=l.morphAttributes.position||[],M=l.morphAttributes.normal||[],T=l.morphAttributes.color||[];let C=0;v===!0&&(C=1),y===!0&&(C=2),w===!0&&(C=3);let x=l.attributes.position.count*C,R=1;x>e.maxTextureSize&&(R=Math.ceil(x/e.maxTextureSize),x=e.maxTextureSize);const P=new Float32Array(x*R*4*p),D=new ix(P,x,R,p);D.type=Rl,D.needsUpdate=!0;const z=C*4;for(let N=0;N<p;N++){const j=S[N],J=M[N],W=T[N],oe=x*R*4*N;for(let ne=0;ne<j.count;ne++){const q=ne*z;v===!0&&(s.fromBufferAttribute(j,ne),P[oe+q+0]=s.x,P[oe+q+1]=s.y,P[oe+q+2]=s.z,P[oe+q+3]=0),y===!0&&(s.fromBufferAttribute(J,ne),P[oe+q+4]=s.x,P[oe+q+5]=s.y,P[oe+q+6]=s.z,P[oe+q+7]=0),w===!0&&(s.fromBufferAttribute(W,ne),P[oe+q+8]=s.x,P[oe+q+9]=s.y,P[oe+q+10]=s.z,P[oe+q+11]=W.itemSize===4?s.w:1)}}h={count:p,texture:D,size:new Gt(x,R)},i.set(l,h),l.addEventListener("dispose",U)}if(o.isInstancedMesh===!0&&o.morphTexture!==null)c.getUniforms().setValue(n,"morphTexture",o.morphTexture,t);else{let v=0;for(let w=0;w<d.length;w++)v+=d[w];const y=l.morphTargetsRelative?1:1-v;c.getUniforms().setValue(n,"morphTargetBaseInfluence",y),c.getUniforms().setValue(n,"morphTargetInfluences",d)}c.getUniforms().setValue(n,"morphTargetsTexture",h.texture,t),c.getUniforms().setValue(n,"morphTargetsTextureSize",h.size)}return{update:r}}function jH(n,e,t,i){let s=new WeakMap;function r(c){const d=i.render.frame,g=c.geometry,p=e.get(c,g);if(s.get(p)!==d&&(e.update(p),s.set(p,d)),c.isInstancedMesh&&(c.hasEventListener("dispose",l)===!1&&c.addEventListener("dispose",l),s.get(c)!==d&&(t.update(c.instanceMatrix,n.ARRAY_BUFFER),c.instanceColor!==null&&t.update(c.instanceColor,n.ARRAY_BUFFER),s.set(c,d))),c.isSkinnedMesh){const h=c.skeleton;s.get(h)!==d&&(h.update(),s.set(h,d))}return p}function o(){s=new WeakMap}function l(c){const d=c.target;d.removeEventListener("dispose",l),t.remove(d.instanceMatrix),d.instanceColor!==null&&t.remove(d.instanceColor)}return{update:r,dispose:o}}const fO=new vr,CC=new fx(1,1),hO=new ix,pO=new sx,mO=new Kv,PC=[],RC=[],DC=new Float32Array(16),BC=new Float32Array(9),IC=new Float32Array(4);function x0(n,e,t){const i=n[0];if(i<=0||i>0)return n;const s=e*t;let r=PC[s];if(r===void 0&&(r=new Float32Array(s),PC[s]=r),e!==0){i.toArray(r,0);for(let o=1,l=0;o!==e;++o)l+=t,n[o].toArray(r,l)}return r}function $a(n,e){if(n.length!==e.length)return!1;for(let t=0,i=n.length;t<i;t++)if(n[t]!==e[t])return!1;return!0}function Wa(n,e){for(let t=0,i=e.length;t<i;t++)n[t]=e[t]}function Ax(n,e){let t=RC[e];t===void 0&&(t=new Int32Array(e),RC[e]=t);for(let i=0;i!==e;++i)t[i]=n.allocateTextureUnit();return t}function $H(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function WH(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if($a(t,e))return;n.uniform2fv(this.addr,e),Wa(t,e)}}function KH(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if($a(t,e))return;n.uniform3fv(this.addr,e),Wa(t,e)}}function qH(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if($a(t,e))return;n.uniform4fv(this.addr,e),Wa(t,e)}}function XH(n,e){const t=this.cache,i=e.elements;if(i===void 0){if($a(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Wa(t,e)}else{if($a(t,i))return;IC.set(i),n.uniformMatrix2fv(this.addr,!1,IC),Wa(t,i)}}function YH(n,e){const t=this.cache,i=e.elements;if(i===void 0){if($a(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Wa(t,e)}else{if($a(t,i))return;BC.set(i),n.uniformMatrix3fv(this.addr,!1,BC),Wa(t,i)}}function JH(n,e){const t=this.cache,i=e.elements;if(i===void 0){if($a(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Wa(t,e)}else{if($a(t,i))return;DC.set(i),n.uniformMatrix4fv(this.addr,!1,DC),Wa(t,i)}}function QH(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function ZH(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if($a(t,e))return;n.uniform2iv(this.addr,e),Wa(t,e)}}function ej(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if($a(t,e))return;n.uniform3iv(this.addr,e),Wa(t,e)}}function tj(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if($a(t,e))return;n.uniform4iv(this.addr,e),Wa(t,e)}}function nj(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function ij(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if($a(t,e))return;n.uniform2uiv(this.addr,e),Wa(t,e)}}function sj(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if($a(t,e))return;n.uniform3uiv(this.addr,e),Wa(t,e)}}function rj(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if($a(t,e))return;n.uniform4uiv(this.addr,e),Wa(t,e)}}function aj(n,e,t){const i=this.cache,s=t.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s);let r;this.type===n.SAMPLER_2D_SHADOW?(CC.compareFunction=bT,r=CC):r=fO,t.setTexture2D(e||r,s)}function oj(n,e,t){const i=this.cache,s=t.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),t.setTexture3D(e||pO,s)}function lj(n,e,t){const i=this.cache,s=t.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),t.setTextureCube(e||mO,s)}function uj(n,e,t){const i=this.cache,s=t.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),t.setTexture2DArray(e||hO,s)}function cj(n){switch(n){case 5126:return $H;case 35664:return WH;case 35665:return KH;case 35666:return qH;case 35674:return XH;case 35675:return YH;case 35676:return JH;case 5124:case 35670:return QH;case 35667:case 35671:return ZH;case 35668:case 35672:return ej;case 35669:case 35673:return tj;case 5125:return nj;case 36294:return ij;case 36295:return sj;case 36296:return rj;case 35678:case 36198:case 36298:case 36306:case 35682:return aj;case 35679:case 36299:case 36307:return oj;case 35680:case 36300:case 36308:case 36293:return lj;case 36289:case 36303:case 36311:case 36292:return uj}}function dj(n,e){n.uniform1fv(this.addr,e)}function fj(n,e){const t=x0(e,this.size,2);n.uniform2fv(this.addr,t)}function hj(n,e){const t=x0(e,this.size,3);n.uniform3fv(this.addr,t)}function pj(n,e){const t=x0(e,this.size,4);n.uniform4fv(this.addr,t)}function mj(n,e){const t=x0(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function gj(n,e){const t=x0(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function _j(n,e){const t=x0(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function vj(n,e){n.uniform1iv(this.addr,e)}function yj(n,e){n.uniform2iv(this.addr,e)}function Mj(n,e){n.uniform3iv(this.addr,e)}function bj(n,e){n.uniform4iv(this.addr,e)}function xj(n,e){n.uniform1uiv(this.addr,e)}function wj(n,e){n.uniform2uiv(this.addr,e)}function Ej(n,e){n.uniform3uiv(this.addr,e)}function Tj(n,e){n.uniform4uiv(this.addr,e)}function Sj(n,e,t){const i=this.cache,s=e.length,r=Ax(t,s);$a(i,r)||(n.uniform1iv(this.addr,r),Wa(i,r));for(let o=0;o!==s;++o)t.setTexture2D(e[o]||fO,r[o])}function Aj(n,e,t){const i=this.cache,s=e.length,r=Ax(t,s);$a(i,r)||(n.uniform1iv(this.addr,r),Wa(i,r));for(let o=0;o!==s;++o)t.setTexture3D(e[o]||pO,r[o])}function Cj(n,e,t){const i=this.cache,s=e.length,r=Ax(t,s);$a(i,r)||(n.uniform1iv(this.addr,r),Wa(i,r));for(let o=0;o!==s;++o)t.setTextureCube(e[o]||mO,r[o])}function Pj(n,e,t){const i=this.cache,s=e.length,r=Ax(t,s);$a(i,r)||(n.uniform1iv(this.addr,r),Wa(i,r));for(let o=0;o!==s;++o)t.setTexture2DArray(e[o]||hO,r[o])}function Rj(n){switch(n){case 5126:return dj;case 35664:return fj;case 35665:return hj;case 35666:return pj;case 35674:return mj;case 35675:return gj;case 35676:return _j;case 5124:case 35670:return vj;case 35667:case 35671:return yj;case 35668:case 35672:return Mj;case 35669:case 35673:return bj;case 5125:return xj;case 36294:return wj;case 36295:return Ej;case 36296:return Tj;case 35678:case 36198:case 36298:case 36306:case 35682:return Sj;case 35679:case 36299:case 36307:return Aj;case 35680:case 36300:case 36308:case 36293:return Cj;case 36289:case 36303:case 36311:case 36292:return Pj}}class Dj{constructor(e,t,i){this.id=e,this.addr=i,this.cache=[],this.type=t.type,this.setValue=cj(t.type)}}class Bj{constructor(e,t,i){this.id=e,this.addr=i,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=Rj(t.type)}}class Ij{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,i){const s=this.seq;for(let r=0,o=s.length;r!==o;++r){const l=s[r];l.setValue(e,t[l.id],i)}}}const $w=/(\w+)(\])?(\[|\.)?/g;function OC(n,e){n.seq.push(e),n.map[e.id]=e}function Oj(n,e,t){const i=n.name,s=i.length;for($w.lastIndex=0;;){const r=$w.exec(i),o=$w.lastIndex;let l=r[1];const c=r[2]==="]",d=r[3];if(c&&(l=l|0),d===void 0||d==="["&&o+2===s){OC(t,d===void 0?new Dj(l,n,e):new Bj(l,n,e));break}else{let p=t.map[l];p===void 0&&(p=new Ij(l),OC(t,p)),t=p}}}class GM{constructor(e,t){this.seq=[],this.map={};const i=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let s=0;s<i;++s){const r=e.getActiveUniform(t,s),o=e.getUniformLocation(t,r.name);Oj(r,o,this)}}setValue(e,t,i,s){const r=this.map[t];r!==void 0&&r.setValue(e,i,s)}setOptional(e,t,i){const s=t[i];s!==void 0&&this.setValue(e,i,s)}static upload(e,t,i,s){for(let r=0,o=t.length;r!==o;++r){const l=t[r],c=i[l.id];c.needsUpdate!==!1&&l.setValue(e,c.value,s)}}static seqWithValue(e,t){const i=[];for(let s=0,r=e.length;s!==r;++s){const o=e[s];o.id in t&&i.push(o)}return i}}function LC(n,e,t){const i=n.createShader(e);return n.shaderSource(i,t),n.compileShader(i),i}const Lj=37297;let Fj=0;function Nj(n,e){const t=n.split(`
`),i=[],s=Math.max(e-6,0),r=Math.min(e+6,t.length);for(let o=s;o<r;o++){const l=o+1;i.push(`${l===e?">":" "} ${l}: ${t[o]}`)}return i.join(`
`)}const FC=new Ai;function zj(n){us._getMatrix(FC,us.workingColorSpace,n);const e=`mat3( ${FC.elements.map(t=>t.toFixed(4))} )`;switch(us.getTransfer(n)){case Iv:return[e,"LinearTransferOETF"];case js:return[e,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",n),[e,"LinearTransferOETF"]}}function NC(n,e,t){const i=n.getShaderParameter(e,n.COMPILE_STATUS),r=(n.getShaderInfoLog(e)||"").trim();if(i&&r==="")return"";const o=/ERROR: 0:(\d+)/.exec(r);if(o){const l=parseInt(o[1]);return t.toUpperCase()+`

`+r+`

`+Nj(n.getShaderSource(e),l)}else return r}function Uj(n,e){const t=zj(e);return[`vec4 ${n}( vec4 value ) {`,`	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,"}"].join(`
`)}function kj(n,e){let t;switch(e){case qB:t="Linear";break;case XB:t="Reinhard";break;case YB:t="Cineon";break;case dT:t="ACESFilmic";break;case QB:t="AgX";break;case ZB:t="Neutral";break;case JB:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}const vM=new Oe;function Gj(){us.getLuminanceCoefficients(vM);const n=vM.x.toFixed(4),e=vM.y.toFixed(4),t=vM.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,"	return dot( weights, rgb );","}"].join(`
`)}function Vj(n){return[n.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",n.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(fv).join(`
`)}function Hj(n){const e=[];for(const t in n){const i=n[t];i!==!1&&e.push("#define "+t+" "+i)}return e.join(`
`)}function jj(n,e){const t={},i=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let s=0;s<i;s++){const r=n.getActiveAttrib(e,s),o=r.name;let l=1;r.type===n.FLOAT_MAT2&&(l=2),r.type===n.FLOAT_MAT3&&(l=3),r.type===n.FLOAT_MAT4&&(l=4),t[o]={type:r.type,location:n.getAttribLocation(e,o),locationSize:l}}return t}function fv(n){return n!==""}function zC(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function UC(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const $j=/^[ \t]*#include +<([\w\d./]+)>/gm;function OE(n){return n.replace($j,Kj)}const Wj=new Map;function Kj(n,e){let t=Ni[e];if(t===void 0){const i=Wj.get(e);if(i!==void 0)t=Ni[i],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,i);else throw new Error("Can not resolve #include <"+e+">")}return OE(t)}const qj=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function kC(n){return n.replace(qj,Xj)}function Xj(n,e,t,i){let s="";for(let r=parseInt(e);r<parseInt(t);r++)s+=i.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return s}function GC(n){let e=`precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function Yj(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===Kb?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===_v?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===Pd&&(e="SHADOWMAP_TYPE_VSM"),e}function Jj(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case Wh:case dm:e="ENVMAP_TYPE_CUBE";break;case g0:e="ENVMAP_TYPE_CUBE_UV";break}return e}function Qj(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case dm:e="ENVMAP_MODE_REFRACTION";break}return e}function Zj(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case $v:e="ENVMAP_BLENDING_MULTIPLY";break;case WB:e="ENVMAP_BLENDING_MIX";break;case KB:e="ENVMAP_BLENDING_ADD";break}return e}function e$(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,i=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:i,maxMip:t}}function t$(n,e,t,i){const s=n.getContext(),r=t.defines;let o=t.vertexShader,l=t.fragmentShader;const c=Yj(t),d=Jj(t),g=Qj(t),p=Zj(t),h=e$(t),v=Vj(t),y=Hj(r),w=s.createProgram();let S,M,T=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(S=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,y].filter(fv).join(`
`),S.length>0&&(S+=`
`),M=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,y].filter(fv).join(`
`),M.length>0&&(M+=`
`)):(S=[GC(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,y,t.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",t.batching?"#define USE_BATCHING":"",t.batchingColor?"#define USE_BATCHING_COLOR":"",t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.instancingMorph?"#define USE_INSTANCING_MORPH":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+g:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.reversedDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(fv).join(`
`),M=[GC(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,y,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+d:"",t.envMap?"#define "+g:"",t.envMap?"#define "+p:"",h?"#define CUBEUV_TEXEL_WIDTH "+h.texelWidth:"",h?"#define CUBEUV_TEXEL_HEIGHT "+h.texelHeight:"",h?"#define CUBEUV_MAX_MIP "+h.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.dispersion?"#define USE_DISPERSION":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor||t.batchingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.reversedDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Ld?"#define TONE_MAPPING":"",t.toneMapping!==Ld?Ni.tonemapping_pars_fragment:"",t.toneMapping!==Ld?kj("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",Ni.colorspace_pars_fragment,Uj("linearToOutputTexel",t.outputColorSpace),Gj(),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(fv).join(`
`)),o=OE(o),o=zC(o,t),o=UC(o,t),l=OE(l),l=zC(l,t),l=UC(l,t),o=kC(o),l=kC(l),t.isRawShaderMaterial!==!0&&(T=`#version 300 es
`,S=[v,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+S,M=["#define varying in",t.glslVersion===TE?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===TE?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+M);const C=T+S+o,x=T+M+l,R=LC(s,s.VERTEX_SHADER,C),P=LC(s,s.FRAGMENT_SHADER,x);s.attachShader(w,R),s.attachShader(w,P),t.index0AttributeName!==void 0?s.bindAttribLocation(w,0,t.index0AttributeName):t.morphTargets===!0&&s.bindAttribLocation(w,0,"position"),s.linkProgram(w);function D(j){if(n.debug.checkShaderErrors){const J=s.getProgramInfoLog(w)||"",W=s.getShaderInfoLog(R)||"",oe=s.getShaderInfoLog(P)||"",ne=J.trim(),q=W.trim(),le=oe.trim();let se=!0,pe=!0;if(s.getProgramParameter(w,s.LINK_STATUS)===!1)if(se=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(s,w,R,P);else{const be=NC(s,R,"vertex"),ee=NC(s,P,"fragment");console.error("THREE.WebGLProgram: Shader Error "+s.getError()+" - VALIDATE_STATUS "+s.getProgramParameter(w,s.VALIDATE_STATUS)+`

Material Name: `+j.name+`
Material Type: `+j.type+`

Program Info Log: `+ne+`
`+be+`
`+ee)}else ne!==""?console.warn("THREE.WebGLProgram: Program Info Log:",ne):(q===""||le==="")&&(pe=!1);pe&&(j.diagnostics={runnable:se,programLog:ne,vertexShader:{log:q,prefix:S},fragmentShader:{log:le,prefix:M}})}s.deleteShader(R),s.deleteShader(P),z=new GM(s,w),U=jj(s,w)}let z;this.getUniforms=function(){return z===void 0&&D(this),z};let U;this.getAttributes=function(){return U===void 0&&D(this),U};let N=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return N===!1&&(N=s.getProgramParameter(w,Lj)),N},this.destroy=function(){i.releaseStatesOfProgram(this),s.deleteProgram(w),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=Fj++,this.cacheKey=e,this.usedTimes=1,this.program=w,this.vertexShader=R,this.fragmentShader=P,this}let n$=0;class i${constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,i=e.fragmentShader,s=this._getShaderStage(t),r=this._getShaderStage(i),o=this._getShaderCacheForMaterial(e);return o.has(s)===!1&&(o.add(s),s.usedTimes++),o.has(r)===!1&&(o.add(r),r.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const i of t)i.usedTimes--,i.usedTimes===0&&this.shaderCache.delete(i.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let i=t.get(e);return i===void 0&&(i=new Set,t.set(e,i)),i}_getShaderStage(e){const t=this.shaderCache;let i=t.get(e);return i===void 0&&(i=new s$(e),t.set(e,i)),i}}class s${constructor(e){this.id=n$++,this.code=e,this.usedTimes=0}}function r$(n,e,t,i,s,r,o){const l=new l0,c=new i$,d=new Set,g=[],p=s.logarithmicDepthBuffer,h=s.vertexTextures;let v=s.precision;const y={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function w(U){return d.add(U),U===0?"uv":`uv${U}`}function S(U,N,j,J,W){const oe=J.fog,ne=W.geometry,q=U.isMeshStandardMaterial?J.environment:null,le=(U.isMeshStandardMaterial?t:e).get(U.envMap||q),se=le&&le.mapping===g0?le.image.height:null,pe=y[U.type];U.precision!==null&&(v=s.getMaxPrecision(U.precision),v!==U.precision&&console.warn("THREE.WebGLProgram.getParameters:",U.precision,"not supported, using",v,"instead."));const be=ne.morphAttributes.position||ne.morphAttributes.normal||ne.morphAttributes.color,ee=be!==void 0?be.length:0;let te=0;ne.morphAttributes.position!==void 0&&(te=1),ne.morphAttributes.normal!==void 0&&(te=2),ne.morphAttributes.color!==void 0&&(te=3);let ue,ae,ce,Be;if(pe){const Ee=Rd[pe];ue=Ee.vertexShader,ae=Ee.fragmentShader}else ue=U.vertexShader,ae=U.fragmentShader,c.update(U),ce=c.getVertexShaderID(U),Be=c.getFragmentShaderID(U);const He=n.getRenderTarget(),Xe=n.state.buffers.depth.getReversed(),ot=W.isInstancedMesh===!0,tt=W.isBatchedMesh===!0,Ae=!!U.map,ye=!!U.matcap,xe=!!le,ke=!!U.aoMap,ze=!!U.lightMap,je=!!U.bumpMap,Fe=!!U.normalMap,Ye=!!U.displacementMap,Ve=!!U.emissiveMap,Qe=!!U.metalnessMap,mt=!!U.roughnessMap,Tt=U.anisotropy>0,Me=U.clearcoat>0,me=U.dispersion>0,$e=U.iridescence>0,et=U.sheen>0,ht=U.transmission>0,at=Tt&&!!U.anisotropyMap,Et=Me&&!!U.clearcoatMap,Dt=Me&&!!U.clearcoatNormalMap,Vt=Me&&!!U.clearcoatRoughnessMap,an=$e&&!!U.iridescenceMap,bt=$e&&!!U.iridescenceThicknessMap,Jt=et&&!!U.sheenColorMap,Tn=et&&!!U.sheenRoughnessMap,We=!!U.specularMap,vt=!!U.specularColorMap,Yt=!!U.specularIntensityMap,qe=ht&&!!U.transmissionMap,Kt=ht&&!!U.thicknessMap,rn=!!U.gradientMap,fe=!!U.alphaMap,B=U.alphaTest>0,I=!!U.alphaHash,A=!!U.extensions;let F=Ld;U.toneMapped&&(He===null||He.isXRRenderTarget===!0)&&(F=n.toneMapping);const K={shaderID:pe,shaderType:U.type,shaderName:U.name,vertexShader:ue,fragmentShader:ae,defines:U.defines,customVertexShaderID:ce,customFragmentShaderID:Be,isRawShaderMaterial:U.isRawShaderMaterial===!0,glslVersion:U.glslVersion,precision:v,batching:tt,batchingColor:tt&&W._colorsTexture!==null,instancing:ot,instancingColor:ot&&W.instanceColor!==null,instancingMorph:ot&&W.morphTexture!==null,supportsVertexTextures:h,outputColorSpace:He===null?n.outputColorSpace:He.isXRRenderTarget===!0?He.texture.colorSpace:Gf,alphaToCoverage:!!U.alphaToCoverage,map:Ae,matcap:ye,envMap:xe,envMapMode:xe&&le.mapping,envMapCubeUVHeight:se,aoMap:ke,lightMap:ze,bumpMap:je,normalMap:Fe,displacementMap:h&&Ye,emissiveMap:Ve,normalMapObjectSpace:Fe&&U.normalMapType===aI,normalMapTangentSpace:Fe&&U.normalMapType===gm,metalnessMap:Qe,roughnessMap:mt,anisotropy:Tt,anisotropyMap:at,clearcoat:Me,clearcoatMap:Et,clearcoatNormalMap:Dt,clearcoatRoughnessMap:Vt,dispersion:me,iridescence:$e,iridescenceMap:an,iridescenceThicknessMap:bt,sheen:et,sheenColorMap:Jt,sheenRoughnessMap:Tn,specularMap:We,specularColorMap:vt,specularIntensityMap:Yt,transmission:ht,transmissionMap:qe,thicknessMap:Kt,gradientMap:rn,opaque:U.transparent===!1&&U.blending===Og&&U.alphaToCoverage===!1,alphaMap:fe,alphaTest:B,alphaHash:I,combine:U.combine,mapUv:Ae&&w(U.map.channel),aoMapUv:ke&&w(U.aoMap.channel),lightMapUv:ze&&w(U.lightMap.channel),bumpMapUv:je&&w(U.bumpMap.channel),normalMapUv:Fe&&w(U.normalMap.channel),displacementMapUv:Ye&&w(U.displacementMap.channel),emissiveMapUv:Ve&&w(U.emissiveMap.channel),metalnessMapUv:Qe&&w(U.metalnessMap.channel),roughnessMapUv:mt&&w(U.roughnessMap.channel),anisotropyMapUv:at&&w(U.anisotropyMap.channel),clearcoatMapUv:Et&&w(U.clearcoatMap.channel),clearcoatNormalMapUv:Dt&&w(U.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:Vt&&w(U.clearcoatRoughnessMap.channel),iridescenceMapUv:an&&w(U.iridescenceMap.channel),iridescenceThicknessMapUv:bt&&w(U.iridescenceThicknessMap.channel),sheenColorMapUv:Jt&&w(U.sheenColorMap.channel),sheenRoughnessMapUv:Tn&&w(U.sheenRoughnessMap.channel),specularMapUv:We&&w(U.specularMap.channel),specularColorMapUv:vt&&w(U.specularColorMap.channel),specularIntensityMapUv:Yt&&w(U.specularIntensityMap.channel),transmissionMapUv:qe&&w(U.transmissionMap.channel),thicknessMapUv:Kt&&w(U.thicknessMap.channel),alphaMapUv:fe&&w(U.alphaMap.channel),vertexTangents:!!ne.attributes.tangent&&(Fe||Tt),vertexColors:U.vertexColors,vertexAlphas:U.vertexColors===!0&&!!ne.attributes.color&&ne.attributes.color.itemSize===4,pointsUvs:W.isPoints===!0&&!!ne.attributes.uv&&(Ae||fe),fog:!!oe,useFog:U.fog===!0,fogExp2:!!oe&&oe.isFogExp2,flatShading:U.flatShading===!0&&U.wireframe===!1,sizeAttenuation:U.sizeAttenuation===!0,logarithmicDepthBuffer:p,reversedDepthBuffer:Xe,skinning:W.isSkinnedMesh===!0,morphTargets:ne.morphAttributes.position!==void 0,morphNormals:ne.morphAttributes.normal!==void 0,morphColors:ne.morphAttributes.color!==void 0,morphTargetsCount:ee,morphTextureStride:te,numDirLights:N.directional.length,numPointLights:N.point.length,numSpotLights:N.spot.length,numSpotLightMaps:N.spotLightMap.length,numRectAreaLights:N.rectArea.length,numHemiLights:N.hemi.length,numDirLightShadows:N.directionalShadowMap.length,numPointLightShadows:N.pointShadowMap.length,numSpotLightShadows:N.spotShadowMap.length,numSpotLightShadowsWithMaps:N.numSpotLightShadowsWithMaps,numLightProbes:N.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:U.dithering,shadowMapEnabled:n.shadowMap.enabled&&j.length>0,shadowMapType:n.shadowMap.type,toneMapping:F,decodeVideoTexture:Ae&&U.map.isVideoTexture===!0&&us.getTransfer(U.map.colorSpace)===js,decodeVideoTextureEmissive:Ve&&U.emissiveMap.isVideoTexture===!0&&us.getTransfer(U.emissiveMap.colorSpace)===js,premultipliedAlpha:U.premultipliedAlpha,doubleSided:U.side===Ro,flipSided:U.side===Ga,useDepthPacking:U.depthPacking>=0,depthPacking:U.depthPacking||0,index0AttributeName:U.index0AttributeName,extensionClipCullDistance:A&&U.extensions.clipCullDistance===!0&&i.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(A&&U.extensions.multiDraw===!0||tt)&&i.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:i.has("KHR_parallel_shader_compile"),customProgramCacheKey:U.customProgramCacheKey()};return K.vertexUv1s=d.has(1),K.vertexUv2s=d.has(2),K.vertexUv3s=d.has(3),d.clear(),K}function M(U){const N=[];if(U.shaderID?N.push(U.shaderID):(N.push(U.customVertexShaderID),N.push(U.customFragmentShaderID)),U.defines!==void 0)for(const j in U.defines)N.push(j),N.push(U.defines[j]);return U.isRawShaderMaterial===!1&&(T(N,U),C(N,U),N.push(n.outputColorSpace)),N.push(U.customProgramCacheKey),N.join()}function T(U,N){U.push(N.precision),U.push(N.outputColorSpace),U.push(N.envMapMode),U.push(N.envMapCubeUVHeight),U.push(N.mapUv),U.push(N.alphaMapUv),U.push(N.lightMapUv),U.push(N.aoMapUv),U.push(N.bumpMapUv),U.push(N.normalMapUv),U.push(N.displacementMapUv),U.push(N.emissiveMapUv),U.push(N.metalnessMapUv),U.push(N.roughnessMapUv),U.push(N.anisotropyMapUv),U.push(N.clearcoatMapUv),U.push(N.clearcoatNormalMapUv),U.push(N.clearcoatRoughnessMapUv),U.push(N.iridescenceMapUv),U.push(N.iridescenceThicknessMapUv),U.push(N.sheenColorMapUv),U.push(N.sheenRoughnessMapUv),U.push(N.specularMapUv),U.push(N.specularColorMapUv),U.push(N.specularIntensityMapUv),U.push(N.transmissionMapUv),U.push(N.thicknessMapUv),U.push(N.combine),U.push(N.fogExp2),U.push(N.sizeAttenuation),U.push(N.morphTargetsCount),U.push(N.morphAttributeCount),U.push(N.numDirLights),U.push(N.numPointLights),U.push(N.numSpotLights),U.push(N.numSpotLightMaps),U.push(N.numHemiLights),U.push(N.numRectAreaLights),U.push(N.numDirLightShadows),U.push(N.numPointLightShadows),U.push(N.numSpotLightShadows),U.push(N.numSpotLightShadowsWithMaps),U.push(N.numLightProbes),U.push(N.shadowMapType),U.push(N.toneMapping),U.push(N.numClippingPlanes),U.push(N.numClipIntersection),U.push(N.depthPacking)}function C(U,N){l.disableAll(),N.supportsVertexTextures&&l.enable(0),N.instancing&&l.enable(1),N.instancingColor&&l.enable(2),N.instancingMorph&&l.enable(3),N.matcap&&l.enable(4),N.envMap&&l.enable(5),N.normalMapObjectSpace&&l.enable(6),N.normalMapTangentSpace&&l.enable(7),N.clearcoat&&l.enable(8),N.iridescence&&l.enable(9),N.alphaTest&&l.enable(10),N.vertexColors&&l.enable(11),N.vertexAlphas&&l.enable(12),N.vertexUv1s&&l.enable(13),N.vertexUv2s&&l.enable(14),N.vertexUv3s&&l.enable(15),N.vertexTangents&&l.enable(16),N.anisotropy&&l.enable(17),N.alphaHash&&l.enable(18),N.batching&&l.enable(19),N.dispersion&&l.enable(20),N.batchingColor&&l.enable(21),N.gradientMap&&l.enable(22),U.push(l.mask),l.disableAll(),N.fog&&l.enable(0),N.useFog&&l.enable(1),N.flatShading&&l.enable(2),N.logarithmicDepthBuffer&&l.enable(3),N.reversedDepthBuffer&&l.enable(4),N.skinning&&l.enable(5),N.morphTargets&&l.enable(6),N.morphNormals&&l.enable(7),N.morphColors&&l.enable(8),N.premultipliedAlpha&&l.enable(9),N.shadowMapEnabled&&l.enable(10),N.doubleSided&&l.enable(11),N.flipSided&&l.enable(12),N.useDepthPacking&&l.enable(13),N.dithering&&l.enable(14),N.transmission&&l.enable(15),N.sheen&&l.enable(16),N.opaque&&l.enable(17),N.pointsUvs&&l.enable(18),N.decodeVideoTexture&&l.enable(19),N.decodeVideoTextureEmissive&&l.enable(20),N.alphaToCoverage&&l.enable(21),U.push(l.mask)}function x(U){const N=y[U.type];let j;if(N){const J=Rd[N];j=yI.clone(J.uniforms)}else j=U.uniforms;return j}function R(U,N){let j;for(let J=0,W=g.length;J<W;J++){const oe=g[J];if(oe.cacheKey===N){j=oe,++j.usedTimes;break}}return j===void 0&&(j=new t$(n,N,U,r),g.push(j)),j}function P(U){if(--U.usedTimes===0){const N=g.indexOf(U);g[N]=g[g.length-1],g.pop(),U.destroy()}}function D(U){c.remove(U)}function z(){c.dispose()}return{getParameters:S,getProgramCacheKey:M,getUniforms:x,acquireProgram:R,releaseProgram:P,releaseShaderCache:D,programs:g,dispose:z}}function a$(){let n=new WeakMap;function e(o){return n.has(o)}function t(o){let l=n.get(o);return l===void 0&&(l={},n.set(o,l)),l}function i(o){n.delete(o)}function s(o,l,c){n.get(o)[l]=c}function r(){n=new WeakMap}return{has:e,get:t,remove:i,update:s,dispose:r}}function o$(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function VC(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function HC(){const n=[];let e=0;const t=[],i=[],s=[];function r(){e=0,t.length=0,i.length=0,s.length=0}function o(p,h,v,y,w,S){let M=n[e];return M===void 0?(M={id:p.id,object:p,geometry:h,material:v,groupOrder:y,renderOrder:p.renderOrder,z:w,group:S},n[e]=M):(M.id=p.id,M.object=p,M.geometry=h,M.material=v,M.groupOrder=y,M.renderOrder=p.renderOrder,M.z=w,M.group=S),e++,M}function l(p,h,v,y,w,S){const M=o(p,h,v,y,w,S);v.transmission>0?i.push(M):v.transparent===!0?s.push(M):t.push(M)}function c(p,h,v,y,w,S){const M=o(p,h,v,y,w,S);v.transmission>0?i.unshift(M):v.transparent===!0?s.unshift(M):t.unshift(M)}function d(p,h){t.length>1&&t.sort(p||o$),i.length>1&&i.sort(h||VC),s.length>1&&s.sort(h||VC)}function g(){for(let p=e,h=n.length;p<h;p++){const v=n[p];if(v.id===null)break;v.id=null,v.object=null,v.geometry=null,v.material=null,v.group=null}}return{opaque:t,transmissive:i,transparent:s,init:r,push:l,unshift:c,finish:g,sort:d}}function l$(){let n=new WeakMap;function e(i,s){const r=n.get(i);let o;return r===void 0?(o=new HC,n.set(i,[o])):s>=r.length?(o=new HC,r.push(o)):o=r[s],o}function t(){n=new WeakMap}return{get:e,dispose:t}}function u$(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new Oe,color:new Sn};break;case"SpotLight":t={position:new Oe,direction:new Oe,color:new Sn,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new Oe,color:new Sn,distance:0,decay:0};break;case"HemisphereLight":t={direction:new Oe,skyColor:new Sn,groundColor:new Sn};break;case"RectAreaLight":t={color:new Sn,position:new Oe,halfWidth:new Oe,halfHeight:new Oe};break}return n[e.id]=t,t}}}function c$(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Gt};break;case"SpotLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Gt};break;case"PointLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Gt,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let d$=0;function f$(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function h$(n){const e=new u$,t=c$(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let d=0;d<9;d++)i.probe.push(new Oe);const s=new Oe,r=new li,o=new li;function l(d){let g=0,p=0,h=0;for(let U=0;U<9;U++)i.probe[U].set(0,0,0);let v=0,y=0,w=0,S=0,M=0,T=0,C=0,x=0,R=0,P=0,D=0;d.sort(f$);for(let U=0,N=d.length;U<N;U++){const j=d[U],J=j.color,W=j.intensity,oe=j.distance,ne=j.shadow&&j.shadow.map?j.shadow.map.texture:null;if(j.isAmbientLight)g+=J.r*W,p+=J.g*W,h+=J.b*W;else if(j.isLightProbe){for(let q=0;q<9;q++)i.probe[q].addScaledVector(j.sh.coefficients[q],W);D++}else if(j.isDirectionalLight){const q=e.get(j);if(q.color.copy(j.color).multiplyScalar(j.intensity),j.castShadow){const le=j.shadow,se=t.get(j);se.shadowIntensity=le.intensity,se.shadowBias=le.bias,se.shadowNormalBias=le.normalBias,se.shadowRadius=le.radius,se.shadowMapSize=le.mapSize,i.directionalShadow[v]=se,i.directionalShadowMap[v]=ne,i.directionalShadowMatrix[v]=j.shadow.matrix,T++}i.directional[v]=q,v++}else if(j.isSpotLight){const q=e.get(j);q.position.setFromMatrixPosition(j.matrixWorld),q.color.copy(J).multiplyScalar(W),q.distance=oe,q.coneCos=Math.cos(j.angle),q.penumbraCos=Math.cos(j.angle*(1-j.penumbra)),q.decay=j.decay,i.spot[w]=q;const le=j.shadow;if(j.map&&(i.spotLightMap[R]=j.map,R++,le.updateMatrices(j),j.castShadow&&P++),i.spotLightMatrix[w]=le.matrix,j.castShadow){const se=t.get(j);se.shadowIntensity=le.intensity,se.shadowBias=le.bias,se.shadowNormalBias=le.normalBias,se.shadowRadius=le.radius,se.shadowMapSize=le.mapSize,i.spotShadow[w]=se,i.spotShadowMap[w]=ne,x++}w++}else if(j.isRectAreaLight){const q=e.get(j);q.color.copy(J).multiplyScalar(W),q.halfWidth.set(j.width*.5,0,0),q.halfHeight.set(0,j.height*.5,0),i.rectArea[S]=q,S++}else if(j.isPointLight){const q=e.get(j);if(q.color.copy(j.color).multiplyScalar(j.intensity),q.distance=j.distance,q.decay=j.decay,j.castShadow){const le=j.shadow,se=t.get(j);se.shadowIntensity=le.intensity,se.shadowBias=le.bias,se.shadowNormalBias=le.normalBias,se.shadowRadius=le.radius,se.shadowMapSize=le.mapSize,se.shadowCameraNear=le.camera.near,se.shadowCameraFar=le.camera.far,i.pointShadow[y]=se,i.pointShadowMap[y]=ne,i.pointShadowMatrix[y]=j.shadow.matrix,C++}i.point[y]=q,y++}else if(j.isHemisphereLight){const q=e.get(j);q.skyColor.copy(j.color).multiplyScalar(W),q.groundColor.copy(j.groundColor).multiplyScalar(W),i.hemi[M]=q,M++}}S>0&&(n.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=Dn.LTC_FLOAT_1,i.rectAreaLTC2=Dn.LTC_FLOAT_2):(i.rectAreaLTC1=Dn.LTC_HALF_1,i.rectAreaLTC2=Dn.LTC_HALF_2)),i.ambient[0]=g,i.ambient[1]=p,i.ambient[2]=h;const z=i.hash;(z.directionalLength!==v||z.pointLength!==y||z.spotLength!==w||z.rectAreaLength!==S||z.hemiLength!==M||z.numDirectionalShadows!==T||z.numPointShadows!==C||z.numSpotShadows!==x||z.numSpotMaps!==R||z.numLightProbes!==D)&&(i.directional.length=v,i.spot.length=w,i.rectArea.length=S,i.point.length=y,i.hemi.length=M,i.directionalShadow.length=T,i.directionalShadowMap.length=T,i.pointShadow.length=C,i.pointShadowMap.length=C,i.spotShadow.length=x,i.spotShadowMap.length=x,i.directionalShadowMatrix.length=T,i.pointShadowMatrix.length=C,i.spotLightMatrix.length=x+R-P,i.spotLightMap.length=R,i.numSpotLightShadowsWithMaps=P,i.numLightProbes=D,z.directionalLength=v,z.pointLength=y,z.spotLength=w,z.rectAreaLength=S,z.hemiLength=M,z.numDirectionalShadows=T,z.numPointShadows=C,z.numSpotShadows=x,z.numSpotMaps=R,z.numLightProbes=D,i.version=d$++)}function c(d,g){let p=0,h=0,v=0,y=0,w=0;const S=g.matrixWorldInverse;for(let M=0,T=d.length;M<T;M++){const C=d[M];if(C.isDirectionalLight){const x=i.directional[p];x.direction.setFromMatrixPosition(C.matrixWorld),s.setFromMatrixPosition(C.target.matrixWorld),x.direction.sub(s),x.direction.transformDirection(S),p++}else if(C.isSpotLight){const x=i.spot[v];x.position.setFromMatrixPosition(C.matrixWorld),x.position.applyMatrix4(S),x.direction.setFromMatrixPosition(C.matrixWorld),s.setFromMatrixPosition(C.target.matrixWorld),x.direction.sub(s),x.direction.transformDirection(S),v++}else if(C.isRectAreaLight){const x=i.rectArea[y];x.position.setFromMatrixPosition(C.matrixWorld),x.position.applyMatrix4(S),o.identity(),r.copy(C.matrixWorld),r.premultiply(S),o.extractRotation(r),x.halfWidth.set(C.width*.5,0,0),x.halfHeight.set(0,C.height*.5,0),x.halfWidth.applyMatrix4(o),x.halfHeight.applyMatrix4(o),y++}else if(C.isPointLight){const x=i.point[h];x.position.setFromMatrixPosition(C.matrixWorld),x.position.applyMatrix4(S),h++}else if(C.isHemisphereLight){const x=i.hemi[w];x.direction.setFromMatrixPosition(C.matrixWorld),x.direction.transformDirection(S),w++}}}return{setup:l,setupView:c,state:i}}function jC(n){const e=new h$(n),t=[],i=[];function s(g){d.camera=g,t.length=0,i.length=0}function r(g){t.push(g)}function o(g){i.push(g)}function l(){e.setup(t)}function c(g){e.setupView(t,g)}const d={lightsArray:t,shadowsArray:i,camera:null,lights:e,transmissionRenderTarget:{}};return{init:s,state:d,setupLights:l,setupLightsView:c,pushLight:r,pushShadow:o}}function p$(n){let e=new WeakMap;function t(s,r=0){const o=e.get(s);let l;return o===void 0?(l=new jC(n),e.set(s,[l])):r>=o.length?(l=new jC(n),o.push(l)):l=o[r],l}function i(){e=new WeakMap}return{get:t,dispose:i}}const m$=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,g$=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function _$(n,e,t){let i=new _0;const s=new Gt,r=new Gt,o=new ds,l=new UT({depthPacking:rI}),c=new kT,d={},g=t.maxTextureSize,p={[Nd]:Ga,[Ga]:Nd,[Ro]:Ro},h=new ja({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Gt},radius:{value:4}},vertexShader:m$,fragmentShader:g$}),v=h.clone();v.defines.HORIZONTAL_PASS=1;const y=new xi;y.setAttribute("position",new hs(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const w=new ea(y,h),S=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Kb;let M=this.type;this.render=function(P,D,z){if(S.enabled===!1||S.autoUpdate===!1&&S.needsUpdate===!1||P.length===0)return;const U=n.getRenderTarget(),N=n.getActiveCubeFace(),j=n.getActiveMipmapLevel(),J=n.state;J.setBlending(Jo),J.buffers.depth.getReversed()?J.buffers.color.setClear(0,0,0,0):J.buffers.color.setClear(1,1,1,1),J.buffers.depth.setTest(!0),J.setScissorTest(!1);const W=M!==Pd&&this.type===Pd,oe=M===Pd&&this.type!==Pd;for(let ne=0,q=P.length;ne<q;ne++){const le=P[ne],se=le.shadow;if(se===void 0){console.warn("THREE.WebGLShadowMap:",le,"has no shadow.");continue}if(se.autoUpdate===!1&&se.needsUpdate===!1)continue;s.copy(se.mapSize);const pe=se.getFrameExtents();if(s.multiply(pe),r.copy(se.mapSize),(s.x>g||s.y>g)&&(s.x>g&&(r.x=Math.floor(g/pe.x),s.x=r.x*pe.x,se.mapSize.x=r.x),s.y>g&&(r.y=Math.floor(g/pe.y),s.y=r.y*pe.y,se.mapSize.y=r.y)),se.map===null||W===!0||oe===!0){const ee=this.type!==Pd?{minFilter:ta,magFilter:ta}:{};se.map!==null&&se.map.dispose(),se.map=new Da(s.x,s.y,ee),se.map.texture.name=le.name+".shadowMap",se.camera.updateProjectionMatrix()}n.setRenderTarget(se.map),n.clear();const be=se.getViewportCount();for(let ee=0;ee<be;ee++){const te=se.getViewport(ee);o.set(r.x*te.x,r.y*te.y,r.x*te.z,r.y*te.w),J.viewport(o),se.updateMatrices(le,ee),i=se.getFrustum(),x(D,z,se.camera,le,this.type)}se.isPointLightShadow!==!0&&this.type===Pd&&T(se,z),se.needsUpdate=!1}M=this.type,S.needsUpdate=!1,n.setRenderTarget(U,N,j)};function T(P,D){const z=e.update(w);h.defines.VSM_SAMPLES!==P.blurSamples&&(h.defines.VSM_SAMPLES=P.blurSamples,v.defines.VSM_SAMPLES=P.blurSamples,h.needsUpdate=!0,v.needsUpdate=!0),P.mapPass===null&&(P.mapPass=new Da(s.x,s.y)),h.uniforms.shadow_pass.value=P.map.texture,h.uniforms.resolution.value=P.mapSize,h.uniforms.radius.value=P.radius,n.setRenderTarget(P.mapPass),n.clear(),n.renderBufferDirect(D,null,z,h,w,null),v.uniforms.shadow_pass.value=P.mapPass.texture,v.uniforms.resolution.value=P.mapSize,v.uniforms.radius.value=P.radius,n.setRenderTarget(P.map),n.clear(),n.renderBufferDirect(D,null,z,v,w,null)}function C(P,D,z,U){let N=null;const j=z.isPointLight===!0?P.customDistanceMaterial:P.customDepthMaterial;if(j!==void 0)N=j;else if(N=z.isPointLight===!0?c:l,n.localClippingEnabled&&D.clipShadows===!0&&Array.isArray(D.clippingPlanes)&&D.clippingPlanes.length!==0||D.displacementMap&&D.displacementScale!==0||D.alphaMap&&D.alphaTest>0||D.map&&D.alphaTest>0||D.alphaToCoverage===!0){const J=N.uuid,W=D.uuid;let oe=d[J];oe===void 0&&(oe={},d[J]=oe);let ne=oe[W];ne===void 0&&(ne=N.clone(),oe[W]=ne,D.addEventListener("dispose",R)),N=ne}if(N.visible=D.visible,N.wireframe=D.wireframe,U===Pd?N.side=D.shadowSide!==null?D.shadowSide:D.side:N.side=D.shadowSide!==null?D.shadowSide:p[D.side],N.alphaMap=D.alphaMap,N.alphaTest=D.alphaToCoverage===!0?.5:D.alphaTest,N.map=D.map,N.clipShadows=D.clipShadows,N.clippingPlanes=D.clippingPlanes,N.clipIntersection=D.clipIntersection,N.displacementMap=D.displacementMap,N.displacementScale=D.displacementScale,N.displacementBias=D.displacementBias,N.wireframeLinewidth=D.wireframeLinewidth,N.linewidth=D.linewidth,z.isPointLight===!0&&N.isMeshDistanceMaterial===!0){const J=n.properties.get(N);J.light=z}return N}function x(P,D,z,U,N){if(P.visible===!1)return;if(P.layers.test(D.layers)&&(P.isMesh||P.isLine||P.isPoints)&&(P.castShadow||P.receiveShadow&&N===Pd)&&(!P.frustumCulled||i.intersectsObject(P))){P.modelViewMatrix.multiplyMatrices(z.matrixWorldInverse,P.matrixWorld);const W=e.update(P),oe=P.material;if(Array.isArray(oe)){const ne=W.groups;for(let q=0,le=ne.length;q<le;q++){const se=ne[q],pe=oe[se.materialIndex];if(pe&&pe.visible){const be=C(P,pe,U,N);P.onBeforeShadow(n,P,D,z,W,be,se),n.renderBufferDirect(z,null,W,be,P,se),P.onAfterShadow(n,P,D,z,W,be,se)}}}else if(oe.visible){const ne=C(P,oe,U,N);P.onBeforeShadow(n,P,D,z,W,ne,null),n.renderBufferDirect(z,null,W,ne,P,null),P.onAfterShadow(n,P,D,z,W,ne,null)}}const J=P.children;for(let W=0,oe=J.length;W<oe;W++)x(J[W],D,z,U,N)}function R(P){P.target.removeEventListener("dispose",R);for(const z in d){const U=d[z],N=P.target.uuid;N in U&&(U[N].dispose(),delete U[N])}}}const v$={[XM]:Pv,[YM]:ZM,[JM]:eb,[zg]:QM,[Pv]:XM,[ZM]:YM,[eb]:JM,[QM]:zg};function y$(n,e){function t(){let qe=!1;const Kt=new ds;let rn=null;const fe=new ds(0,0,0,0);return{setMask:function(B){rn!==B&&!qe&&(n.colorMask(B,B,B,B),rn=B)},setLocked:function(B){qe=B},setClear:function(B,I,A,F,K){K===!0&&(B*=F,I*=F,A*=F),Kt.set(B,I,A,F),fe.equals(Kt)===!1&&(n.clearColor(B,I,A,F),fe.copy(Kt))},reset:function(){qe=!1,rn=null,fe.set(-1,0,0,0)}}}function i(){let qe=!1,Kt=!1,rn=null,fe=null,B=null;return{setReversed:function(I){if(Kt!==I){const A=e.get("EXT_clip_control");I?A.clipControlEXT(A.LOWER_LEFT_EXT,A.ZERO_TO_ONE_EXT):A.clipControlEXT(A.LOWER_LEFT_EXT,A.NEGATIVE_ONE_TO_ONE_EXT),Kt=I;const F=B;B=null,this.setClear(F)}},getReversed:function(){return Kt},setTest:function(I){I?He(n.DEPTH_TEST):Xe(n.DEPTH_TEST)},setMask:function(I){rn!==I&&!qe&&(n.depthMask(I),rn=I)},setFunc:function(I){if(Kt&&(I=v$[I]),fe!==I){switch(I){case XM:n.depthFunc(n.NEVER);break;case Pv:n.depthFunc(n.ALWAYS);break;case YM:n.depthFunc(n.LESS);break;case zg:n.depthFunc(n.LEQUAL);break;case JM:n.depthFunc(n.EQUAL);break;case QM:n.depthFunc(n.GEQUAL);break;case ZM:n.depthFunc(n.GREATER);break;case eb:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}fe=I}},setLocked:function(I){qe=I},setClear:function(I){B!==I&&(Kt&&(I=1-I),n.clearDepth(I),B=I)},reset:function(){qe=!1,rn=null,fe=null,B=null,Kt=!1}}}function s(){let qe=!1,Kt=null,rn=null,fe=null,B=null,I=null,A=null,F=null,K=null;return{setTest:function(Ee){qe||(Ee?He(n.STENCIL_TEST):Xe(n.STENCIL_TEST))},setMask:function(Ee){Kt!==Ee&&!qe&&(n.stencilMask(Ee),Kt=Ee)},setFunc:function(Ee,k,re){(rn!==Ee||fe!==k||B!==re)&&(n.stencilFunc(Ee,k,re),rn=Ee,fe=k,B=re)},setOp:function(Ee,k,re){(I!==Ee||A!==k||F!==re)&&(n.stencilOp(Ee,k,re),I=Ee,A=k,F=re)},setLocked:function(Ee){qe=Ee},setClear:function(Ee){K!==Ee&&(n.clearStencil(Ee),K=Ee)},reset:function(){qe=!1,Kt=null,rn=null,fe=null,B=null,I=null,A=null,F=null,K=null}}}const r=new t,o=new i,l=new s,c=new WeakMap,d=new WeakMap;let g={},p={},h=new WeakMap,v=[],y=null,w=!1,S=null,M=null,T=null,C=null,x=null,R=null,P=null,D=new Sn(0,0,0),z=0,U=!1,N=null,j=null,J=null,W=null,oe=null;const ne=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let q=!1,le=0;const se=n.getParameter(n.VERSION);se.indexOf("WebGL")!==-1?(le=parseFloat(/^WebGL (\d)/.exec(se)[1]),q=le>=1):se.indexOf("OpenGL ES")!==-1&&(le=parseFloat(/^OpenGL ES (\d)/.exec(se)[1]),q=le>=2);let pe=null,be={};const ee=n.getParameter(n.SCISSOR_BOX),te=n.getParameter(n.VIEWPORT),ue=new ds().fromArray(ee),ae=new ds().fromArray(te);function ce(qe,Kt,rn,fe){const B=new Uint8Array(4),I=n.createTexture();n.bindTexture(qe,I),n.texParameteri(qe,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(qe,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let A=0;A<rn;A++)qe===n.TEXTURE_3D||qe===n.TEXTURE_2D_ARRAY?n.texImage3D(Kt,0,n.RGBA,1,1,fe,0,n.RGBA,n.UNSIGNED_BYTE,B):n.texImage2D(Kt+A,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,B);return I}const Be={};Be[n.TEXTURE_2D]=ce(n.TEXTURE_2D,n.TEXTURE_2D,1),Be[n.TEXTURE_CUBE_MAP]=ce(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),Be[n.TEXTURE_2D_ARRAY]=ce(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),Be[n.TEXTURE_3D]=ce(n.TEXTURE_3D,n.TEXTURE_3D,1,1),r.setClear(0,0,0,1),o.setClear(1),l.setClear(0),He(n.DEPTH_TEST),o.setFunc(zg),je(!1),Fe(yE),He(n.CULL_FACE),ke(Jo);function He(qe){g[qe]!==!0&&(n.enable(qe),g[qe]=!0)}function Xe(qe){g[qe]!==!1&&(n.disable(qe),g[qe]=!1)}function ot(qe,Kt){return p[qe]!==Kt?(n.bindFramebuffer(qe,Kt),p[qe]=Kt,qe===n.DRAW_FRAMEBUFFER&&(p[n.FRAMEBUFFER]=Kt),qe===n.FRAMEBUFFER&&(p[n.DRAW_FRAMEBUFFER]=Kt),!0):!1}function tt(qe,Kt){let rn=v,fe=!1;if(qe){rn=h.get(Kt),rn===void 0&&(rn=[],h.set(Kt,rn));const B=qe.textures;if(rn.length!==B.length||rn[0]!==n.COLOR_ATTACHMENT0){for(let I=0,A=B.length;I<A;I++)rn[I]=n.COLOR_ATTACHMENT0+I;rn.length=B.length,fe=!0}}else rn[0]!==n.BACK&&(rn[0]=n.BACK,fe=!0);fe&&n.drawBuffers(rn)}function Ae(qe){return y!==qe?(n.useProgram(qe),y=qe,!0):!1}const ye={[om]:n.FUNC_ADD,[PB]:n.FUNC_SUBTRACT,[RB]:n.FUNC_REVERSE_SUBTRACT};ye[DB]=n.MIN,ye[BB]=n.MAX;const xe={[IB]:n.ZERO,[OB]:n.ONE,[LB]:n.SRC_COLOR,[KM]:n.SRC_ALPHA,[GB]:n.SRC_ALPHA_SATURATE,[UB]:n.DST_COLOR,[NB]:n.DST_ALPHA,[FB]:n.ONE_MINUS_SRC_COLOR,[qM]:n.ONE_MINUS_SRC_ALPHA,[kB]:n.ONE_MINUS_DST_COLOR,[zB]:n.ONE_MINUS_DST_ALPHA,[VB]:n.CONSTANT_COLOR,[HB]:n.ONE_MINUS_CONSTANT_COLOR,[jB]:n.CONSTANT_ALPHA,[$B]:n.ONE_MINUS_CONSTANT_ALPHA};function ke(qe,Kt,rn,fe,B,I,A,F,K,Ee){if(qe===Jo){w===!0&&(Xe(n.BLEND),w=!1);return}if(w===!1&&(He(n.BLEND),w=!0),qe!==CB){if(qe!==S||Ee!==U){if((M!==om||x!==om)&&(n.blendEquation(n.FUNC_ADD),M=om,x=om),Ee)switch(qe){case Og:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case ME:n.blendFunc(n.ONE,n.ONE);break;case bE:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case xE:n.blendFuncSeparate(n.DST_COLOR,n.ONE_MINUS_SRC_ALPHA,n.ZERO,n.ONE);break;default:console.error("THREE.WebGLState: Invalid blending: ",qe);break}else switch(qe){case Og:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case ME:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE,n.ONE,n.ONE);break;case bE:console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case xE:console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:console.error("THREE.WebGLState: Invalid blending: ",qe);break}T=null,C=null,R=null,P=null,D.set(0,0,0),z=0,S=qe,U=Ee}return}B=B||Kt,I=I||rn,A=A||fe,(Kt!==M||B!==x)&&(n.blendEquationSeparate(ye[Kt],ye[B]),M=Kt,x=B),(rn!==T||fe!==C||I!==R||A!==P)&&(n.blendFuncSeparate(xe[rn],xe[fe],xe[I],xe[A]),T=rn,C=fe,R=I,P=A),(F.equals(D)===!1||K!==z)&&(n.blendColor(F.r,F.g,F.b,K),D.copy(F),z=K),S=qe,U=!1}function ze(qe,Kt){qe.side===Ro?Xe(n.CULL_FACE):He(n.CULL_FACE);let rn=qe.side===Ga;Kt&&(rn=!rn),je(rn),qe.blending===Og&&qe.transparent===!1?ke(Jo):ke(qe.blending,qe.blendEquation,qe.blendSrc,qe.blendDst,qe.blendEquationAlpha,qe.blendSrcAlpha,qe.blendDstAlpha,qe.blendColor,qe.blendAlpha,qe.premultipliedAlpha),o.setFunc(qe.depthFunc),o.setTest(qe.depthTest),o.setMask(qe.depthWrite),r.setMask(qe.colorWrite);const fe=qe.stencilWrite;l.setTest(fe),fe&&(l.setMask(qe.stencilWriteMask),l.setFunc(qe.stencilFunc,qe.stencilRef,qe.stencilFuncMask),l.setOp(qe.stencilFail,qe.stencilZFail,qe.stencilZPass)),Ve(qe.polygonOffset,qe.polygonOffsetFactor,qe.polygonOffsetUnits),qe.alphaToCoverage===!0?He(n.SAMPLE_ALPHA_TO_COVERAGE):Xe(n.SAMPLE_ALPHA_TO_COVERAGE)}function je(qe){N!==qe&&(qe?n.frontFace(n.CW):n.frontFace(n.CCW),N=qe)}function Fe(qe){qe!==TB?(He(n.CULL_FACE),qe!==j&&(qe===yE?n.cullFace(n.BACK):qe===SB?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):Xe(n.CULL_FACE),j=qe}function Ye(qe){qe!==J&&(q&&n.lineWidth(qe),J=qe)}function Ve(qe,Kt,rn){qe?(He(n.POLYGON_OFFSET_FILL),(W!==Kt||oe!==rn)&&(n.polygonOffset(Kt,rn),W=Kt,oe=rn)):Xe(n.POLYGON_OFFSET_FILL)}function Qe(qe){qe?He(n.SCISSOR_TEST):Xe(n.SCISSOR_TEST)}function mt(qe){qe===void 0&&(qe=n.TEXTURE0+ne-1),pe!==qe&&(n.activeTexture(qe),pe=qe)}function Tt(qe,Kt,rn){rn===void 0&&(pe===null?rn=n.TEXTURE0+ne-1:rn=pe);let fe=be[rn];fe===void 0&&(fe={type:void 0,texture:void 0},be[rn]=fe),(fe.type!==qe||fe.texture!==Kt)&&(pe!==rn&&(n.activeTexture(rn),pe=rn),n.bindTexture(qe,Kt||Be[qe]),fe.type=qe,fe.texture=Kt)}function Me(){const qe=be[pe];qe!==void 0&&qe.type!==void 0&&(n.bindTexture(qe.type,null),qe.type=void 0,qe.texture=void 0)}function me(){try{n.compressedTexImage2D(...arguments)}catch(qe){console.error("THREE.WebGLState:",qe)}}function $e(){try{n.compressedTexImage3D(...arguments)}catch(qe){console.error("THREE.WebGLState:",qe)}}function et(){try{n.texSubImage2D(...arguments)}catch(qe){console.error("THREE.WebGLState:",qe)}}function ht(){try{n.texSubImage3D(...arguments)}catch(qe){console.error("THREE.WebGLState:",qe)}}function at(){try{n.compressedTexSubImage2D(...arguments)}catch(qe){console.error("THREE.WebGLState:",qe)}}function Et(){try{n.compressedTexSubImage3D(...arguments)}catch(qe){console.error("THREE.WebGLState:",qe)}}function Dt(){try{n.texStorage2D(...arguments)}catch(qe){console.error("THREE.WebGLState:",qe)}}function Vt(){try{n.texStorage3D(...arguments)}catch(qe){console.error("THREE.WebGLState:",qe)}}function an(){try{n.texImage2D(...arguments)}catch(qe){console.error("THREE.WebGLState:",qe)}}function bt(){try{n.texImage3D(...arguments)}catch(qe){console.error("THREE.WebGLState:",qe)}}function Jt(qe){ue.equals(qe)===!1&&(n.scissor(qe.x,qe.y,qe.z,qe.w),ue.copy(qe))}function Tn(qe){ae.equals(qe)===!1&&(n.viewport(qe.x,qe.y,qe.z,qe.w),ae.copy(qe))}function We(qe,Kt){let rn=d.get(Kt);rn===void 0&&(rn=new WeakMap,d.set(Kt,rn));let fe=rn.get(qe);fe===void 0&&(fe=n.getUniformBlockIndex(Kt,qe.name),rn.set(qe,fe))}function vt(qe,Kt){const fe=d.get(Kt).get(qe);c.get(Kt)!==fe&&(n.uniformBlockBinding(Kt,fe,qe.__bindingPointIndex),c.set(Kt,fe))}function Yt(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),o.setReversed(!1),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),g={},pe=null,be={},p={},h=new WeakMap,v=[],y=null,w=!1,S=null,M=null,T=null,C=null,x=null,R=null,P=null,D=new Sn(0,0,0),z=0,U=!1,N=null,j=null,J=null,W=null,oe=null,ue.set(0,0,n.canvas.width,n.canvas.height),ae.set(0,0,n.canvas.width,n.canvas.height),r.reset(),o.reset(),l.reset()}return{buffers:{color:r,depth:o,stencil:l},enable:He,disable:Xe,bindFramebuffer:ot,drawBuffers:tt,useProgram:Ae,setBlending:ke,setMaterial:ze,setFlipSided:je,setCullFace:Fe,setLineWidth:Ye,setPolygonOffset:Ve,setScissorTest:Qe,activeTexture:mt,bindTexture:Tt,unbindTexture:Me,compressedTexImage2D:me,compressedTexImage3D:$e,texImage2D:an,texImage3D:bt,updateUBOMapping:We,uniformBlockBinding:vt,texStorage2D:Dt,texStorage3D:Vt,texSubImage2D:et,texSubImage3D:ht,compressedTexSubImage2D:at,compressedTexSubImage3D:Et,scissor:Jt,viewport:Tn,reset:Yt}}function M$(n,e,t,i,s,r,o){const l=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,c=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),d=new Gt,g=new WeakMap;let p;const h=new WeakMap;let v=!1;try{v=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function y(Me,me){return v?new OffscreenCanvas(Me,me):Lv("canvas")}function w(Me,me,$e){let et=1;const ht=Tt(Me);if((ht.width>$e||ht.height>$e)&&(et=$e/Math.max(ht.width,ht.height)),et<1)if(typeof HTMLImageElement<"u"&&Me instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&Me instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&Me instanceof ImageBitmap||typeof VideoFrame<"u"&&Me instanceof VideoFrame){const at=Math.floor(et*ht.width),Et=Math.floor(et*ht.height);p===void 0&&(p=y(at,Et));const Dt=me?y(at,Et):p;return Dt.width=at,Dt.height=Et,Dt.getContext("2d").drawImage(Me,0,0,at,Et),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+ht.width+"x"+ht.height+") to ("+at+"x"+Et+")."),Dt}else return"data"in Me&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+ht.width+"x"+ht.height+")."),Me;return Me}function S(Me){return Me.generateMipmaps}function M(Me){n.generateMipmap(Me)}function T(Me){return Me.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:Me.isWebGL3DRenderTarget?n.TEXTURE_3D:Me.isWebGLArrayRenderTarget||Me.isCompressedArrayTexture?n.TEXTURE_2D_ARRAY:n.TEXTURE_2D}function C(Me,me,$e,et,ht=!1){if(Me!==null){if(n[Me]!==void 0)return n[Me];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+Me+"'")}let at=me;if(me===n.RED&&($e===n.FLOAT&&(at=n.R32F),$e===n.HALF_FLOAT&&(at=n.R16F),$e===n.UNSIGNED_BYTE&&(at=n.R8)),me===n.RED_INTEGER&&($e===n.UNSIGNED_BYTE&&(at=n.R8UI),$e===n.UNSIGNED_SHORT&&(at=n.R16UI),$e===n.UNSIGNED_INT&&(at=n.R32UI),$e===n.BYTE&&(at=n.R8I),$e===n.SHORT&&(at=n.R16I),$e===n.INT&&(at=n.R32I)),me===n.RG&&($e===n.FLOAT&&(at=n.RG32F),$e===n.HALF_FLOAT&&(at=n.RG16F),$e===n.UNSIGNED_BYTE&&(at=n.RG8)),me===n.RG_INTEGER&&($e===n.UNSIGNED_BYTE&&(at=n.RG8UI),$e===n.UNSIGNED_SHORT&&(at=n.RG16UI),$e===n.UNSIGNED_INT&&(at=n.RG32UI),$e===n.BYTE&&(at=n.RG8I),$e===n.SHORT&&(at=n.RG16I),$e===n.INT&&(at=n.RG32I)),me===n.RGB_INTEGER&&($e===n.UNSIGNED_BYTE&&(at=n.RGB8UI),$e===n.UNSIGNED_SHORT&&(at=n.RGB16UI),$e===n.UNSIGNED_INT&&(at=n.RGB32UI),$e===n.BYTE&&(at=n.RGB8I),$e===n.SHORT&&(at=n.RGB16I),$e===n.INT&&(at=n.RGB32I)),me===n.RGBA_INTEGER&&($e===n.UNSIGNED_BYTE&&(at=n.RGBA8UI),$e===n.UNSIGNED_SHORT&&(at=n.RGBA16UI),$e===n.UNSIGNED_INT&&(at=n.RGBA32UI),$e===n.BYTE&&(at=n.RGBA8I),$e===n.SHORT&&(at=n.RGBA16I),$e===n.INT&&(at=n.RGBA32I)),me===n.RGB&&$e===n.UNSIGNED_INT_5_9_9_9_REV&&(at=n.RGB9_E5),me===n.RGBA){const Et=ht?Iv:us.getTransfer(et);$e===n.FLOAT&&(at=n.RGBA32F),$e===n.HALF_FLOAT&&(at=n.RGBA16F),$e===n.UNSIGNED_BYTE&&(at=Et===js?n.SRGB8_ALPHA8:n.RGBA8),$e===n.UNSIGNED_SHORT_4_4_4_4&&(at=n.RGBA4),$e===n.UNSIGNED_SHORT_5_5_5_1&&(at=n.RGB5_A1)}return(at===n.R16F||at===n.R32F||at===n.RG16F||at===n.RG32F||at===n.RGBA16F||at===n.RGBA32F)&&e.get("EXT_color_buffer_float"),at}function x(Me,me){let $e;return Me?me===null||me===kf||me===Ug?$e=n.DEPTH24_STENCIL8:me===Rl?$e=n.DEPTH32F_STENCIL8:me===n0&&($e=n.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):me===null||me===kf||me===Ug?$e=n.DEPTH_COMPONENT24:me===Rl?$e=n.DEPTH_COMPONENT32F:me===n0&&($e=n.DEPTH_COMPONENT16),$e}function R(Me,me){return S(Me)===!0||Me.isFramebufferTexture&&Me.minFilter!==ta&&Me.minFilter!==Tr?Math.log2(Math.max(me.width,me.height))+1:Me.mipmaps!==void 0&&Me.mipmaps.length>0?Me.mipmaps.length:Me.isCompressedTexture&&Array.isArray(Me.image)?me.mipmaps.length:1}function P(Me){const me=Me.target;me.removeEventListener("dispose",P),z(me),me.isVideoTexture&&g.delete(me)}function D(Me){const me=Me.target;me.removeEventListener("dispose",D),N(me)}function z(Me){const me=i.get(Me);if(me.__webglInit===void 0)return;const $e=Me.source,et=h.get($e);if(et){const ht=et[me.__cacheKey];ht.usedTimes--,ht.usedTimes===0&&U(Me),Object.keys(et).length===0&&h.delete($e)}i.remove(Me)}function U(Me){const me=i.get(Me);n.deleteTexture(me.__webglTexture);const $e=Me.source,et=h.get($e);delete et[me.__cacheKey],o.memory.textures--}function N(Me){const me=i.get(Me);if(Me.depthTexture&&(Me.depthTexture.dispose(),i.remove(Me.depthTexture)),Me.isWebGLCubeRenderTarget)for(let et=0;et<6;et++){if(Array.isArray(me.__webglFramebuffer[et]))for(let ht=0;ht<me.__webglFramebuffer[et].length;ht++)n.deleteFramebuffer(me.__webglFramebuffer[et][ht]);else n.deleteFramebuffer(me.__webglFramebuffer[et]);me.__webglDepthbuffer&&n.deleteRenderbuffer(me.__webglDepthbuffer[et])}else{if(Array.isArray(me.__webglFramebuffer))for(let et=0;et<me.__webglFramebuffer.length;et++)n.deleteFramebuffer(me.__webglFramebuffer[et]);else n.deleteFramebuffer(me.__webglFramebuffer);if(me.__webglDepthbuffer&&n.deleteRenderbuffer(me.__webglDepthbuffer),me.__webglMultisampledFramebuffer&&n.deleteFramebuffer(me.__webglMultisampledFramebuffer),me.__webglColorRenderbuffer)for(let et=0;et<me.__webglColorRenderbuffer.length;et++)me.__webglColorRenderbuffer[et]&&n.deleteRenderbuffer(me.__webglColorRenderbuffer[et]);me.__webglDepthRenderbuffer&&n.deleteRenderbuffer(me.__webglDepthRenderbuffer)}const $e=Me.textures;for(let et=0,ht=$e.length;et<ht;et++){const at=i.get($e[et]);at.__webglTexture&&(n.deleteTexture(at.__webglTexture),o.memory.textures--),i.remove($e[et])}i.remove(Me)}let j=0;function J(){j=0}function W(){const Me=j;return Me>=s.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+Me+" texture units while this GPU supports only "+s.maxTextures),j+=1,Me}function oe(Me){const me=[];return me.push(Me.wrapS),me.push(Me.wrapT),me.push(Me.wrapR||0),me.push(Me.magFilter),me.push(Me.minFilter),me.push(Me.anisotropy),me.push(Me.internalFormat),me.push(Me.format),me.push(Me.type),me.push(Me.generateMipmaps),me.push(Me.premultiplyAlpha),me.push(Me.flipY),me.push(Me.unpackAlignment),me.push(Me.colorSpace),me.join()}function ne(Me,me){const $e=i.get(Me);if(Me.isVideoTexture&&Qe(Me),Me.isRenderTargetTexture===!1&&Me.isExternalTexture!==!0&&Me.version>0&&$e.__version!==Me.version){const et=Me.image;if(et===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(et.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Be($e,Me,me);return}}else Me.isExternalTexture&&($e.__webglTexture=Me.sourceTexture?Me.sourceTexture:null);t.bindTexture(n.TEXTURE_2D,$e.__webglTexture,n.TEXTURE0+me)}function q(Me,me){const $e=i.get(Me);if(Me.isRenderTargetTexture===!1&&Me.version>0&&$e.__version!==Me.version){Be($e,Me,me);return}t.bindTexture(n.TEXTURE_2D_ARRAY,$e.__webglTexture,n.TEXTURE0+me)}function le(Me,me){const $e=i.get(Me);if(Me.isRenderTargetTexture===!1&&Me.version>0&&$e.__version!==Me.version){Be($e,Me,me);return}t.bindTexture(n.TEXTURE_3D,$e.__webglTexture,n.TEXTURE0+me)}function se(Me,me){const $e=i.get(Me);if(Me.version>0&&$e.__version!==Me.version){He($e,Me,me);return}t.bindTexture(n.TEXTURE_CUBE_MAP,$e.__webglTexture,n.TEXTURE0+me)}const pe={[fm]:n.REPEAT,[Wu]:n.CLAMP_TO_EDGE,[t0]:n.MIRRORED_REPEAT},be={[ta]:n.NEAREST,[Xb]:n.NEAREST_MIPMAP_NEAREST,[Ag]:n.NEAREST_MIPMAP_LINEAR,[Tr]:n.LINEAR,[J_]:n.LINEAR_MIPMAP_NEAREST,[Oc]:n.LINEAR_MIPMAP_LINEAR},ee={[oI]:n.NEVER,[hI]:n.ALWAYS,[lI]:n.LESS,[bT]:n.LEQUAL,[uI]:n.EQUAL,[fI]:n.GEQUAL,[cI]:n.GREATER,[dI]:n.NOTEQUAL};function te(Me,me){if(me.type===Rl&&e.has("OES_texture_float_linear")===!1&&(me.magFilter===Tr||me.magFilter===J_||me.magFilter===Ag||me.magFilter===Oc||me.minFilter===Tr||me.minFilter===J_||me.minFilter===Ag||me.minFilter===Oc)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),n.texParameteri(Me,n.TEXTURE_WRAP_S,pe[me.wrapS]),n.texParameteri(Me,n.TEXTURE_WRAP_T,pe[me.wrapT]),(Me===n.TEXTURE_3D||Me===n.TEXTURE_2D_ARRAY)&&n.texParameteri(Me,n.TEXTURE_WRAP_R,pe[me.wrapR]),n.texParameteri(Me,n.TEXTURE_MAG_FILTER,be[me.magFilter]),n.texParameteri(Me,n.TEXTURE_MIN_FILTER,be[me.minFilter]),me.compareFunction&&(n.texParameteri(Me,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(Me,n.TEXTURE_COMPARE_FUNC,ee[me.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if(me.magFilter===ta||me.minFilter!==Ag&&me.minFilter!==Oc||me.type===Rl&&e.has("OES_texture_float_linear")===!1)return;if(me.anisotropy>1||i.get(me).__currentAnisotropy){const $e=e.get("EXT_texture_filter_anisotropic");n.texParameterf(Me,$e.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(me.anisotropy,s.getMaxAnisotropy())),i.get(me).__currentAnisotropy=me.anisotropy}}}function ue(Me,me){let $e=!1;Me.__webglInit===void 0&&(Me.__webglInit=!0,me.addEventListener("dispose",P));const et=me.source;let ht=h.get(et);ht===void 0&&(ht={},h.set(et,ht));const at=oe(me);if(at!==Me.__cacheKey){ht[at]===void 0&&(ht[at]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,$e=!0),ht[at].usedTimes++;const Et=ht[Me.__cacheKey];Et!==void 0&&(ht[Me.__cacheKey].usedTimes--,Et.usedTimes===0&&U(me)),Me.__cacheKey=at,Me.__webglTexture=ht[at].texture}return $e}function ae(Me,me,$e){return Math.floor(Math.floor(Me/$e)/me)}function ce(Me,me,$e,et){const at=Me.updateRanges;if(at.length===0)t.texSubImage2D(n.TEXTURE_2D,0,0,0,me.width,me.height,$e,et,me.data);else{at.sort((bt,Jt)=>bt.start-Jt.start);let Et=0;for(let bt=1;bt<at.length;bt++){const Jt=at[Et],Tn=at[bt],We=Jt.start+Jt.count,vt=ae(Tn.start,me.width,4),Yt=ae(Jt.start,me.width,4);Tn.start<=We+1&&vt===Yt&&ae(Tn.start+Tn.count-1,me.width,4)===vt?Jt.count=Math.max(Jt.count,Tn.start+Tn.count-Jt.start):(++Et,at[Et]=Tn)}at.length=Et+1;const Dt=n.getParameter(n.UNPACK_ROW_LENGTH),Vt=n.getParameter(n.UNPACK_SKIP_PIXELS),an=n.getParameter(n.UNPACK_SKIP_ROWS);n.pixelStorei(n.UNPACK_ROW_LENGTH,me.width);for(let bt=0,Jt=at.length;bt<Jt;bt++){const Tn=at[bt],We=Math.floor(Tn.start/4),vt=Math.ceil(Tn.count/4),Yt=We%me.width,qe=Math.floor(We/me.width),Kt=vt,rn=1;n.pixelStorei(n.UNPACK_SKIP_PIXELS,Yt),n.pixelStorei(n.UNPACK_SKIP_ROWS,qe),t.texSubImage2D(n.TEXTURE_2D,0,Yt,qe,Kt,rn,$e,et,me.data)}Me.clearUpdateRanges(),n.pixelStorei(n.UNPACK_ROW_LENGTH,Dt),n.pixelStorei(n.UNPACK_SKIP_PIXELS,Vt),n.pixelStorei(n.UNPACK_SKIP_ROWS,an)}}function Be(Me,me,$e){let et=n.TEXTURE_2D;(me.isDataArrayTexture||me.isCompressedArrayTexture)&&(et=n.TEXTURE_2D_ARRAY),me.isData3DTexture&&(et=n.TEXTURE_3D);const ht=ue(Me,me),at=me.source;t.bindTexture(et,Me.__webglTexture,n.TEXTURE0+$e);const Et=i.get(at);if(at.version!==Et.__version||ht===!0){t.activeTexture(n.TEXTURE0+$e);const Dt=us.getPrimaries(us.workingColorSpace),Vt=me.colorSpace===Bd?null:us.getPrimaries(me.colorSpace),an=me.colorSpace===Bd||Dt===Vt?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,me.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,me.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,me.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,an);let bt=w(me.image,!1,s.maxTextureSize);bt=mt(me,bt);const Jt=r.convert(me.format,me.colorSpace),Tn=r.convert(me.type);let We=C(me.internalFormat,Jt,Tn,me.colorSpace,me.isVideoTexture);te(et,me);let vt;const Yt=me.mipmaps,qe=me.isVideoTexture!==!0,Kt=Et.__version===void 0||ht===!0,rn=at.dataReady,fe=R(me,bt);if(me.isDepthTexture)We=x(me.format===kg,me.type),Kt&&(qe?t.texStorage2D(n.TEXTURE_2D,1,We,bt.width,bt.height):t.texImage2D(n.TEXTURE_2D,0,We,bt.width,bt.height,0,Jt,Tn,null));else if(me.isDataTexture)if(Yt.length>0){qe&&Kt&&t.texStorage2D(n.TEXTURE_2D,fe,We,Yt[0].width,Yt[0].height);for(let B=0,I=Yt.length;B<I;B++)vt=Yt[B],qe?rn&&t.texSubImage2D(n.TEXTURE_2D,B,0,0,vt.width,vt.height,Jt,Tn,vt.data):t.texImage2D(n.TEXTURE_2D,B,We,vt.width,vt.height,0,Jt,Tn,vt.data);me.generateMipmaps=!1}else qe?(Kt&&t.texStorage2D(n.TEXTURE_2D,fe,We,bt.width,bt.height),rn&&ce(me,bt,Jt,Tn)):t.texImage2D(n.TEXTURE_2D,0,We,bt.width,bt.height,0,Jt,Tn,bt.data);else if(me.isCompressedTexture)if(me.isCompressedArrayTexture){qe&&Kt&&t.texStorage3D(n.TEXTURE_2D_ARRAY,fe,We,Yt[0].width,Yt[0].height,bt.depth);for(let B=0,I=Yt.length;B<I;B++)if(vt=Yt[B],me.format!==Xo)if(Jt!==null)if(qe){if(rn)if(me.layerUpdates.size>0){const A=BE(vt.width,vt.height,me.format,me.type);for(const F of me.layerUpdates){const K=vt.data.subarray(F*A/vt.data.BYTES_PER_ELEMENT,(F+1)*A/vt.data.BYTES_PER_ELEMENT);t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,B,0,0,F,vt.width,vt.height,1,Jt,K)}me.clearLayerUpdates()}else t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,B,0,0,0,vt.width,vt.height,bt.depth,Jt,vt.data)}else t.compressedTexImage3D(n.TEXTURE_2D_ARRAY,B,We,vt.width,vt.height,bt.depth,0,vt.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else qe?rn&&t.texSubImage3D(n.TEXTURE_2D_ARRAY,B,0,0,0,vt.width,vt.height,bt.depth,Jt,Tn,vt.data):t.texImage3D(n.TEXTURE_2D_ARRAY,B,We,vt.width,vt.height,bt.depth,0,Jt,Tn,vt.data)}else{qe&&Kt&&t.texStorage2D(n.TEXTURE_2D,fe,We,Yt[0].width,Yt[0].height);for(let B=0,I=Yt.length;B<I;B++)vt=Yt[B],me.format!==Xo?Jt!==null?qe?rn&&t.compressedTexSubImage2D(n.TEXTURE_2D,B,0,0,vt.width,vt.height,Jt,vt.data):t.compressedTexImage2D(n.TEXTURE_2D,B,We,vt.width,vt.height,0,vt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):qe?rn&&t.texSubImage2D(n.TEXTURE_2D,B,0,0,vt.width,vt.height,Jt,Tn,vt.data):t.texImage2D(n.TEXTURE_2D,B,We,vt.width,vt.height,0,Jt,Tn,vt.data)}else if(me.isDataArrayTexture)if(qe){if(Kt&&t.texStorage3D(n.TEXTURE_2D_ARRAY,fe,We,bt.width,bt.height,bt.depth),rn)if(me.layerUpdates.size>0){const B=BE(bt.width,bt.height,me.format,me.type);for(const I of me.layerUpdates){const A=bt.data.subarray(I*B/bt.data.BYTES_PER_ELEMENT,(I+1)*B/bt.data.BYTES_PER_ELEMENT);t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,I,bt.width,bt.height,1,Jt,Tn,A)}me.clearLayerUpdates()}else t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,bt.width,bt.height,bt.depth,Jt,Tn,bt.data)}else t.texImage3D(n.TEXTURE_2D_ARRAY,0,We,bt.width,bt.height,bt.depth,0,Jt,Tn,bt.data);else if(me.isData3DTexture)qe?(Kt&&t.texStorage3D(n.TEXTURE_3D,fe,We,bt.width,bt.height,bt.depth),rn&&t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,bt.width,bt.height,bt.depth,Jt,Tn,bt.data)):t.texImage3D(n.TEXTURE_3D,0,We,bt.width,bt.height,bt.depth,0,Jt,Tn,bt.data);else if(me.isFramebufferTexture){if(Kt)if(qe)t.texStorage2D(n.TEXTURE_2D,fe,We,bt.width,bt.height);else{let B=bt.width,I=bt.height;for(let A=0;A<fe;A++)t.texImage2D(n.TEXTURE_2D,A,We,B,I,0,Jt,Tn,null),B>>=1,I>>=1}}else if(Yt.length>0){if(qe&&Kt){const B=Tt(Yt[0]);t.texStorage2D(n.TEXTURE_2D,fe,We,B.width,B.height)}for(let B=0,I=Yt.length;B<I;B++)vt=Yt[B],qe?rn&&t.texSubImage2D(n.TEXTURE_2D,B,0,0,Jt,Tn,vt):t.texImage2D(n.TEXTURE_2D,B,We,Jt,Tn,vt);me.generateMipmaps=!1}else if(qe){if(Kt){const B=Tt(bt);t.texStorage2D(n.TEXTURE_2D,fe,We,B.width,B.height)}rn&&t.texSubImage2D(n.TEXTURE_2D,0,0,0,Jt,Tn,bt)}else t.texImage2D(n.TEXTURE_2D,0,We,Jt,Tn,bt);S(me)&&M(et),Et.__version=at.version,me.onUpdate&&me.onUpdate(me)}Me.__version=me.version}function He(Me,me,$e){if(me.image.length!==6)return;const et=ue(Me,me),ht=me.source;t.bindTexture(n.TEXTURE_CUBE_MAP,Me.__webglTexture,n.TEXTURE0+$e);const at=i.get(ht);if(ht.version!==at.__version||et===!0){t.activeTexture(n.TEXTURE0+$e);const Et=us.getPrimaries(us.workingColorSpace),Dt=me.colorSpace===Bd?null:us.getPrimaries(me.colorSpace),Vt=me.colorSpace===Bd||Et===Dt?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,me.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,me.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,me.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,Vt);const an=me.isCompressedTexture||me.image[0].isCompressedTexture,bt=me.image[0]&&me.image[0].isDataTexture,Jt=[];for(let I=0;I<6;I++)!an&&!bt?Jt[I]=w(me.image[I],!0,s.maxCubemapSize):Jt[I]=bt?me.image[I].image:me.image[I],Jt[I]=mt(me,Jt[I]);const Tn=Jt[0],We=r.convert(me.format,me.colorSpace),vt=r.convert(me.type),Yt=C(me.internalFormat,We,vt,me.colorSpace),qe=me.isVideoTexture!==!0,Kt=at.__version===void 0||et===!0,rn=ht.dataReady;let fe=R(me,Tn);te(n.TEXTURE_CUBE_MAP,me);let B;if(an){qe&&Kt&&t.texStorage2D(n.TEXTURE_CUBE_MAP,fe,Yt,Tn.width,Tn.height);for(let I=0;I<6;I++){B=Jt[I].mipmaps;for(let A=0;A<B.length;A++){const F=B[A];me.format!==Xo?We!==null?qe?rn&&t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+I,A,0,0,F.width,F.height,We,F.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+I,A,Yt,F.width,F.height,0,F.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):qe?rn&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+I,A,0,0,F.width,F.height,We,vt,F.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+I,A,Yt,F.width,F.height,0,We,vt,F.data)}}}else{if(B=me.mipmaps,qe&&Kt){B.length>0&&fe++;const I=Tt(Jt[0]);t.texStorage2D(n.TEXTURE_CUBE_MAP,fe,Yt,I.width,I.height)}for(let I=0;I<6;I++)if(bt){qe?rn&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+I,0,0,0,Jt[I].width,Jt[I].height,We,vt,Jt[I].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+I,0,Yt,Jt[I].width,Jt[I].height,0,We,vt,Jt[I].data);for(let A=0;A<B.length;A++){const K=B[A].image[I].image;qe?rn&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+I,A+1,0,0,K.width,K.height,We,vt,K.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+I,A+1,Yt,K.width,K.height,0,We,vt,K.data)}}else{qe?rn&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+I,0,0,0,We,vt,Jt[I]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+I,0,Yt,We,vt,Jt[I]);for(let A=0;A<B.length;A++){const F=B[A];qe?rn&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+I,A+1,0,0,We,vt,F.image[I]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+I,A+1,Yt,We,vt,F.image[I])}}}S(me)&&M(n.TEXTURE_CUBE_MAP),at.__version=ht.version,me.onUpdate&&me.onUpdate(me)}Me.__version=me.version}function Xe(Me,me,$e,et,ht,at){const Et=r.convert($e.format,$e.colorSpace),Dt=r.convert($e.type),Vt=C($e.internalFormat,Et,Dt,$e.colorSpace),an=i.get(me),bt=i.get($e);if(bt.__renderTarget=me,!an.__hasExternalTextures){const Jt=Math.max(1,me.width>>at),Tn=Math.max(1,me.height>>at);ht===n.TEXTURE_3D||ht===n.TEXTURE_2D_ARRAY?t.texImage3D(ht,at,Vt,Jt,Tn,me.depth,0,Et,Dt,null):t.texImage2D(ht,at,Vt,Jt,Tn,0,Et,Dt,null)}t.bindFramebuffer(n.FRAMEBUFFER,Me),Ve(me)?l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,et,ht,bt.__webglTexture,0,Ye(me)):(ht===n.TEXTURE_2D||ht>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&ht<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,et,ht,bt.__webglTexture,at),t.bindFramebuffer(n.FRAMEBUFFER,null)}function ot(Me,me,$e){if(n.bindRenderbuffer(n.RENDERBUFFER,Me),me.depthBuffer){const et=me.depthTexture,ht=et&&et.isDepthTexture?et.type:null,at=x(me.stencilBuffer,ht),Et=me.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Dt=Ye(me);Ve(me)?l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,Dt,at,me.width,me.height):$e?n.renderbufferStorageMultisample(n.RENDERBUFFER,Dt,at,me.width,me.height):n.renderbufferStorage(n.RENDERBUFFER,at,me.width,me.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,Et,n.RENDERBUFFER,Me)}else{const et=me.textures;for(let ht=0;ht<et.length;ht++){const at=et[ht],Et=r.convert(at.format,at.colorSpace),Dt=r.convert(at.type),Vt=C(at.internalFormat,Et,Dt,at.colorSpace),an=Ye(me);$e&&Ve(me)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,an,Vt,me.width,me.height):Ve(me)?l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,an,Vt,me.width,me.height):n.renderbufferStorage(n.RENDERBUFFER,Vt,me.width,me.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function tt(Me,me){if(me&&me.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,Me),!(me.depthTexture&&me.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const et=i.get(me.depthTexture);et.__renderTarget=me,(!et.__webglTexture||me.depthTexture.image.width!==me.width||me.depthTexture.image.height!==me.height)&&(me.depthTexture.image.width=me.width,me.depthTexture.image.height=me.height,me.depthTexture.needsUpdate=!0),ne(me.depthTexture,0);const ht=et.__webglTexture,at=Ye(me);if(me.depthTexture.format===i0)Ve(me)?l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,ht,0,at):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,ht,0);else if(me.depthTexture.format===kg)Ve(me)?l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,ht,0,at):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,ht,0);else throw new Error("Unknown depthTexture format")}function Ae(Me){const me=i.get(Me),$e=Me.isWebGLCubeRenderTarget===!0;if(me.__boundDepthTexture!==Me.depthTexture){const et=Me.depthTexture;if(me.__depthDisposeCallback&&me.__depthDisposeCallback(),et){const ht=()=>{delete me.__boundDepthTexture,delete me.__depthDisposeCallback,et.removeEventListener("dispose",ht)};et.addEventListener("dispose",ht),me.__depthDisposeCallback=ht}me.__boundDepthTexture=et}if(Me.depthTexture&&!me.__autoAllocateDepthBuffer){if($e)throw new Error("target.depthTexture not supported in Cube render targets");const et=Me.texture.mipmaps;et&&et.length>0?tt(me.__webglFramebuffer[0],Me):tt(me.__webglFramebuffer,Me)}else if($e){me.__webglDepthbuffer=[];for(let et=0;et<6;et++)if(t.bindFramebuffer(n.FRAMEBUFFER,me.__webglFramebuffer[et]),me.__webglDepthbuffer[et]===void 0)me.__webglDepthbuffer[et]=n.createRenderbuffer(),ot(me.__webglDepthbuffer[et],Me,!1);else{const ht=Me.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,at=me.__webglDepthbuffer[et];n.bindRenderbuffer(n.RENDERBUFFER,at),n.framebufferRenderbuffer(n.FRAMEBUFFER,ht,n.RENDERBUFFER,at)}}else{const et=Me.texture.mipmaps;if(et&&et.length>0?t.bindFramebuffer(n.FRAMEBUFFER,me.__webglFramebuffer[0]):t.bindFramebuffer(n.FRAMEBUFFER,me.__webglFramebuffer),me.__webglDepthbuffer===void 0)me.__webglDepthbuffer=n.createRenderbuffer(),ot(me.__webglDepthbuffer,Me,!1);else{const ht=Me.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,at=me.__webglDepthbuffer;n.bindRenderbuffer(n.RENDERBUFFER,at),n.framebufferRenderbuffer(n.FRAMEBUFFER,ht,n.RENDERBUFFER,at)}}t.bindFramebuffer(n.FRAMEBUFFER,null)}function ye(Me,me,$e){const et=i.get(Me);me!==void 0&&Xe(et.__webglFramebuffer,Me,Me.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),$e!==void 0&&Ae(Me)}function xe(Me){const me=Me.texture,$e=i.get(Me),et=i.get(me);Me.addEventListener("dispose",D);const ht=Me.textures,at=Me.isWebGLCubeRenderTarget===!0,Et=ht.length>1;if(Et||(et.__webglTexture===void 0&&(et.__webglTexture=n.createTexture()),et.__version=me.version,o.memory.textures++),at){$e.__webglFramebuffer=[];for(let Dt=0;Dt<6;Dt++)if(me.mipmaps&&me.mipmaps.length>0){$e.__webglFramebuffer[Dt]=[];for(let Vt=0;Vt<me.mipmaps.length;Vt++)$e.__webglFramebuffer[Dt][Vt]=n.createFramebuffer()}else $e.__webglFramebuffer[Dt]=n.createFramebuffer()}else{if(me.mipmaps&&me.mipmaps.length>0){$e.__webglFramebuffer=[];for(let Dt=0;Dt<me.mipmaps.length;Dt++)$e.__webglFramebuffer[Dt]=n.createFramebuffer()}else $e.__webglFramebuffer=n.createFramebuffer();if(Et)for(let Dt=0,Vt=ht.length;Dt<Vt;Dt++){const an=i.get(ht[Dt]);an.__webglTexture===void 0&&(an.__webglTexture=n.createTexture(),o.memory.textures++)}if(Me.samples>0&&Ve(Me)===!1){$e.__webglMultisampledFramebuffer=n.createFramebuffer(),$e.__webglColorRenderbuffer=[],t.bindFramebuffer(n.FRAMEBUFFER,$e.__webglMultisampledFramebuffer);for(let Dt=0;Dt<ht.length;Dt++){const Vt=ht[Dt];$e.__webglColorRenderbuffer[Dt]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,$e.__webglColorRenderbuffer[Dt]);const an=r.convert(Vt.format,Vt.colorSpace),bt=r.convert(Vt.type),Jt=C(Vt.internalFormat,an,bt,Vt.colorSpace,Me.isXRRenderTarget===!0),Tn=Ye(Me);n.renderbufferStorageMultisample(n.RENDERBUFFER,Tn,Jt,Me.width,Me.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Dt,n.RENDERBUFFER,$e.__webglColorRenderbuffer[Dt])}n.bindRenderbuffer(n.RENDERBUFFER,null),Me.depthBuffer&&($e.__webglDepthRenderbuffer=n.createRenderbuffer(),ot($e.__webglDepthRenderbuffer,Me,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}}if(at){t.bindTexture(n.TEXTURE_CUBE_MAP,et.__webglTexture),te(n.TEXTURE_CUBE_MAP,me);for(let Dt=0;Dt<6;Dt++)if(me.mipmaps&&me.mipmaps.length>0)for(let Vt=0;Vt<me.mipmaps.length;Vt++)Xe($e.__webglFramebuffer[Dt][Vt],Me,me,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+Dt,Vt);else Xe($e.__webglFramebuffer[Dt],Me,me,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+Dt,0);S(me)&&M(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(Et){for(let Dt=0,Vt=ht.length;Dt<Vt;Dt++){const an=ht[Dt],bt=i.get(an);let Jt=n.TEXTURE_2D;(Me.isWebGL3DRenderTarget||Me.isWebGLArrayRenderTarget)&&(Jt=Me.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY),t.bindTexture(Jt,bt.__webglTexture),te(Jt,an),Xe($e.__webglFramebuffer,Me,an,n.COLOR_ATTACHMENT0+Dt,Jt,0),S(an)&&M(Jt)}t.unbindTexture()}else{let Dt=n.TEXTURE_2D;if((Me.isWebGL3DRenderTarget||Me.isWebGLArrayRenderTarget)&&(Dt=Me.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY),t.bindTexture(Dt,et.__webglTexture),te(Dt,me),me.mipmaps&&me.mipmaps.length>0)for(let Vt=0;Vt<me.mipmaps.length;Vt++)Xe($e.__webglFramebuffer[Vt],Me,me,n.COLOR_ATTACHMENT0,Dt,Vt);else Xe($e.__webglFramebuffer,Me,me,n.COLOR_ATTACHMENT0,Dt,0);S(me)&&M(Dt),t.unbindTexture()}Me.depthBuffer&&Ae(Me)}function ke(Me){const me=Me.textures;for(let $e=0,et=me.length;$e<et;$e++){const ht=me[$e];if(S(ht)){const at=T(Me),Et=i.get(ht).__webglTexture;t.bindTexture(at,Et),M(at),t.unbindTexture()}}}const ze=[],je=[];function Fe(Me){if(Me.samples>0){if(Ve(Me)===!1){const me=Me.textures,$e=Me.width,et=Me.height;let ht=n.COLOR_BUFFER_BIT;const at=Me.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Et=i.get(Me),Dt=me.length>1;if(Dt)for(let an=0;an<me.length;an++)t.bindFramebuffer(n.FRAMEBUFFER,Et.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+an,n.RENDERBUFFER,null),t.bindFramebuffer(n.FRAMEBUFFER,Et.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+an,n.TEXTURE_2D,null,0);t.bindFramebuffer(n.READ_FRAMEBUFFER,Et.__webglMultisampledFramebuffer);const Vt=Me.texture.mipmaps;Vt&&Vt.length>0?t.bindFramebuffer(n.DRAW_FRAMEBUFFER,Et.__webglFramebuffer[0]):t.bindFramebuffer(n.DRAW_FRAMEBUFFER,Et.__webglFramebuffer);for(let an=0;an<me.length;an++){if(Me.resolveDepthBuffer&&(Me.depthBuffer&&(ht|=n.DEPTH_BUFFER_BIT),Me.stencilBuffer&&Me.resolveStencilBuffer&&(ht|=n.STENCIL_BUFFER_BIT)),Dt){n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,Et.__webglColorRenderbuffer[an]);const bt=i.get(me[an]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,bt,0)}n.blitFramebuffer(0,0,$e,et,0,0,$e,et,ht,n.NEAREST),c===!0&&(ze.length=0,je.length=0,ze.push(n.COLOR_ATTACHMENT0+an),Me.depthBuffer&&Me.resolveDepthBuffer===!1&&(ze.push(at),je.push(at),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,je)),n.invalidateFramebuffer(n.READ_FRAMEBUFFER,ze))}if(t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),Dt)for(let an=0;an<me.length;an++){t.bindFramebuffer(n.FRAMEBUFFER,Et.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+an,n.RENDERBUFFER,Et.__webglColorRenderbuffer[an]);const bt=i.get(me[an]).__webglTexture;t.bindFramebuffer(n.FRAMEBUFFER,Et.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+an,n.TEXTURE_2D,bt,0)}t.bindFramebuffer(n.DRAW_FRAMEBUFFER,Et.__webglMultisampledFramebuffer)}else if(Me.depthBuffer&&Me.resolveDepthBuffer===!1&&c){const me=Me.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT;n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[me])}}}function Ye(Me){return Math.min(s.maxSamples,Me.samples)}function Ve(Me){const me=i.get(Me);return Me.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&me.__useRenderToTexture!==!1}function Qe(Me){const me=o.render.frame;g.get(Me)!==me&&(g.set(Me,me),Me.update())}function mt(Me,me){const $e=Me.colorSpace,et=Me.format,ht=Me.type;return Me.isCompressedTexture===!0||Me.isVideoTexture===!0||$e!==Gf&&$e!==Bd&&(us.getTransfer($e)===js?(et!==Xo||ht!==Ha)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",$e)),me}function Tt(Me){return typeof HTMLImageElement<"u"&&Me instanceof HTMLImageElement?(d.width=Me.naturalWidth||Me.width,d.height=Me.naturalHeight||Me.height):typeof VideoFrame<"u"&&Me instanceof VideoFrame?(d.width=Me.displayWidth,d.height=Me.displayHeight):(d.width=Me.width,d.height=Me.height),d}this.allocateTextureUnit=W,this.resetTextureUnits=J,this.setTexture2D=ne,this.setTexture2DArray=q,this.setTexture3D=le,this.setTextureCube=se,this.rebindTextures=ye,this.setupRenderTarget=xe,this.updateRenderTargetMipmap=ke,this.updateMultisampleRenderTarget=Fe,this.setupDepthRenderbuffer=Ae,this.setupFrameBufferTexture=Xe,this.useMultisampledRTT=Ve}function gO(n,e){function t(i,s=Bd){let r;const o=us.getTransfer(s);if(i===Ha)return n.UNSIGNED_BYTE;if(i===Jb)return n.UNSIGNED_SHORT_4_4_4_4;if(i===Qb)return n.UNSIGNED_SHORT_5_5_5_1;if(i===pT)return n.UNSIGNED_INT_5_9_9_9_REV;if(i===fT)return n.BYTE;if(i===hT)return n.SHORT;if(i===n0)return n.UNSIGNED_SHORT;if(i===Yb)return n.INT;if(i===kf)return n.UNSIGNED_INT;if(i===Rl)return n.FLOAT;if(i===Jg)return n.HALF_FLOAT;if(i===mT)return n.ALPHA;if(i===gT)return n.RGB;if(i===Xo)return n.RGBA;if(i===i0)return n.DEPTH_COMPONENT;if(i===kg)return n.DEPTH_STENCIL;if(i===Zb)return n.RED;if(i===Wv)return n.RED_INTEGER;if(i===_T)return n.RG;if(i===ex)return n.RG_INTEGER;if(i===tx)return n.RGBA_INTEGER;if(i===vv||i===yv||i===Mv||i===bv)if(o===js)if(r=e.get("WEBGL_compressed_texture_s3tc_srgb"),r!==null){if(i===vv)return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(i===yv)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(i===Mv)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(i===bv)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(r=e.get("WEBGL_compressed_texture_s3tc"),r!==null){if(i===vv)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===yv)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===Mv)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===bv)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(i===tb||i===nb||i===ib||i===sb)if(r=e.get("WEBGL_compressed_texture_pvrtc"),r!==null){if(i===tb)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===nb)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===ib)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===sb)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(i===rb||i===ab||i===ob)if(r=e.get("WEBGL_compressed_texture_etc"),r!==null){if(i===rb||i===ab)return o===js?r.COMPRESSED_SRGB8_ETC2:r.COMPRESSED_RGB8_ETC2;if(i===ob)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:r.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(i===lb||i===ub||i===cb||i===db||i===fb||i===hb||i===pb||i===mb||i===gb||i===_b||i===vb||i===yb||i===Mb||i===bb)if(r=e.get("WEBGL_compressed_texture_astc"),r!==null){if(i===lb)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:r.COMPRESSED_RGBA_ASTC_4x4_KHR;if(i===ub)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:r.COMPRESSED_RGBA_ASTC_5x4_KHR;if(i===cb)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:r.COMPRESSED_RGBA_ASTC_5x5_KHR;if(i===db)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:r.COMPRESSED_RGBA_ASTC_6x5_KHR;if(i===fb)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:r.COMPRESSED_RGBA_ASTC_6x6_KHR;if(i===hb)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:r.COMPRESSED_RGBA_ASTC_8x5_KHR;if(i===pb)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:r.COMPRESSED_RGBA_ASTC_8x6_KHR;if(i===mb)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:r.COMPRESSED_RGBA_ASTC_8x8_KHR;if(i===gb)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:r.COMPRESSED_RGBA_ASTC_10x5_KHR;if(i===_b)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:r.COMPRESSED_RGBA_ASTC_10x6_KHR;if(i===vb)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:r.COMPRESSED_RGBA_ASTC_10x8_KHR;if(i===yb)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:r.COMPRESSED_RGBA_ASTC_10x10_KHR;if(i===Mb)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:r.COMPRESSED_RGBA_ASTC_12x10_KHR;if(i===bb)return o===js?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:r.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(i===xv||i===xb||i===wb)if(r=e.get("EXT_texture_compression_bptc"),r!==null){if(i===xv)return o===js?r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:r.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(i===xb)return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(i===wb)return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(i===vT||i===Eb||i===Tb||i===Sb)if(r=e.get("EXT_texture_compression_rgtc"),r!==null){if(i===xv)return r.COMPRESSED_RED_RGTC1_EXT;if(i===Eb)return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(i===Tb)return r.COMPRESSED_RED_GREEN_RGTC2_EXT;if(i===Sb)return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return i===Ug?n.UNSIGNED_INT_24_8:n[i]!==void 0?n[i]:null}return{convert:t}}class _O extends vr{constructor(e=null){super(),this.sourceTexture=e,this.isExternalTexture=!0}}const b$=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,x$=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class w${constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,t){if(this.texture===null){const i=new _O(e.texture);(e.depthNear!==t.depthNear||e.depthFar!==t.depthFar)&&(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=i}}getMesh(e){if(this.texture!==null&&this.mesh===null){const t=e.cameras[0].viewport,i=new ja({vertexShader:b$,fragmentShader:x$,uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new ea(new v0(20,20),i)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class E$ extends Zu{constructor(e,t){super();const i=this;let s=null,r=1,o=null,l="local-floor",c=1,d=null,g=null,p=null,h=null,v=null,y=null;const w=new w$,S={},M=t.getContextAttributes();let T=null,C=null;const x=[],R=[],P=new Gt;let D=null;const z=new Er;z.viewport=new ds;const U=new Er;U.viewport=new ds;const N=[z,U],j=new rO;let J=null,W=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(ce){let Be=x[ce];return Be===void 0&&(Be=new kM,x[ce]=Be),Be.getTargetRaySpace()},this.getControllerGrip=function(ce){let Be=x[ce];return Be===void 0&&(Be=new kM,x[ce]=Be),Be.getGripSpace()},this.getHand=function(ce){let Be=x[ce];return Be===void 0&&(Be=new kM,x[ce]=Be),Be.getHandSpace()};function oe(ce){const Be=R.indexOf(ce.inputSource);if(Be===-1)return;const He=x[Be];He!==void 0&&(He.update(ce.inputSource,ce.frame,d||o),He.dispatchEvent({type:ce.type,data:ce.inputSource}))}function ne(){s.removeEventListener("select",oe),s.removeEventListener("selectstart",oe),s.removeEventListener("selectend",oe),s.removeEventListener("squeeze",oe),s.removeEventListener("squeezestart",oe),s.removeEventListener("squeezeend",oe),s.removeEventListener("end",ne),s.removeEventListener("inputsourceschange",q);for(let ce=0;ce<x.length;ce++){const Be=R[ce];Be!==null&&(R[ce]=null,x[ce].disconnect(Be))}J=null,W=null,w.reset();for(const ce in S)delete S[ce];e.setRenderTarget(T),v=null,h=null,p=null,s=null,C=null,ae.stop(),i.isPresenting=!1,e.setPixelRatio(D),e.setSize(P.width,P.height,!1),i.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(ce){r=ce,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(ce){l=ce,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return d||o},this.setReferenceSpace=function(ce){d=ce},this.getBaseLayer=function(){return h!==null?h:v},this.getBinding=function(){return p},this.getFrame=function(){return y},this.getSession=function(){return s},this.setSession=async function(ce){if(s=ce,s!==null){if(T=e.getRenderTarget(),s.addEventListener("select",oe),s.addEventListener("selectstart",oe),s.addEventListener("selectend",oe),s.addEventListener("squeeze",oe),s.addEventListener("squeezestart",oe),s.addEventListener("squeezeend",oe),s.addEventListener("end",ne),s.addEventListener("inputsourceschange",q),M.xrCompatible!==!0&&await t.makeXRCompatible(),D=e.getPixelRatio(),e.getSize(P),typeof XRWebGLBinding<"u"&&(p=new XRWebGLBinding(s,t)),p!==null&&"createProjectionLayer"in XRWebGLBinding.prototype){let He=null,Xe=null,ot=null;M.depth&&(ot=M.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,He=M.stencil?kg:i0,Xe=M.stencil?Ug:kf);const tt={colorFormat:t.RGBA8,depthFormat:ot,scaleFactor:r};h=p.createProjectionLayer(tt),s.updateRenderState({layers:[h]}),e.setPixelRatio(1),e.setSize(h.textureWidth,h.textureHeight,!1),C=new Da(h.textureWidth,h.textureHeight,{format:Xo,type:Ha,depthTexture:new fx(h.textureWidth,h.textureHeight,Xe,void 0,void 0,void 0,void 0,void 0,void 0,He),stencilBuffer:M.stencil,colorSpace:e.outputColorSpace,samples:M.antialias?4:0,resolveDepthBuffer:h.ignoreDepthValues===!1,resolveStencilBuffer:h.ignoreDepthValues===!1})}else{const He={antialias:M.antialias,alpha:!0,depth:M.depth,stencil:M.stencil,framebufferScaleFactor:r};v=new XRWebGLLayer(s,t,He),s.updateRenderState({baseLayer:v}),e.setPixelRatio(1),e.setSize(v.framebufferWidth,v.framebufferHeight,!1),C=new Da(v.framebufferWidth,v.framebufferHeight,{format:Xo,type:Ha,colorSpace:e.outputColorSpace,stencilBuffer:M.stencil,resolveDepthBuffer:v.ignoreDepthValues===!1,resolveStencilBuffer:v.ignoreDepthValues===!1})}C.isXRRenderTarget=!0,this.setFoveation(c),d=null,o=await s.requestReferenceSpace(l),ae.setContext(s),ae.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(s!==null)return s.environmentBlendMode},this.getDepthTexture=function(){return w.getDepthTexture()};function q(ce){for(let Be=0;Be<ce.removed.length;Be++){const He=ce.removed[Be],Xe=R.indexOf(He);Xe>=0&&(R[Xe]=null,x[Xe].disconnect(He))}for(let Be=0;Be<ce.added.length;Be++){const He=ce.added[Be];let Xe=R.indexOf(He);if(Xe===-1){for(let tt=0;tt<x.length;tt++)if(tt>=R.length){R.push(He),Xe=tt;break}else if(R[tt]===null){R[tt]=He,Xe=tt;break}if(Xe===-1)break}const ot=x[Xe];ot&&ot.connect(He)}}const le=new Oe,se=new Oe;function pe(ce,Be,He){le.setFromMatrixPosition(Be.matrixWorld),se.setFromMatrixPosition(He.matrixWorld);const Xe=le.distanceTo(se),ot=Be.projectionMatrix.elements,tt=He.projectionMatrix.elements,Ae=ot[14]/(ot[10]-1),ye=ot[14]/(ot[10]+1),xe=(ot[9]+1)/ot[5],ke=(ot[9]-1)/ot[5],ze=(ot[8]-1)/ot[0],je=(tt[8]+1)/tt[0],Fe=Ae*ze,Ye=Ae*je,Ve=Xe/(-ze+je),Qe=Ve*-ze;if(Be.matrixWorld.decompose(ce.position,ce.quaternion,ce.scale),ce.translateX(Qe),ce.translateZ(Ve),ce.matrixWorld.compose(ce.position,ce.quaternion,ce.scale),ce.matrixWorldInverse.copy(ce.matrixWorld).invert(),ot[10]===-1)ce.projectionMatrix.copy(Be.projectionMatrix),ce.projectionMatrixInverse.copy(Be.projectionMatrixInverse);else{const mt=Ae+Ve,Tt=ye+Ve,Me=Fe-Qe,me=Ye+(Xe-Qe),$e=xe*ye/Tt*mt,et=ke*ye/Tt*mt;ce.projectionMatrix.makePerspective(Me,me,$e,et,mt,Tt),ce.projectionMatrixInverse.copy(ce.projectionMatrix).invert()}}function be(ce,Be){Be===null?ce.matrixWorld.copy(ce.matrix):ce.matrixWorld.multiplyMatrices(Be.matrixWorld,ce.matrix),ce.matrixWorldInverse.copy(ce.matrixWorld).invert()}this.updateCamera=function(ce){if(s===null)return;let Be=ce.near,He=ce.far;w.texture!==null&&(w.depthNear>0&&(Be=w.depthNear),w.depthFar>0&&(He=w.depthFar)),j.near=U.near=z.near=Be,j.far=U.far=z.far=He,(J!==j.near||W!==j.far)&&(s.updateRenderState({depthNear:j.near,depthFar:j.far}),J=j.near,W=j.far),j.layers.mask=ce.layers.mask|6,z.layers.mask=j.layers.mask&3,U.layers.mask=j.layers.mask&5;const Xe=ce.parent,ot=j.cameras;be(j,Xe);for(let tt=0;tt<ot.length;tt++)be(ot[tt],Xe);ot.length===2?pe(j,z,U):j.projectionMatrix.copy(z.projectionMatrix),ee(ce,j,Xe)};function ee(ce,Be,He){He===null?ce.matrix.copy(Be.matrixWorld):(ce.matrix.copy(He.matrixWorld),ce.matrix.invert(),ce.matrix.multiply(Be.matrixWorld)),ce.matrix.decompose(ce.position,ce.quaternion,ce.scale),ce.updateMatrixWorld(!0),ce.projectionMatrix.copy(Be.projectionMatrix),ce.projectionMatrixInverse.copy(Be.projectionMatrixInverse),ce.isPerspectiveCamera&&(ce.fov=o0*2*Math.atan(1/ce.projectionMatrix.elements[5]),ce.zoom=1)}this.getCamera=function(){return j},this.getFoveation=function(){if(!(h===null&&v===null))return c},this.setFoveation=function(ce){c=ce,h!==null&&(h.fixedFoveation=ce),v!==null&&v.fixedFoveation!==void 0&&(v.fixedFoveation=ce)},this.hasDepthSensing=function(){return w.texture!==null},this.getDepthSensingMesh=function(){return w.getMesh(j)},this.getCameraTexture=function(ce){return S[ce]};let te=null;function ue(ce,Be){if(g=Be.getViewerPose(d||o),y=Be,g!==null){const He=g.views;v!==null&&(e.setRenderTargetFramebuffer(C,v.framebuffer),e.setRenderTarget(C));let Xe=!1;He.length!==j.cameras.length&&(j.cameras.length=0,Xe=!0);for(let ye=0;ye<He.length;ye++){const xe=He[ye];let ke=null;if(v!==null)ke=v.getViewport(xe);else{const je=p.getViewSubImage(h,xe);ke=je.viewport,ye===0&&(e.setRenderTargetTextures(C,je.colorTexture,je.depthStencilTexture),e.setRenderTarget(C))}let ze=N[ye];ze===void 0&&(ze=new Er,ze.layers.enable(ye),ze.viewport=new ds,N[ye]=ze),ze.matrix.fromArray(xe.transform.matrix),ze.matrix.decompose(ze.position,ze.quaternion,ze.scale),ze.projectionMatrix.fromArray(xe.projectionMatrix),ze.projectionMatrixInverse.copy(ze.projectionMatrix).invert(),ze.viewport.set(ke.x,ke.y,ke.width,ke.height),ye===0&&(j.matrix.copy(ze.matrix),j.matrix.decompose(j.position,j.quaternion,j.scale)),Xe===!0&&j.cameras.push(ze)}const ot=s.enabledFeatures;if(ot&&ot.includes("depth-sensing")&&s.depthUsage=="gpu-optimized"&&p){const ye=p.getDepthInformation(He[0]);ye&&ye.isValid&&ye.texture&&w.init(ye,s.renderState)}if(ot&&ot.includes("camera-access")&&(e.state.unbindTexture(),p))for(let ye=0;ye<He.length;ye++){const xe=He[ye].camera;if(xe){let ke=S[xe];ke||(ke=new _O,S[xe]=ke);const ze=p.getCameraImage(xe);ke.sourceTexture=ze}}}for(let He=0;He<x.length;He++){const Xe=R[He],ot=x[He];Xe!==null&&ot!==void 0&&ot.update(Xe,Be,d||o)}te&&te(ce,Be),Be.detectedPlanes&&i.dispatchEvent({type:"planesdetected",data:Be}),y=null}const ae=new dO;ae.setAnimationLoop(ue),this.setAnimationLoop=function(ce){te=ce},this.dispose=function(){}}}const hg=new Ju,T$=new li;function S$(n,e){function t(S,M){S.matrixAutoUpdate===!0&&S.updateMatrix(),M.value.copy(S.matrix)}function i(S,M){M.color.getRGB(S.fogColor.value,vI(n)),M.isFog?(S.fogNear.value=M.near,S.fogFar.value=M.far):M.isFogExp2&&(S.fogDensity.value=M.density)}function s(S,M,T,C,x){M.isMeshBasicMaterial||M.isMeshLambertMaterial?r(S,M):M.isMeshToonMaterial?(r(S,M),p(S,M)):M.isMeshPhongMaterial?(r(S,M),g(S,M)):M.isMeshStandardMaterial?(r(S,M),h(S,M),M.isMeshPhysicalMaterial&&v(S,M,x)):M.isMeshMatcapMaterial?(r(S,M),y(S,M)):M.isMeshDepthMaterial?r(S,M):M.isMeshDistanceMaterial?(r(S,M),w(S,M)):M.isMeshNormalMaterial?r(S,M):M.isLineBasicMaterial?(o(S,M),M.isLineDashedMaterial&&l(S,M)):M.isPointsMaterial?c(S,M,T,C):M.isSpriteMaterial?d(S,M):M.isShadowMaterial?(S.color.value.copy(M.color),S.opacity.value=M.opacity):M.isShaderMaterial&&(M.uniformsNeedUpdate=!1)}function r(S,M){S.opacity.value=M.opacity,M.color&&S.diffuse.value.copy(M.color),M.emissive&&S.emissive.value.copy(M.emissive).multiplyScalar(M.emissiveIntensity),M.map&&(S.map.value=M.map,t(M.map,S.mapTransform)),M.alphaMap&&(S.alphaMap.value=M.alphaMap,t(M.alphaMap,S.alphaMapTransform)),M.bumpMap&&(S.bumpMap.value=M.bumpMap,t(M.bumpMap,S.bumpMapTransform),S.bumpScale.value=M.bumpScale,M.side===Ga&&(S.bumpScale.value*=-1)),M.normalMap&&(S.normalMap.value=M.normalMap,t(M.normalMap,S.normalMapTransform),S.normalScale.value.copy(M.normalScale),M.side===Ga&&S.normalScale.value.negate()),M.displacementMap&&(S.displacementMap.value=M.displacementMap,t(M.displacementMap,S.displacementMapTransform),S.displacementScale.value=M.displacementScale,S.displacementBias.value=M.displacementBias),M.emissiveMap&&(S.emissiveMap.value=M.emissiveMap,t(M.emissiveMap,S.emissiveMapTransform)),M.specularMap&&(S.specularMap.value=M.specularMap,t(M.specularMap,S.specularMapTransform)),M.alphaTest>0&&(S.alphaTest.value=M.alphaTest);const T=e.get(M),C=T.envMap,x=T.envMapRotation;C&&(S.envMap.value=C,hg.copy(x),hg.x*=-1,hg.y*=-1,hg.z*=-1,C.isCubeTexture&&C.isRenderTargetTexture===!1&&(hg.y*=-1,hg.z*=-1),S.envMapRotation.value.setFromMatrix4(T$.makeRotationFromEuler(hg)),S.flipEnvMap.value=C.isCubeTexture&&C.isRenderTargetTexture===!1?-1:1,S.reflectivity.value=M.reflectivity,S.ior.value=M.ior,S.refractionRatio.value=M.refractionRatio),M.lightMap&&(S.lightMap.value=M.lightMap,S.lightMapIntensity.value=M.lightMapIntensity,t(M.lightMap,S.lightMapTransform)),M.aoMap&&(S.aoMap.value=M.aoMap,S.aoMapIntensity.value=M.aoMapIntensity,t(M.aoMap,S.aoMapTransform))}function o(S,M){S.diffuse.value.copy(M.color),S.opacity.value=M.opacity,M.map&&(S.map.value=M.map,t(M.map,S.mapTransform))}function l(S,M){S.dashSize.value=M.dashSize,S.totalSize.value=M.dashSize+M.gapSize,S.scale.value=M.scale}function c(S,M,T,C){S.diffuse.value.copy(M.color),S.opacity.value=M.opacity,S.size.value=M.size*T,S.scale.value=C*.5,M.map&&(S.map.value=M.map,t(M.map,S.uvTransform)),M.alphaMap&&(S.alphaMap.value=M.alphaMap,t(M.alphaMap,S.alphaMapTransform)),M.alphaTest>0&&(S.alphaTest.value=M.alphaTest)}function d(S,M){S.diffuse.value.copy(M.color),S.opacity.value=M.opacity,S.rotation.value=M.rotation,M.map&&(S.map.value=M.map,t(M.map,S.mapTransform)),M.alphaMap&&(S.alphaMap.value=M.alphaMap,t(M.alphaMap,S.alphaMapTransform)),M.alphaTest>0&&(S.alphaTest.value=M.alphaTest)}function g(S,M){S.specular.value.copy(M.specular),S.shininess.value=Math.max(M.shininess,1e-4)}function p(S,M){M.gradientMap&&(S.gradientMap.value=M.gradientMap)}function h(S,M){S.metalness.value=M.metalness,M.metalnessMap&&(S.metalnessMap.value=M.metalnessMap,t(M.metalnessMap,S.metalnessMapTransform)),S.roughness.value=M.roughness,M.roughnessMap&&(S.roughnessMap.value=M.roughnessMap,t(M.roughnessMap,S.roughnessMapTransform)),M.envMap&&(S.envMapIntensity.value=M.envMapIntensity)}function v(S,M,T){S.ior.value=M.ior,M.sheen>0&&(S.sheenColor.value.copy(M.sheenColor).multiplyScalar(M.sheen),S.sheenRoughness.value=M.sheenRoughness,M.sheenColorMap&&(S.sheenColorMap.value=M.sheenColorMap,t(M.sheenColorMap,S.sheenColorMapTransform)),M.sheenRoughnessMap&&(S.sheenRoughnessMap.value=M.sheenRoughnessMap,t(M.sheenRoughnessMap,S.sheenRoughnessMapTransform))),M.clearcoat>0&&(S.clearcoat.value=M.clearcoat,S.clearcoatRoughness.value=M.clearcoatRoughness,M.clearcoatMap&&(S.clearcoatMap.value=M.clearcoatMap,t(M.clearcoatMap,S.clearcoatMapTransform)),M.clearcoatRoughnessMap&&(S.clearcoatRoughnessMap.value=M.clearcoatRoughnessMap,t(M.clearcoatRoughnessMap,S.clearcoatRoughnessMapTransform)),M.clearcoatNormalMap&&(S.clearcoatNormalMap.value=M.clearcoatNormalMap,t(M.clearcoatNormalMap,S.clearcoatNormalMapTransform),S.clearcoatNormalScale.value.copy(M.clearcoatNormalScale),M.side===Ga&&S.clearcoatNormalScale.value.negate())),M.dispersion>0&&(S.dispersion.value=M.dispersion),M.iridescence>0&&(S.iridescence.value=M.iridescence,S.iridescenceIOR.value=M.iridescenceIOR,S.iridescenceThicknessMinimum.value=M.iridescenceThicknessRange[0],S.iridescenceThicknessMaximum.value=M.iridescenceThicknessRange[1],M.iridescenceMap&&(S.iridescenceMap.value=M.iridescenceMap,t(M.iridescenceMap,S.iridescenceMapTransform)),M.iridescenceThicknessMap&&(S.iridescenceThicknessMap.value=M.iridescenceThicknessMap,t(M.iridescenceThicknessMap,S.iridescenceThicknessMapTransform))),M.transmission>0&&(S.transmission.value=M.transmission,S.transmissionSamplerMap.value=T.texture,S.transmissionSamplerSize.value.set(T.width,T.height),M.transmissionMap&&(S.transmissionMap.value=M.transmissionMap,t(M.transmissionMap,S.transmissionMapTransform)),S.thickness.value=M.thickness,M.thicknessMap&&(S.thicknessMap.value=M.thicknessMap,t(M.thicknessMap,S.thicknessMapTransform)),S.attenuationDistance.value=M.attenuationDistance,S.attenuationColor.value.copy(M.attenuationColor)),M.anisotropy>0&&(S.anisotropyVector.value.set(M.anisotropy*Math.cos(M.anisotropyRotation),M.anisotropy*Math.sin(M.anisotropyRotation)),M.anisotropyMap&&(S.anisotropyMap.value=M.anisotropyMap,t(M.anisotropyMap,S.anisotropyMapTransform))),S.specularIntensity.value=M.specularIntensity,S.specularColor.value.copy(M.specularColor),M.specularColorMap&&(S.specularColorMap.value=M.specularColorMap,t(M.specularColorMap,S.specularColorMapTransform)),M.specularIntensityMap&&(S.specularIntensityMap.value=M.specularIntensityMap,t(M.specularIntensityMap,S.specularIntensityMapTransform))}function y(S,M){M.matcap&&(S.matcap.value=M.matcap)}function w(S,M){const T=e.get(M).light;S.referencePosition.value.setFromMatrixPosition(T.matrixWorld),S.nearDistance.value=T.shadow.camera.near,S.farDistance.value=T.shadow.camera.far}return{refreshFogUniforms:i,refreshMaterialUniforms:s}}function A$(n,e,t,i){let s={},r={},o=[];const l=n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);function c(T,C){const x=C.program;i.uniformBlockBinding(T,x)}function d(T,C){let x=s[T.id];x===void 0&&(y(T),x=g(T),s[T.id]=x,T.addEventListener("dispose",S));const R=C.program;i.updateUBOMapping(T,R);const P=e.render.frame;r[T.id]!==P&&(h(T),r[T.id]=P)}function g(T){const C=p();T.__bindingPointIndex=C;const x=n.createBuffer(),R=T.__size,P=T.usage;return n.bindBuffer(n.UNIFORM_BUFFER,x),n.bufferData(n.UNIFORM_BUFFER,R,P),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,C,x),x}function p(){for(let T=0;T<l;T++)if(o.indexOf(T)===-1)return o.push(T),T;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function h(T){const C=s[T.id],x=T.uniforms,R=T.__cache;n.bindBuffer(n.UNIFORM_BUFFER,C);for(let P=0,D=x.length;P<D;P++){const z=Array.isArray(x[P])?x[P]:[x[P]];for(let U=0,N=z.length;U<N;U++){const j=z[U];if(v(j,P,U,R)===!0){const J=j.__offset,W=Array.isArray(j.value)?j.value:[j.value];let oe=0;for(let ne=0;ne<W.length;ne++){const q=W[ne],le=w(q);typeof q=="number"||typeof q=="boolean"?(j.__data[0]=q,n.bufferSubData(n.UNIFORM_BUFFER,J+oe,j.__data)):q.isMatrix3?(j.__data[0]=q.elements[0],j.__data[1]=q.elements[1],j.__data[2]=q.elements[2],j.__data[3]=0,j.__data[4]=q.elements[3],j.__data[5]=q.elements[4],j.__data[6]=q.elements[5],j.__data[7]=0,j.__data[8]=q.elements[6],j.__data[9]=q.elements[7],j.__data[10]=q.elements[8],j.__data[11]=0):(q.toArray(j.__data,oe),oe+=le.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,J,j.__data)}}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function v(T,C,x,R){const P=T.value,D=C+"_"+x;if(R[D]===void 0)return typeof P=="number"||typeof P=="boolean"?R[D]=P:R[D]=P.clone(),!0;{const z=R[D];if(typeof P=="number"||typeof P=="boolean"){if(z!==P)return R[D]=P,!0}else if(z.equals(P)===!1)return z.copy(P),!0}return!1}function y(T){const C=T.uniforms;let x=0;const R=16;for(let D=0,z=C.length;D<z;D++){const U=Array.isArray(C[D])?C[D]:[C[D]];for(let N=0,j=U.length;N<j;N++){const J=U[N],W=Array.isArray(J.value)?J.value:[J.value];for(let oe=0,ne=W.length;oe<ne;oe++){const q=W[oe],le=w(q),se=x%R,pe=se%le.boundary,be=se+pe;x+=pe,be!==0&&R-be<le.storage&&(x+=R-be),J.__data=new Float32Array(le.storage/Float32Array.BYTES_PER_ELEMENT),J.__offset=x,x+=le.storage}}}const P=x%R;return P>0&&(x+=R-P),T.__size=x,T.__cache={},this}function w(T){const C={boundary:0,storage:0};return typeof T=="number"||typeof T=="boolean"?(C.boundary=4,C.storage=4):T.isVector2?(C.boundary=8,C.storage=8):T.isVector3||T.isColor?(C.boundary=16,C.storage=12):T.isVector4?(C.boundary=16,C.storage=16):T.isMatrix3?(C.boundary=48,C.storage=48):T.isMatrix4?(C.boundary=64,C.storage=64):T.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",T),C}function S(T){const C=T.target;C.removeEventListener("dispose",S);const x=o.indexOf(C.__bindingPointIndex);o.splice(x,1),n.deleteBuffer(s[C.id]),delete s[C.id],delete r[C.id]}function M(){for(const T in s)n.deleteBuffer(s[T]);o=[],s={},r={}}return{bind:c,update:d,dispose:M}}class vO{constructor(e={}){const{canvas:t=mI(),context:i=null,depth:s=!0,stencil:r=!1,alpha:o=!1,antialias:l=!1,premultipliedAlpha:c=!0,preserveDrawingBuffer:d=!1,powerPreference:g="default",failIfMajorPerformanceCaveat:p=!1,reversedDepthBuffer:h=!1}=e;this.isWebGLRenderer=!0;let v;if(i!==null){if(typeof WebGLRenderingContext<"u"&&i instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");v=i.getContextAttributes().alpha}else v=o;const y=new Uint32Array(4),w=new Int32Array(4);let S=null,M=null;const T=[],C=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=Ld,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const x=this;let R=!1;this._outputColorSpace=Rs;let P=0,D=0,z=null,U=-1,N=null;const j=new ds,J=new ds;let W=null;const oe=new Sn(0);let ne=0,q=t.width,le=t.height,se=1,pe=null,be=null;const ee=new ds(0,0,q,le),te=new ds(0,0,q,le);let ue=!1;const ae=new _0;let ce=!1,Be=!1;const He=new li,Xe=new Oe,ot=new ds,tt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let Ae=!1;function ye(){return z===null?se:1}let xe=i;function ke(Se,we){return t.getContext(Se,we)}try{const Se={alpha:!0,depth:s,stencil:r,antialias:l,premultipliedAlpha:c,preserveDrawingBuffer:d,powerPreference:g,failIfMajorPerformanceCaveat:p};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${Yg}`),t.addEventListener("webglcontextlost",rn,!1),t.addEventListener("webglcontextrestored",fe,!1),t.addEventListener("webglcontextcreationerror",B,!1),xe===null){const we="webgl2";if(xe=ke(we,Se),xe===null)throw ke(we)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(Se){throw console.error("THREE.WebGLRenderer: "+Se.message),Se}let ze,je,Fe,Ye,Ve,Qe,mt,Tt,Me,me,$e,et,ht,at,Et,Dt,Vt,an,bt,Jt,Tn,We,vt,Yt;function qe(){ze=new UH(xe),ze.init(),We=new gO(xe,ze),je=new BH(xe,ze,e,We),Fe=new y$(xe,ze),je.reversedDepthBuffer&&h&&Fe.buffers.depth.setReversed(!0),Ye=new VH(xe),Ve=new a$,Qe=new M$(xe,ze,Fe,Ve,je,We,Ye),mt=new OH(x),Tt=new zH(x),Me=new q4(xe),vt=new RH(xe,Me),me=new kH(xe,Me,Ye,vt),$e=new jH(xe,me,Me,Ye),bt=new HH(xe,je,Qe),Dt=new IH(Ve),et=new r$(x,mt,Tt,ze,je,vt,Dt),ht=new S$(x,Ve),at=new l$,Et=new p$(ze),an=new PH(x,mt,Tt,Fe,$e,v,c),Vt=new _$(x,$e,je),Yt=new A$(xe,Ye,je,Fe),Jt=new DH(xe,ze,Ye),Tn=new GH(xe,ze,Ye),Ye.programs=et.programs,x.capabilities=je,x.extensions=ze,x.properties=Ve,x.renderLists=at,x.shadowMap=Vt,x.state=Fe,x.info=Ye}qe();const Kt=new E$(x,xe);this.xr=Kt,this.getContext=function(){return xe},this.getContextAttributes=function(){return xe.getContextAttributes()},this.forceContextLoss=function(){const Se=ze.get("WEBGL_lose_context");Se&&Se.loseContext()},this.forceContextRestore=function(){const Se=ze.get("WEBGL_lose_context");Se&&Se.restoreContext()},this.getPixelRatio=function(){return se},this.setPixelRatio=function(Se){Se!==void 0&&(se=Se,this.setSize(q,le,!1))},this.getSize=function(Se){return Se.set(q,le)},this.setSize=function(Se,we,Ge=!0){if(Kt.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}q=Se,le=we,t.width=Math.floor(Se*se),t.height=Math.floor(we*se),Ge===!0&&(t.style.width=Se+"px",t.style.height=we+"px"),this.setViewport(0,0,Se,we)},this.getDrawingBufferSize=function(Se){return Se.set(q*se,le*se).floor()},this.setDrawingBufferSize=function(Se,we,Ge){q=Se,le=we,se=Ge,t.width=Math.floor(Se*Ge),t.height=Math.floor(we*Ge),this.setViewport(0,0,Se,we)},this.getCurrentViewport=function(Se){return Se.copy(j)},this.getViewport=function(Se){return Se.copy(ee)},this.setViewport=function(Se,we,Ge,Je){Se.isVector4?ee.set(Se.x,Se.y,Se.z,Se.w):ee.set(Se,we,Ge,Je),Fe.viewport(j.copy(ee).multiplyScalar(se).round())},this.getScissor=function(Se){return Se.copy(te)},this.setScissor=function(Se,we,Ge,Je){Se.isVector4?te.set(Se.x,Se.y,Se.z,Se.w):te.set(Se,we,Ge,Je),Fe.scissor(J.copy(te).multiplyScalar(se).round())},this.getScissorTest=function(){return ue},this.setScissorTest=function(Se){Fe.setScissorTest(ue=Se)},this.setOpaqueSort=function(Se){pe=Se},this.setTransparentSort=function(Se){be=Se},this.getClearColor=function(Se){return Se.copy(an.getClearColor())},this.setClearColor=function(){an.setClearColor(...arguments)},this.getClearAlpha=function(){return an.getClearAlpha()},this.setClearAlpha=function(){an.setClearAlpha(...arguments)},this.clear=function(Se=!0,we=!0,Ge=!0){let Je=0;if(Se){let Ue=!1;if(z!==null){const Ot=z.texture.format;Ue=Ot===tx||Ot===ex||Ot===Wv}if(Ue){const Ot=z.texture.type,jt=Ot===Ha||Ot===kf||Ot===n0||Ot===Ug||Ot===Jb||Ot===Qb,tn=an.getClearColor(),en=an.getClearAlpha(),dn=tn.r,wn=tn.g,_n=tn.b;jt?(y[0]=dn,y[1]=wn,y[2]=_n,y[3]=en,xe.clearBufferuiv(xe.COLOR,0,y)):(w[0]=dn,w[1]=wn,w[2]=_n,w[3]=en,xe.clearBufferiv(xe.COLOR,0,w))}else Je|=xe.COLOR_BUFFER_BIT}we&&(Je|=xe.DEPTH_BUFFER_BIT),Ge&&(Je|=xe.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),xe.clear(Je)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",rn,!1),t.removeEventListener("webglcontextrestored",fe,!1),t.removeEventListener("webglcontextcreationerror",B,!1),an.dispose(),at.dispose(),Et.dispose(),Ve.dispose(),mt.dispose(),Tt.dispose(),$e.dispose(),vt.dispose(),Yt.dispose(),et.dispose(),Kt.dispose(),Kt.removeEventListener("sessionstart",re),Kt.removeEventListener("sessionend",Q),ve.stop()};function rn(Se){Se.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),R=!0}function fe(){console.log("THREE.WebGLRenderer: Context Restored."),R=!1;const Se=Ye.autoReset,we=Vt.enabled,Ge=Vt.autoUpdate,Je=Vt.needsUpdate,Ue=Vt.type;qe(),Ye.autoReset=Se,Vt.enabled=we,Vt.autoUpdate=Ge,Vt.needsUpdate=Je,Vt.type=Ue}function B(Se){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",Se.statusMessage)}function I(Se){const we=Se.target;we.removeEventListener("dispose",I),A(we)}function A(Se){F(Se),Ve.remove(Se)}function F(Se){const we=Ve.get(Se).programs;we!==void 0&&(we.forEach(function(Ge){et.releaseProgram(Ge)}),Se.isShaderMaterial&&et.releaseShaderCache(Se))}this.renderBufferDirect=function(Se,we,Ge,Je,Ue,Ot){we===null&&(we=tt);const jt=Ue.isMesh&&Ue.matrixWorld.determinant()<0,tn=on(Se,we,Ge,Je,Ue);Fe.setMaterial(Je,jt);let en=Ge.index,dn=1;if(Je.wireframe===!0){if(en=me.getWireframeAttribute(Ge),en===void 0)return;dn=2}const wn=Ge.drawRange,_n=Ge.attributes.position;let Fn=wn.start*dn,ti=(wn.start+wn.count)*dn;Ot!==null&&(Fn=Math.max(Fn,Ot.start*dn),ti=Math.min(ti,(Ot.start+Ot.count)*dn)),en!==null?(Fn=Math.max(Fn,0),ti=Math.min(ti,en.count)):_n!=null&&(Fn=Math.max(Fn,0),ti=Math.min(ti,_n.count));const Pn=ti-Fn;if(Pn<0||Pn===1/0)return;vt.setup(Ue,Je,tn,Ge,en);let Ln,Ct=Jt;if(en!==null&&(Ln=Me.get(en),Ct=Tn,Ct.setIndex(Ln)),Ue.isMesh)Je.wireframe===!0?(Fe.setLineWidth(Je.wireframeLinewidth*ye()),Ct.setMode(xe.LINES)):Ct.setMode(xe.TRIANGLES);else if(Ue.isLine){let gt=Je.linewidth;gt===void 0&&(gt=1),Fe.setLineWidth(gt*ye()),Ue.isLineSegments?Ct.setMode(xe.LINES):Ue.isLineLoop?Ct.setMode(xe.LINE_LOOP):Ct.setMode(xe.LINE_STRIP)}else Ue.isPoints?Ct.setMode(xe.POINTS):Ue.isSprite&&Ct.setMode(xe.TRIANGLES);if(Ue.isBatchedMesh)if(Ue._multiDrawInstances!==null)Q_("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),Ct.renderMultiDrawInstances(Ue._multiDrawStarts,Ue._multiDrawCounts,Ue._multiDrawCount,Ue._multiDrawInstances);else if(ze.get("WEBGL_multi_draw"))Ct.renderMultiDraw(Ue._multiDrawStarts,Ue._multiDrawCounts,Ue._multiDrawCount);else{const gt=Ue._multiDrawStarts,Qt=Ue._multiDrawCounts,Nn=Ue._multiDrawCount,Ss=en?Me.get(en).bytesPerElement:1,yr=Ve.get(Je).currentProgram.getUniforms();for(let $i=0;$i<Nn;$i++)yr.setValue(xe,"_gl_DrawID",$i),Ct.render(gt[$i]/Ss,Qt[$i])}else if(Ue.isInstancedMesh)Ct.renderInstances(Fn,Pn,Ue.count);else if(Ge.isInstancedBufferGeometry){const gt=Ge._maxInstanceCount!==void 0?Ge._maxInstanceCount:1/0,Qt=Math.min(Ge.instanceCount,gt);Ct.renderInstances(Fn,Pn,Qt)}else Ct.render(Fn,Pn)};function K(Se,we,Ge){Se.transparent===!0&&Se.side===Ro&&Se.forceSinglePass===!1?(Se.side=Ga,Se.needsUpdate=!0,yt(Se,we,Ge),Se.side=Nd,Se.needsUpdate=!0,yt(Se,we,Ge),Se.side=Ro):yt(Se,we,Ge)}this.compile=function(Se,we,Ge=null){Ge===null&&(Ge=Se),M=Et.get(Ge),M.init(we),C.push(M),Ge.traverseVisible(function(Ue){Ue.isLight&&Ue.layers.test(we.layers)&&(M.pushLight(Ue),Ue.castShadow&&M.pushShadow(Ue))}),Se!==Ge&&Se.traverseVisible(function(Ue){Ue.isLight&&Ue.layers.test(we.layers)&&(M.pushLight(Ue),Ue.castShadow&&M.pushShadow(Ue))}),M.setupLights();const Je=new Set;return Se.traverse(function(Ue){if(!(Ue.isMesh||Ue.isPoints||Ue.isLine||Ue.isSprite))return;const Ot=Ue.material;if(Ot)if(Array.isArray(Ot))for(let jt=0;jt<Ot.length;jt++){const tn=Ot[jt];K(tn,Ge,Ue),Je.add(tn)}else K(Ot,Ge,Ue),Je.add(Ot)}),M=C.pop(),Je},this.compileAsync=function(Se,we,Ge=null){const Je=this.compile(Se,we,Ge);return new Promise(Ue=>{function Ot(){if(Je.forEach(function(jt){Ve.get(jt).currentProgram.isReady()&&Je.delete(jt)}),Je.size===0){Ue(Se);return}setTimeout(Ot,10)}ze.get("KHR_parallel_shader_compile")!==null?Ot():setTimeout(Ot,10)})};let Ee=null;function k(Se){Ee&&Ee(Se)}function re(){ve.stop()}function Q(){ve.start()}const ve=new dO;ve.setAnimationLoop(k),typeof self<"u"&&ve.setContext(self),this.setAnimationLoop=function(Se){Ee=Se,Kt.setAnimationLoop(Se),Se===null?ve.stop():ve.start()},Kt.addEventListener("sessionstart",re),Kt.addEventListener("sessionend",Q),this.render=function(Se,we){if(we!==void 0&&we.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(R===!0)return;if(Se.matrixWorldAutoUpdate===!0&&Se.updateMatrixWorld(),we.parent===null&&we.matrixWorldAutoUpdate===!0&&we.updateMatrixWorld(),Kt.enabled===!0&&Kt.isPresenting===!0&&(Kt.cameraAutoUpdate===!0&&Kt.updateCamera(we),we=Kt.getCamera()),Se.isScene===!0&&Se.onBeforeRender(x,Se,we,z),M=Et.get(Se,C.length),M.init(we),C.push(M),He.multiplyMatrices(we.projectionMatrix,we.matrixWorldInverse),ae.setFromProjectionMatrix(He,Ku,we.reversedDepth),Be=this.localClippingEnabled,ce=Dt.init(this.clippingPlanes,Be),S=at.get(Se,T.length),S.init(),T.push(S),Kt.enabled===!0&&Kt.isPresenting===!0){const Ot=x.xr.getDepthSensingMesh();Ot!==null&&ge(Ot,we,-1/0,x.sortObjects)}ge(Se,we,0,x.sortObjects),S.finish(),x.sortObjects===!0&&S.sort(pe,be),Ae=Kt.enabled===!1||Kt.isPresenting===!1||Kt.hasDepthSensing()===!1,Ae&&an.addToRenderList(S,Se),this.info.render.frame++,ce===!0&&Dt.beginShadows();const Ge=M.state.shadowsArray;Vt.render(Ge,Se,we),ce===!0&&Dt.endShadows(),this.info.autoReset===!0&&this.info.reset();const Je=S.opaque,Ue=S.transmissive;if(M.setupLights(),we.isArrayCamera){const Ot=we.cameras;if(Ue.length>0)for(let jt=0,tn=Ot.length;jt<tn;jt++){const en=Ot[jt];rt(Je,Ue,Se,en)}Ae&&an.render(Se);for(let jt=0,tn=Ot.length;jt<tn;jt++){const en=Ot[jt];Le(S,Se,en,en.viewport)}}else Ue.length>0&&rt(Je,Ue,Se,we),Ae&&an.render(Se),Le(S,Se,we);z!==null&&D===0&&(Qe.updateMultisampleRenderTarget(z),Qe.updateRenderTargetMipmap(z)),Se.isScene===!0&&Se.onAfterRender(x,Se,we),vt.resetDefaultState(),U=-1,N=null,C.pop(),C.length>0?(M=C[C.length-1],ce===!0&&Dt.setGlobalState(x.clippingPlanes,M.state.camera)):M=null,T.pop(),T.length>0?S=T[T.length-1]:S=null};function ge(Se,we,Ge,Je){if(Se.visible===!1)return;if(Se.layers.test(we.layers)){if(Se.isGroup)Ge=Se.renderOrder;else if(Se.isLOD)Se.autoUpdate===!0&&Se.update(we);else if(Se.isLight)M.pushLight(Se),Se.castShadow&&M.pushShadow(Se);else if(Se.isSprite){if(!Se.frustumCulled||ae.intersectsSprite(Se)){Je&&ot.setFromMatrixPosition(Se.matrixWorld).applyMatrix4(He);const jt=$e.update(Se),tn=Se.material;tn.visible&&S.push(Se,jt,tn,Ge,ot.z,null)}}else if((Se.isMesh||Se.isLine||Se.isPoints)&&(!Se.frustumCulled||ae.intersectsObject(Se))){const jt=$e.update(Se),tn=Se.material;if(Je&&(Se.boundingSphere!==void 0?(Se.boundingSphere===null&&Se.computeBoundingSphere(),ot.copy(Se.boundingSphere.center)):(jt.boundingSphere===null&&jt.computeBoundingSphere(),ot.copy(jt.boundingSphere.center)),ot.applyMatrix4(Se.matrixWorld).applyMatrix4(He)),Array.isArray(tn)){const en=jt.groups;for(let dn=0,wn=en.length;dn<wn;dn++){const _n=en[dn],Fn=tn[_n.materialIndex];Fn&&Fn.visible&&S.push(Se,jt,Fn,Ge,ot.z,_n)}}else tn.visible&&S.push(Se,jt,tn,Ge,ot.z,null)}}const Ot=Se.children;for(let jt=0,tn=Ot.length;jt<tn;jt++)ge(Ot[jt],we,Ge,Je)}function Le(Se,we,Ge,Je){const Ue=Se.opaque,Ot=Se.transmissive,jt=Se.transparent;M.setupLightsView(Ge),ce===!0&&Dt.setGlobalState(x.clippingPlanes,Ge),Je&&Fe.viewport(j.copy(Je)),Ue.length>0&&nt(Ue,we,Ge),Ot.length>0&&nt(Ot,we,Ge),jt.length>0&&nt(jt,we,Ge),Fe.buffers.depth.setTest(!0),Fe.buffers.depth.setMask(!0),Fe.buffers.color.setMask(!0),Fe.setPolygonOffset(!1)}function rt(Se,we,Ge,Je){if((Ge.isScene===!0?Ge.overrideMaterial:null)!==null)return;M.state.transmissionRenderTarget[Je.id]===void 0&&(M.state.transmissionRenderTarget[Je.id]=new Da(1,1,{generateMipmaps:!0,type:ze.has("EXT_color_buffer_half_float")||ze.has("EXT_color_buffer_float")?Jg:Ha,minFilter:Oc,samples:4,stencilBuffer:r,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:us.workingColorSpace}));const Ot=M.state.transmissionRenderTarget[Je.id],jt=Je.viewport||j;Ot.setSize(jt.z*x.transmissionResolutionScale,jt.w*x.transmissionResolutionScale);const tn=x.getRenderTarget(),en=x.getActiveCubeFace(),dn=x.getActiveMipmapLevel();x.setRenderTarget(Ot),x.getClearColor(oe),ne=x.getClearAlpha(),ne<1&&x.setClearColor(16777215,.5),x.clear(),Ae&&an.render(Ge);const wn=x.toneMapping;x.toneMapping=Ld;const _n=Je.viewport;if(Je.viewport!==void 0&&(Je.viewport=void 0),M.setupLightsView(Je),ce===!0&&Dt.setGlobalState(x.clippingPlanes,Je),nt(Se,Ge,Je),Qe.updateMultisampleRenderTarget(Ot),Qe.updateRenderTargetMipmap(Ot),ze.has("WEBGL_multisampled_render_to_texture")===!1){let Fn=!1;for(let ti=0,Pn=we.length;ti<Pn;ti++){const Ln=we[ti],Ct=Ln.object,gt=Ln.geometry,Qt=Ln.material,Nn=Ln.group;if(Qt.side===Ro&&Ct.layers.test(Je.layers)){const Ss=Qt.side;Qt.side=Ga,Qt.needsUpdate=!0,ft(Ct,Ge,Je,gt,Qt,Nn),Qt.side=Ss,Qt.needsUpdate=!0,Fn=!0}}Fn===!0&&(Qe.updateMultisampleRenderTarget(Ot),Qe.updateRenderTargetMipmap(Ot))}x.setRenderTarget(tn,en,dn),x.setClearColor(oe,ne),_n!==void 0&&(Je.viewport=_n),x.toneMapping=wn}function nt(Se,we,Ge){const Je=we.isScene===!0?we.overrideMaterial:null;for(let Ue=0,Ot=Se.length;Ue<Ot;Ue++){const jt=Se[Ue],tn=jt.object,en=jt.geometry,dn=jt.group;let wn=jt.material;wn.allowOverride===!0&&Je!==null&&(wn=Je),tn.layers.test(Ge.layers)&&ft(tn,we,Ge,en,wn,dn)}}function ft(Se,we,Ge,Je,Ue,Ot){Se.onBeforeRender(x,we,Ge,Je,Ue,Ot),Se.modelViewMatrix.multiplyMatrices(Ge.matrixWorldInverse,Se.matrixWorld),Se.normalMatrix.getNormalMatrix(Se.modelViewMatrix),Ue.onBeforeRender(x,we,Ge,Je,Se,Ot),Ue.transparent===!0&&Ue.side===Ro&&Ue.forceSinglePass===!1?(Ue.side=Ga,Ue.needsUpdate=!0,x.renderBufferDirect(Ge,we,Je,Ue,Se,Ot),Ue.side=Nd,Ue.needsUpdate=!0,x.renderBufferDirect(Ge,we,Je,Ue,Se,Ot),Ue.side=Ro):x.renderBufferDirect(Ge,we,Je,Ue,Se,Ot),Se.onAfterRender(x,we,Ge,Je,Ue,Ot)}function yt(Se,we,Ge){we.isScene!==!0&&(we=tt);const Je=Ve.get(Se),Ue=M.state.lights,Ot=M.state.shadowsArray,jt=Ue.state.version,tn=et.getParameters(Se,Ue.state,Ot,we,Ge),en=et.getProgramCacheKey(tn);let dn=Je.programs;Je.environment=Se.isMeshStandardMaterial?we.environment:null,Je.fog=we.fog,Je.envMap=(Se.isMeshStandardMaterial?Tt:mt).get(Se.envMap||Je.environment),Je.envMapRotation=Je.environment!==null&&Se.envMap===null?we.environmentRotation:Se.envMapRotation,dn===void 0&&(Se.addEventListener("dispose",I),dn=new Map,Je.programs=dn);let wn=dn.get(en);if(wn!==void 0){if(Je.currentProgram===wn&&Je.lightsStateVersion===jt)return Bt(Se,tn),wn}else tn.uniforms=et.getUniforms(Se),Se.onBeforeCompile(tn,x),wn=et.acquireProgram(tn,en),dn.set(en,wn),Je.uniforms=tn.uniforms;const _n=Je.uniforms;return(!Se.isShaderMaterial&&!Se.isRawShaderMaterial||Se.clipping===!0)&&(_n.clippingPlanes=Dt.uniform),Bt(Se,tn),Je.needsLights=Bn(Se),Je.lightsStateVersion=jt,Je.needsLights&&(_n.ambientLightColor.value=Ue.state.ambient,_n.lightProbe.value=Ue.state.probe,_n.directionalLights.value=Ue.state.directional,_n.directionalLightShadows.value=Ue.state.directionalShadow,_n.spotLights.value=Ue.state.spot,_n.spotLightShadows.value=Ue.state.spotShadow,_n.rectAreaLights.value=Ue.state.rectArea,_n.ltc_1.value=Ue.state.rectAreaLTC1,_n.ltc_2.value=Ue.state.rectAreaLTC2,_n.pointLights.value=Ue.state.point,_n.pointLightShadows.value=Ue.state.pointShadow,_n.hemisphereLights.value=Ue.state.hemi,_n.directionalShadowMap.value=Ue.state.directionalShadowMap,_n.directionalShadowMatrix.value=Ue.state.directionalShadowMatrix,_n.spotShadowMap.value=Ue.state.spotShadowMap,_n.spotLightMatrix.value=Ue.state.spotLightMatrix,_n.spotLightMap.value=Ue.state.spotLightMap,_n.pointShadowMap.value=Ue.state.pointShadowMap,_n.pointShadowMatrix.value=Ue.state.pointShadowMatrix),Je.currentProgram=wn,Je.uniformsList=null,wn}function Ne(Se){if(Se.uniformsList===null){const we=Se.currentProgram.getUniforms();Se.uniformsList=GM.seqWithValue(we.seq,Se.uniforms)}return Se.uniformsList}function Bt(Se,we){const Ge=Ve.get(Se);Ge.outputColorSpace=we.outputColorSpace,Ge.batching=we.batching,Ge.batchingColor=we.batchingColor,Ge.instancing=we.instancing,Ge.instancingColor=we.instancingColor,Ge.instancingMorph=we.instancingMorph,Ge.skinning=we.skinning,Ge.morphTargets=we.morphTargets,Ge.morphNormals=we.morphNormals,Ge.morphColors=we.morphColors,Ge.morphTargetsCount=we.morphTargetsCount,Ge.numClippingPlanes=we.numClippingPlanes,Ge.numIntersection=we.numClipIntersection,Ge.vertexAlphas=we.vertexAlphas,Ge.vertexTangents=we.vertexTangents,Ge.toneMapping=we.toneMapping}function on(Se,we,Ge,Je,Ue){we.isScene!==!0&&(we=tt),Qe.resetTextureUnits();const Ot=we.fog,jt=Je.isMeshStandardMaterial?we.environment:null,tn=z===null?x.outputColorSpace:z.isXRRenderTarget===!0?z.texture.colorSpace:Gf,en=(Je.isMeshStandardMaterial?Tt:mt).get(Je.envMap||jt),dn=Je.vertexColors===!0&&!!Ge.attributes.color&&Ge.attributes.color.itemSize===4,wn=!!Ge.attributes.tangent&&(!!Je.normalMap||Je.anisotropy>0),_n=!!Ge.morphAttributes.position,Fn=!!Ge.morphAttributes.normal,ti=!!Ge.morphAttributes.color;let Pn=Ld;Je.toneMapped&&(z===null||z.isXRRenderTarget===!0)&&(Pn=x.toneMapping);const Ln=Ge.morphAttributes.position||Ge.morphAttributes.normal||Ge.morphAttributes.color,Ct=Ln!==void 0?Ln.length:0,gt=Ve.get(Je),Qt=M.state.lights;if(ce===!0&&(Be===!0||Se!==N)){const Ds=Se===N&&Je.id===U;Dt.setState(Je,Se,Ds)}let Nn=!1;Je.version===gt.__version?(gt.needsLights&&gt.lightsStateVersion!==Qt.state.version||gt.outputColorSpace!==tn||Ue.isBatchedMesh&&gt.batching===!1||!Ue.isBatchedMesh&&gt.batching===!0||Ue.isBatchedMesh&&gt.batchingColor===!0&&Ue.colorTexture===null||Ue.isBatchedMesh&&gt.batchingColor===!1&&Ue.colorTexture!==null||Ue.isInstancedMesh&&gt.instancing===!1||!Ue.isInstancedMesh&&gt.instancing===!0||Ue.isSkinnedMesh&&gt.skinning===!1||!Ue.isSkinnedMesh&&gt.skinning===!0||Ue.isInstancedMesh&&gt.instancingColor===!0&&Ue.instanceColor===null||Ue.isInstancedMesh&&gt.instancingColor===!1&&Ue.instanceColor!==null||Ue.isInstancedMesh&&gt.instancingMorph===!0&&Ue.morphTexture===null||Ue.isInstancedMesh&&gt.instancingMorph===!1&&Ue.morphTexture!==null||gt.envMap!==en||Je.fog===!0&&gt.fog!==Ot||gt.numClippingPlanes!==void 0&&(gt.numClippingPlanes!==Dt.numPlanes||gt.numIntersection!==Dt.numIntersection)||gt.vertexAlphas!==dn||gt.vertexTangents!==wn||gt.morphTargets!==_n||gt.morphNormals!==Fn||gt.morphColors!==ti||gt.toneMapping!==Pn||gt.morphTargetsCount!==Ct)&&(Nn=!0):(Nn=!0,gt.__version=Je.version);let Ss=gt.currentProgram;Nn===!0&&(Ss=yt(Je,we,Ue));let yr=!1,$i=!1,ma=!1;const fi=Ss.getUniforms(),ks=gt.uniforms;if(Fe.useProgram(Ss.program)&&(yr=!0,$i=!0,ma=!0),Je.id!==U&&(U=Je.id,$i=!0),yr||N!==Se){Fe.buffers.depth.getReversed()&&Se.reversedDepth!==!0&&(Se._reversedDepth=!0,Se.updateProjectionMatrix()),fi.setValue(xe,"projectionMatrix",Se.projectionMatrix),fi.setValue(xe,"viewMatrix",Se.matrixWorldInverse);const lt=fi.map.cameraPosition;lt!==void 0&&lt.setValue(xe,Xe.setFromMatrixPosition(Se.matrixWorld)),je.logarithmicDepthBuffer&&fi.setValue(xe,"logDepthBufFC",2/(Math.log(Se.far+1)/Math.LN2)),(Je.isMeshPhongMaterial||Je.isMeshToonMaterial||Je.isMeshLambertMaterial||Je.isMeshBasicMaterial||Je.isMeshStandardMaterial||Je.isShaderMaterial)&&fi.setValue(xe,"isOrthographic",Se.isOrthographicCamera===!0),N!==Se&&(N=Se,$i=!0,ma=!0)}if(Ue.isSkinnedMesh){fi.setOptional(xe,Ue,"bindMatrix"),fi.setOptional(xe,Ue,"bindMatrixInverse");const Ds=Ue.skeleton;Ds&&(Ds.boneTexture===null&&Ds.computeBoneTexture(),fi.setValue(xe,"boneTexture",Ds.boneTexture,Qe))}Ue.isBatchedMesh&&(fi.setOptional(xe,Ue,"batchingTexture"),fi.setValue(xe,"batchingTexture",Ue._matricesTexture,Qe),fi.setOptional(xe,Ue,"batchingIdTexture"),fi.setValue(xe,"batchingIdTexture",Ue._indirectTexture,Qe),fi.setOptional(xe,Ue,"batchingColorTexture"),Ue._colorsTexture!==null&&fi.setValue(xe,"batchingColorTexture",Ue._colorsTexture,Qe));const $s=Ge.morphAttributes;if(($s.position!==void 0||$s.normal!==void 0||$s.color!==void 0)&&bt.update(Ue,Ge,Ss),($i||gt.receiveShadow!==Ue.receiveShadow)&&(gt.receiveShadow=Ue.receiveShadow,fi.setValue(xe,"receiveShadow",Ue.receiveShadow)),Je.isMeshGouraudMaterial&&Je.envMap!==null&&(ks.envMap.value=en,ks.flipEnvMap.value=en.isCubeTexture&&en.isRenderTargetTexture===!1?-1:1),Je.isMeshStandardMaterial&&Je.envMap===null&&we.environment!==null&&(ks.envMapIntensity.value=we.environmentIntensity),$i&&(fi.setValue(xe,"toneMappingExposure",x.toneMappingExposure),gt.needsLights&&xn(ks,ma),Ot&&Je.fog===!0&&ht.refreshFogUniforms(ks,Ot),ht.refreshMaterialUniforms(ks,Je,se,le,M.state.transmissionRenderTarget[Se.id]),GM.upload(xe,Ne(gt),ks,Qe)),Je.isShaderMaterial&&Je.uniformsNeedUpdate===!0&&(GM.upload(xe,Ne(gt),ks,Qe),Je.uniformsNeedUpdate=!1),Je.isSpriteMaterial&&fi.setValue(xe,"center",Ue.center),fi.setValue(xe,"modelViewMatrix",Ue.modelViewMatrix),fi.setValue(xe,"normalMatrix",Ue.normalMatrix),fi.setValue(xe,"modelMatrix",Ue.matrixWorld),Je.isShaderMaterial||Je.isRawShaderMaterial){const Ds=Je.uniformsGroups;for(let lt=0,de=Ds.length;lt<de;lt++){const Ie=Ds[lt];Yt.update(Ie,Ss),Yt.bind(Ie,Ss)}}return Ss}function xn(Se,we){Se.ambientLightColor.needsUpdate=we,Se.lightProbe.needsUpdate=we,Se.directionalLights.needsUpdate=we,Se.directionalLightShadows.needsUpdate=we,Se.pointLights.needsUpdate=we,Se.pointLightShadows.needsUpdate=we,Se.spotLights.needsUpdate=we,Se.spotLightShadows.needsUpdate=we,Se.rectAreaLights.needsUpdate=we,Se.hemisphereLights.needsUpdate=we}function Bn(Se){return Se.isMeshLambertMaterial||Se.isMeshToonMaterial||Se.isMeshPhongMaterial||Se.isMeshStandardMaterial||Se.isShadowMaterial||Se.isShaderMaterial&&Se.lights===!0}this.getActiveCubeFace=function(){return P},this.getActiveMipmapLevel=function(){return D},this.getRenderTarget=function(){return z},this.setRenderTargetTextures=function(Se,we,Ge){const Je=Ve.get(Se);Je.__autoAllocateDepthBuffer=Se.resolveDepthBuffer===!1,Je.__autoAllocateDepthBuffer===!1&&(Je.__useRenderToTexture=!1),Ve.get(Se.texture).__webglTexture=we,Ve.get(Se.depthTexture).__webglTexture=Je.__autoAllocateDepthBuffer?void 0:Ge,Je.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(Se,we){const Ge=Ve.get(Se);Ge.__webglFramebuffer=we,Ge.__useDefaultFramebuffer=we===void 0};const bi=xe.createFramebuffer();this.setRenderTarget=function(Se,we=0,Ge=0){z=Se,P=we,D=Ge;let Je=!0,Ue=null,Ot=!1,jt=!1;if(Se){const en=Ve.get(Se);if(en.__useDefaultFramebuffer!==void 0)Fe.bindFramebuffer(xe.FRAMEBUFFER,null),Je=!1;else if(en.__webglFramebuffer===void 0)Qe.setupRenderTarget(Se);else if(en.__hasExternalTextures)Qe.rebindTextures(Se,Ve.get(Se.texture).__webglTexture,Ve.get(Se.depthTexture).__webglTexture);else if(Se.depthBuffer){const _n=Se.depthTexture;if(en.__boundDepthTexture!==_n){if(_n!==null&&Ve.has(_n)&&(Se.width!==_n.image.width||Se.height!==_n.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");Qe.setupDepthRenderbuffer(Se)}}const dn=Se.texture;(dn.isData3DTexture||dn.isDataArrayTexture||dn.isCompressedArrayTexture)&&(jt=!0);const wn=Ve.get(Se).__webglFramebuffer;Se.isWebGLCubeRenderTarget?(Array.isArray(wn[we])?Ue=wn[we][Ge]:Ue=wn[we],Ot=!0):Se.samples>0&&Qe.useMultisampledRTT(Se)===!1?Ue=Ve.get(Se).__webglMultisampledFramebuffer:Array.isArray(wn)?Ue=wn[Ge]:Ue=wn,j.copy(Se.viewport),J.copy(Se.scissor),W=Se.scissorTest}else j.copy(ee).multiplyScalar(se).floor(),J.copy(te).multiplyScalar(se).floor(),W=ue;if(Ge!==0&&(Ue=bi),Fe.bindFramebuffer(xe.FRAMEBUFFER,Ue)&&Je&&Fe.drawBuffers(Se,Ue),Fe.viewport(j),Fe.scissor(J),Fe.setScissorTest(W),Ot){const en=Ve.get(Se.texture);xe.framebufferTexture2D(xe.FRAMEBUFFER,xe.COLOR_ATTACHMENT0,xe.TEXTURE_CUBE_MAP_POSITIVE_X+we,en.__webglTexture,Ge)}else if(jt){const en=we;for(let dn=0;dn<Se.textures.length;dn++){const wn=Ve.get(Se.textures[dn]);xe.framebufferTextureLayer(xe.FRAMEBUFFER,xe.COLOR_ATTACHMENT0+dn,wn.__webglTexture,Ge,en)}}else if(Se!==null&&Ge!==0){const en=Ve.get(Se.texture);xe.framebufferTexture2D(xe.FRAMEBUFFER,xe.COLOR_ATTACHMENT0,xe.TEXTURE_2D,en.__webglTexture,Ge)}U=-1},this.readRenderTargetPixels=function(Se,we,Ge,Je,Ue,Ot,jt,tn=0){if(!(Se&&Se.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let en=Ve.get(Se).__webglFramebuffer;if(Se.isWebGLCubeRenderTarget&&jt!==void 0&&(en=en[jt]),en){Fe.bindFramebuffer(xe.FRAMEBUFFER,en);try{const dn=Se.textures[tn],wn=dn.format,_n=dn.type;if(!je.textureFormatReadable(wn)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!je.textureTypeReadable(_n)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}we>=0&&we<=Se.width-Je&&Ge>=0&&Ge<=Se.height-Ue&&(Se.textures.length>1&&xe.readBuffer(xe.COLOR_ATTACHMENT0+tn),xe.readPixels(we,Ge,Je,Ue,We.convert(wn),We.convert(_n),Ot))}finally{const dn=z!==null?Ve.get(z).__webglFramebuffer:null;Fe.bindFramebuffer(xe.FRAMEBUFFER,dn)}}},this.readRenderTargetPixelsAsync=async function(Se,we,Ge,Je,Ue,Ot,jt,tn=0){if(!(Se&&Se.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let en=Ve.get(Se).__webglFramebuffer;if(Se.isWebGLCubeRenderTarget&&jt!==void 0&&(en=en[jt]),en)if(we>=0&&we<=Se.width-Je&&Ge>=0&&Ge<=Se.height-Ue){Fe.bindFramebuffer(xe.FRAMEBUFFER,en);const dn=Se.textures[tn],wn=dn.format,_n=dn.type;if(!je.textureFormatReadable(wn))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!je.textureTypeReadable(_n))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const Fn=xe.createBuffer();xe.bindBuffer(xe.PIXEL_PACK_BUFFER,Fn),xe.bufferData(xe.PIXEL_PACK_BUFFER,Ot.byteLength,xe.STREAM_READ),Se.textures.length>1&&xe.readBuffer(xe.COLOR_ATTACHMENT0+tn),xe.readPixels(we,Ge,Je,Ue,We.convert(wn),We.convert(_n),0);const ti=z!==null?Ve.get(z).__webglFramebuffer:null;Fe.bindFramebuffer(xe.FRAMEBUFFER,ti);const Pn=xe.fenceSync(xe.SYNC_GPU_COMMANDS_COMPLETE,0);return xe.flush(),await pU(xe,Pn,4),xe.bindBuffer(xe.PIXEL_PACK_BUFFER,Fn),xe.getBufferSubData(xe.PIXEL_PACK_BUFFER,0,Ot),xe.deleteBuffer(Fn),xe.deleteSync(Pn),Ot}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")},this.copyFramebufferToTexture=function(Se,we=null,Ge=0){const Je=Math.pow(2,-Ge),Ue=Math.floor(Se.image.width*Je),Ot=Math.floor(Se.image.height*Je),jt=we!==null?we.x:0,tn=we!==null?we.y:0;Qe.setTexture2D(Se,0),xe.copyTexSubImage2D(xe.TEXTURE_2D,Ge,0,0,jt,tn,Ue,Ot),Fe.unbindTexture()};const gn=xe.createFramebuffer(),Mn=xe.createFramebuffer();this.copyTextureToTexture=function(Se,we,Ge=null,Je=null,Ue=0,Ot=null){Ot===null&&(Ue!==0?(Q_("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),Ot=Ue,Ue=0):Ot=0);let jt,tn,en,dn,wn,_n,Fn,ti,Pn;const Ln=Se.isCompressedTexture?Se.mipmaps[Ot]:Se.image;if(Ge!==null)jt=Ge.max.x-Ge.min.x,tn=Ge.max.y-Ge.min.y,en=Ge.isBox3?Ge.max.z-Ge.min.z:1,dn=Ge.min.x,wn=Ge.min.y,_n=Ge.isBox3?Ge.min.z:0;else{const $s=Math.pow(2,-Ue);jt=Math.floor(Ln.width*$s),tn=Math.floor(Ln.height*$s),Se.isDataArrayTexture?en=Ln.depth:Se.isData3DTexture?en=Math.floor(Ln.depth*$s):en=1,dn=0,wn=0,_n=0}Je!==null?(Fn=Je.x,ti=Je.y,Pn=Je.z):(Fn=0,ti=0,Pn=0);const Ct=We.convert(we.format),gt=We.convert(we.type);let Qt;we.isData3DTexture?(Qe.setTexture3D(we,0),Qt=xe.TEXTURE_3D):we.isDataArrayTexture||we.isCompressedArrayTexture?(Qe.setTexture2DArray(we,0),Qt=xe.TEXTURE_2D_ARRAY):(Qe.setTexture2D(we,0),Qt=xe.TEXTURE_2D),xe.pixelStorei(xe.UNPACK_FLIP_Y_WEBGL,we.flipY),xe.pixelStorei(xe.UNPACK_PREMULTIPLY_ALPHA_WEBGL,we.premultiplyAlpha),xe.pixelStorei(xe.UNPACK_ALIGNMENT,we.unpackAlignment);const Nn=xe.getParameter(xe.UNPACK_ROW_LENGTH),Ss=xe.getParameter(xe.UNPACK_IMAGE_HEIGHT),yr=xe.getParameter(xe.UNPACK_SKIP_PIXELS),$i=xe.getParameter(xe.UNPACK_SKIP_ROWS),ma=xe.getParameter(xe.UNPACK_SKIP_IMAGES);xe.pixelStorei(xe.UNPACK_ROW_LENGTH,Ln.width),xe.pixelStorei(xe.UNPACK_IMAGE_HEIGHT,Ln.height),xe.pixelStorei(xe.UNPACK_SKIP_PIXELS,dn),xe.pixelStorei(xe.UNPACK_SKIP_ROWS,wn),xe.pixelStorei(xe.UNPACK_SKIP_IMAGES,_n);const fi=Se.isDataArrayTexture||Se.isData3DTexture,ks=we.isDataArrayTexture||we.isData3DTexture;if(Se.isDepthTexture){const $s=Ve.get(Se),Ds=Ve.get(we),lt=Ve.get($s.__renderTarget),de=Ve.get(Ds.__renderTarget);Fe.bindFramebuffer(xe.READ_FRAMEBUFFER,lt.__webglFramebuffer),Fe.bindFramebuffer(xe.DRAW_FRAMEBUFFER,de.__webglFramebuffer);for(let Ie=0;Ie<en;Ie++)fi&&(xe.framebufferTextureLayer(xe.READ_FRAMEBUFFER,xe.COLOR_ATTACHMENT0,Ve.get(Se).__webglTexture,Ue,_n+Ie),xe.framebufferTextureLayer(xe.DRAW_FRAMEBUFFER,xe.COLOR_ATTACHMENT0,Ve.get(we).__webglTexture,Ot,Pn+Ie)),xe.blitFramebuffer(dn,wn,jt,tn,Fn,ti,jt,tn,xe.DEPTH_BUFFER_BIT,xe.NEAREST);Fe.bindFramebuffer(xe.READ_FRAMEBUFFER,null),Fe.bindFramebuffer(xe.DRAW_FRAMEBUFFER,null)}else if(Ue!==0||Se.isRenderTargetTexture||Ve.has(Se)){const $s=Ve.get(Se),Ds=Ve.get(we);Fe.bindFramebuffer(xe.READ_FRAMEBUFFER,gn),Fe.bindFramebuffer(xe.DRAW_FRAMEBUFFER,Mn);for(let lt=0;lt<en;lt++)fi?xe.framebufferTextureLayer(xe.READ_FRAMEBUFFER,xe.COLOR_ATTACHMENT0,$s.__webglTexture,Ue,_n+lt):xe.framebufferTexture2D(xe.READ_FRAMEBUFFER,xe.COLOR_ATTACHMENT0,xe.TEXTURE_2D,$s.__webglTexture,Ue),ks?xe.framebufferTextureLayer(xe.DRAW_FRAMEBUFFER,xe.COLOR_ATTACHMENT0,Ds.__webglTexture,Ot,Pn+lt):xe.framebufferTexture2D(xe.DRAW_FRAMEBUFFER,xe.COLOR_ATTACHMENT0,xe.TEXTURE_2D,Ds.__webglTexture,Ot),Ue!==0?xe.blitFramebuffer(dn,wn,jt,tn,Fn,ti,jt,tn,xe.COLOR_BUFFER_BIT,xe.NEAREST):ks?xe.copyTexSubImage3D(Qt,Ot,Fn,ti,Pn+lt,dn,wn,jt,tn):xe.copyTexSubImage2D(Qt,Ot,Fn,ti,dn,wn,jt,tn);Fe.bindFramebuffer(xe.READ_FRAMEBUFFER,null),Fe.bindFramebuffer(xe.DRAW_FRAMEBUFFER,null)}else ks?Se.isDataTexture||Se.isData3DTexture?xe.texSubImage3D(Qt,Ot,Fn,ti,Pn,jt,tn,en,Ct,gt,Ln.data):we.isCompressedArrayTexture?xe.compressedTexSubImage3D(Qt,Ot,Fn,ti,Pn,jt,tn,en,Ct,Ln.data):xe.texSubImage3D(Qt,Ot,Fn,ti,Pn,jt,tn,en,Ct,gt,Ln):Se.isDataTexture?xe.texSubImage2D(xe.TEXTURE_2D,Ot,Fn,ti,jt,tn,Ct,gt,Ln.data):Se.isCompressedTexture?xe.compressedTexSubImage2D(xe.TEXTURE_2D,Ot,Fn,ti,Ln.width,Ln.height,Ct,Ln.data):xe.texSubImage2D(xe.TEXTURE_2D,Ot,Fn,ti,jt,tn,Ct,gt,Ln);xe.pixelStorei(xe.UNPACK_ROW_LENGTH,Nn),xe.pixelStorei(xe.UNPACK_IMAGE_HEIGHT,Ss),xe.pixelStorei(xe.UNPACK_SKIP_PIXELS,yr),xe.pixelStorei(xe.UNPACK_SKIP_ROWS,$i),xe.pixelStorei(xe.UNPACK_SKIP_IMAGES,ma),Ot===0&&we.generateMipmaps&&xe.generateMipmap(Qt),Fe.unbindTexture()},this.copyTextureToTexture3D=function(Se,we,Ge=null,Je=null,Ue=0){return Q_('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(Se,we,Ge,Je,Ue)},this.initRenderTarget=function(Se){Ve.get(Se).__webglFramebuffer===void 0&&Qe.setupRenderTarget(Se)},this.initTexture=function(Se){Se.isCubeTexture?Qe.setTextureCube(Se,0):Se.isData3DTexture?Qe.setTexture3D(Se,0):Se.isDataArrayTexture||Se.isCompressedArrayTexture?Qe.setTexture2DArray(Se,0):Qe.setTexture2D(Se,0),Fe.unbindTexture()},this.resetState=function(){P=0,D=0,z=null,Fe.reset(),vt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Ku}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=us._getDrawingBufferColorSpace(e),t.unpackColorSpace=us._getUnpackColorSpace()}}const C$=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:dT,AddEquation:om,AddOperation:KB,AdditiveAnimationBlendMode:yT,AdditiveBlending:ME,AgXToneMapping:QB,AlphaFormat:mT,AlwaysCompare:hI,AlwaysDepth:Pv,AlwaysStencilFunc:EE,AmbientLight:QI,AnimationAction:lO,AnimationClip:d0,AnimationLoader:Gk,AnimationMixer:p4,AnimationObjectGroup:f4,AnimationUtils:Nk,ArcCurve:AI,ArrayCamera:rO,ArrowHelper:U4,AttachedBindMode:wE,Audio:aO,AudioAnalyser:n4,AudioContext:XT,AudioListener:Zk,AudioLoader:Yk,AxesHelper:k4,BackSide:Ga,BasicDepthPacking:mm,BasicShadowMap:AB,BatchedMesh:TI,Bone:lx,BooleanKeyframeTrack:e_,Box2:w4,Box3:Ra,Box3Helper:N4,BoxGeometry:Zg,BoxHelper:F4,BufferAttribute:hs,BufferGeometry:xi,BufferGeometryLoader:iO,ByteType:fT,Cache:zf,Camera:rx,CameraHelper:L4,CanvasTexture:ak,CapsuleGeometry:hx,CatmullRomCurve3:CI,CineonToneMapping:YB,CircleGeometry:px,ClampToEdgeWrapping:Wu,Clock:YT,Color:Sn,ColorKeyframeTrack:HT,ColorManagement:us,CompressedArrayTexture:sk,CompressedCubeTexture:rk,CompressedTexture:dx,CompressedTextureLoader:Vk,ConeGeometry:Jv,ConstantAlphaFactor:jB,ConstantColorFactor:VB,Controls:V4,CubeCamera:MI,CubeReflectionMapping:Wh,CubeRefractionMapping:dm,CubeTexture:Kv,CubeTextureLoader:Hk,CubeUVReflectionMapping:g0,CubicBezierCurve:IT,CubicBezierCurve3:PI,CubicInterpolant:WI,CullFaceBack:yE,CullFaceFront:SB,CullFaceFrontBack:_z,CullFaceNone:TB,Curve:kd,CurvePath:DI,CustomBlending:CB,CustomToneMapping:JB,CylinderGeometry:Yv,Cylindrical:x4,Data3DTexture:sx,DataArrayTexture:ix,DataTexture:Uf,DataTextureLoader:jk,DataUtils:PU,DecrementStencilOp:Cz,DecrementWrapStencilOp:Rz,DefaultLoadingManager:XI,DepthFormat:i0,DepthStencilFormat:kg,DepthTexture:fx,DetachedBindMode:eI,DirectionalLight:qT,DirectionalLightHelper:O4,DiscreteInterpolant:KI,DodecahedronGeometry:mx,DoubleSide:Ro,DstAlphaFactor:NB,DstColorFactor:UB,DynamicCopyUsage:$z,DynamicDrawUsage:Uz,DynamicReadUsage:Vz,EdgesGeometry:DT,EllipseCurve:gx,EqualCompare:uI,EqualDepth:JM,EqualStencilFunc:Oz,EquirectangularReflectionMapping:Rv,EquirectangularRefractionMapping:Dv,Euler:Ju,EventDispatcher:Zu,ExtrudeGeometry:_x,FileLoader:Qu,Float16BufferAttribute:FU,Float32BufferAttribute:Hn,FloatType:Rl,Fog:ox,FogExp2:ax,FramebufferTexture:ik,FrontSide:Nd,Frustum:_0,FrustumArray:ux,GLBufferAttribute:y4,GLSL1:Kz,GLSL3:TE,GreaterCompare:cI,GreaterDepth:ZM,GreaterEqualCompare:fI,GreaterEqualDepth:QM,GreaterEqualStencilFunc:zz,GreaterStencilFunc:Fz,GridHelper:B4,Group:Hh,HalfFloatType:Jg,HemisphereLight:JI,HemisphereLightHelper:D4,IcosahedronGeometry:vx,ImageBitmapLoader:sO,ImageLoader:kv,ImageUtils:gI,IncrementStencilOp:Az,IncrementWrapStencilOp:Pz,InstancedBufferAttribute:Gg,InstancedBufferGeometry:nO,InstancedInterleavedBuffer:v4,InstancedMesh:CT,Int16BufferAttribute:OU,Int32BufferAttribute:LU,Int8BufferAttribute:DU,IntType:Yb,InterleavedBuffer:qv,InterleavedBufferAttribute:hm,Interpolant:b0,InterpolateDiscrete:s0,InterpolateLinear:r0,InterpolateSmooth:UM,InterpolationSamplingMode:Yz,InterpolationSamplingType:Xz,InvertStencilOp:Dz,KeepStencilOp:bg,KeyframeTrack:zc,LOD:EI,LatheGeometry:yx,Layers:l0,LessCompare:lI,LessDepth:YM,LessEqualCompare:bT,LessEqualDepth:zg,LessEqualStencilFunc:Lz,LessStencilFunc:Iz,Light:vm,LightProbe:tO,Line:Kh,Line3:S4,LineBasicMaterial:Qo,LineCurve:OT,LineCurve3:RI,LineDashedMaterial:HI,LineLoop:PT,LineSegments:Ud,LinearFilter:Tr,LinearInterpolant:VT,LinearMipMapLinearFilter:bz,LinearMipMapNearestFilter:Mz,LinearMipmapLinearFilter:Oc,LinearMipmapNearestFilter:J_,LinearSRGBColorSpace:Gf,LinearToneMapping:qB,LinearTransfer:Iv,Loader:Zo,LoaderUtils:cm,LoadingManager:jT,LoopOnce:tI,LoopPingPong:iI,LoopRepeat:nI,MOUSE:yg,Material:pa,MaterialLoader:Sx,MathUtils:Vh,Matrix2:ZT,Matrix3:Ai,Matrix4:li,MaxEquation:BB,Mesh:ea,MeshBasicMaterial:qu,MeshDepthMaterial:UT,MeshDistanceMaterial:kT,MeshLambertMaterial:GI,MeshMatcapMaterial:VI,MeshNormalMaterial:zT,MeshPhongMaterial:UI,MeshPhysicalMaterial:Nc,MeshStandardMaterial:M0,MeshToonMaterial:kI,MinEquation:DB,MirroredRepeatWrapping:t0,MixOperation:WB,MultiplyBlending:xE,MultiplyOperation:$v,NearestFilter:ta,NearestMipMapLinearFilter:yz,NearestMipMapNearestFilter:vz,NearestMipmapLinearFilter:Ag,NearestMipmapNearestFilter:Xb,NeutralToneMapping:ZB,NeverCompare:oI,NeverDepth:XM,NeverStencilFunc:Bz,NoBlending:Jo,NoColorSpace:Bd,NoToneMapping:Ld,NormalAnimationBlendMode:nx,NormalBlending:Og,NotEqualCompare:dI,NotEqualDepth:eb,NotEqualStencilFunc:Nz,NumberKeyframeTrack:Hg,Object3D:fs,ObjectLoader:qk,ObjectSpaceNormalMap:aI,OctahedronGeometry:Qv,OneFactor:OB,OneMinusConstantAlphaFactor:$B,OneMinusConstantColorFactor:HB,OneMinusDstAlphaFactor:zB,OneMinusDstColorFactor:kB,OneMinusSrcAlphaFactor:qM,OneMinusSrcColorFactor:FB,OrthographicCamera:Lc,PCFShadowMap:Kb,PCFSoftShadowMap:_v,PMREMGenerator:IE,Path:Db,PerspectiveCamera:Er,Plane:Uh,PlaneGeometry:v0,PlaneHelper:z4,PointLight:KT,PointLightHelper:P4,Points:RT,PointsMaterial:cx,PolarGridHelper:I4,PolyhedronGeometry:_m,PositionalAudio:t4,PropertyBinding:ys,PropertyMixer:oO,QuadraticBezierCurve:LT,QuadraticBezierCurve3:FT,Quaternion:lo,QuaternionKeyframeTrack:jg,QuaternionLinearInterpolant:qI,RED_GREEN_RGTC2_Format:Tb,RED_RGTC1_Format:vT,REVISION:Yg,RGBADepthPacking:rI,RGBAFormat:Xo,RGBAIntegerFormat:tx,RGBA_ASTC_10x10_Format:yb,RGBA_ASTC_10x5_Format:gb,RGBA_ASTC_10x6_Format:_b,RGBA_ASTC_10x8_Format:vb,RGBA_ASTC_12x10_Format:Mb,RGBA_ASTC_12x12_Format:bb,RGBA_ASTC_4x4_Format:lb,RGBA_ASTC_5x4_Format:ub,RGBA_ASTC_5x5_Format:cb,RGBA_ASTC_6x5_Format:db,RGBA_ASTC_6x6_Format:fb,RGBA_ASTC_8x5_Format:hb,RGBA_ASTC_8x6_Format:pb,RGBA_ASTC_8x8_Format:mb,RGBA_BPTC_Format:xv,RGBA_ETC2_EAC_Format:ob,RGBA_PVRTC_2BPPV1_Format:sb,RGBA_PVRTC_4BPPV1_Format:ib,RGBA_S3TC_DXT1_Format:yv,RGBA_S3TC_DXT3_Format:Mv,RGBA_S3TC_DXT5_Format:bv,RGBDepthPacking:wz,RGBFormat:gT,RGBIntegerFormat:xz,RGB_BPTC_SIGNED_Format:xb,RGB_BPTC_UNSIGNED_Format:wb,RGB_ETC1_Format:rb,RGB_ETC2_Format:ab,RGB_PVRTC_2BPPV1_Format:nb,RGB_PVRTC_4BPPV1_Format:tb,RGB_S3TC_DXT1_Format:vv,RGDepthPacking:Ez,RGFormat:_T,RGIntegerFormat:ex,RawShaderMaterial:zI,Ray:Qg,Raycaster:uO,RectAreaLight:ZI,RedFormat:Zb,RedIntegerFormat:Wv,ReinhardToneMapping:XB,RenderTarget:wT,RenderTarget3D:m4,RepeatWrapping:fm,ReplaceStencilOp:Sz,ReverseSubtractEquation:RB,RingGeometry:Mx,SIGNED_RED_GREEN_RGTC2_Format:Sb,SIGNED_RED_RGTC1_Format:Eb,SRGBColorSpace:Rs,SRGBTransfer:js,Scene:Fv,ShaderChunk:Ni,ShaderLib:Rd,ShaderMaterial:ja,ShadowMaterial:NI,Shape:Fg,ShapeGeometry:bx,ShapePath:G4,ShapeUtils:Od,ShortType:hT,Skeleton:Xv,SkeletonHelper:C4,SkinnedMesh:AT,Source:um,Sphere:uo,SphereGeometry:y0,Spherical:DE,SphericalHarmonics3:eO,SplineCurve:NT,SpotLight:WT,SpotLightHelper:A4,Sprite:wI,SpriteMaterial:ST,SrcAlphaFactor:KM,SrcAlphaSaturateFactor:GB,SrcColorFactor:LB,StaticCopyUsage:jz,StaticDrawUsage:Ov,StaticReadUsage:Gz,StereoCamera:Jk,StreamCopyUsage:Wz,StreamDrawUsage:kz,StreamReadUsage:Hz,StringKeyframeTrack:t_,SubtractEquation:PB,SubtractiveBlending:bE,TOUCH:Mg,TangentSpaceNormalMap:gm,TetrahedronGeometry:xx,Texture:vr,TextureLoader:YI,TextureUtils:K4,Timer:M4,TimestampQuery:qz,TorusGeometry:wx,TorusKnotGeometry:Ex,Triangle:ou,TriangleFanDrawMode:Ab,TriangleStripDrawMode:MT,TrianglesDrawMode:sI,TubeGeometry:Tx,UVMapping:qb,Uint16BufferAttribute:ET,Uint32BufferAttribute:TT,Uint8BufferAttribute:BU,Uint8ClampedBufferAttribute:IU,Uniform:cs,UniformsGroup:_4,UniformsLib:Dn,UniformsUtils:yI,UnsignedByteType:Ha,UnsignedInt248Type:Ug,UnsignedInt5999Type:pT,UnsignedIntType:kf,UnsignedShort4444Type:Jb,UnsignedShort5551Type:Qb,UnsignedShortType:n0,VSMShadowMap:Pd,Vector2:Gt,Vector3:Oe,Vector4:ds,VectorKeyframeTrack:$g,VideoFrameTexture:nk,VideoTexture:SI,WebGL3DRenderTarget:yU,WebGLArrayRenderTarget:vU,WebGLCoordinateSystem:Ku,WebGLCubeRenderTarget:bI,WebGLRenderTarget:Da,WebGLRenderer:vO,WebGLUtils:gO,WebGPUCoordinateSystem:a0,WebXRController:kM,WireframeGeometry:FI,WrapAroundEnding:Bv,ZeroCurvatureEnding:Cg,ZeroFactor:IB,ZeroSlopeEnding:Pg,ZeroStencilOp:Tz,createCanvasElement:mI},Symbol.toStringTag,{value:"Module"}));var Ww={exports:{}},Kw={},qw={exports:{}},Xw={};var $C;function P$(){if($C)return Xw;$C=1;var n=m0();function e(p,h){return p===h&&(p!==0||1/p===1/h)||p!==p&&h!==h}var t=typeof Object.is=="function"?Object.is:e,i=n.useState,s=n.useEffect,r=n.useLayoutEffect,o=n.useDebugValue;function l(p,h){var v=h(),y=i({inst:{value:v,getSnapshot:h}}),w=y[0].inst,S=y[1];return r(function(){w.value=v,w.getSnapshot=h,c(w)&&S({inst:w})},[p,v,h]),s(function(){return c(w)&&S({inst:w}),p(function(){c(w)&&S({inst:w})})},[p]),o(v),v}function c(p){var h=p.getSnapshot;p=p.value;try{var v=h();return!t(p,v)}catch{return!0}}function d(p,h){return h()}var g=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?d:l;return Xw.useSyncExternalStore=n.useSyncExternalStore!==void 0?n.useSyncExternalStore:g,Xw}var WC;function R$(){return WC||(WC=1,qw.exports=P$()),qw.exports}var KC;function D$(){if(KC)return Kw;KC=1;var n=m0(),e=R$();function t(d,g){return d===g&&(d!==0||1/d===1/g)||d!==d&&g!==g}var i=typeof Object.is=="function"?Object.is:t,s=e.useSyncExternalStore,r=n.useRef,o=n.useEffect,l=n.useMemo,c=n.useDebugValue;return Kw.useSyncExternalStoreWithSelector=function(d,g,p,h,v){var y=r(null);if(y.current===null){var w={hasValue:!1,value:null};y.current=w}else w=y.current;y=l(function(){function M(P){if(!T){if(T=!0,C=P,P=h(P),v!==void 0&&w.hasValue){var D=w.value;if(v(D,P))return x=D}return x=P}if(D=x,i(C,P))return D;var z=h(P);return v!==void 0&&v(D,z)?(C=P,D):(C=P,x=z)}var T=!1,C,x,R=p===void 0?null:p;return[function(){return M(g())},R===null?void 0:function(){return M(R())}]},[g,p,h,v]);var S=s(d,y[0],y[1]);return o(function(){w.hasValue=!0,w.value=S},[S]),c(S),S},Kw}var qC;function B$(){return qC||(qC=1,Ww.exports=D$()),Ww.exports}var I$=B$();const O$=Wb(I$),XC=n=>{let e;const t=new Set,i=(d,g)=>{const p=typeof d=="function"?d(e):d;if(!Object.is(p,e)){const h=e;e=g??(typeof p!="object"||p===null)?p:Object.assign({},e,p),t.forEach(v=>v(e,h))}},s=()=>e,l={setState:i,getState:s,getInitialState:()=>c,subscribe:d=>(t.add(d),()=>t.delete(d))},c=e=n(i,s,l);return l},L$=(n=>n?XC(n):XC),{useSyncExternalStoreWithSelector:F$}=O$,N$=n=>n;function z$(n,e=N$,t){const i=F$(n.subscribe,n.getState,n.getInitialState,e,t);return wB.useDebugValue(i),i}const YC=(n,e)=>{const t=L$(n),i=(s,r=e)=>z$(t,s,r);return Object.assign(i,t),i},U$=((n,e)=>n?YC(n,e):YC),k$=n=>typeof n=="object"&&typeof n.then=="function",Dg=[];function yO(n,e,t=(i,s)=>i===s){if(n===e)return!0;if(!n||!e)return!1;const i=n.length;if(e.length!==i)return!1;for(let s=0;s<i;s++)if(!t(n[s],e[s]))return!1;return!0}function MO(n,e=null,t=!1,i={}){e===null&&(e=[n]);for(const r of Dg)if(yO(e,r.keys,r.equal)){if(t)return;if(Object.prototype.hasOwnProperty.call(r,"error"))throw r.error;if(Object.prototype.hasOwnProperty.call(r,"response"))return i.lifespan&&i.lifespan>0&&(r.timeout&&clearTimeout(r.timeout),r.timeout=setTimeout(r.remove,i.lifespan)),r.response;if(!t)throw r.promise}const s={keys:e,equal:i.equal,remove:()=>{const r=Dg.indexOf(s);r!==-1&&Dg.splice(r,1)},promise:(k$(n)?n:n(...e)).then(r=>{s.response=r,i.lifespan&&i.lifespan>0&&(s.timeout=setTimeout(s.remove,i.lifespan))}).catch(r=>s.error=r)};if(Dg.push(s),!t)throw s.promise}const G$=(n,e,t)=>MO(n,e,!1,t),V$=(n,e,t)=>void MO(n,e,!0,t),H$=n=>{if(n===void 0||n.length===0)Dg.splice(0,Dg.length);else{const e=Dg.find(t=>yO(n,t.keys,t.equal));e&&e.remove()}};var Yw={exports:{}},Jw={exports:{}},Qw={exports:{}},Zw={};var JC;function j$(){return JC||(JC=1,(function(n){function e(q,le){var se=q.length;q.push(le);e:for(;0<se;){var pe=se-1>>>1,be=q[pe];if(0<s(be,le))q[pe]=le,q[se]=be,se=pe;else break e}}function t(q){return q.length===0?null:q[0]}function i(q){if(q.length===0)return null;var le=q[0],se=q.pop();if(se!==le){q[0]=se;e:for(var pe=0,be=q.length,ee=be>>>1;pe<ee;){var te=2*(pe+1)-1,ue=q[te],ae=te+1,ce=q[ae];if(0>s(ue,se))ae<be&&0>s(ce,ue)?(q[pe]=ce,q[ae]=se,pe=ae):(q[pe]=ue,q[te]=se,pe=te);else if(ae<be&&0>s(ce,se))q[pe]=ce,q[ae]=se,pe=ae;else break e}}return le}function s(q,le){var se=q.sortIndex-le.sortIndex;return se!==0?se:q.id-le.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var r=performance;n.unstable_now=function(){return r.now()}}else{var o=Date,l=o.now();n.unstable_now=function(){return o.now()-l}}var c=[],d=[],g=1,p=null,h=3,v=!1,y=!1,w=!1,S=typeof setTimeout=="function"?setTimeout:null,M=typeof clearTimeout=="function"?clearTimeout:null,T=typeof setImmediate<"u"?setImmediate:null;function C(q){for(var le=t(d);le!==null;){if(le.callback===null)i(d);else if(le.startTime<=q)i(d),le.sortIndex=le.expirationTime,e(c,le);else break;le=t(d)}}function x(q){if(w=!1,C(q),!y)if(t(c)!==null)y=!0,oe();else{var le=t(d);le!==null&&ne(x,le.startTime-q)}}var R=!1,P=-1,D=5,z=-1;function U(){return!(n.unstable_now()-z<D)}function N(){if(R){var q=n.unstable_now();z=q;var le=!0;try{e:{y=!1,w&&(w=!1,M(P),P=-1),v=!0;var se=h;try{t:{for(C(q),p=t(c);p!==null&&!(p.expirationTime>q&&U());){var pe=p.callback;if(typeof pe=="function"){p.callback=null,h=p.priorityLevel;var be=pe(p.expirationTime<=q);if(q=n.unstable_now(),typeof be=="function"){p.callback=be,C(q),le=!0;break t}p===t(c)&&i(c),C(q)}else i(c);p=t(c)}if(p!==null)le=!0;else{var ee=t(d);ee!==null&&ne(x,ee.startTime-q),le=!1}}break e}finally{p=null,h=se,v=!1}le=void 0}}finally{le?j():R=!1}}}var j;if(typeof T=="function")j=function(){T(N)};else if(typeof MessageChannel<"u"){var J=new MessageChannel,W=J.port2;J.port1.onmessage=N,j=function(){W.postMessage(null)}}else j=function(){S(N,0)};function oe(){R||(R=!0,j())}function ne(q,le){P=S(function(){q(n.unstable_now())},le)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(q){q.callback=null},n.unstable_continueExecution=function(){y||v||(y=!0,oe())},n.unstable_forceFrameRate=function(q){0>q||125<q?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):D=0<q?Math.floor(1e3/q):5},n.unstable_getCurrentPriorityLevel=function(){return h},n.unstable_getFirstCallbackNode=function(){return t(c)},n.unstable_next=function(q){switch(h){case 1:case 2:case 3:var le=3;break;default:le=h}var se=h;h=le;try{return q()}finally{h=se}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(q,le){switch(q){case 1:case 2:case 3:case 4:case 5:break;default:q=3}var se=h;h=q;try{return le()}finally{h=se}},n.unstable_scheduleCallback=function(q,le,se){var pe=n.unstable_now();switch(typeof se=="object"&&se!==null?(se=se.delay,se=typeof se=="number"&&0<se?pe+se:pe):se=pe,q){case 1:var be=-1;break;case 2:be=250;break;case 5:be=1073741823;break;case 4:be=1e4;break;default:be=5e3}return be=se+be,q={id:g++,callback:le,priorityLevel:q,startTime:se,expirationTime:be,sortIndex:-1},se>pe?(q.sortIndex=se,e(d,q),t(c)===null&&q===t(d)&&(w?(M(P),P=-1):w=!0,ne(x,se-pe))):(q.sortIndex=be,e(c,q),y||v||(y=!0,oe())),q},n.unstable_shouldYield=U,n.unstable_wrapCallback=function(q){var le=h;return function(){var se=h;h=le;try{return q.apply(this,arguments)}finally{h=se}}}})(Zw)),Zw}var QC;function bO(){return QC||(QC=1,Qw.exports=j$()),Qw.exports}var ZC;function $$(){return ZC||(ZC=1,(function(n){n.exports=function(e){function t(f,m,E,L){return new Zh(f,m,E,L)}function i(){}function s(f){var m="https://react.dev/errors/"+f;if(1<arguments.length){m+="?args[]="+encodeURIComponent(arguments[1]);for(var E=2;E<arguments.length;E++)m+="&args[]="+encodeURIComponent(arguments[E])}return"Minified React error #"+f+"; visit "+m+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(f){return f===null||typeof f!="object"?null:(f=ap&&f[ap]||f["@@iterator"],typeof f=="function"?f:null)}function o(f){if(f==null)return null;if(typeof f=="function")return f.$$typeof===pc?null:f.displayName||f.name||null;if(typeof f=="string")return f;switch(f){case sd:return"Fragment";case go:return"Portal";case eh:return"Profiler";case rp:return"StrictMode";case th:return"Suspense";case xu:return"SuspenseList"}if(typeof f=="object")switch(f.$$typeof){case zo:return(f.displayName||"Context")+".Provider";case bu:return(f._context.displayName||"Context")+".Consumer";case rd:var m=f.render;return f=f.displayName,f||(f=m.displayName||m.name||"",f=f!==""?"ForwardRef("+f+")":"ForwardRef"),f;case sf:return m=f.displayName||null,m!==null?m:o(f.type)||"Memo";case _o:m=f._payload,f=f._init;try{return o(f(m))}catch{}}return null}function l(f){if(nh===void 0)try{throw Error()}catch(E){var m=E.stack.trim().match(/\n( *(at )?)/);nh=m&&m[1]||"",op=-1<E.stack.indexOf(`
    at`)?" (<anonymous>)":-1<E.stack.indexOf("@")?"@unknown:0:0":""}return`
`+nh+f+op}function c(f,m){if(!f||wu)return"";wu=!0;var E=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var L={DetermineComponentFrameRoot:function(){try{if(m){var An=function(){throw Error()};if(Object.defineProperty(An.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(An,[])}catch(ci){var Rn=ci}Reflect.construct(f,[],An)}else{try{An.call()}catch(ci){Rn=ci}f.call(An.prototype)}}else{try{throw Error()}catch(ci){Rn=ci}(An=f())&&typeof An.catch=="function"&&An.catch(function(){})}}catch(ci){if(ci&&Rn&&typeof ci.stack=="string")return[ci.stack,Rn.stack]}return[null,null]}};L.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var $=Object.getOwnPropertyDescriptor(L.DetermineComponentFrameRoot,"name");$&&$.configurable&&Object.defineProperty(L.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var ie=L.DetermineComponentFrameRoot(),De=ie[0],it=ie[1];if(De&&it){var pt=De.split(`
`),Xt=it.split(`
`);for($=L=0;L<pt.length&&!pt[L].includes("DetermineComponentFrameRoot");)L++;for(;$<Xt.length&&!Xt[$].includes("DetermineComponentFrameRoot");)$++;if(L===pt.length||$===Xt.length)for(L=pt.length-1,$=Xt.length-1;1<=L&&0<=$&&pt[L]!==Xt[$];)$--;for(;1<=L&&0<=$;L--,$--)if(pt[L]!==Xt[$]){if(L!==1||$!==1)do if(L--,$--,0>$||pt[L]!==Xt[$]){var mn=`
`+pt[L].replace(" at new "," at ");return f.displayName&&mn.includes("<anonymous>")&&(mn=mn.replace("<anonymous>",f.displayName)),mn}while(1<=L&&0<=$);break}}}finally{wu=!1,Error.prepareStackTrace=E}return(E=f?f.displayName||f.name:"")?l(E):""}function d(f){switch(f.tag){case 26:case 27:case 5:return l(f.type);case 16:return l("Lazy");case 13:return l("Suspense");case 19:return l("SuspenseList");case 0:case 15:return f=c(f.type,!1),f;case 11:return f=c(f.type.render,!1),f;case 1:return f=c(f.type,!0),f;default:return""}}function g(f){try{var m="";do m+=d(f),f=f.return;while(f);return m}catch(E){return`
Error generating stack: `+E.message+`
`+E.stack}}function p(f){var m=f,E=f;if(f.alternate)for(;m.return;)m=m.return;else{f=m;do m=f,(m.flags&4098)!==0&&(E=m.return),f=m.return;while(f)}return m.tag===3?E:null}function h(f){if(p(f)!==f)throw Error(s(188))}function v(f){var m=f.alternate;if(!m){if(m=p(f),m===null)throw Error(s(188));return m!==f?null:f}for(var E=f,L=m;;){var $=E.return;if($===null)break;var ie=$.alternate;if(ie===null){if(L=$.return,L!==null){E=L;continue}break}if($.child===ie.child){for(ie=$.child;ie;){if(ie===E)return h($),f;if(ie===L)return h($),m;ie=ie.sibling}throw Error(s(188))}if(E.return!==L.return)E=$,L=ie;else{for(var De=!1,it=$.child;it;){if(it===E){De=!0,E=$,L=ie;break}if(it===L){De=!0,L=$,E=ie;break}it=it.sibling}if(!De){for(it=ie.child;it;){if(it===E){De=!0,E=ie,L=$;break}if(it===L){De=!0,L=ie,E=$;break}it=it.sibling}if(!De)throw Error(s(189))}}if(E.alternate!==L)throw Error(s(190))}if(E.tag!==3)throw Error(s(188));return E.stateNode.current===E?f:m}function y(f){var m=f.tag;if(m===5||m===26||m===27||m===6)return f;for(f=f.child;f!==null;){if(m=y(f),m!==null)return m;f=f.sibling}return null}function w(f){var m=f.tag;if(m===5||m===26||m===27||m===6)return f;for(f=f.child;f!==null;){if(f.tag!==4&&(m=w(f),m!==null))return m;f=f.sibling}return null}function S(f){return{current:f}}function M(f){0>Xl||(f.current=vc[Xl],vc[Xl]=null,Xl--)}function T(f,m){Xl++,vc[Xl]=f.current,f.current=m}function C(f){return f>>>=0,f===0?32:31-(_f(f)/Vm|0)|0}function x(f){var m=f&42;if(m!==0)return m;switch(f&-f){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return f&4194176;case 4194304:case 8388608:case 16777216:case 33554432:return f&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return f}}function R(f,m){var E=f.pendingLanes;if(E===0)return 0;var L=0,$=f.suspendedLanes,ie=f.pingedLanes,De=f.warmLanes;f=f.finishedLanes!==0;var it=E&134217727;return it!==0?(E=it&~$,E!==0?L=x(E):(ie&=it,ie!==0?L=x(ie):f||(De=it&~De,De!==0&&(L=x(De))))):(it=E&~$,it!==0?L=x(it):ie!==0?L=x(ie):f||(De=E&~De,De!==0&&(L=x(De)))),L===0?0:m!==0&&m!==L&&(m&$)===0&&($=L&-L,De=m&-m,$>=De||$===32&&(De&4194176)!==0)?m:L}function P(f,m){return(f.pendingLanes&~(f.suspendedLanes&~f.pingedLanes)&m)===0}function D(f,m){switch(f){case 1:case 2:case 4:case 8:return m+250;case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return m+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function z(){var f=Mc;return Mc<<=1,(Mc&4194176)===0&&(Mc=128),f}function U(){var f=vf;return vf<<=1,(vf&62914560)===0&&(vf=4194304),f}function N(f){for(var m=[],E=0;31>E;E++)m.push(f);return m}function j(f,m){f.pendingLanes|=m,m!==268435456&&(f.suspendedLanes=0,f.pingedLanes=0,f.warmLanes=0)}function J(f,m,E,L,$,ie){var De=f.pendingLanes;f.pendingLanes=E,f.suspendedLanes=0,f.pingedLanes=0,f.warmLanes=0,f.expiredLanes&=E,f.entangledLanes&=E,f.errorRecoveryDisabledLanes&=E,f.shellSuspendCounter=0;var it=f.entanglements,pt=f.expirationTimes,Xt=f.hiddenUpdates;for(E=De&~E;0<E;){var mn=31-xa(E),An=1<<mn;it[mn]=0,pt[mn]=-1;var Rn=Xt[mn];if(Rn!==null)for(Xt[mn]=null,mn=0;mn<Rn.length;mn++){var ci=Rn[mn];ci!==null&&(ci.lane&=-536870913)}E&=~An}L!==0&&W(f,L,0),ie!==0&&$===0&&f.tag!==0&&(f.suspendedLanes|=ie&~(De&~m))}function W(f,m,E){f.pendingLanes|=m,f.suspendedLanes&=~m;var L=31-xa(m);f.entangledLanes|=m,f.entanglements[L]=f.entanglements[L]|1073741824|E&4194218}function oe(f,m){var E=f.entangledLanes|=m;for(f=f.entanglements;E;){var L=31-xa(E),$=1<<L;$&m|f[L]&m&&(f[L]|=m),E&=~$}}function ne(f){return f&=-f,2<f?8<f?(f&134217727)!==0?32:268435456:8:2}function q(f){if(Oa&&typeof Oa.onCommitFiberRoot=="function")try{Oa.onCommitFiberRoot(dd,f,void 0,(f.current.flags&128)===128)}catch{}}function le(f){if(typeof Wm=="function"&&Fp(f),Oa&&typeof Oa.setStrictMode=="function")try{Oa.setStrictMode(dd,f)}catch{}}function se(f,m){return f===m&&(f!==0||1/f===1/m)||f!==f&&m!==m}function pe(f,m){if(typeof f=="object"&&f!==null){var E=yh.get(f);return E!==void 0?E:(m={value:f,source:m,stack:g(m)},yh.set(f,m),m)}return{value:f,source:m,stack:g(m)}}function be(f,m){zs[nr++]=Mf,zs[nr++]=Cu,Cu=f,Mf=m}function ee(f,m,E){Ja[Qa++]=vo,Ja[Qa++]=yo,Ja[Qa++]=Go,Go=f;var L=vo;f=yo;var $=32-xa(L)-1;L&=~(1<<$),E+=1;var ie=32-xa(m)+$;if(30<ie){var De=$-$%5;ie=(L&(1<<De)-1).toString(32),L>>=De,$-=De,vo=1<<32-xa(m)+$|E<<$|L,yo=ie+f}else vo=1<<ie|E<<$|L,yo=f}function te(f){f.return!==null&&(be(f,1),ee(f,1,0))}function ue(f){for(;f===Cu;)Cu=zs[--nr],zs[nr]=null,Mf=zs[--nr],zs[nr]=null;for(;f===Go;)Go=Ja[--Qa],Ja[Qa]=null,yo=Ja[--Qa],Ja[Qa]=null,vo=Ja[--Qa],Ja[Qa]=null}function ae(f,m){T(vl,m),T(bf,f),T(Ur,null),f=mc(m),M(Ur),T(Ur,f)}function ce(){M(Ur),M(bf),M(vl)}function Be(f){f.memoizedState!==null&&T(fd,f);var m=Ur.current,E=lp(m,f.type);m!==E&&(T(bf,f),T(Ur,E))}function He(f){bf.current===f&&(M(Ur),M(bf)),fd.current===f&&(M(fd),ml?si._currentValue=Ia:si._currentValue2=Ia)}function Xe(f){var m=Error(s(418,""));throw xe(pe(m,f)),xf}function ot(f,m){if(!Ma)throw Error(s(175));a_(f.stateNode,f.type,f.memoizedProps,m,f)||Xe(f)}function tt(f){for(ua=f.return;ua;)switch(ua.tag){case 3:case 27:Mo=!0;return;case 5:case 13:Mo=!1;return;default:ua=ua.return}}function Ae(f){if(!Ma||f!==ua)return!1;if(!Di)return tt(f),Di=!0,!1;var m=!1;if(Yr?f.tag!==3&&f.tag!==27&&(f.tag!==5||Um(f.type)&&!Kl(f.type,f.memoizedProps))&&(m=!0):f.tag!==3&&(f.tag!==5||Um(f.type)&&!Kl(f.type,f.memoizedProps))&&(m=!0),m&&Qr&&Xe(f),tt(f),f.tag===13){if(!Ma)throw Error(s(316));if(f=f.memoizedState,f=f!==null?f.dehydrated:null,!f)throw Error(s(317));Qr=Nm(f)}else Qr=ua?Mp(f.stateNode):null;return!0}function ye(){Ma&&(Qr=ua=null,Di=!1)}function xe(f){Za===null?Za=[f]:Za.push(f)}function ke(){for(var f=Pu,m=hd=Pu=0;m<f;){var E=eo[m];eo[m++]=null;var L=eo[m];eo[m++]=null;var $=eo[m];eo[m++]=null;var ie=eo[m];if(eo[m++]=null,L!==null&&$!==null){var De=L.pending;De===null?$.next=$:($.next=De.next,De.next=$),L.pending=$}ie!==0&&Ye(E,$,ie)}}function ze(f,m,E,L){eo[Pu++]=f,eo[Pu++]=m,eo[Pu++]=E,eo[Pu++]=L,hd|=L,f.lanes|=L,f=f.alternate,f!==null&&(f.lanes|=L)}function je(f,m,E,L){return ze(f,m,E,L),Ve(f)}function Fe(f,m){return ze(f,null,null,m),Ve(f)}function Ye(f,m,E){f.lanes|=E;var L=f.alternate;L!==null&&(L.lanes|=E);for(var $=!1,ie=f.return;ie!==null;)ie.childLanes|=E,L=ie.alternate,L!==null&&(L.childLanes|=E),ie.tag===22&&(f=ie.stateNode,f===null||f._visibility&1||($=!0)),f=ie,ie=ie.return;$&&m!==null&&f.tag===3&&(ie=f.stateNode,$=31-xa(E),ie=ie.hiddenUpdates,f=ie[$],f===null?ie[$]=[m]:f.push(m),m.lane=E|536870912)}function Ve(f){if(50<yd)throw yd=0,Aa=null,Error(s(185));for(var m=f.return;m!==null;)f=m,m=f.return;return f.tag===3?f.stateNode:null}function Qe(f){f!==Yl&&f.next===null&&(Yl===null?pd=Yl=f:Yl=Yl.next=f),wf=!0,Mh||(Mh=!0,et(Tt))}function mt(f,m){if(!Vo&&wf){Vo=!0;do for(var E=!1,L=pd;L!==null;){if(f!==0){var $=L.pendingLanes;if($===0)var ie=0;else{var De=L.suspendedLanes,it=L.pingedLanes;ie=(1<<31-xa(42|f)+1)-1,ie&=$&~(De&~it),ie=ie&201326677?ie&201326677|1:ie?ie|2:0}ie!==0&&(E=!0,$e(L,ie))}else ie=wi,ie=R(L,L===Si?ie:0),(ie&3)===0||P(L,ie)||(E=!0,$e(L,ie));L=L.next}while(E);Vo=!1}}function Tt(){wf=Mh=!1;var f=0;Ru!==0&&(Su()&&(f=Ru),Ru=0);for(var m=Jr(),E=null,L=pd;L!==null;){var $=L.next,ie=Me(L,m);ie===0?(L.next=null,E===null?pd=$:E.next=$,$===null&&(Yl=E)):(E=L,(f!==0||(ie&3)!==0)&&(wf=!0)),L=$}mt(f)}function Me(f,m){for(var E=f.suspendedLanes,L=f.pingedLanes,$=f.expirationTimes,ie=f.pendingLanes&-62914561;0<ie;){var De=31-xa(ie),it=1<<De,pt=$[De];pt===-1?((it&E)===0||(it&L)!==0)&&($[De]=D(it,m)):pt<=m&&(f.expiredLanes|=it),ie&=~it}if(m=Si,E=wi,E=R(f,f===m?E:0),L=f.callbackNode,E===0||f===m&&xs===2||f.cancelPendingCommit!==null)return L!==null&&L!==null&&ko(L),f.callbackNode=null,f.callbackPriority=0;if((E&3)===0||P(f,E)){if(m=E&-E,m===f.callbackPriority)return m;switch(L!==null&&ko(L),ne(E)){case 2:case 8:E=$m;break;case 32:E=vh;break;case 268435456:E=yf;break;default:E=vh}return L=me.bind(null,f),E=cd(E,L),f.callbackPriority=m,f.callbackNode=E,m}return L!==null&&L!==null&&ko(L),f.callbackPriority=2,f.callbackNode=null,2}function me(f,m){var E=f.callbackNode;if(Nr()&&f.callbackNode!==E)return null;var L=wi;return L=R(f,f===Si?L:0),L===0?null:(Zc(f,L,m),Me(f,Jr()),f.callbackNode!=null&&f.callbackNode===E?me.bind(null,f):null)}function $e(f,m){if(Nr())return null;Zc(f,m,!0)}function et(f){br?oh(function(){(jn&6)!==0?cd(Lp,f):f()}):cd(Lp,f)}function ht(){return Ru===0&&(Ru=z()),Ru}function at(f,m){if(Ef===null){var E=Ef=[];Tf=0,La=ht(),Du={status:"pending",value:void 0,then:function(L){E.push(L)}}}return Tf++,m.then(Et,Et),m}function Et(){if(--Tf===0&&Ef!==null){Du!==null&&(Du.status="fulfilled");var f=Ef;Ef=null,La=0,Du=null;for(var m=0;m<f.length;m++)(0,f[m])()}}function Dt(f,m){var E=[],L={status:"pending",value:null,reason:null,then:function($){E.push($)}};return f.then(function(){L.status="fulfilled",L.value=m;for(var $=0;$<E.length;$++)(0,E[$])(m)},function($){for(L.status="rejected",L.reason=$,$=0;$<E.length;$++)(0,E[$])(void 0)}),L}function Vt(f){f.updateQueue={baseState:f.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function an(f,m){f=f.updateQueue,m.updateQueue===f&&(m.updateQueue={baseState:f.baseState,firstBaseUpdate:f.firstBaseUpdate,lastBaseUpdate:f.lastBaseUpdate,shared:f.shared,callbacks:null})}function bt(f){return{lane:f,tag:0,payload:null,callback:null,next:null}}function Jt(f,m,E){var L=f.updateQueue;if(L===null)return null;if(L=L.shared,(jn&2)!==0){var $=L.pending;return $===null?m.next=m:(m.next=$.next,$.next=m),L.pending=m,m=Ve(f),Ye(f,null,E),m}return ze(f,L,m,E),Ve(f)}function Tn(f,m,E){if(m=m.updateQueue,m!==null&&(m=m.shared,(E&4194176)!==0)){var L=m.lanes;L&=f.pendingLanes,E|=L,m.lanes=E,oe(f,E)}}function We(f,m){var E=f.updateQueue,L=f.alternate;if(L!==null&&(L=L.updateQueue,E===L)){var $=null,ie=null;if(E=E.firstBaseUpdate,E!==null){do{var De={lane:E.lane,tag:E.tag,payload:E.payload,callback:null,next:null};ie===null?$=ie=De:ie=ie.next=De,E=E.next}while(E!==null);ie===null?$=ie=m:ie=ie.next=m}else $=ie=m;E={baseState:L.baseState,firstBaseUpdate:$,lastBaseUpdate:ie,shared:L.shared,callbacks:L.callbacks},f.updateQueue=E;return}f=E.lastBaseUpdate,f===null?E.firstBaseUpdate=m:f.next=m,E.lastBaseUpdate=m}function vt(){if(md){var f=Du;if(f!==null)throw f}}function Yt(f,m,E,L){md=!1;var $=f.updateQueue;yl=!1;var ie=$.firstBaseUpdate,De=$.lastBaseUpdate,it=$.shared.pending;if(it!==null){$.shared.pending=null;var pt=it,Xt=pt.next;pt.next=null,De===null?ie=Xt:De.next=Xt,De=pt;var mn=f.alternate;mn!==null&&(mn=mn.updateQueue,it=mn.lastBaseUpdate,it!==De&&(it===null?mn.firstBaseUpdate=Xt:it.next=Xt,mn.lastBaseUpdate=pt))}if(ie!==null){var An=$.baseState;De=0,mn=Xt=pt=null,it=ie;do{var Rn=it.lane&-536870913,ci=Rn!==it.lane;if(ci?(wi&Rn)===Rn:(L&Rn)===Rn){Rn!==0&&Rn===La&&(md=!0),mn!==null&&(mn=mn.next={lane:0,tag:it.tag,payload:it.payload,callback:null,next:null});e:{var Ua=f,Bf=it;Rn=m;var Tc=E;switch(Bf.tag){case 1:if(Ua=Bf.payload,typeof Ua=="function"){An=Ua.call(Tc,An,Rn);break e}An=Ua;break e;case 3:Ua.flags=Ua.flags&-65537|128;case 0:if(Ua=Bf.payload,Rn=typeof Ua=="function"?Ua.call(Tc,An,Rn):Ua,Rn==null)break e;An=Mu({},An,Rn);break e;case 2:yl=!0}}Rn=it.callback,Rn!==null&&(f.flags|=64,ci&&(f.flags|=8192),ci=$.callbacks,ci===null?$.callbacks=[Rn]:ci.push(Rn))}else ci={lane:Rn,tag:it.tag,payload:it.payload,callback:it.callback,next:null},mn===null?(Xt=mn=ci,pt=An):mn=mn.next=ci,De|=Rn;if(it=it.next,it===null){if(it=$.shared.pending,it===null)break;ci=it,it=ci.next,ci.next=null,$.lastBaseUpdate=ci,$.shared.pending=null}}while(!0);mn===null&&(pt=An),$.baseState=pt,$.firstBaseUpdate=Xt,$.lastBaseUpdate=mn,ie===null&&($.shared.lanes=0),io|=De,f.lanes=De,f.memoizedState=An}}function qe(f,m){if(typeof f!="function")throw Error(s(191,f));f.call(m)}function Kt(f,m){var E=f.callbacks;if(E!==null)for(f.callbacks=null,f=0;f<E.length;f++)qe(E[f],m)}function rn(f,m){if(wa(f,m))return!0;if(typeof f!="object"||f===null||typeof m!="object"||m===null)return!1;var E=Object.keys(f),L=Object.keys(m);if(E.length!==L.length)return!1;for(L=0;L<E.length;L++){var $=E[L];if(!Sf.call(m,$)||!wa(f[$],m[$]))return!1}return!0}function fe(f){return f=f.status,f==="fulfilled"||f==="rejected"}function B(){}function I(f,m,E){switch(E=f[E],E===void 0?f.push(m):E!==m&&(m.then(B,B),m=E),m.status){case"fulfilled":return m.value;case"rejected":throw f=m.reason,f===is?Error(s(483)):f;default:if(typeof m.status=="string")m.then(B,B);else{if(f=Si,f!==null&&100<f.shellSuspendCounter)throw Error(s(482));f=m,f.status="pending",f.then(function(L){if(m.status==="pending"){var $=m;$.status="fulfilled",$.value=L}},function(L){if(m.status==="pending"){var $=m;$.status="rejected",$.reason=L}})}switch(m.status){case"fulfilled":return m.value;case"rejected":throw f=m.reason,f===is?Error(s(483)):f}throw Bu=m,is}}function A(){if(Bu===null)throw Error(s(459));var f=Bu;return Bu=null,f}function F(f){var m=bo;return bo+=1,Ml===null&&(Ml=[]),I(Ml,f,m)}function K(f,m){m=m.props.ref,f.ref=m!==void 0?m:null}function Ee(f,m){throw m.$$typeof===sp?Error(s(525)):(f=Object.prototype.toString.call(m),Error(s(31,f==="[object Object]"?"object with keys {"+Object.keys(m).join(", ")+"}":f)))}function k(f){var m=f._init;return m(f._payload)}function re(f){function m(Rt,_t){if(f){var Lt=Rt.deletions;Lt===null?(Rt.deletions=[_t],Rt.flags|=16):Lt.push(_t)}}function E(Rt,_t){if(!f)return null;for(;_t!==null;)m(Rt,_t),_t=_t.sibling;return null}function L(Rt){for(var _t=new Map;Rt!==null;)Rt.key!==null?_t.set(Rt.key,Rt):_t.set(Rt.index,Rt),Rt=Rt.sibling;return _t}function $(Rt,_t){return Rt=qr(Rt,_t),Rt.index=0,Rt.sibling=null,Rt}function ie(Rt,_t,Lt){return Rt.index=Lt,f?(Lt=Rt.alternate,Lt!==null?(Lt=Lt.index,Lt<_t?(Rt.flags|=33554434,_t):Lt):(Rt.flags|=33554434,_t)):(Rt.flags|=1048576,_t)}function De(Rt){return f&&Rt.alternate===null&&(Rt.flags|=33554434),Rt}function it(Rt,_t,Lt,cn){return _t===null||_t.tag!==6?(_t=yu(Lt,Rt.mode,cn),_t.return=Rt,_t):(_t=$(_t,Lt),_t.return=Rt,_t)}function pt(Rt,_t,Lt,cn){var $n=Lt.type;return $n===sd?mn(Rt,_t,Lt.props.children,cn,Lt.key):_t!==null&&(_t.elementType===$n||typeof $n=="object"&&$n!==null&&$n.$$typeof===_o&&k($n)===_t.type)?(_t=$(_t,Lt.props),K(_t,Lt),_t.return=Rt,_t):(_t=mo(Lt.type,Lt.key,Lt.props,null,Rt.mode,cn),K(_t,Lt),_t.return=Rt,_t)}function Xt(Rt,_t,Lt,cn){return _t===null||_t.tag!==4||_t.stateNode.containerInfo!==Lt.containerInfo||_t.stateNode.implementation!==Lt.implementation?(_t=id(Lt,Rt.mode,cn),_t.return=Rt,_t):(_t=$(_t,Lt.children||[]),_t.return=Rt,_t)}function mn(Rt,_t,Lt,cn,$n){return _t===null||_t.tag!==7?(_t=hl(Lt,Rt.mode,cn,$n),_t.return=Rt,_t):(_t=$(_t,Lt),_t.return=Rt,_t)}function An(Rt,_t,Lt){if(typeof _t=="string"&&_t!==""||typeof _t=="number"||typeof _t=="bigint")return _t=yu(""+_t,Rt.mode,Lt),_t.return=Rt,_t;if(typeof _t=="object"&&_t!==null){switch(_t.$$typeof){case $l:return Lt=mo(_t.type,_t.key,_t.props,null,Rt.mode,Lt),K(Lt,_t),Lt.return=Rt,Lt;case go:return _t=id(_t,Rt.mode,Lt),_t.return=Rt,_t;case _o:var cn=_t._init;return _t=cn(_t._payload),An(Rt,_t,Lt)}if(Eu(_t)||r(_t))return _t=hl(_t,Rt.mode,Lt,null),_t.return=Rt,_t;if(typeof _t.then=="function")return An(Rt,F(_t),Lt);if(_t.$$typeof===zo)return An(Rt,il(Rt,_t),Lt);Ee(Rt,_t)}return null}function Rn(Rt,_t,Lt,cn){var $n=_t!==null?_t.key:null;if(typeof Lt=="string"&&Lt!==""||typeof Lt=="number"||typeof Lt=="bigint")return $n!==null?null:it(Rt,_t,""+Lt,cn);if(typeof Lt=="object"&&Lt!==null){switch(Lt.$$typeof){case $l:return Lt.key===$n?pt(Rt,_t,Lt,cn):null;case go:return Lt.key===$n?Xt(Rt,_t,Lt,cn):null;case _o:return $n=Lt._init,Lt=$n(Lt._payload),Rn(Rt,_t,Lt,cn)}if(Eu(Lt)||r(Lt))return $n!==null?null:mn(Rt,_t,Lt,cn,null);if(typeof Lt.then=="function")return Rn(Rt,_t,F(Lt),cn);if(Lt.$$typeof===zo)return Rn(Rt,_t,il(Rt,Lt),cn);Ee(Rt,Lt)}return null}function ci(Rt,_t,Lt,cn,$n){if(typeof cn=="string"&&cn!==""||typeof cn=="number"||typeof cn=="bigint")return Rt=Rt.get(Lt)||null,it(_t,Rt,""+cn,$n);if(typeof cn=="object"&&cn!==null){switch(cn.$$typeof){case $l:return Rt=Rt.get(cn.key===null?Lt:cn.key)||null,pt(_t,Rt,cn,$n);case go:return Rt=Rt.get(cn.key===null?Lt:cn.key)||null,Xt(_t,Rt,cn,$n);case _o:var Os=cn._init;return cn=Os(cn._payload),ci(Rt,_t,Lt,cn,$n)}if(Eu(cn)||r(cn))return Rt=Rt.get(Lt)||null,mn(_t,Rt,cn,$n,null);if(typeof cn.then=="function")return ci(Rt,_t,Lt,F(cn),$n);if(cn.$$typeof===zo)return ci(Rt,_t,Lt,il(_t,cn),$n);Ee(_t,cn)}return null}function Ua(Rt,_t,Lt,cn){for(var $n=null,Os=null,ri=_t,Xi=_t=0,Ir=null;ri!==null&&Xi<Lt.length;Xi++){ri.index>Xi?(Ir=ri,ri=null):Ir=ri.sibling;var Yi=Rn(Rt,ri,Lt[Xi],cn);if(Yi===null){ri===null&&(ri=Ir);break}f&&ri&&Yi.alternate===null&&m(Rt,ri),_t=ie(Yi,_t,Xi),Os===null?$n=Yi:Os.sibling=Yi,Os=Yi,ri=Ir}if(Xi===Lt.length)return E(Rt,ri),Di&&be(Rt,Xi),$n;if(ri===null){for(;Xi<Lt.length;Xi++)ri=An(Rt,Lt[Xi],cn),ri!==null&&(_t=ie(ri,_t,Xi),Os===null?$n=ri:Os.sibling=ri,Os=ri);return Di&&be(Rt,Xi),$n}for(ri=L(ri);Xi<Lt.length;Xi++)Ir=ci(ri,Rt,Xi,Lt[Xi],cn),Ir!==null&&(f&&Ir.alternate!==null&&ri.delete(Ir.key===null?Xi:Ir.key),_t=ie(Ir,_t,Xi),Os===null?$n=Ir:Os.sibling=Ir,Os=Ir);return f&&ri.forEach(function(Nu){return m(Rt,Nu)}),Di&&be(Rt,Xi),$n}function Bf(Rt,_t,Lt,cn){if(Lt==null)throw Error(s(151));for(var $n=null,Os=null,ri=_t,Xi=_t=0,Ir=null,Yi=Lt.next();ri!==null&&!Yi.done;Xi++,Yi=Lt.next()){ri.index>Xi?(Ir=ri,ri=null):Ir=ri.sibling;var Nu=Rn(Rt,ri,Yi.value,cn);if(Nu===null){ri===null&&(ri=Ir);break}f&&ri&&Nu.alternate===null&&m(Rt,ri),_t=ie(Nu,_t,Xi),Os===null?$n=Nu:Os.sibling=Nu,Os=Nu,ri=Ir}if(Yi.done)return E(Rt,ri),Di&&be(Rt,Xi),$n;if(ri===null){for(;!Yi.done;Xi++,Yi=Lt.next())Yi=An(Rt,Yi.value,cn),Yi!==null&&(_t=ie(Yi,_t,Xi),Os===null?$n=Yi:Os.sibling=Yi,Os=Yi);return Di&&be(Rt,Xi),$n}for(ri=L(ri);!Yi.done;Xi++,Yi=Lt.next())Yi=ci(ri,Rt,Xi,Yi.value,cn),Yi!==null&&(f&&Yi.alternate!==null&&ri.delete(Yi.key===null?Xi:Yi.key),_t=ie(Yi,_t,Xi),Os===null?$n=Yi:Os.sibling=Yi,Os=Yi);return f&&ri.forEach(function(kp){return m(Rt,kp)}),Di&&be(Rt,Xi),$n}function Tc(Rt,_t,Lt,cn){if(typeof Lt=="object"&&Lt!==null&&Lt.type===sd&&Lt.key===null&&(Lt=Lt.props.children),typeof Lt=="object"&&Lt!==null){switch(Lt.$$typeof){case $l:e:{for(var $n=Lt.key;_t!==null;){if(_t.key===$n){if($n=Lt.type,$n===sd){if(_t.tag===7){E(Rt,_t.sibling),cn=$(_t,Lt.props.children),cn.return=Rt,Rt=cn;break e}}else if(_t.elementType===$n||typeof $n=="object"&&$n!==null&&$n.$$typeof===_o&&k($n)===_t.type){E(Rt,_t.sibling),cn=$(_t,Lt.props),K(cn,Lt),cn.return=Rt,Rt=cn;break e}E(Rt,_t);break}else m(Rt,_t);_t=_t.sibling}Lt.type===sd?(cn=hl(Lt.props.children,Rt.mode,cn,Lt.key),cn.return=Rt,Rt=cn):(cn=mo(Lt.type,Lt.key,Lt.props,null,Rt.mode,cn),K(cn,Lt),cn.return=Rt,Rt=cn)}return De(Rt);case go:e:{for($n=Lt.key;_t!==null;){if(_t.key===$n)if(_t.tag===4&&_t.stateNode.containerInfo===Lt.containerInfo&&_t.stateNode.implementation===Lt.implementation){E(Rt,_t.sibling),cn=$(_t,Lt.children||[]),cn.return=Rt,Rt=cn;break e}else{E(Rt,_t);break}else m(Rt,_t);_t=_t.sibling}cn=id(Lt,Rt.mode,cn),cn.return=Rt,Rt=cn}return De(Rt);case _o:return $n=Lt._init,Lt=$n(Lt._payload),Tc(Rt,_t,Lt,cn)}if(Eu(Lt))return Ua(Rt,_t,Lt,cn);if(r(Lt)){if($n=r(Lt),typeof $n!="function")throw Error(s(150));return Lt=$n.call(Lt),Bf(Rt,_t,Lt,cn)}if(typeof Lt.then=="function")return Tc(Rt,_t,F(Lt),cn);if(Lt.$$typeof===zo)return Tc(Rt,_t,il(Rt,Lt),cn);Ee(Rt,Lt)}return typeof Lt=="string"&&Lt!==""||typeof Lt=="number"||typeof Lt=="bigint"?(Lt=""+Lt,_t!==null&&_t.tag===6?(E(Rt,_t.sibling),cn=$(_t,Lt),cn.return=Rt,Rt=cn):(E(Rt,_t),cn=yu(Lt,Rt.mode,cn),cn.return=Rt,Rt=cn),De(Rt)):E(Rt,_t)}return function(Rt,_t,Lt,cn){try{bo=0;var $n=Tc(Rt,_t,Lt,cn);return Ml=null,$n}catch(ri){if(ri===is)throw ri;var Os=t(29,ri,null,Rt.mode);return Os.lanes=cn,Os.return=Rt,Os}finally{}}}function Q(f,m){f=Ho,T(Ea,f),T(bl,m),Ho=f|m.baseLanes}function ve(){T(Ea,Ho),T(bl,bl.current)}function ge(){Ho=Ea.current,M(bl),M(Ea)}function Le(f){var m=f.alternate;T(xr,xr.current&1),T(to,f),xo===null&&(m===null||bl.current!==null||m.memoizedState!==null)&&(xo=f)}function rt(f){if(f.tag===22){if(T(xr,xr.current),T(to,f),xo===null){var m=f.alternate;m!==null&&m.memoizedState!==null&&(xo=f)}}else nt()}function nt(){T(xr,xr.current),T(to,to.current)}function ft(f){M(to),xo===f&&(xo=null),M(xr)}function yt(f){for(var m=f;m!==null;){if(m.tag===13){var E=m.memoizedState;if(E!==null&&(E=E.dehydrated,E===null||hh(E)||pf(E)))return m}else if(m.tag===19&&m.memoizedProps.revealOrder!==void 0){if((m.flags&128)!==0)return m}else if(m.child!==null){m.child.return=m,m=m.child;continue}if(m===f)break;for(;m.sibling===null;){if(m.return===null||m.return===f)return null;m=m.return}m.sibling.return=m.return,m=m.sibling}return null}function Ne(){throw Error(s(321))}function Bt(f,m){if(m===null)return!1;for(var E=0;E<m.length&&E<f.length;E++)if(!wa(f[E],m[E]))return!1;return!0}function on(f,m,E,L,$,ie){return xl=ie,gi=m,m.memoizedState=null,m.updateQueue=null,m.lanes=0,Jn.H=f===null||f.memoizedState===null?Dr:Ta,wl=!1,ie=E(L,$),wl=!1,Us&&(ie=Bn(m,E,L,$)),xn(f),ie}function xn(f){Jn.H=Gi;var m=Wi!==null&&Wi.next!==null;if(xl=0,wr=Wi=gi=null,wo=!1,ir=0,bc=null,m)throw Error(s(300));f===null||hr||(f=f.dependencies,f!==null&&nl(f)&&(hr=!0))}function Bn(f,m,E,L){gi=f;var $=0;do{if(Us&&(bc=null),ir=0,Us=!1,25<=$)throw Error(s(301));if($+=1,wr=Wi=null,f.updateQueue!=null){var ie=f.updateQueue;ie.lastEffect=null,ie.events=null,ie.stores=null,ie.memoCache!=null&&(ie.memoCache.index=0)}Jn.H=Ql,ie=m(E,L)}while(Us);return ie}function bi(){var f=Jn.H,m=f.useState()[0];return m=typeof m.then=="function"?Je(m):m,f=f.useState()[0],(Wi!==null?Wi.memoizedState:null)!==f&&(gi.flags|=1024),m}function gn(){var f=Af!==0;return Af=0,f}function Mn(f,m,E){m.updateQueue=f.updateQueue,m.flags&=-2053,f.lanes&=~E}function Se(f){if(wo){for(f=f.memoizedState;f!==null;){var m=f.queue;m!==null&&(m.pending=null),f=f.next}wo=!1}xl=0,wr=Wi=gi=null,Us=!1,ir=Af=0,bc=null}function we(){var f={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return wr===null?gi.memoizedState=wr=f:wr=wr.next=f,wr}function Ge(){if(Wi===null){var f=gi.alternate;f=f!==null?f.memoizedState:null}else f=Wi.next;var m=wr===null?gi.memoizedState:wr.next;if(m!==null)wr=m,Wi=f;else{if(f===null)throw gi.alternate===null?Error(s(467)):Error(s(310));Wi=f,f={memoizedState:Wi.memoizedState,baseState:Wi.baseState,baseQueue:Wi.baseQueue,queue:Wi.queue,next:null},wr===null?gi.memoizedState=wr=f:wr=wr.next=f}return wr}function Je(f){var m=ir;return ir+=1,bc===null&&(bc=[]),f=I(bc,f,m),m=gi,(wr===null?m.memoizedState:wr.next)===null&&(m=m.alternate,Jn.H=m===null||m.memoizedState===null?Dr:Ta),f}function Ue(f){if(f!==null&&typeof f=="object"){if(typeof f.then=="function")return Je(f);if(f.$$typeof===zo)return Ar(f)}throw Error(s(438,String(f)))}function Ot(f){var m=null,E=gi.updateQueue;if(E!==null&&(m=E.memoCache),m==null){var L=gi.alternate;L!==null&&(L=L.updateQueue,L!==null&&(L=L.memoCache,L!=null&&(m={data:L.data.map(function($){return $.slice()}),index:0})))}if(m==null&&(m={data:[],index:0}),E===null&&(E=xh(),gi.updateQueue=E),E.memoCache=m,E=m.data[m.index],E===void 0)for(E=m.data[m.index]=Array(f),L=0;L<f;L++)E[L]=Em;return m.index++,E}function jt(f,m){return typeof m=="function"?m(f):m}function tn(f){var m=Ge();return en(m,Wi,f)}function en(f,m,E){var L=f.queue;if(L===null)throw Error(s(311));L.lastRenderedReducer=E;var $=f.baseQueue,ie=L.pending;if(ie!==null){if($!==null){var De=$.next;$.next=ie.next,ie.next=De}m.baseQueue=$=ie,L.pending=null}if(ie=f.baseState,$===null)f.memoizedState=ie;else{m=$.next;var it=De=null,pt=null,Xt=m,mn=!1;do{var An=Xt.lane&-536870913;if(An!==Xt.lane?(wi&An)===An:(xl&An)===An){var Rn=Xt.revertLane;if(Rn===0)pt!==null&&(pt=pt.next={lane:0,revertLane:0,action:Xt.action,hasEagerState:Xt.hasEagerState,eagerState:Xt.eagerState,next:null}),An===La&&(mn=!0);else if((xl&Rn)===Rn){Xt=Xt.next,Rn===La&&(mn=!0);continue}else An={lane:0,revertLane:Xt.revertLane,action:Xt.action,hasEagerState:Xt.hasEagerState,eagerState:Xt.eagerState,next:null},pt===null?(it=pt=An,De=ie):pt=pt.next=An,gi.lanes|=Rn,io|=Rn;An=Xt.action,wl&&E(ie,An),ie=Xt.hasEagerState?Xt.eagerState:E(ie,An)}else Rn={lane:An,revertLane:Xt.revertLane,action:Xt.action,hasEagerState:Xt.hasEagerState,eagerState:Xt.eagerState,next:null},pt===null?(it=pt=Rn,De=ie):pt=pt.next=Rn,gi.lanes|=An,io|=An;Xt=Xt.next}while(Xt!==null&&Xt!==m);if(pt===null?De=ie:pt.next=it,!wa(ie,f.memoizedState)&&(hr=!0,mn&&(E=Du,E!==null)))throw E;f.memoizedState=ie,f.baseState=De,f.baseQueue=pt,L.lastRenderedState=ie}return $===null&&(L.lanes=0),[f.memoizedState,L.dispatch]}function dn(f){var m=Ge(),E=m.queue;if(E===null)throw Error(s(311));E.lastRenderedReducer=f;var L=E.dispatch,$=E.pending,ie=m.memoizedState;if($!==null){E.pending=null;var De=$=$.next;do ie=f(ie,De.action),De=De.next;while(De!==$);wa(ie,m.memoizedState)||(hr=!0),m.memoizedState=ie,m.baseQueue===null&&(m.baseState=ie),E.lastRenderedState=ie}return[ie,L]}function wn(f,m,E){var L=gi,$=Ge(),ie=Di;if(ie){if(E===void 0)throw Error(s(407));E=E()}else E=m();var De=!wa((Wi||$).memoizedState,E);if(De&&($.memoizedState=E,hr=!0),$=$.queue,vn(ti.bind(null,L,$,f),[f]),$.getSnapshot!==m||De||wr!==null&&wr.memoizedState.tag&1){if(L.flags|=2048,Ie(9,Fn.bind(null,L,$,E,m),{destroy:void 0},null),Si===null)throw Error(s(349));ie||(xl&60)!==0||_n(L,m,E)}return E}function _n(f,m,E){f.flags|=16384,f={getSnapshot:m,value:E},m=gi.updateQueue,m===null?(m=xh(),gi.updateQueue=m,m.stores=[f]):(E=m.stores,E===null?m.stores=[f]:E.push(f))}function Fn(f,m,E,L){m.value=E,m.getSnapshot=L,Pn(m)&&Ln(f)}function ti(f,m,E){return E(function(){Pn(m)&&Ln(f)})}function Pn(f){var m=f.getSnapshot;f=f.value;try{var E=m();return!wa(f,E)}catch{return!0}}function Ln(f){var m=Fe(f,2);m!==null&&aa(m,f,2)}function Ct(f){var m=we();if(typeof f=="function"){var E=f;if(f=E(),wl){le(!0);try{E()}finally{le(!1)}}}return m.memoizedState=m.baseState=f,m.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:jt,lastRenderedState:f},m}function gt(f,m,E,L){return f.baseState=E,en(f,Wi,typeof L=="function"?L:jt)}function Qt(f,m,E,L,$){if(Ks(f))throw Error(s(485));if(f=m.action,f!==null){var ie={payload:$,action:f,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(De){ie.listeners.push(De)}};Jn.T!==null?E(!0):ie.isTransition=!1,L(ie),E=m.pending,E===null?(ie.next=m.pending=ie,Nn(m,ie)):(ie.next=E.next,m.pending=E.next=ie)}}function Nn(f,m){var E=m.action,L=m.payload,$=f.state;if(m.isTransition){var ie=Jn.T,De={};Jn.T=De;try{var it=E($,L),pt=Jn.S;pt!==null&&pt(De,it),Ss(f,m,it)}catch(Xt){$i(f,m,Xt)}finally{Jn.T=ie}}else try{ie=E($,L),Ss(f,m,ie)}catch(Xt){$i(f,m,Xt)}}function Ss(f,m,E){E!==null&&typeof E=="object"&&typeof E.then=="function"?E.then(function(L){yr(f,m,L)},function(L){return $i(f,m,L)}):yr(f,m,E)}function yr(f,m,E){m.status="fulfilled",m.value=E,ma(m),f.state=E,m=f.pending,m!==null&&(E=m.next,E===m?f.pending=null:(E=E.next,m.next=E,Nn(f,E)))}function $i(f,m,E){var L=f.pending;if(f.pending=null,L!==null){L=L.next;do m.status="rejected",m.reason=E,ma(m),m=m.next;while(m!==L)}f.action=null}function ma(f){f=f.listeners;for(var m=0;m<f.length;m++)(0,f[m])()}function fi(f,m){return m}function ks(f,m){if(Di){var E=Si.formState;if(E!==null){e:{var L=gi;if(Di){if(Qr){var $=Dm(Qr,Mo);if($){Qr=Mp($),L=Bm($);break e}}Xe(L)}L=!1}L&&(m=E[0])}}E=we(),E.memoizedState=E.baseState=m,L={pending:null,lanes:0,dispatch:null,lastRenderedReducer:fi,lastRenderedState:m},E.queue=L,E=Sr.bind(null,gi,L),L.dispatch=E,L=Ct(!1);var ie=na.bind(null,gi,!1,L.queue);return L=we(),$={state:m,dispatch:null,action:f,pending:null},L.queue=$,E=Qt.bind(null,gi,$,ie,E),$.dispatch=E,L.memoizedState=f,[m,E,!1]}function $s(f){var m=Ge();return Ds(m,Wi,f)}function Ds(f,m,E){m=en(f,m,fi)[0],f=tn(jt)[0],m=typeof m=="object"&&m!==null&&typeof m.then=="function"?Je(m):m;var L=Ge(),$=L.queue,ie=$.dispatch;return E!==L.memoizedState&&(gi.flags|=2048,Ie(9,lt.bind(null,$,E),{destroy:void 0},null)),[m,ie,f]}function lt(f,m){f.action=m}function de(f){var m=Ge(),E=Wi;if(E!==null)return Ds(m,E,f);Ge(),m=m.memoizedState,E=Ge();var L=E.queue.dispatch;return E.memoizedState=f,[m,L,!1]}function Ie(f,m,E,L){return f={tag:f,create:m,inst:E,deps:L,next:null},m=gi.updateQueue,m===null&&(m=xh(),gi.updateQueue=m),E=m.lastEffect,E===null?m.lastEffect=f.next=f:(L=E.next,E.next=f,f.next=L,m.lastEffect=f),f}function Ke(){return Ge().memoizedState}function Ze(f,m,E,L){var $=we();gi.flags|=f,$.memoizedState=Ie(1|m,E,{destroy:void 0},L===void 0?null:L)}function wt(f,m,E,L){var $=Ge();L=L===void 0?null:L;var ie=$.memoizedState.inst;Wi!==null&&L!==null&&Bt(L,Wi.memoizedState.deps)?$.memoizedState=Ie(m,E,ie,L):(gi.flags|=f,$.memoizedState=Ie(1|m,E,ie,L))}function $t(f,m){Ze(8390656,8,f,m)}function vn(f,m){wt(2048,8,f,m)}function bn(f,m){return wt(4,2,f,m)}function En(f,m){return wt(4,4,f,m)}function un(f,m){if(typeof m=="function"){f=f();var E=m(f);return function(){typeof E=="function"?E():m(null)}}if(m!=null)return f=f(),m.current=f,function(){m.current=null}}function Qn(f,m,E){E=E!=null?E.concat([f]):null,wt(4,4,un.bind(null,m,f),E)}function ni(){}function Ms(f,m){var E=Ge();m=m===void 0?null:m;var L=E.memoizedState;return m!==null&&Bt(m,L[1])?L[0]:(E.memoizedState=[f,m],f)}function bs(f,m){var E=Ge();m=m===void 0?null:m;var L=E.memoizedState;if(m!==null&&Bt(m,L[1]))return L[0];if(L=f(),wl){le(!0);try{f()}finally{le(!1)}}return E.memoizedState=[L,m],L}function Ci(f,m,E){return E===void 0||(xl&1073741824)!==0?f.memoizedState=m:(f.memoizedState=E,f=ul(),gi.lanes|=f,io|=f,E)}function ps(f,m,E,L){return wa(E,m)?E:bl.current!==null?(f=Ci(f,E,L),wa(f,m)||(hr=!0),f):(xl&42)===0?(hr=!0,f.memoizedState=E):(f=ul(),gi.lanes|=f,io|=f,m)}function Ws(f,m,E,L,$){var ie=Mr();oa(ie!==0&&8>ie?ie:8);var De=Jn.T,it={};Jn.T=it,na(f,!1,m,E);try{var pt=$(),Xt=Jn.S;if(Xt!==null&&Xt(it,pt),pt!==null&&typeof pt=="object"&&typeof pt.then=="function"){var mn=Dt(pt,L);Fr(f,m,mn,ra(f))}else Fr(f,m,L,ra(f))}catch(An){Fr(f,m,{then:function(){},status:"rejected",reason:An},ra())}finally{oa(ie),Jn.T=De}}function Wr(f){var m=f.memoizedState;if(m!==null)return m;m={memoizedState:Ia,baseState:Ia,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:jt,lastRenderedState:Ia},next:null};var E={};return m.next={memoizedState:E,baseState:E,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:jt,lastRenderedState:E},next:null},f.memoizedState=m,f=f.alternate,f!==null&&(f.memoizedState=m),m}function Kr(){return Ar(si)}function Bs(){return Ge().memoizedState}function co(){return Ge().memoizedState}function es(f){for(var m=f.return;m!==null;){switch(m.tag){case 24:case 3:var E=ra();f=bt(E);var L=Jt(m,f,E);L!==null&&(aa(L,m,E),Tn(L,m,E)),m={cache:ic()},f.payload=m;return}m=m.return}}function ms(f,m,E){var L=ra();E={lane:L,revertLane:0,action:E,hasEagerState:!1,eagerState:null,next:null},Ks(f)?ia(m,E):(E=je(f,m,E,L),E!==null&&(aa(E,f,L),Gs(E,m,L)))}function Sr(f,m,E){var L=ra();Fr(f,m,E,L)}function Fr(f,m,E,L){var $={lane:L,revertLane:0,action:E,hasEagerState:!1,eagerState:null,next:null};if(Ks(f))ia(m,$);else{var ie=f.alternate;if(f.lanes===0&&(ie===null||ie.lanes===0)&&(ie=m.lastRenderedReducer,ie!==null))try{var De=m.lastRenderedState,it=ie(De,E);if($.hasEagerState=!0,$.eagerState=it,wa(it,De))return ze(f,m,$,0),Si===null&&ke(),!1}catch{}finally{}if(E=je(f,m,$,L),E!==null)return aa(E,f,L),Gs(E,m,L),!0}return!1}function na(f,m,E,L){if(L={lane:2,revertLane:ht(),action:L,hasEagerState:!1,eagerState:null,next:null},Ks(f)){if(m)throw Error(s(479))}else m=je(f,E,L,2),m!==null&&aa(m,f,2)}function Ks(f){var m=f.alternate;return f===gi||m!==null&&m===gi}function ia(f,m){Us=wo=!0;var E=f.pending;E===null?m.next=m:(m.next=E.next,E.next=m),f.pending=m}function Gs(f,m,E){if((E&4194176)!==0){var L=m.lanes;L&=f.pendingLanes,E|=L,m.lanes=E,oe(f,E)}}function Pi(f,m,E,L){m=f.memoizedState,E=E(L,m),E=E==null?m:Mu({},m,E),f.memoizedState=E,f.lanes===0&&(f.updateQueue.baseState=E)}function ns(f,m,E,L,$,ie,De){return f=f.stateNode,typeof f.shouldComponentUpdate=="function"?f.shouldComponentUpdate(L,ie,De):m.prototype&&m.prototype.isPureReactComponent?!rn(E,L)||!rn($,ie):!0}function Ns(f,m,E,L){f=m.state,typeof m.componentWillReceiveProps=="function"&&m.componentWillReceiveProps(E,L),typeof m.UNSAFE_componentWillReceiveProps=="function"&&m.UNSAFE_componentWillReceiveProps(E,L),m.state!==f&&gd.enqueueReplaceState(m,m.state,null)}function Vs(f,m){var E=m;if("ref"in m){E={};for(var L in m)L!=="ref"&&(E[L]=m[L])}if(f=f.defaultProps){E===m&&(E=Mu({},E));for(var $ in f)E[$]===void 0&&(E[$]=f[$])}return E}function Ba(f,m){try{var E=f.onUncaughtError;E(m.value,{componentStack:m.stack})}catch(L){setTimeout(function(){throw L})}}function Dl(f,m,E){try{var L=f.onCaughtError;L(E.value,{componentStack:E.stack,errorBoundary:m.tag===1?m.stateNode:null})}catch($){setTimeout(function(){throw $})}}function ec(f,m,E){return E=bt(E),E.tag=3,E.payload={element:null},E.callback=function(){Ba(f,m)},E}function uu(f){return f=bt(f),f.tag=3,f}function tc(f,m,E,L){var $=E.type.getDerivedStateFromError;if(typeof $=="function"){var ie=L.value;f.payload=function(){return $(ie)},f.callback=function(){Dl(m,E,L)}}var De=E.stateNode;De!==null&&typeof De.componentDidCatch=="function"&&(f.callback=function(){Dl(m,E,L),typeof $!="function"&&(ro===null?ro=new Set([this]):ro.add(this));var it=L.stack;this.componentDidCatch(L.value,{componentStack:it!==null?it:""})})}function Vf(f,m,E,L,$){if(E.flags|=32768,L!==null&&typeof L=="object"&&typeof L.then=="function"){if(m=E.alternate,m!==null&&Bl(m,E,$,!0),E=to.current,E!==null){switch(E.tag){case 13:return xo===null?ya():E.alternate===null&&Hi===0&&(Hi=3),E.flags&=-257,E.flags|=65536,E.lanes=$,L===bh?E.flags|=16384:(m=E.updateQueue,m===null?E.updateQueue=new Set([L]):m.add(L),Qf(f,L,$)),!1;case 22:return E.flags|=65536,L===bh?E.flags|=16384:(m=E.updateQueue,m===null?(m={transitions:null,markerInstances:null,retryQueue:new Set([L])},E.updateQueue=m):(E=m.retryQueue,E===null?m.retryQueue=new Set([L]):E.add(L)),Qf(f,L,$)),!1}throw Error(s(435,E.tag))}return Qf(f,L,$),ya(),!1}if(Di)return m=to.current,m!==null?((m.flags&65536)===0&&(m.flags|=256),m.flags|=65536,m.lanes=$,L!==xf&&(f=Error(s(422),{cause:L}),xe(pe(f,E)))):(L!==xf&&(m=Error(s(423),{cause:L}),xe(pe(m,E))),f=f.current.alternate,f.flags|=65536,$&=-$,f.lanes|=$,L=pe(L,E),$=ec(f.stateNode,L,$),We(f,$),Hi!==4&&(Hi=2)),!1;var ie=Error(s(520),{cause:L});if(ie=pe(ie,E),Li===null?Li=[ie]:Li.push(ie),Hi!==4&&(Hi=2),m===null)return!0;L=pe(L,E),E=m;do{switch(E.tag){case 3:return E.flags|=65536,f=$&-$,E.lanes|=f,f=ec(E.stateNode,L,f),We(E,f),!1;case 1:if(m=E.type,ie=E.stateNode,(E.flags&128)===0&&(typeof m.getDerivedStateFromError=="function"||ie!==null&&typeof ie.componentDidCatch=="function"&&(ro===null||!ro.has(ie))))return E.flags|=65536,$&=-$,E.lanes|=$,$=uu($),tc($,f,E,L),We(E,$),!1}E=E.return}while(E!==null);return!1}function qs(f,m,E,L){m.child=f===null?zp(m,null,E,L):Jl(m,f.child,E,L)}function Hf(f,m,E,L,$){E=E.render;var ie=m.ref;if("ref"in L){var De={};for(var it in L)it!=="ref"&&(De[it]=L[it])}else De=L;return Il(m),L=on(f,m,E,De,ie,$),it=gn(),f!==null&&!hr?(Mn(f,m,$),tl(f,m,$)):(Di&&it&&te(m),m.flags|=1,qs(f,m,L,$),m.child)}function jf(f,m,E,L,$){if(f===null){var ie=E.type;return typeof ie=="function"&&!Hl(ie)&&ie.defaultProps===void 0&&E.compare===null?(m.tag=15,m.type=ie,Uc(f,m,ie,L,$)):(f=mo(E.type,null,L,m,m.mode,$),f.ref=m.ref,f.return=m,m.child=f)}if(ie=f.child,!nc(f,$)){var De=ie.memoizedProps;if(E=E.compare,E=E!==null?E:rn,E(De,L)&&f.ref===m.ref)return tl(f,m,$)}return m.flags|=1,f=qr(ie,L),f.ref=m.ref,f.return=m,m.child=f}function Uc(f,m,E,L,$){if(f!==null){var ie=f.memoizedProps;if(rn(ie,L)&&f.ref===m.ref)if(hr=!1,m.pendingProps=L=ie,nc(f,$))(f.flags&131072)!==0&&(hr=!0);else return m.lanes=f.lanes,tl(f,m,$)}return Vd(f,m,E,L,$)}function $f(f,m,E){var L=m.pendingProps,$=L.children,ie=(m.stateNode._pendingVisibility&2)!==0,De=f!==null?f.memoizedState:null;if(Do(f,m),L.mode==="hidden"||ie){if((m.flags&128)!==0){if(L=De!==null?De.baseLanes|E:E,f!==null){for($=m.child=f.child,ie=0;$!==null;)ie=ie|$.lanes|$.childLanes,$=$.sibling;m.childLanes=ie&~L}else m.childLanes=0,m.child=null;return Wf(f,m,L,E)}if((E&536870912)!==0)m.memoizedState={baseLanes:0,cachePool:null},f!==null&&du(m,De!==null?De.cachePool:null),De!==null?Q(m,De):ve(),rt(m);else return m.lanes=m.childLanes=536870912,Wf(f,m,De!==null?De.baseLanes|E:E,E)}else De!==null?(du(m,De.cachePool),Q(m,De),nt(),m.memoizedState=null):(f!==null&&du(m,null),ve(),nt());return qs(f,m,$,E),m.child}function Wf(f,m,E,L){var $=Io();return $=$===null?null:{parent:ml?ss._currentValue:ss._currentValue2,pool:$},m.memoizedState={baseLanes:E,cachePool:$},f!==null&&du(m,null),ve(),rt(m),f!==null&&Bl(f,m,L,!0),null}function Do(f,m){var E=m.ref;if(E===null)f!==null&&f.ref!==null&&(m.flags|=2097664);else{if(typeof E!="function"&&typeof E!="object")throw Error(s(284));(f===null||f.ref!==E)&&(m.flags|=2097664)}}function Vd(f,m,E,L,$){return Il(m),E=on(f,m,E,L,void 0,$),L=gn(),f!==null&&!hr?(Mn(f,m,$),tl(f,m,$)):(Di&&L&&te(m),m.flags|=1,qs(f,m,E,$),m.child)}function Hd(f,m,E,L,$,ie){return Il(m),m.updateQueue=null,E=Bn(m,L,E,$),xn(f),L=gn(),f!==null&&!hr?(Mn(f,m,ie),tl(f,m,ie)):(Di&&L&&te(m),m.flags|=1,qs(f,m,E,ie),m.child)}function kc(f,m,E,L,$){if(Il(m),m.stateNode===null){var ie=yc,De=E.contextType;typeof De=="object"&&De!==null&&(ie=Ar(De)),ie=new E(L,ie),m.memoizedState=ie.state!==null&&ie.state!==void 0?ie.state:null,ie.updater=gd,m.stateNode=ie,ie._reactInternals=m,ie=m.stateNode,ie.props=L,ie.state=m.memoizedState,ie.refs={},Vt(m),De=E.contextType,ie.context=typeof De=="object"&&De!==null?Ar(De):yc,ie.state=m.memoizedState,De=E.getDerivedStateFromProps,typeof De=="function"&&(Pi(m,E,De,L),ie.state=m.memoizedState),typeof E.getDerivedStateFromProps=="function"||typeof ie.getSnapshotBeforeUpdate=="function"||typeof ie.UNSAFE_componentWillMount!="function"&&typeof ie.componentWillMount!="function"||(De=ie.state,typeof ie.componentWillMount=="function"&&ie.componentWillMount(),typeof ie.UNSAFE_componentWillMount=="function"&&ie.UNSAFE_componentWillMount(),De!==ie.state&&gd.enqueueReplaceState(ie,ie.state,null),Yt(m,L,ie,$),vt(),ie.state=m.memoizedState),typeof ie.componentDidMount=="function"&&(m.flags|=4194308),L=!0}else if(f===null){ie=m.stateNode;var it=m.memoizedProps,pt=Vs(E,it);ie.props=pt;var Xt=ie.context,mn=E.contextType;De=yc,typeof mn=="object"&&mn!==null&&(De=Ar(mn));var An=E.getDerivedStateFromProps;mn=typeof An=="function"||typeof ie.getSnapshotBeforeUpdate=="function",it=m.pendingProps!==it,mn||typeof ie.UNSAFE_componentWillReceiveProps!="function"&&typeof ie.componentWillReceiveProps!="function"||(it||Xt!==De)&&Ns(m,ie,L,De),yl=!1;var Rn=m.memoizedState;ie.state=Rn,Yt(m,L,ie,$),vt(),Xt=m.memoizedState,it||Rn!==Xt||yl?(typeof An=="function"&&(Pi(m,E,An,L),Xt=m.memoizedState),(pt=yl||ns(m,E,pt,L,Rn,Xt,De))?(mn||typeof ie.UNSAFE_componentWillMount!="function"&&typeof ie.componentWillMount!="function"||(typeof ie.componentWillMount=="function"&&ie.componentWillMount(),typeof ie.UNSAFE_componentWillMount=="function"&&ie.UNSAFE_componentWillMount()),typeof ie.componentDidMount=="function"&&(m.flags|=4194308)):(typeof ie.componentDidMount=="function"&&(m.flags|=4194308),m.memoizedProps=L,m.memoizedState=Xt),ie.props=L,ie.state=Xt,ie.context=De,L=pt):(typeof ie.componentDidMount=="function"&&(m.flags|=4194308),L=!1)}else{ie=m.stateNode,an(f,m),De=m.memoizedProps,mn=Vs(E,De),ie.props=mn,An=m.pendingProps,Rn=ie.context,Xt=E.contextType,pt=yc,typeof Xt=="object"&&Xt!==null&&(pt=Ar(Xt)),it=E.getDerivedStateFromProps,(Xt=typeof it=="function"||typeof ie.getSnapshotBeforeUpdate=="function")||typeof ie.UNSAFE_componentWillReceiveProps!="function"&&typeof ie.componentWillReceiveProps!="function"||(De!==An||Rn!==pt)&&Ns(m,ie,L,pt),yl=!1,Rn=m.memoizedState,ie.state=Rn,Yt(m,L,ie,$),vt();var ci=m.memoizedState;De!==An||Rn!==ci||yl||f!==null&&f.dependencies!==null&&nl(f.dependencies)?(typeof it=="function"&&(Pi(m,E,it,L),ci=m.memoizedState),(mn=yl||ns(m,E,mn,L,Rn,ci,pt)||f!==null&&f.dependencies!==null&&nl(f.dependencies))?(Xt||typeof ie.UNSAFE_componentWillUpdate!="function"&&typeof ie.componentWillUpdate!="function"||(typeof ie.componentWillUpdate=="function"&&ie.componentWillUpdate(L,ci,pt),typeof ie.UNSAFE_componentWillUpdate=="function"&&ie.UNSAFE_componentWillUpdate(L,ci,pt)),typeof ie.componentDidUpdate=="function"&&(m.flags|=4),typeof ie.getSnapshotBeforeUpdate=="function"&&(m.flags|=1024)):(typeof ie.componentDidUpdate!="function"||De===f.memoizedProps&&Rn===f.memoizedState||(m.flags|=4),typeof ie.getSnapshotBeforeUpdate!="function"||De===f.memoizedProps&&Rn===f.memoizedState||(m.flags|=1024),m.memoizedProps=L,m.memoizedState=ci),ie.props=L,ie.state=ci,ie.context=pt,L=mn):(typeof ie.componentDidUpdate!="function"||De===f.memoizedProps&&Rn===f.memoizedState||(m.flags|=4),typeof ie.getSnapshotBeforeUpdate!="function"||De===f.memoizedProps&&Rn===f.memoizedState||(m.flags|=1024),L=!1)}return ie=L,Do(f,m),L=(m.flags&128)!==0,ie||L?(ie=m.stateNode,E=L&&typeof E.getDerivedStateFromError!="function"?null:ie.render(),m.flags|=1,f!==null&&L?(m.child=Jl(m,f.child,null,$),m.child=Jl(m,null,E,$)):qs(f,m,E,$),m.memoizedState=ie.state,f=m.child):f=tl(f,m,$),f}function jd(f,m,E,L){return ye(),m.flags|=256,qs(f,m,E,L),m.child}function $d(f){return{baseLanes:f,cachePool:sc()}}function Gc(f,m,E){return f=f!==null?f.childLanes&~E:0,m&&(f|=za),f}function Wd(f,m,E){var L=m.pendingProps,$=!1,ie=(m.flags&128)!==0,De;if((De=ie)||(De=f!==null&&f.memoizedState===null?!1:(xr.current&2)!==0),De&&($=!0,m.flags&=-129),De=(m.flags&32)!==0,m.flags&=-33,f===null){if(Di){if($?Le(m):nt(),Di){var it=Qr,pt;(pt=it)&&(it=xp(it,Mo),it!==null?(m.memoizedState={dehydrated:it,treeContext:Go!==null?{id:vo,overflow:yo}:null,retryLane:536870912},pt=t(18,null,null,0),pt.stateNode=it,pt.return=m,m.child=pt,ua=m,Qr=null,pt=!0):pt=!1),pt||Xe(m)}if(it=m.memoizedState,it!==null&&(it=it.dehydrated,it!==null))return pf(it)?m.lanes=16:m.lanes=536870912,null;ft(m)}return it=L.children,L=L.fallback,$?(nt(),$=m.mode,it=el({mode:"hidden",children:it},$),L=hl(L,$,E,null),it.return=m,L.return=m,it.sibling=L,m.child=it,$=m.child,$.memoizedState=$d(E),$.childLanes=Gc(f,De,E),m.memoizedState=kr,L):(Le(m),cu(m,it))}if(pt=f.memoizedState,pt!==null&&(it=pt.dehydrated,it!==null)){if(ie)m.flags&256?(Le(m),m.flags&=-257,m=Kd(f,m,E)):m.memoizedState!==null?(nt(),m.child=f.child,m.flags|=128,m=null):(nt(),$=L.fallback,it=m.mode,L=el({mode:"visible",children:L.children},it),$=hl($,it,E,null),$.flags|=2,L.return=m,$.return=m,L.sibling=$,m.child=L,Jl(m,f.child,null,E),L=m.child,L.memoizedState=$d(E),L.childLanes=Gc(f,De,E),m.memoizedState=kr,m=$);else if(Le(m),pf(it))De=Rm(it).digest,L=Error(s(419)),L.stack="",L.digest=De,xe({value:L,source:null,stack:null}),m=Kd(f,m,E);else if(hr||Bl(f,m,E,!1),De=(E&f.childLanes)!==0,hr||De){if(De=Si,De!==null){if(L=E&-E,(L&42)!==0)L=1;else switch(L){case 2:L=1;break;case 8:L=4;break;case 32:L=16;break;case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:L=64;break;case 268435456:L=134217728;break;default:L=0}if(L=(L&(De.suspendedLanes|E))!==0?0:L,L!==0&&L!==pt.retryLane)throw pt.retryLane=L,Fe(f,L),aa(De,f,L),qm}hh(it)||ya(),m=Kd(f,m,E)}else hh(it)?(m.flags|=128,m.child=f.child,m=fc.bind(null,f),r_(it,m),m=null):(f=pt.treeContext,Ma&&(Qr=bp(it),ua=m,Di=!0,Za=null,Mo=!1,f!==null&&(Ja[Qa++]=vo,Ja[Qa++]=yo,Ja[Qa++]=Go,vo=f.id,yo=f.overflow,Go=m)),m=cu(m,L.children),m.flags|=4096);return m}return $?(nt(),$=L.fallback,it=m.mode,pt=f.child,ie=pt.sibling,L=qr(pt,{mode:"hidden",children:L.children}),L.subtreeFlags=pt.subtreeFlags&31457280,ie!==null?$=qr(ie,$):($=hl($,it,E,null),$.flags|=2),$.return=m,L.return=m,L.sibling=$,m.child=L,L=$,$=m.child,it=f.child.memoizedState,it===null?it=$d(E):(pt=it.cachePool,pt!==null?(ie=ml?ss._currentValue:ss._currentValue2,pt=pt.parent!==ie?{parent:ie,pool:ie}:pt):pt=sc(),it={baseLanes:it.baseLanes|E,cachePool:pt}),$.memoizedState=it,$.childLanes=Gc(f,De,E),m.memoizedState=kr,L):(Le(m),E=f.child,f=E.sibling,E=qr(E,{mode:"visible",children:L.children}),E.return=m,E.sibling=null,f!==null&&(De=m.deletions,De===null?(m.deletions=[f],m.flags|=16):De.push(f)),m.child=E,m.memoizedState=null,E)}function cu(f,m){return m=el({mode:"visible",children:m},f.mode),m.return=f,f.child=m}function el(f,m){return Zf(f,m,0,null)}function Kd(f,m,E){return Jl(m,f.child,null,E),f=cu(m,m.pendingProps.children),f.flags|=2,m.memoizedState=null,f}function Vc(f,m,E){f.lanes|=m;var L=f.alternate;L!==null&&(L.lanes|=m),Jd(f.return,m,E)}function Hc(f,m,E,L,$){var ie=f.memoizedState;ie===null?f.memoizedState={isBackwards:m,rendering:null,renderingStartTime:0,last:L,tail:E,tailMode:$}:(ie.isBackwards=m,ie.rendering=null,ie.renderingStartTime=0,ie.last=L,ie.tail=E,ie.tailMode=$)}function qd(f,m,E){var L=m.pendingProps,$=L.revealOrder,ie=L.tail;if(qs(f,m,L.children,E),L=xr.current,(L&2)!==0)L=L&1|2,m.flags|=128;else{if(f!==null&&(f.flags&128)!==0)e:for(f=m.child;f!==null;){if(f.tag===13)f.memoizedState!==null&&Vc(f,E,m);else if(f.tag===19)Vc(f,E,m);else if(f.child!==null){f.child.return=f,f=f.child;continue}if(f===m)break e;for(;f.sibling===null;){if(f.return===null||f.return===m)break e;f=f.return}f.sibling.return=f.return,f=f.sibling}L&=1}switch(T(xr,L),$){case"forwards":for(E=m.child,$=null;E!==null;)f=E.alternate,f!==null&&yt(f)===null&&($=E),E=E.sibling;E=$,E===null?($=m.child,m.child=null):($=E.sibling,E.sibling=null),Hc(m,!1,$,E,ie);break;case"backwards":for(E=null,$=m.child,m.child=null;$!==null;){if(f=$.alternate,f!==null&&yt(f)===null){m.child=$;break}f=$.sibling,$.sibling=E,E=$,$=f}Hc(m,!0,E,null,ie);break;case"together":Hc(m,!1,null,null,void 0);break;default:m.memoizedState=null}return m.child}function tl(f,m,E){if(f!==null&&(m.dependencies=f.dependencies),io|=m.lanes,(E&m.childLanes)===0)if(f!==null){if(Bl(f,m,E,!1),(E&m.childLanes)===0)return null}else return null;if(f!==null&&m.child!==f.child)throw Error(s(153));if(m.child!==null){for(f=m.child,E=qr(f,f.pendingProps),m.child=E,E.return=m;f.sibling!==null;)f=f.sibling,E=E.sibling=qr(f,f.pendingProps),E.return=m;E.sibling=null}return m.child}function nc(f,m){return(f.lanes&m)!==0?!0:(f=f.dependencies,!!(f!==null&&nl(f)))}function Xd(f,m,E){switch(m.tag){case 3:ae(m,m.stateNode.containerInfo),fo(m,ss,f.memoizedState.cache),ye();break;case 27:case 5:Be(m);break;case 4:ae(m,m.stateNode.containerInfo);break;case 10:fo(m,m.type,m.memoizedProps.value);break;case 13:var L=m.memoizedState;if(L!==null)return L.dehydrated!==null?(Le(m),m.flags|=128,null):(E&m.child.childLanes)!==0?Wd(f,m,E):(Le(m),f=tl(f,m,E),f!==null?f.sibling:null);Le(m);break;case 19:var $=(f.flags&128)!==0;if(L=(E&m.childLanes)!==0,L||(Bl(f,m,E,!1),L=(E&m.childLanes)!==0),$){if(L)return qd(f,m,E);m.flags|=128}if($=m.memoizedState,$!==null&&($.rendering=null,$.tail=null,$.lastEffect=null),T(xr,xr.current),L)break;return null;case 22:case 23:return m.lanes=0,$f(f,m,E);case 24:fo(m,ss,f.memoizedState.cache)}return tl(f,m,E)}function Yd(f,m,E){if(f!==null)if(f.memoizedProps!==m.pendingProps)hr=!0;else{if(!nc(f,E)&&(m.flags&128)===0)return hr=!1,Xd(f,m,E);hr=(f.flags&131072)!==0}else hr=!1,Di&&(m.flags&1048576)!==0&&ee(m,Mf,m.index);switch(m.lanes=0,m.tag){case 16:e:{f=m.pendingProps;var L=m.elementType,$=L._init;if(L=$(L._payload),m.type=L,typeof L=="function")Hl(L)?(f=Vs(L,f),m.tag=1,m=kc(null,m,L,f,E)):(m.tag=0,m=Vd(null,m,L,f,E));else{if(L!=null){if($=L.$$typeof,$===rd){m.tag=11,m=Hf(null,m,L,f,E);break e}else if($===sf){m.tag=14,m=jf(null,m,L,f,E);break e}}throw m=o(L)||L,Error(s(306,m,""))}}return m;case 0:return Vd(f,m,m.type,m.pendingProps,E);case 1:return L=m.type,$=Vs(L,m.pendingProps),kc(f,m,L,$,E);case 3:e:{if(ae(m,m.stateNode.containerInfo),f===null)throw Error(s(387));var ie=m.pendingProps;$=m.memoizedState,L=$.element,an(f,m),Yt(m,ie,null,E);var De=m.memoizedState;if(ie=De.cache,fo(m,ss,ie),ie!==$.cache&&Qd(m,[ss],E,!0),vt(),ie=De.element,Ma&&$.isDehydrated)if($={element:ie,isDehydrated:!1,cache:De.cache},m.updateQueue.baseState=$,m.memoizedState=$,m.flags&256){m=jd(f,m,ie,E);break e}else if(ie!==L){L=pe(Error(s(424)),m),xe(L),m=jd(f,m,ie,E);break e}else for(Ma&&(Qr=Im(m.stateNode.containerInfo),ua=m,Di=!0,Za=null,Mo=!0),E=zp(m,null,ie,E),m.child=E;E;)E.flags=E.flags&-3|4096,E=E.sibling;else{if(ye(),ie===L){m=tl(f,m,E);break e}qs(f,m,ie,E)}m=m.child}return m;case 26:if(Ya)return Do(f,m),f===null?(E=_h(m.type,null,m.pendingProps,null))?m.memoizedState=E:Di||(m.stateNode=o_(m.type,m.pendingProps,vl.current,m)):m.memoizedState=_h(m.type,f.memoizedProps,m.pendingProps,f.memoizedState),null;case 27:if(Yr)return Be(m),f===null&&Yr&&Di&&(L=m.stateNode=Op(m.type,m.pendingProps,vl.current,Ur.current,!1),ua=m,Mo=!0,Qr=ph(L)),L=m.pendingProps.children,f!==null||Di?qs(f,m,L,E):m.child=Jl(m,null,L,E),Do(f,m),m.child;case 5:return f===null&&Di&&(km(m.type,m.pendingProps,Ur.current),($=L=Qr)&&(L=Om(L,m.type,m.pendingProps,Mo),L!==null?(m.stateNode=L,ua=m,Qr=ph(L),Mo=!1,$=!0):$=!1),$||Xe(m)),Be(m),$=m.type,ie=m.pendingProps,De=f!==null?f.memoizedProps:null,L=ie.children,Kl($,ie)?L=null:De!==null&&Kl($,De)&&(m.flags|=32),m.memoizedState!==null&&($=on(f,m,bi,null,null,E),ml?si._currentValue=$:si._currentValue2=$),Do(f,m),qs(f,m,L,E),m.child;case 6:return f===null&&Di&&(wp(m.pendingProps,Ur.current),(f=E=Qr)&&(E=Lm(E,m.pendingProps,Mo),E!==null?(m.stateNode=E,ua=m,Qr=null,f=!0):f=!1),f||Xe(m)),null;case 13:return Wd(f,m,E);case 4:return ae(m,m.stateNode.containerInfo),L=m.pendingProps,f===null?m.child=Jl(m,null,L,E):qs(f,m,L,E),m.child;case 11:return Hf(f,m,m.type,m.pendingProps,E);case 7:return qs(f,m,m.pendingProps,E),m.child;case 8:return qs(f,m,m.pendingProps.children,E),m.child;case 12:return qs(f,m,m.pendingProps.children,E),m.child;case 10:return L=m.pendingProps,fo(m,m.type,L.value),qs(f,m,L.children,E),m.child;case 9:return $=m.type._context,L=m.pendingProps.children,Il(m),$=Ar($),L=L($),m.flags|=1,qs(f,m,L,E),m.child;case 14:return jf(f,m,m.type,m.pendingProps,E);case 15:return Uc(f,m,m.type,m.pendingProps,E);case 19:return qd(f,m,E);case 22:return $f(f,m,E);case 24:return Il(m),L=Ar(ss),f===null?($=Io(),$===null&&($=Si,ie=ic(),$.pooledCache=ie,ie.refCount++,ie!==null&&($.pooledCacheLanes|=E),$=ie),m.memoizedState={parent:L,cache:$},Vt(m),fo(m,ss,$)):((f.lanes&E)!==0&&(an(f,m),Yt(m,null,null,E),vt()),$=f.memoizedState,ie=m.memoizedState,$.parent!==L?($={parent:L,cache:L},m.memoizedState=$,m.lanes===0&&(m.memoizedState=m.updateQueue.baseState=$),fo(m,ss,L)):(L=ie.cache,fo(m,ss,L),L!==$.cache&&Qd(m,[ss],E,!0))),qs(f,m,m.pendingProps.children,E),m.child;case 29:throw m.pendingProps}throw Error(s(156,m.tag))}function fo(f,m,E){ml?(T(Fa,m._currentValue),m._currentValue=E):(T(Fa,m._currentValue2),m._currentValue2=E)}function Bo(f){var m=Fa.current;ml?f._currentValue=m:f._currentValue2=m,M(Fa)}function Jd(f,m,E){for(;f!==null;){var L=f.alternate;if((f.childLanes&m)!==m?(f.childLanes|=m,L!==null&&(L.childLanes|=m)):L!==null&&(L.childLanes&m)!==m&&(L.childLanes|=m),f===E)break;f=f.return}}function Qd(f,m,E,L){var $=f.child;for($!==null&&($.return=f);$!==null;){var ie=$.dependencies;if(ie!==null){var De=$.child;ie=ie.firstContext;e:for(;ie!==null;){var it=ie;ie=$;for(var pt=0;pt<m.length;pt++)if(it.context===m[pt]){ie.lanes|=E,it=ie.alternate,it!==null&&(it.lanes|=E),Jd(ie.return,E,f),L||(De=null);break e}ie=it.next}}else if($.tag===18){if(De=$.return,De===null)throw Error(s(341));De.lanes|=E,ie=De.alternate,ie!==null&&(ie.lanes|=E),Jd(De,E,f),De=null}else De=$.child;if(De!==null)De.return=$;else for(De=$;De!==null;){if(De===f){De=null;break}if($=De.sibling,$!==null){$.return=De.return,De=$;break}De=De.return}$=De}}function Bl(f,m,E,L){f=null;for(var $=m,ie=!1;$!==null;){if(!ie){if(($.flags&524288)!==0)ie=!0;else if(($.flags&262144)!==0)break}if($.tag===10){var De=$.alternate;if(De===null)throw Error(s(387));if(De=De.memoizedProps,De!==null){var it=$.type;wa($.pendingProps.value,De.value)||(f!==null?f.push(it):f=[it])}}else if($===fd.current){if(De=$.alternate,De===null)throw Error(s(387));De.memoizedState.memoizedState!==$.memoizedState.memoizedState&&(f!==null?f.push(si):f=[si])}$=$.return}f!==null&&Qd(m,f,E,L),m.flags|=262144}function nl(f){for(f=f.firstContext;f!==null;){var m=f.context;if(!wa(ml?m._currentValue:m._currentValue2,f.memoizedValue))return!0;f=f.next}return!1}function Il(f){Iu=f,sr=null,f=f.dependencies,f!==null&&(f.firstContext=null)}function Ar(f){return sl(Iu,f)}function il(f,m){return Iu===null&&Il(f),sl(f,m)}function sl(f,m){var E=ml?m._currentValue:m._currentValue2;if(m={context:m,memoizedValue:E,next:null},sr===null){if(f===null)throw Error(s(308));sr=m,f.dependencies={lanes:0,firstContext:m},f.flags|=524288}else sr=sr.next=m;return E}function ic(){return{controller:new wh,data:new Map,refCount:0}}function rl(f){f.refCount--,f.refCount===0&&Zl(xc,function(){f.controller.abort()})}function Io(){var f=eu.current;return f!==null?f:Si.pooledCache}function du(f,m){m===null?T(eu,eu.current):T(eu,m.pool)}function sc(){var f=Io();return f===null?null:{parent:ml?ss._currentValue:ss._currentValue2,pool:f}}function cr(f){f.flags|=4}function jc(f,m){if(f!==null&&f.child===m.child)return!1;if((m.flags&16)!==0)return!0;for(f=m.child;f!==null;){if((f.flags&13878)!==0||(f.subtreeFlags&13878)!==0)return!0;f=f.sibling}return!1}function $c(f,m,E,L){if(zr)for(E=m.child;E!==null;){if(E.tag===5||E.tag===6)pl(f,E.stateNode);else if(!(E.tag===4||Yr&&E.tag===27)&&E.child!==null){E.child.return=E,E=E.child;continue}if(E===m)break;for(;E.sibling===null;){if(E.return===null||E.return===m)return;E=E.return}E.sibling.return=E.return,E=E.sibling}else if(qa)for(var $=m.child;$!==null;){if($.tag===5){var ie=$.stateNode;E&&L&&(ie=yp(ie,$.type,$.memoizedProps)),pl(f,ie)}else if($.tag===6)ie=$.stateNode,E&&L&&(ie=hf(ie,$.memoizedProps)),pl(f,ie);else if($.tag!==4){if($.tag===22&&$.memoizedState!==null)ie=$.child,ie!==null&&(ie.return=$),$c(f,$,!0,!0);else if($.child!==null){$.child.return=$,$=$.child;continue}}if($===m)break;for(;$.sibling===null;){if($.return===null||$.return===m)return;$=$.return}$.sibling.return=$.return,$=$.sibling}}function Ol(f,m,E,L){if(qa)for(var $=m.child;$!==null;){if($.tag===5){var ie=$.stateNode;E&&L&&(ie=yp(ie,$.type,$.memoizedProps)),_p(f,ie)}else if($.tag===6)ie=$.stateNode,E&&L&&(ie=hf(ie,$.memoizedProps)),_p(f,ie);else if($.tag!==4){if($.tag===22&&$.memoizedState!==null)ie=$.child,ie!==null&&(ie.return=$),Ol(f,$,!($.memoizedProps!==null&&$.memoizedProps.mode==="manual"),!0);else if($.child!==null){$.child.return=$,$=$.child;continue}}if($===m)break;for(;$.sibling===null;){if($.return===null||$.return===m)return;$=$.return}$.sibling.return=$.return,$=$.sibling}}function fu(f,m){if(qa&&jc(f,m)){f=m.stateNode;var E=f.containerInfo,L=ff();Ol(L,m,!1,!1),f.pendingChildren=L,cr(m),Pm(E,L)}}function Wc(f,m,E,L){if(zr)f.memoizedProps!==L&&cr(m);else if(qa){var $=f.stateNode,ie=f.memoizedProps;if((f=jc(f,m))||ie!==L){var De=Ur.current;ie=gp($,E,ie,L,!f,null),ie===$?m.stateNode=$:(Wl(ie,E,L,De)&&cr(m),m.stateNode=ie,f?$c(ie,m,!1,!1):cr(m))}else m.stateNode=$}}function Ll(f,m,E){if(Tm(m,E)){if(f.flags|=16777216,!ql(m,E))if(ed())f.flags|=8192;else throw Bu=bh,Np}else f.flags&=-16777217}function Kc(f,m){if(Dp(m)){if(f.flags|=16777216,!Bp(m))if(ed())f.flags|=8192;else throw Bu=bh,Np}else f.flags&=-16777217}function hu(f,m){m!==null&&(f.flags|=4),f.flags&16384&&(m=f.tag!==22?U():536870912,f.lanes|=m,nu|=m)}function ho(f,m){if(!Di)switch(f.tailMode){case"hidden":m=f.tail;for(var E=null;m!==null;)m.alternate!==null&&(E=m),m=m.sibling;E===null?f.tail=null:E.sibling=null;break;case"collapsed":E=f.tail;for(var L=null;E!==null;)E.alternate!==null&&(L=E),E=E.sibling;L===null?m||f.tail===null?f.tail=null:f.tail.sibling=null:L.sibling=null}}function yn(f){var m=f.alternate!==null&&f.alternate.child===f.child,E=0,L=0;if(m)for(var $=f.child;$!==null;)E|=$.lanes|$.childLanes,L|=$.subtreeFlags&31457280,L|=$.flags&31457280,$.return=f,$=$.sibling;else for($=f.child;$!==null;)E|=$.lanes|$.childLanes,L|=$.subtreeFlags,L|=$.flags,$.return=f,$=$.sibling;return f.subtreeFlags|=L,f.childLanes=E,m}function Kf(f,m,E){var L=m.pendingProps;switch(ue(m),m.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return yn(m),null;case 1:return yn(m),null;case 3:return E=m.stateNode,L=null,f!==null&&(L=f.memoizedState.cache),m.memoizedState.cache!==L&&(m.flags|=2048),Bo(ss),ce(),E.pendingContext&&(E.context=E.pendingContext,E.pendingContext=null),(f===null||f.child===null)&&(Ae(m)?cr(m):f===null||f.memoizedState.isDehydrated&&(m.flags&256)===0||(m.flags|=1024,Za!==null&&(Gl(Za),Za=null))),fu(f,m),yn(m),null;case 26:if(Ya){E=m.type;var $=m.memoizedState;return f===null?(cr(m),$!==null?(yn(m),Kc(m,$)):(yn(m),Ll(m,E,L))):$?$!==f.memoizedState?(cr(m),yn(m),Kc(m,$)):(yn(m),m.flags&=-16777217):(zr?f.memoizedProps!==L&&cr(m):Wc(f,m,E,L),yn(m),Ll(m,E,L)),null}case 27:if(Yr){if(He(m),E=vl.current,$=m.type,f!==null&&m.stateNode!=null)zr?f.memoizedProps!==L&&cr(m):Wc(f,m,$,L);else{if(!L){if(m.stateNode===null)throw Error(s(166));return yn(m),null}f=Ur.current,Ae(m)?ot(m,f):(f=Op($,L,E,f,!0),m.stateNode=f,cr(m))}return yn(m),null}case 5:if(He(m),E=m.type,f!==null&&m.stateNode!=null)Wc(f,m,E,L);else{if(!L){if(m.stateNode===null)throw Error(s(166));return yn(m),null}f=Ur.current,Ae(m)?ot(m,f):($=ih(E,L,vl.current,f,m),$c($,m,!1,!1),m.stateNode=$,Wl($,E,L,f)&&cr(m))}return yn(m),Ll(m,m.type,m.pendingProps),null;case 6:if(f&&m.stateNode!=null)E=f.memoizedProps,zr?E!==L&&cr(m):qa&&(E!==L?(m.stateNode=sh(L,vl.current,Ur.current,m),cr(m)):m.stateNode=f.stateNode);else{if(typeof L!="string"&&m.stateNode===null)throw Error(s(166));if(f=vl.current,E=Ur.current,Ae(m)){if(!Ma)throw Error(s(176));if(f=m.stateNode,E=m.memoizedProps,L=null,$=ua,$!==null)switch($.tag){case 27:case 5:L=$.memoizedProps}Fm(f,E,m,L)||Xe(m)}else m.stateNode=sh(L,f,E,m)}return yn(m),null;case 13:if(L=m.memoizedState,f===null||f.memoizedState!==null&&f.memoizedState.dehydrated!==null){if($=Ae(m),L!==null&&L.dehydrated!==null){if(f===null){if(!$)throw Error(s(318));if(!Ma)throw Error(s(344));if($=m.memoizedState,$=$!==null?$.dehydrated:null,!$)throw Error(s(317));ld($,m)}else ye(),(m.flags&128)===0&&(m.memoizedState=null),m.flags|=4;yn(m),$=!1}else Za!==null&&(Gl(Za),Za=null),$=!0;if(!$)return m.flags&256?(ft(m),m):(ft(m),null)}if(ft(m),(m.flags&128)!==0)return m.lanes=E,m;if(E=L!==null,f=f!==null&&f.memoizedState!==null,E){L=m.child,$=null,L.alternate!==null&&L.alternate.memoizedState!==null&&L.alternate.memoizedState.cachePool!==null&&($=L.alternate.memoizedState.cachePool.pool);var ie=null;L.memoizedState!==null&&L.memoizedState.cachePool!==null&&(ie=L.memoizedState.cachePool.pool),ie!==$&&(L.flags|=2048)}return E!==f&&E&&(m.child.flags|=8192),hu(m,m.updateQueue),yn(m),null;case 4:return ce(),fu(f,m),f===null&&dp(m.stateNode.containerInfo),yn(m),null;case 10:return Bo(m.type),yn(m),null;case 19:if(M(xr),$=m.memoizedState,$===null)return yn(m),null;if(L=(m.flags&128)!==0,ie=$.rendering,ie===null)if(L)ho($,!1);else{if(Hi!==0||f!==null&&(f.flags&128)!==0)for(f=m.child;f!==null;){if(ie=yt(f),ie!==null){for(m.flags|=128,ho($,!1),f=ie.updateQueue,m.updateQueue=f,hu(m,f),m.subtreeFlags=0,f=E,E=m.child;E!==null;)jl(E,f),E=E.sibling;return T(xr,xr.current&1|2),m.child}f=f.sibling}$.tail!==null&&Jr()>ar&&(m.flags|=128,L=!0,ho($,!1),m.lanes=4194304)}else{if(!L)if(f=yt(ie),f!==null){if(m.flags|=128,L=!0,f=f.updateQueue,m.updateQueue=f,hu(m,f),ho($,!0),$.tail===null&&$.tailMode==="hidden"&&!ie.alternate&&!Di)return yn(m),null}else 2*Jr()-$.renderingStartTime>ar&&E!==536870912&&(m.flags|=128,L=!0,ho($,!1),m.lanes=4194304);$.isBackwards?(ie.sibling=m.child,m.child=ie):(f=$.last,f!==null?f.sibling=ie:m.child=ie,$.last=ie)}return $.tail!==null?(m=$.tail,$.rendering=m,$.tail=m.sibling,$.renderingStartTime=Jr(),m.sibling=null,f=xr.current,T(xr,L?f&1|2:f&1),m):(yn(m),null);case 22:case 23:return ft(m),ge(),L=m.memoizedState!==null,f!==null?f.memoizedState!==null!==L&&(m.flags|=8192):L&&(m.flags|=8192),L?(E&536870912)!==0&&(m.flags&128)===0&&(yn(m),m.subtreeFlags&6&&(m.flags|=8192)):yn(m),E=m.updateQueue,E!==null&&hu(m,E.retryQueue),E=null,f!==null&&f.memoizedState!==null&&f.memoizedState.cachePool!==null&&(E=f.memoizedState.cachePool.pool),L=null,m.memoizedState!==null&&m.memoizedState.cachePool!==null&&(L=m.memoizedState.cachePool.pool),L!==E&&(m.flags|=2048),f!==null&&M(eu),null;case 24:return E=null,f!==null&&(E=f.memoizedState.cache),m.memoizedState.cache!==E&&(m.flags|=2048),Bo(ss),yn(m),null;case 25:return null}throw Error(s(156,m.tag))}function rc(f,m){switch(ue(m),m.tag){case 1:return f=m.flags,f&65536?(m.flags=f&-65537|128,m):null;case 3:return Bo(ss),ce(),f=m.flags,(f&65536)!==0&&(f&128)===0?(m.flags=f&-65537|128,m):null;case 26:case 27:case 5:return He(m),null;case 13:if(ft(m),f=m.memoizedState,f!==null&&f.dehydrated!==null){if(m.alternate===null)throw Error(s(340));ye()}return f=m.flags,f&65536?(m.flags=f&-65537|128,m):null;case 19:return M(xr),null;case 4:return ce(),null;case 10:return Bo(m.type),null;case 22:case 23:return ft(m),ge(),f!==null&&M(eu),f=m.flags,f&65536?(m.flags=f&-65537|128,m):null;case 24:return Bo(ss),null;case 25:return null;default:return null}}function qc(f,m){switch(ue(m),m.tag){case 3:Bo(ss),ce();break;case 26:case 27:case 5:He(m);break;case 4:ce();break;case 13:ft(m);break;case 19:M(xr);break;case 10:Bo(m.type);break;case 22:case 23:ft(m),ge(),f!==null&&M(eu);break;case 24:Bo(ss)}}function al(f,m){try{var E=m.updateQueue,L=E!==null?E.lastEffect:null;if(L!==null){var $=L.next;E=$;do{if((E.tag&f)===f){L=void 0;var ie=E.create,De=E.inst;L=ie(),De.destroy=L}E=E.next}while(E!==$)}}catch(it){Ri(m,m.return,it)}}function Cr(f,m,E){try{var L=m.updateQueue,$=L!==null?L.lastEffect:null;if($!==null){var ie=$.next;L=ie;do{if((L.tag&f)===f){var De=L.inst,it=De.destroy;if(it!==void 0){De.destroy=void 0,$=m;var pt=E;try{it()}catch(Xt){Ri($,pt,Xt)}}}L=L.next}while(L!==ie)}}catch(Xt){Ri(m,m.return,Xt)}}function pu(f){var m=f.updateQueue;if(m!==null){var E=f.stateNode;try{Kt(m,E)}catch(L){Ri(f,f.return,L)}}}function Xc(f,m,E){E.props=Vs(f.type,f.memoizedProps),E.state=f.memoizedState;try{E.componentWillUnmount()}catch(L){Ri(f,m,L)}}function ol(f,m){try{var E=f.ref;if(E!==null){var L=f.stateNode;switch(f.tag){case 26:case 27:case 5:var $=ad(L);break;default:$=L}typeof E=="function"?f.refCleanup=E($):E.current=$}}catch(ie){Ri(f,m,ie)}}function gs(f,m){var E=f.ref,L=f.refCleanup;if(E!==null)if(typeof L=="function")try{L()}catch($){Ri(f,m,$)}finally{f.refCleanup=null,f=f.alternate,f!=null&&(f.refCleanup=null)}else if(typeof E=="function")try{E(null)}catch($){Ri(f,m,$)}else E.current=null}function Fl(f){var m=f.type,E=f.memoizedProps,L=f.stateNode;try{Cm(L,m,E,f)}catch($){Ri(f,f.return,$)}}function ac(f,m,E){try{hp(f.stateNode,f.type,E,m,f)}catch(L){Ri(f,f.return,L)}}function oc(f){return f.tag===5||f.tag===3||(Ya?f.tag===26:!1)||(Yr?f.tag===27:!1)||f.tag===4}function lc(f){e:for(;;){for(;f.sibling===null;){if(f.return===null||oc(f.return))return null;f=f.return}for(f.sibling.return=f.return,f=f.sibling;f.tag!==5&&f.tag!==6&&(!Yr||f.tag!==27)&&f.tag!==18;){if(f.flags&2||f.child===null||f.tag===4)continue e;f.child.return=f,f=f.child}if(!(f.flags&2))return f.stateNode}}function uc(f,m,E){var L=f.tag;if(L===5||L===6)f=f.stateNode,m?ch(E,f,m):Sm(E,f);else if(!(L===4||Yr&&L===27)&&(f=f.child,f!==null))for(uc(f,m,E),f=f.sibling;f!==null;)uc(f,m,E),f=f.sibling}function po(f,m,E){var L=f.tag;if(L===5||L===6)f=f.stateNode,m?pp(E,f,m):uh(E,f);else if(!(L===4||Yr&&L===27)&&(f=f.child,f!==null))for(po(f,m,E),f=f.sibling;f!==null;)po(f,m,E),f=f.sibling}function Yc(f,m,E){f=f.containerInfo;try{vp(f,E)}catch(L){Ri(m,m.return,L)}}function ll(f,m){for(Tu(f.containerInfo),rr=m;rr!==null;)if(f=rr,m=f.child,(f.subtreeFlags&1028)!==0&&m!==null)m.return=f,rr=m;else for(;rr!==null;){f=rr;var E=f.alternate;switch(m=f.flags,f.tag){case 0:break;case 11:case 15:break;case 1:if((m&1024)!==0&&E!==null){m=void 0;var L=f,$=E.memoizedProps;E=E.memoizedState;var ie=L.stateNode;try{var De=Vs(L.type,$,L.elementType===L.type);m=ie.getSnapshotBeforeUpdate(De,E),ie.__reactInternalSnapshotBeforeUpdate=m}catch(it){Ri(L,L.return,it)}}break;case 3:(m&1024)!==0&&zr&&fh(f.stateNode.containerInfo);break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((m&1024)!==0)throw Error(s(163))}if(m=f.sibling,m!==null){m.return=f.return,rr=m;break}rr=f.return}return De=wc,wc=!1,De}function mu(f,m,E){var L=E.flags;switch(E.tag){case 0:case 11:case 15:Nt(f,E),L&4&&al(5,E);break;case 1:if(Nt(f,E),L&4)if(f=E.stateNode,m===null)try{f.componentDidMount()}catch(it){Ri(E,E.return,it)}else{var $=Vs(E.type,m.memoizedProps);m=m.memoizedState;try{f.componentDidUpdate($,m,f.__reactInternalSnapshotBeforeUpdate)}catch(it){Ri(E,E.return,it)}}L&64&&pu(E),L&512&&ol(E,E.return);break;case 3:if(Nt(f,E),L&64&&(L=E.updateQueue,L!==null)){if(f=null,E.child!==null)switch(E.child.tag){case 27:case 5:f=ad(E.child.stateNode);break;case 1:f=E.child.stateNode}try{Kt(L,f)}catch(it){Ri(E,E.return,it)}}break;case 26:if(Ya){Nt(f,E),L&512&&ol(E,E.return);break}case 27:case 5:Nt(f,E),m===null&&L&4&&Fl(E),L&512&&ol(E,E.return);break;case 12:Nt(f,E);break;case 13:Nt(f,E),L&4&&Oo(f,E);break;case 22:if($=E.memoizedState!==null||Br,!$){m=m!==null&&m.memoizedState!==null||Ys;var ie=Br,De=Ys;Br=$,(Ys=m)&&!De?pn(f,E,(E.subtreeFlags&8772)!==0):Nt(f,E),Br=ie,Ys=De}L&512&&(E.memoizedProps.mode==="manual"?ol(E,E.return):gs(E,E.return));break;default:Nt(f,E)}}function Nl(f){var m=f.alternate;m!==null&&(f.alternate=null,Nl(m)),f.child=null,f.deletions=null,f.sibling=null,f.tag===5&&(m=f.stateNode,m!==null&&rh(m)),f.stateNode=null,f.return=null,f.dependencies=null,f.memoizedProps=null,f.memoizedState=null,f.pendingProps=null,f.stateNode=null,f.updateQueue=null}function sa(f,m,E){for(E=E.child;E!==null;)gu(f,m,E),E=E.sibling}function gu(f,m,E){if(Oa&&typeof Oa.onCommitFiberUnmount=="function")try{Oa.onCommitFiberUnmount(dd,E)}catch{}switch(E.tag){case 26:if(Ya){Ys||gs(E,m),sa(f,m,E),E.memoizedState?Sp(E.memoizedState):E.stateNode&&Pp(E.stateNode);break}case 27:if(Yr){Ys||gs(E,m);var L=pr,$=Na;pr=E.stateNode,sa(f,m,E),Gm(E.stateNode),pr=L,Na=$;break}case 5:Ys||gs(E,m);case 6:if(zr){if(L=pr,$=Na,pr=null,sa(f,m,E),pr=L,Na=$,pr!==null)if(Na)try{fr(pr,E.stateNode)}catch(ie){Ri(E,m,ie)}else try{ba(pr,E.stateNode)}catch(ie){Ri(E,m,ie)}}else sa(f,m,E);break;case 18:zr&&pr!==null&&(Na?gh(pr,E.stateNode):zm(pr,E.stateNode));break;case 4:zr?(L=pr,$=Na,pr=E.stateNode.containerInfo,Na=!0,sa(f,m,E),pr=L,Na=$):(qa&&Yc(E.stateNode,E,ff()),sa(f,m,E));break;case 0:case 11:case 14:case 15:Ys||Cr(2,E,m),Ys||Cr(4,E,m),sa(f,m,E);break;case 1:Ys||(gs(E,m),L=E.stateNode,typeof L.componentWillUnmount=="function"&&Xc(E,m,L)),sa(f,m,E);break;case 21:sa(f,m,E);break;case 22:Ys||gs(E,m),Ys=(L=Ys)||E.memoizedState!==null,sa(f,m,E),Ys=L;break;default:sa(f,m,E)}}function Oo(f,m){if(Ma&&m.memoizedState===null&&(f=m.alternate,f!==null&&(f=f.memoizedState,f!==null&&(f=f.dehydrated,f!==null))))try{mh(f)}catch(E){Ri(m,m.return,E)}}function G(f){switch(f.tag){case 13:case 19:var m=f.stateNode;return m===null&&(m=f.stateNode=new vd),m;case 22:return f=f.stateNode,m=f._retryCache,m===null&&(m=f._retryCache=new vd),m;default:throw Error(s(435,f.tag))}}function Z(f,m){var E=G(f);m.forEach(function(L){var $=Qh.bind(null,f,L);E.has(L)||(E.add(L),L.then($,$))})}function _e(f,m){var E=m.deletions;if(E!==null)for(var L=0;L<E.length;L++){var $=E[L],ie=f,De=m;if(zr){var it=De;e:for(;it!==null;){switch(it.tag){case 27:case 5:pr=it.stateNode,Na=!1;break e;case 3:pr=it.stateNode.containerInfo,Na=!0;break e;case 4:pr=it.stateNode.containerInfo,Na=!0;break e}it=it.return}if(pr===null)throw Error(s(160));gu(ie,De,$),pr=null,Na=!1}else gu(ie,De,$);ie=$.alternate,ie!==null&&(ie.return=null),$.return=null}if(m.subtreeFlags&13878)for(m=m.child;m!==null;)Te(m,f),m=m.sibling}function Te(f,m){var E=f.alternate,L=f.flags;switch(f.tag){case 0:case 11:case 14:case 15:_e(m,f),Re(f),L&4&&(Cr(3,f,f.return),al(3,f),Cr(5,f,f.return));break;case 1:_e(m,f),Re(f),L&512&&(Ys||E===null||gs(E,E.return)),L&64&&Br&&(f=f.updateQueue,f!==null&&(L=f.callbacks,L!==null&&(E=f.shared.hiddenCallbacks,f.shared.hiddenCallbacks=E===null?L:E.concat(L))));break;case 26:if(Ya){var $=Sa;_e(m,f),Re(f),L&512&&(Ys||E===null||gs(E,E.return)),L&4&&(L=E!==null?E.memoizedState:null,m=f.memoizedState,E===null?m===null?f.stateNode===null?f.stateNode=Ap($,f.type,f.memoizedProps,f):Cp($,f.type,f.stateNode):f.stateNode=Tp($,m,f.memoizedProps):L!==m?(L===null?E.stateNode!==null&&Pp(E.stateNode):Sp(L),m===null?Cp($,f.type,f.stateNode):Tp($,m,f.memoizedProps)):m===null&&f.stateNode!==null&&ac(f,f.memoizedProps,E.memoizedProps));break}case 27:if(Yr&&L&4&&f.alternate===null){$=f.stateNode;var ie=f.memoizedProps;try{l_($),u_(f.type,ie,$,f)}catch(mn){Ri(f,f.return,mn)}}case 5:if(_e(m,f),Re(f),L&512&&(Ys||E===null||gs(E,E.return)),zr){if(f.flags&32){m=f.stateNode;try{_c(m)}catch(mn){Ri(f,f.return,mn)}}L&4&&f.stateNode!=null&&(m=f.memoizedProps,ac(f,m,E!==null?E.memoizedProps:m)),L&1024&&(Ou=!0)}break;case 6:if(_e(m,f),Re(f),L&4&&zr){if(f.stateNode===null)throw Error(s(162));L=f.memoizedProps,E=E!==null?E.memoizedProps:L,m=f.stateNode;try{Am(m,E,L)}catch(mn){Ri(f,f.return,mn)}}break;case 3:if(Ya?(Rp(),$=Sa,Sa=gf(m.containerInfo),_e(m,f),Sa=$):_e(m,f),Re(f),L&4){if(zr&&Ma&&E!==null&&E.memoizedState.isDehydrated)try{mf(m.containerInfo)}catch(mn){Ri(f,f.return,mn)}if(qa){L=m.containerInfo,E=m.pendingChildren;try{vp(L,E)}catch(mn){Ri(f,f.return,mn)}}}Ou&&(Ou=!1,ct(f));break;case 4:Ya?(E=Sa,Sa=gf(f.stateNode.containerInfo),_e(m,f),Re(f),Sa=E):(_e(m,f),Re(f)),L&4&&qa&&Yc(f.stateNode,f,f.stateNode.pendingChildren);break;case 12:_e(m,f),Re(f);break;case 13:_e(m,f),Re(f),f.child.flags&8192&&f.memoizedState!==null!=(E!==null&&E.memoizedState!==null)&&(iu=Jr()),L&4&&(L=f.updateQueue,L!==null&&(f.updateQueue=null,Z(f,L)));break;case 22:L&512&&(Ys||E===null||gs(E,E.return)),$=f.memoizedState!==null;var De=E!==null&&E.memoizedState!==null,it=Br,pt=Ys;if(Br=it||$,Ys=pt||De,_e(m,f),Ys=pt,Br=it,Re(f),m=f.stateNode,m._current=f,m._visibility&=-3,m._visibility|=m._pendingVisibility&2,L&8192&&(m._visibility=$?m._visibility&-2:m._visibility|1,$&&(m=Br||Ys,E===null||De||m||sn(f)),zr&&(f.memoizedProps===null||f.memoizedProps.mode!=="manual"))){e:if(E=null,zr)for(m=f;;){if(m.tag===5||Ya&&m.tag===26||Yr&&m.tag===27){if(E===null){De=E=m;try{ie=De.stateNode,$?df(ie):mp(De.stateNode,De.memoizedProps)}catch(mn){Ri(De,De.return,mn)}}}else if(m.tag===6){if(E===null){De=m;try{var Xt=De.stateNode;$?dh(Xt):_l(Xt,De.memoizedProps)}catch(mn){Ri(De,De.return,mn)}}}else if((m.tag!==22&&m.tag!==23||m.memoizedState===null||m===f)&&m.child!==null){m.child.return=m,m=m.child;continue}if(m===f)break e;for(;m.sibling===null;){if(m.return===null||m.return===f)break e;E===m&&(E=null),m=m.return}E===m&&(E=null),m.sibling.return=m.return,m=m.sibling}}L&4&&(L=f.updateQueue,L!==null&&(E=L.retryQueue,E!==null&&(L.retryQueue=null,Z(f,E))));break;case 19:_e(m,f),Re(f),L&4&&(L=f.updateQueue,L!==null&&(f.updateQueue=null,Z(f,L)));break;case 21:break;default:_e(m,f),Re(f)}}function Re(f){var m=f.flags;if(m&2){try{if(zr&&(!Yr||f.tag!==27)){e:{for(var E=f.return;E!==null;){if(oc(E)){var L=E;break e}E=E.return}throw Error(s(160))}switch(L.tag){case 27:if(Yr){var $=L.stateNode,ie=lc(f);po(f,ie,$);break}case 5:var De=L.stateNode;L.flags&32&&(_c(De),L.flags&=-33);var it=lc(f);po(f,it,De);break;case 3:case 4:var pt=L.stateNode.containerInfo,Xt=lc(f);uc(f,Xt,pt);break;default:throw Error(s(161))}}}catch(mn){Ri(f,f.return,mn)}f.flags&=-3}m&4096&&(f.flags&=-4097)}function ct(f){if(f.subtreeFlags&1024)for(f=f.child;f!==null;){var m=f;ct(m),m.tag===5&&m.flags&1024&&_s(m.stateNode),f=f.sibling}}function Nt(f,m){if(m.subtreeFlags&8772)for(m=m.child;m!==null;)mu(f,m.alternate,m),m=m.sibling}function sn(f){for(f=f.child;f!==null;){var m=f;switch(m.tag){case 0:case 11:case 14:case 15:Cr(4,m,m.return),sn(m);break;case 1:gs(m,m.return);var E=m.stateNode;typeof E.componentWillUnmount=="function"&&Xc(m,m.return,E),sn(m);break;case 26:case 27:case 5:gs(m,m.return),sn(m);break;case 22:gs(m,m.return),m.memoizedState===null&&sn(m);break;default:sn(m)}f=f.sibling}}function pn(f,m,E){for(E=E&&(m.subtreeFlags&8772)!==0,m=m.child;m!==null;){var L=m.alternate,$=f,ie=m,De=ie.flags;switch(ie.tag){case 0:case 11:case 15:pn($,ie,E),al(4,ie);break;case 1:if(pn($,ie,E),L=ie,$=L.stateNode,typeof $.componentDidMount=="function")try{$.componentDidMount()}catch(Xt){Ri(L,L.return,Xt)}if(L=ie,$=L.updateQueue,$!==null){var it=L.stateNode;try{var pt=$.shared.hiddenCallbacks;if(pt!==null)for($.shared.hiddenCallbacks=null,$=0;$<pt.length;$++)qe(pt[$],it)}catch(Xt){Ri(L,L.return,Xt)}}E&&De&64&&pu(ie),ol(ie,ie.return);break;case 26:case 27:case 5:pn($,ie,E),E&&L===null&&De&4&&Fl(ie),ol(ie,ie.return);break;case 12:pn($,ie,E);break;case 13:pn($,ie,E),E&&De&4&&Oo($,ie);break;case 22:ie.memoizedState===null&&pn($,ie,E),ol(ie,ie.return);break;default:pn($,ie,E)}m=m.sibling}}function On(f,m){var E=null;f!==null&&f.memoizedState!==null&&f.memoizedState.cachePool!==null&&(E=f.memoizedState.cachePool.pool),f=null,m.memoizedState!==null&&m.memoizedState.cachePool!==null&&(f=m.memoizedState.cachePool.pool),f!==E&&(f!=null&&f.refCount++,E!=null&&rl(E))}function Zn(f,m){f=null,m.alternate!==null&&(f=m.alternate.memoizedState.cache),m=m.memoizedState.cache,m!==f&&(m.refCount++,f!=null&&rl(f))}function hi(f,m,E,L){if(m.subtreeFlags&10256)for(m=m.child;m!==null;)zi(f,m,E,L),m=m.sibling}function zi(f,m,E,L){var $=m.flags;switch(m.tag){case 0:case 11:case 15:hi(f,m,E,L),$&2048&&al(9,m);break;case 3:hi(f,m,E,L),$&2048&&(f=null,m.alternate!==null&&(f=m.alternate.memoizedState.cache),m=m.memoizedState.cache,m!==f&&(m.refCount++,f!=null&&rl(f)));break;case 12:if($&2048){hi(f,m,E,L),f=m.stateNode;try{var ie=m.memoizedProps,De=ie.id,it=ie.onPostCommit;typeof it=="function"&&it(De,m.alternate===null?"mount":"update",f.passiveEffectDuration,-0)}catch(pt){Ri(m,m.return,pt)}}else hi(f,m,E,L);break;case 23:break;case 22:ie=m.stateNode,m.memoizedState!==null?ie._visibility&4?hi(f,m,E,L):ga(f,m):ie._visibility&4?hi(f,m,E,L):(ie._visibility|=4,ki(f,m,E,L,(m.subtreeFlags&10256)!==0)),$&2048&&On(m.alternate,m);break;case 24:hi(f,m,E,L),$&2048&&Zn(m.alternate,m);break;default:hi(f,m,E,L)}}function ki(f,m,E,L,$){for($=$&&(m.subtreeFlags&10256)!==0,m=m.child;m!==null;){var ie=f,De=m,it=E,pt=L,Xt=De.flags;switch(De.tag){case 0:case 11:case 15:ki(ie,De,it,pt,$),al(8,De);break;case 23:break;case 22:var mn=De.stateNode;De.memoizedState!==null?mn._visibility&4?ki(ie,De,it,pt,$):ga(ie,De):(mn._visibility|=4,ki(ie,De,it,pt,$)),$&&Xt&2048&&On(De.alternate,De);break;case 24:ki(ie,De,it,pt,$),$&&Xt&2048&&Zn(De.alternate,De);break;default:ki(ie,De,it,pt,$)}m=m.sibling}}function ga(f,m){if(m.subtreeFlags&10256)for(m=m.child;m!==null;){var E=f,L=m,$=L.flags;switch(L.tag){case 22:ga(E,L),$&2048&&On(L.alternate,L);break;case 24:ga(E,L),$&2048&&Zn(L.alternate,L);break;default:ga(E,L)}m=m.sibling}}function dr(f){if(f.subtreeFlags&Lu)for(f=f.child;f!==null;)cc(f),f=f.sibling}function cc(f){switch(f.tag){case 26:dr(f),f.flags&Lu&&(f.memoizedState!==null?Ip(Sa,f.memoizedState,f.memoizedProps):Xs(f.type,f.memoizedProps));break;case 5:dr(f),f.flags&Lu&&Xs(f.type,f.memoizedProps);break;case 3:case 4:if(Ya){var m=Sa;Sa=gf(f.stateNode.containerInfo),dr(f),Sa=m}else dr(f);break;case 22:f.memoizedState===null&&(m=f.alternate,m!==null&&m.memoizedState!==null?(m=Lu,Lu=16777216,dr(f),Lu=m):dr(f));break;default:dr(f)}}function qf(f){var m=f.alternate;if(m!==null&&(f=m.child,f!==null)){m.child=null;do m=f.sibling,f.sibling=null,f=m;while(f!==null)}}function zl(f){var m=f.deletions;if((f.flags&16)!==0){if(m!==null)for(var E=0;E<m.length;E++){var L=m[E];rr=L,Ul(L,f)}qf(f)}if(f.subtreeFlags&10256)for(f=f.child;f!==null;)Zd(f),f=f.sibling}function Zd(f){switch(f.tag){case 0:case 11:case 15:zl(f),f.flags&2048&&Cr(9,f,f.return);break;case 3:zl(f);break;case 12:zl(f);break;case 22:var m=f.stateNode;f.memoizedState!==null&&m._visibility&4&&(f.return===null||f.return.tag!==13)?(m._visibility&=-5,Jc(f)):zl(f);break;default:zl(f)}}function Jc(f){var m=f.deletions;if((f.flags&16)!==0){if(m!==null)for(var E=0;E<m.length;E++){var L=m[E];rr=L,Ul(L,f)}qf(f)}for(f=f.child;f!==null;){switch(m=f,m.tag){case 0:case 11:case 15:Cr(8,m,m.return),Jc(m);break;case 22:E=m.stateNode,E._visibility&4&&(E._visibility&=-5,Jc(m));break;default:Jc(m)}f=f.sibling}}function Ul(f,m){for(;rr!==null;){var E=rr;switch(E.tag){case 0:case 11:case 15:Cr(8,E,m);break;case 23:case 22:if(E.memoizedState!==null&&E.memoizedState.cachePool!==null){var L=E.memoizedState.cachePool.pool;L!=null&&L.refCount++}break;case 24:rl(E.memoizedState.cache)}if(L=E.child,L!==null)L.return=E,rr=L;else e:for(E=f;rr!==null;){L=rr;var $=L.sibling,ie=L.return;if(Nl(L),L===E){rr=null;break e}if($!==null){$.return=ie,rr=$;break e}rr=ie}}}function Xf(f){var m=uf(f);if(m!=null){if(typeof m.memoizedProps["data-testname"]!="string")throw Error(s(364));return m}if(f=Au(f),f===null)throw Error(s(362));return f.stateNode.current}function Qc(f,m){var E=f.tag;switch(m.$$typeof){case Cf:if(f.type===m.value)return!0;break;case Pf:e:{for(m=m.value,f=[f,0],E=0;E<f.length;){var L=f[E++],$=L.tag,ie=f[E++],De=m[ie];if($!==5&&$!==26&&$!==27||!Uo(L)){for(;De!=null&&Qc(L,De);)ie++,De=m[ie];if(ie===m.length){m=!0;break e}else for(L=L.child;L!==null;)f.push(L,ie),L=L.sibling}}m=!1}return m;case Th:if((E===5||E===26||E===27)&&s_(f.stateNode,m.value))return!0;break;case rs:if((E===5||E===6||E===26||E===27)&&(f=cf(f),f!==null&&0<=f.indexOf(m.value)))return!0;break;case Vi:if((E===5||E===26||E===27)&&(f=f.memoizedProps["data-testname"],typeof f=="string"&&f.toLowerCase()===m.value.toLowerCase()))return!0;break;default:throw Error(s(365))}return!1}function kl(f){switch(f.$$typeof){case Cf:return"<"+(o(f.value)||"Unknown")+">";case Pf:return":has("+(kl(f)||"")+")";case Th:return'[role="'+f.value+'"]';case rs:return'"'+f.value+'"';case Vi:return'[data-testname="'+f.value+'"]';default:throw Error(s(365))}}function Mm(f,m){var E=[];f=[f,0];for(var L=0;L<f.length;){var $=f[L++],ie=$.tag,De=f[L++],it=m[De];if(ie!==5&&ie!==26&&ie!==27||!Uo($)){for(;it!=null&&Qc($,it);)De++,it=m[De];if(De===m.length)E.push($);else for($=$.child;$!==null;)f.push($,De),$=$.sibling}}return E}function _a(f,m){if(!gl)throw Error(s(363));f=Xf(f),f=Mm(f,m),m=[],f=Array.from(f);for(var E=0;E<f.length;){var L=f[E++],$=L.tag;if($===5||$===26||$===27)Uo(L)||m.push(L.stateNode);else for(L=L.child;L!==null;)f.push(L),L=L.sibling}return m}function ra(){if((jn&2)!==0&&wi!==0)return wi&-wi;if(Jn.T!==null){var f=La;return f!==0?f:ht()}return Xa()}function ul(){za===0&&(za=(wi&536870912)===0||Di?z():536870912);var f=to.current;return f!==null&&(f.flags|=32),za}function aa(f,m,E){(f===Si&&xs===2||f.cancelPendingCommit!==null)&&(Fo(f,0),Lo(f,wi,za,!1)),j(f,E),((jn&2)===0||f!==Si)&&(f===Si&&((jn&2)===0&&(so|=E),Hi===4&&Lo(f,wi,za,!1)),Qe(f))}function Zc(f,m,E){if((jn&6)!==0)throw Error(s(327));var L=!E&&(m&60)===0&&(m&f.expiredLanes)===0||P(f,m),$=L?No(f,m):cl(f,m,!0),ie=L;do{if($===0){no&&!L&&Lo(f,m,0,!1);break}else if($===6)Lo(f,m,0,!qi);else{if(E=f.current.alternate,ie&&!Xh(E)){$=cl(f,m,!1),ie=!1;continue}if($===2){if(ie=m,f.errorRecoveryDisabledLanes&ie)var De=0;else De=f.pendingLanes&-536870913,De=De!==0?De:De&536870912?536870912:0;if(De!==0){m=De;e:{var it=f;$=Li;var pt=Ma&&it.current.memoizedState.isDehydrated;if(pt&&(Fo(it,De).flags|=256),De=cl(it,De,!1),De!==2){if(tu&&!pt){it.errorRecoveryDisabledLanes|=ie,so|=ie,$=4;break e}ie=Eo,Eo=$,ie!==null&&Gl(ie)}$=De}if(ie=!1,$!==2)continue}}if($===1){Fo(f,0),Lo(f,m,0,!0);break}e:{switch(L=f,$){case 0:case 1:throw Error(s(345));case 4:if((m&4194176)===m){Lo(L,m,za,!qi);break e}break;case 2:Eo=null;break;case 3:case 5:break;default:throw Error(s(329))}if(L.finishedWork=E,L.finishedLanes=m,(m&62914560)===m&&(ie=iu+300-Jr(),10<ie)){if(Lo(L,m,za,!qi),R(L,0)!==0)break e;L.timeoutHandle=cp(Yf.bind(null,L,E,Eo,To,Rf,m,za,so,nu,qi,2,-0,0),ie);break e}Yf(L,E,Eo,To,Rf,m,za,so,nu,qi,0,-0,0)}}break}while(!0);Qe(f)}function Gl(f){Eo===null?Eo=f:Eo.push.apply(Eo,f)}function Yf(f,m,E,L,$,ie,De,it,pt,Xt,mn,An,Rn){var ci=m.subtreeFlags;if((ci&8192||(ci&16785408)===16785408)&&(la(),cc(m),m=ah(),m!==null)){f.cancelPendingCommit=m(Is.bind(null,f,E,L,$,De,it,pt,1,An,Rn)),Lo(f,ie,De,!Xt);return}Is(f,E,L,$,De,it,pt,mn,An,Rn)}function Xh(f){for(var m=f;;){var E=m.tag;if((E===0||E===11||E===15)&&m.flags&16384&&(E=m.updateQueue,E!==null&&(E=E.stores,E!==null)))for(var L=0;L<E.length;L++){var $=E[L],ie=$.getSnapshot;$=$.value;try{if(!wa(ie(),$))return!1}catch{return!1}}if(E=m.child,m.subtreeFlags&16384&&E!==null)E.return=m,m=E;else{if(m===f)break;for(;m.sibling===null;){if(m.return===null||m.return===f)return!0;m=m.return}m.sibling.return=m.return,m=m.sibling}}return!0}function Lo(f,m,E,L){m&=~ca,m&=~so,f.suspendedLanes|=m,f.pingedLanes&=~m,L&&(f.warmLanes|=m),L=f.expirationTimes;for(var $=m;0<$;){var ie=31-xa($),De=1<<ie;L[ie]=-1,$&=~De}E!==0&&W(f,E,m)}function Yh(){return(jn&6)===0?(mt(0),!1):!0}function va(){if(pi!==null){if(xs===0)var f=pi.return;else f=pi,sr=Iu=null,Se(f),Ml=null,bo=0,f=pi;for(;f!==null;)qc(f.alternate,f),f=f.return;pi=null}}function Fo(f,m){f.finishedWork=null,f.finishedLanes=0;var E=f.timeoutHandle;E!==gc&&(f.timeoutHandle=gc,od(E)),E=f.cancelPendingCommit,E!==null&&(f.cancelPendingCommit=null,E()),va(),Si=f,pi=E=qr(f.current,null),wi=m,xs=0,mr=null,qi=!1,no=P(f,m),tu=!1,nu=za=ca=so=io=Hi=0,Eo=Li=null,Rf=!1,(m&8)!==0&&(m|=m&32);var L=f.entangledLanes;if(L!==0)for(f=f.entanglements,L&=m;0<L;){var $=31-xa(L),ie=1<<$;m|=f[$],L&=~ie}return Ho=m,ke(),E}function dc(f,m){gi=null,Jn.H=Gi,m===is?(m=A(),xs=3):m===Np?(m=A(),xs=4):xs=m===qm?8:m!==null&&typeof m=="object"&&typeof m.then=="function"?6:1,mr=m,pi===null&&(Hi=1,Ba(f,pe(m,f.current)))}function ed(){var f=to.current;return f===null?!0:(wi&4194176)===wi?xo===null:(wi&62914560)===wi||(wi&536870912)!==0?f===xo:!1}function td(){var f=Jn.H;return Jn.H=Gi,f===null?Gi:f}function Ka(){var f=Jn.A;return Jn.A=Eh,f}function ya(){Hi=4,qi||(wi&4194176)!==wi&&to.current!==null||(no=!0),(io&134217727)===0&&(so&134217727)===0||Si===null||Lo(Si,wi,za,!1)}function cl(f,m,E){var L=jn;jn|=2;var $=td(),ie=Ka();(Si!==f||wi!==m)&&(To=null,Fo(f,m)),m=!1;var De=Hi;e:do try{if(xs!==0&&pi!==null){var it=pi,pt=mr;switch(xs){case 8:va(),De=6;break e;case 3:case 2:case 6:to.current===null&&(m=!0);var Xt=xs;if(xs=0,mr=null,_u(f,it,pt,Xt),E&&no){De=0;break e}break;default:Xt=xs,xs=0,mr=null,_u(f,it,pt,Xt)}}dl(),De=Hi;break}catch(mn){dc(f,mn)}while(!0);return m&&f.shellSuspendCounter++,sr=Iu=null,jn=L,Jn.H=$,Jn.A=ie,pi===null&&(Si=null,wi=0,ke()),De}function dl(){for(;pi!==null;)Jh(pi)}function No(f,m){var E=jn;jn|=2;var L=td(),$=Ka();Si!==f||wi!==m?(To=null,ar=Jr()+500,Fo(f,m)):no=P(f,m);e:do try{if(xs!==0&&pi!==null){m=pi;var ie=mr;t:switch(xs){case 1:xs=0,mr=null,_u(f,m,ie,1);break;case 2:if(fe(ie)){xs=0,mr=null,ef(m);break}m=function(){xs===2&&Si===f&&(xs=7),Qe(f)},ie.then(m,m);break e;case 3:xs=7;break e;case 4:xs=5;break e;case 7:fe(ie)?(xs=0,mr=null,ef(m)):(xs=0,mr=null,_u(f,m,ie,7));break;case 5:var De=null;switch(pi.tag){case 26:De=pi.memoizedState;case 5:case 27:var it=pi,pt=it.type,Xt=it.pendingProps;if(De?Bp(De):ql(pt,Xt)){xs=0,mr=null;var mn=it.sibling;if(mn!==null)pi=mn;else{var An=it.return;An!==null?(pi=An,tf(An)):pi=null}break t}}xs=0,mr=null,_u(f,m,ie,5);break;case 6:xs=0,mr=null,_u(f,m,ie,6);break;case 8:va(),Hi=6;break e;default:throw Error(s(462))}}Vl();break}catch(Rn){dc(f,Rn)}while(!0);return sr=Iu=null,Jn.H=L,Jn.A=$,jn=E,pi!==null?0:(Si=null,wi=0,ke(),Hi)}function Vl(){for(;pi!==null&&!Hm();)Jh(pi)}function Jh(f){var m=Yd(f.alternate,f,Ho);f.memoizedProps=f.pendingProps,m===null?tf(f):pi=m}function ef(f){var m=f,E=m.alternate;switch(m.tag){case 15:case 0:m=Hd(E,m,m.pendingProps,m.type,void 0,wi);break;case 11:m=Hd(E,m,m.pendingProps,m.type.render,m.ref,wi);break;case 5:Se(m);default:qc(E,m),m=pi=jl(m,Ho),m=Yd(E,m,Ho)}f.memoizedProps=f.pendingProps,m===null?tf(f):pi=m}function _u(f,m,E,L){sr=Iu=null,Se(m),Ml=null,bo=0;var $=m.return;try{if(Vf(f,$,m,E,wi)){Hi=1,Ba(f,pe(E,f.current)),pi=null;return}}catch(ie){if($!==null)throw pi=$,ie;Hi=1,Ba(f,pe(E,f.current)),pi=null;return}m.flags&32768?(Di||L===1?f=!0:no||(wi&536870912)!==0?f=!1:(qi=f=!0,(L===2||L===3||L===6)&&(L=to.current,L!==null&&L.tag===13&&(L.flags|=16384))),Pr(m,f)):tf(m)}function tf(f){var m=f;do{if((m.flags&32768)!==0){Pr(m,qi);return}f=m.return;var E=Kf(m.alternate,m,Ho);if(E!==null){pi=E;return}if(m=m.sibling,m!==null){pi=m;return}pi=m=f}while(m!==null);Hi===0&&(Hi=5)}function Pr(f,m){do{var E=rc(f.alternate,f);if(E!==null){E.flags&=32767,pi=E;return}if(E=f.return,E!==null&&(E.flags|=32768,E.subtreeFlags=0,E.deletions=null),!m&&(f=f.sibling,f!==null)){pi=f;return}pi=f=E}while(f!==null);Hi=6,pi=null}function Is(f,m,E,L,$,ie,De,it,pt,Xt){var mn=Jn.T,An=Mr();try{oa(2),Jn.T=null,Ui(f,m,E,L,An,$,ie,De,it,pt,Xt)}finally{Jn.T=mn,oa(An)}}function Ui(f,m,E,L,$,ie,De,it){do Nr();while(su!==null);if((jn&6)!==0)throw Error(s(327));var pt=f.finishedWork;if(L=f.finishedLanes,pt===null)return null;if(f.finishedWork=null,f.finishedLanes=0,pt===f.current)throw Error(s(177));f.callbackNode=null,f.callbackPriority=0,f.cancelPendingCommit=null;var Xt=pt.lanes|pt.childLanes;if(Xt|=hd,J(f,L,Xt,ie,De,it),f===Si&&(pi=Si=null,wi=0),(pt.subtreeFlags&10256)===0&&(pt.flags&10256)===0||So||(So=!0,Df=Xt,Fu=E,nd(vh,function(){return Nr(),null})),E=(pt.flags&15990)!==0,(pt.subtreeFlags&15990)!==0||E?(E=Jn.T,Jn.T=null,ie=Mr(),oa(2),De=jn,jn|=4,ll(f,pt),Te(pt,f),up(f.containerInfo),f.current=pt,mu(f,pt.alternate,pt),jm(),jn=De,oa(ie),Jn.T=E):f.current=pt,So?(So=!1,su=f,Ec=L):fl(f,Xt),Xt=f.pendingLanes,Xt===0&&(ro=null),q(pt.stateNode),Qe(f),m!==null)for($=f.onRecoverableError,pt=0;pt<m.length;pt++)Xt=m[pt],$(Xt.value,{componentStack:Xt.stack});return(Ec&3)!==0&&Nr(),Xt=f.pendingLanes,(L&4194218)!==0&&(Xt&42)!==0?f===Aa?yd++:(yd=0,Aa=f):yd=0,mt(0),null}function fl(f,m){(f.pooledCacheLanes&=m)===0&&(m=f.pooledCache,m!=null&&(f.pooledCache=null,rl(m)))}function Nr(){if(su!==null){var f=su,m=Df;Df=0;var E=ne(Ec),L=32>E?32:E;E=Jn.T;var $=Mr();try{if(oa(L),Jn.T=null,su===null)var ie=!1;else{L=Fu,Fu=null;var De=su,it=Ec;if(su=null,Ec=0,(jn&6)!==0)throw Error(s(331));var pt=jn;if(jn|=4,Zd(De.current),zi(De,De.current,it,L),jn=pt,mt(0,!1),Oa&&typeof Oa.onPostCommitFiberRoot=="function")try{Oa.onPostCommitFiberRoot(dd,De)}catch{}ie=!0}return ie}finally{oa($),Jn.T=E,fl(f,m)}}return!1}function Jf(f,m,E){m=pe(E,m),m=ec(f.stateNode,m,2),f=Jt(f,m,2),f!==null&&(j(f,2),Qe(f))}function Ri(f,m,E){if(f.tag===3)Jf(f,f,E);else for(;m!==null;){if(m.tag===3){Jf(m,f,E);break}else if(m.tag===1){var L=m.stateNode;if(typeof m.type.getDerivedStateFromError=="function"||typeof L.componentDidCatch=="function"&&(ro===null||!ro.has(L))){f=pe(E,f),E=uu(2),L=Jt(m,E,2),L!==null&&(tc(E,L,m,f),j(L,2),Qe(L));break}}m=m.return}}function Qf(f,m,E){var L=f.pingCache;if(L===null){L=f.pingCache=new Oi;var $=new Set;L.set(m,$)}else $=L.get(m),$===void 0&&($=new Set,L.set(m,$));$.has(E)||(tu=!0,$.add(E),f=bm.bind(null,f,m,E),m.then(f,f))}function bm(f,m,E){var L=f.pingCache;L!==null&&L.delete(m),f.pingedLanes|=f.suspendedLanes&E,f.warmLanes&=~E,Si===f&&(wi&E)===E&&(Hi===4||Hi===3&&(wi&62914560)===wi&&300>Jr()-iu?(jn&2)===0&&Fo(f,0):ca|=E,nu===wi&&(nu=0)),Qe(f)}function vu(f,m){m===0&&(m=U()),f=Fe(f,m),f!==null&&(j(f,m),Qe(f))}function fc(f){var m=f.memoizedState,E=0;m!==null&&(E=m.retryLane),vu(f,E)}function Qh(f,m){var E=0;switch(f.tag){case 13:var L=f.stateNode,$=f.memoizedState;$!==null&&(E=$.retryLane);break;case 19:L=f.stateNode;break;case 22:L=f.stateNode._retryCache;break;default:throw Error(s(314))}L!==null&&L.delete(m),vu(f,E)}function nd(f,m){return cd(f,m)}function Zh(f,m,E,L){this.tag=f,this.key=E,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=m,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=L,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Hl(f){return f=f.prototype,!(!f||!f.isReactComponent)}function qr(f,m){var E=f.alternate;return E===null?(E=t(f.tag,m,f.key,f.mode),E.elementType=f.elementType,E.type=f.type,E.stateNode=f.stateNode,E.alternate=f,f.alternate=E):(E.pendingProps=m,E.type=f.type,E.flags=0,E.subtreeFlags=0,E.deletions=null),E.flags=f.flags&31457280,E.childLanes=f.childLanes,E.lanes=f.lanes,E.child=f.child,E.memoizedProps=f.memoizedProps,E.memoizedState=f.memoizedState,E.updateQueue=f.updateQueue,m=f.dependencies,E.dependencies=m===null?null:{lanes:m.lanes,firstContext:m.firstContext},E.sibling=f.sibling,E.index=f.index,E.ref=f.ref,E.refCleanup=f.refCleanup,E}function jl(f,m){f.flags&=31457282;var E=f.alternate;return E===null?(f.childLanes=0,f.lanes=m,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=E.childLanes,f.lanes=E.lanes,f.child=E.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=E.memoizedProps,f.memoizedState=E.memoizedState,f.updateQueue=E.updateQueue,f.type=E.type,m=E.dependencies,f.dependencies=m===null?null:{lanes:m.lanes,firstContext:m.firstContext}),f}function mo(f,m,E,L,$,ie){var De=0;if(L=f,typeof f=="function")Hl(f)&&(De=1);else if(typeof f=="string")De=Ya&&Yr?Ep(f,E,Ur.current)?26:ud(f)?27:5:Ya?Ep(f,E,Ur.current)?26:5:Yr&&ud(f)?27:5;else e:switch(f){case sd:return hl(E.children,$,ie,m);case rp:De=8,$|=24;break;case eh:return f=t(12,E,m,$|2),f.elementType=eh,f.lanes=ie,f;case th:return f=t(13,E,m,$),f.elementType=th,f.lanes=ie,f;case xu:return f=t(19,E,m,$),f.elementType=xu,f.lanes=ie,f;case rf:return Zf(E,$,ie,m);default:if(typeof f=="object"&&f!==null)switch(f.$$typeof){case wm:case zo:De=10;break e;case bu:De=9;break e;case rd:De=11;break e;case sf:De=14;break e;case _o:De=16,L=null;break e}De=29,E=Error(s(130,f===null?"null":typeof f,"")),L=null}return m=t(De,E,m,$),m.elementType=f,m.type=L,m.lanes=ie,m}function hl(f,m,E,L){return f=t(7,f,L,m),f.lanes=E,f}function Zf(f,m,E,L){f=t(22,f,L,m),f.elementType=rf,f.lanes=E;var $={_visibility:1,_pendingVisibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null,_current:null,detach:function(){var ie=$._current;if(ie===null)throw Error(s(456));if(($._pendingVisibility&2)===0){var De=Fe(ie,2);De!==null&&($._pendingVisibility|=2,aa(De,ie,2))}},attach:function(){var ie=$._current;if(ie===null)throw Error(s(456));if(($._pendingVisibility&2)!==0){var De=Fe(ie,2);De!==null&&($._pendingVisibility&=-3,aa(De,ie,2))}}};return f.stateNode=$,f}function yu(f,m,E){return f=t(6,f,null,m),f.lanes=E,f}function id(f,m,E){return m=t(4,f.children!==null?f.children:[],f.key,m),m.lanes=E,m.stateNode={containerInfo:f.containerInfo,pendingChildren:null,implementation:f.implementation},m}function hc(f,m,E,L,$,ie,De,it){this.tag=1,this.containerInfo=f,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=gc,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=N(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.finishedLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=N(0),this.hiddenUpdates=N(null),this.identifierPrefix=L,this.onUncaughtError=$,this.onCaughtError=ie,this.onRecoverableError=De,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=it,this.incompleteTransitions=new Map}function Rr(f,m,E,L,$,ie,De,it,pt,Xt,mn,An){return f=new hc(f,m,E,De,it,pt,Xt,An),m=1,ie===!0&&(m|=24),ie=t(3,null,null,m),f.current=ie,ie.stateNode=f,m=ic(),m.refCount++,f.pooledCache=m,m.refCount++,ie.memoizedState={element:L,isDehydrated:E,cache:m},Vt(ie),f}function nf(f){return f?(f=yc,f):yc}function ep(f){var m=f._reactInternals;if(m===void 0)throw typeof f.render=="function"?Error(s(188)):(f=Object.keys(f).join(","),Error(s(268,f)));return f=v(m),f=f!==null?y(f):null,f===null?null:ad(f.stateNode)}function tp(f,m,E,L,$,ie){$=nf($),L.context===null?L.context=$:L.pendingContext=$,L=bt(m),L.payload={element:E},ie=ie===void 0?null:ie,ie!==null&&(L.callback=ie),E=Jt(f,L,m),E!==null&&(aa(E,f,m),Tn(E,f,m))}function xm(f,m){if(f=f.memoizedState,f!==null&&f.dehydrated!==null){var E=f.retryLane;f.retryLane=E!==0&&E<m?E:m}}function np(f,m){xm(f,m),(f=f.alternate)&&xm(f,m)}var Kn={},ip=m0(),Xr=bO(),Mu=Object.assign,sp=Symbol.for("react.element"),$l=Symbol.for("react.transitional.element"),go=Symbol.for("react.portal"),sd=Symbol.for("react.fragment"),rp=Symbol.for("react.strict_mode"),eh=Symbol.for("react.profiler"),wm=Symbol.for("react.provider"),bu=Symbol.for("react.consumer"),zo=Symbol.for("react.context"),rd=Symbol.for("react.forward_ref"),th=Symbol.for("react.suspense"),xu=Symbol.for("react.suspense_list"),sf=Symbol.for("react.memo"),_o=Symbol.for("react.lazy"),rf=Symbol.for("react.offscreen"),Em=Symbol.for("react.memo_cache_sentinel"),ap=Symbol.iterator,pc=Symbol.for("react.client.reference"),Jn=ip.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,nh,op,wu=!1,Eu=Array.isArray,af=e.rendererVersion,of=e.rendererPackageName,lf=e.extraDevToolsConfig,ad=e.getPublicInstance,mc=e.getRootHostContext,lp=e.getChildHostContext,Tu=e.prepareForCommit,up=e.resetAfterCommit,ih=e.createInstance,pl=e.appendInitialChild,Wl=e.finalizeInitialChildren,Kl=e.shouldSetTextContent,sh=e.createTextInstance,cp=e.scheduleTimeout,od=e.cancelTimeout,gc=e.noTimeout,ml=e.isPrimaryRenderer;e.warnsIfNotActing;var zr=e.supportsMutation,qa=e.supportsPersistence,Ma=e.supportsHydration,uf=e.getInstanceFromNode;e.beforeActiveInstanceBlur,e.afterActiveInstanceBlur;var dp=e.preparePortalMount;e.prepareScopeUpdate,e.getInstanceFromScope;var oa=e.setCurrentUpdatePriority,Mr=e.getCurrentUpdatePriority,Xa=e.resolveUpdatePriority;e.resolveEventType,e.resolveEventTimeStamp;var Su=e.shouldAttemptEagerTransition,rh=e.detachDeletedInstance;e.requestPostPaintCallback;var Tm=e.maySuspendCommit,ql=e.preloadInstance,la=e.startSuspendingCommit,Xs=e.suspendInstance,ah=e.waitForCommitToBeReady,Ia=e.NotPendingTransition,si=e.HostTransitionContext,_s=e.resetFormInstance;e.bindToConsole;var br=e.supportsMicrotasks,oh=e.scheduleMicrotask,gl=e.supportsTestSelectors,Au=e.findFiberRoot,lh=e.getBoundingRect,cf=e.getTextContent,Uo=e.isHiddenSubtree,s_=e.matchAccessibilityRole,tr=e.setFocusIfFocusable,fp=e.setupIntersectionObserver,uh=e.appendChild,Sm=e.appendChildToContainer,Am=e.commitTextUpdate,Cm=e.commitMount,hp=e.commitUpdate,pp=e.insertBefore,ch=e.insertInContainerBefore,ba=e.removeChild,fr=e.removeChildFromContainer,_c=e.resetTextContent,df=e.hideInstance,dh=e.hideTextInstance,mp=e.unhideInstance,_l=e.unhideTextInstance,fh=e.clearContainer,gp=e.cloneInstance,ff=e.createContainerChildSet,_p=e.appendChildToContainerChildSet,Pm=e.finalizeContainerChildren,vp=e.replaceContainerChildren,yp=e.cloneHiddenInstance,hf=e.cloneHiddenTextInstance,hh=e.isSuspenseInstancePending,pf=e.isSuspenseInstanceFallback,Rm=e.getSuspenseInstanceFallbackErrorDetails,r_=e.registerSuspenseInstanceRetry,Dm=e.canHydrateFormStateMarker,Bm=e.isFormStateMarkerMatching,Mp=e.getNextHydratableSibling,ph=e.getFirstHydratableChild,Im=e.getFirstHydratableChildWithinContainer,bp=e.getFirstHydratableChildWithinSuspenseInstance,Om=e.canHydrateInstance,Lm=e.canHydrateTextInstance,xp=e.canHydrateSuspenseInstance,a_=e.hydrateInstance,Fm=e.hydrateTextInstance,ld=e.hydrateSuspenseInstance,Nm=e.getNextHydratableInstanceAfterSuspenseInstance,mf=e.commitHydratedContainer,mh=e.commitHydratedSuspenseInstance,zm=e.clearSuspenseBoundary,gh=e.clearSuspenseBoundaryFromContainer,Um=e.shouldDeleteUnhydratedTailInstances;e.diffHydratedPropsForDevWarnings,e.diffHydratedTextForDevWarnings,e.describeHydratableInstanceForDevWarnings;var km=e.validateHydratableInstance,wp=e.validateHydratableTextInstance,Ya=e.supportsResources,Ep=e.isHostHoistableType,gf=e.getHoistableRoot,_h=e.getResource,Tp=e.acquireResource,Sp=e.releaseResource,Ap=e.hydrateHoistable,Cp=e.mountHoistable,Pp=e.unmountHoistable,o_=e.createHoistableInstance,Rp=e.prepareToCommitHoistables,Dp=e.mayResourceSuspendCommit,Bp=e.preloadResource,Ip=e.suspendResource,Yr=e.supportsSingletons,Op=e.resolveSingletonInstance,l_=e.clearSingleton,u_=e.acquireSingletonInstance,Gm=e.releaseSingletonInstance,ud=e.isHostSingletonType,vc=[],Xl=-1,yc={},xa=Math.clz32?Math.clz32:C,_f=Math.log,Vm=Math.LN2,Mc=128,vf=4194304,cd=Xr.unstable_scheduleCallback,ko=Xr.unstable_cancelCallback,Hm=Xr.unstable_shouldYield,jm=Xr.unstable_requestPaint,Jr=Xr.unstable_now,Lp=Xr.unstable_ImmediatePriority,$m=Xr.unstable_UserBlockingPriority,vh=Xr.unstable_NormalPriority,yf=Xr.unstable_IdlePriority,Wm=Xr.log,Fp=Xr.unstable_setDisableYieldValue,dd=null,Oa=null,wa=typeof Object.is=="function"?Object.is:se,yh=new WeakMap,zs=[],nr=0,Cu=null,Mf=0,Ja=[],Qa=0,Go=null,vo=1,yo="",Ur=S(null),bf=S(null),vl=S(null),fd=S(null),ua=null,Qr=null,Di=!1,Za=null,Mo=!1,xf=Error(s(519)),eo=[],Pu=0,hd=0,pd=null,Yl=null,Mh=!1,wf=!1,Vo=!1,Ru=0,Ef=null,Tf=0,La=0,Du=null,yl=!1,md=!1,Sf=Object.prototype.hasOwnProperty,is=Error(s(460)),Np=Error(s(474)),bh={then:function(){}},Bu=null,Ml=null,bo=0,Jl=re(!0),zp=re(!1),bl=S(null),Ea=S(0),to=S(null),xo=null,xr=S(0),xl=0,gi=null,Wi=null,wr=null,wo=!1,Us=!1,wl=!1,Af=0,ir=0,bc=null,Km=0,xh=function(){return{lastEffect:null,events:null,stores:null,memoCache:null}},Gi={readContext:Ar,use:Ue,useCallback:Ne,useContext:Ne,useEffect:Ne,useImperativeHandle:Ne,useLayoutEffect:Ne,useInsertionEffect:Ne,useMemo:Ne,useReducer:Ne,useRef:Ne,useState:Ne,useDebugValue:Ne,useDeferredValue:Ne,useTransition:Ne,useSyncExternalStore:Ne,useId:Ne};Gi.useCacheRefresh=Ne,Gi.useMemoCache=Ne,Gi.useHostTransitionStatus=Ne,Gi.useFormState=Ne,Gi.useActionState=Ne,Gi.useOptimistic=Ne;var Dr={readContext:Ar,use:Ue,useCallback:function(f,m){return we().memoizedState=[f,m===void 0?null:m],f},useContext:Ar,useEffect:$t,useImperativeHandle:function(f,m,E){E=E!=null?E.concat([f]):null,Ze(4194308,4,un.bind(null,m,f),E)},useLayoutEffect:function(f,m){return Ze(4194308,4,f,m)},useInsertionEffect:function(f,m){Ze(4,2,f,m)},useMemo:function(f,m){var E=we();m=m===void 0?null:m;var L=f();if(wl){le(!0);try{f()}finally{le(!1)}}return E.memoizedState=[L,m],L},useReducer:function(f,m,E){var L=we();if(E!==void 0){var $=E(m);if(wl){le(!0);try{E(m)}finally{le(!1)}}}else $=m;return L.memoizedState=L.baseState=$,f={pending:null,lanes:0,dispatch:null,lastRenderedReducer:f,lastRenderedState:$},L.queue=f,f=f.dispatch=ms.bind(null,gi,f),[L.memoizedState,f]},useRef:function(f){var m=we();return f={current:f},m.memoizedState=f},useState:function(f){f=Ct(f);var m=f.queue,E=Sr.bind(null,gi,m);return m.dispatch=E,[f.memoizedState,E]},useDebugValue:ni,useDeferredValue:function(f,m){var E=we();return Ci(E,f,m)},useTransition:function(){var f=Ct(!1);return f=Ws.bind(null,gi,f.queue,!0,!1),we().memoizedState=f,[!1,f]},useSyncExternalStore:function(f,m,E){var L=gi,$=we();if(Di){if(E===void 0)throw Error(s(407));E=E()}else{if(E=m(),Si===null)throw Error(s(349));(wi&60)!==0||_n(L,m,E)}$.memoizedState=E;var ie={value:E,getSnapshot:m};return $.queue=ie,$t(ti.bind(null,L,ie,f),[f]),L.flags|=2048,Ie(9,Fn.bind(null,L,ie,E,m),{destroy:void 0},null),E},useId:function(){var f=we(),m=Si.identifierPrefix;if(Di){var E=yo,L=vo;E=(L&~(1<<32-xa(L)-1)).toString(32)+E,m=":"+m+"R"+E,E=Af++,0<E&&(m+="H"+E.toString(32)),m+=":"}else E=Km++,m=":"+m+"r"+E.toString(32)+":";return f.memoizedState=m},useCacheRefresh:function(){return we().memoizedState=es.bind(null,gi)}};Dr.useMemoCache=Ot,Dr.useHostTransitionStatus=Kr,Dr.useFormState=ks,Dr.useActionState=ks,Dr.useOptimistic=function(f){var m=we();m.memoizedState=m.baseState=f;var E={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return m.queue=E,m=na.bind(null,gi,!0,E),E.dispatch=m,[f,m]};var Ta={readContext:Ar,use:Ue,useCallback:Ms,useContext:Ar,useEffect:vn,useImperativeHandle:Qn,useInsertionEffect:bn,useLayoutEffect:En,useMemo:bs,useReducer:tn,useRef:Ke,useState:function(){return tn(jt)},useDebugValue:ni,useDeferredValue:function(f,m){var E=Ge();return ps(E,Wi.memoizedState,f,m)},useTransition:function(){var f=tn(jt)[0],m=Ge().memoizedState;return[typeof f=="boolean"?f:Je(f),m]},useSyncExternalStore:wn,useId:Bs};Ta.useCacheRefresh=co,Ta.useMemoCache=Ot,Ta.useHostTransitionStatus=Kr,Ta.useFormState=$s,Ta.useActionState=$s,Ta.useOptimistic=function(f,m){var E=Ge();return gt(E,Wi,f,m)};var Ql={readContext:Ar,use:Ue,useCallback:Ms,useContext:Ar,useEffect:vn,useImperativeHandle:Qn,useInsertionEffect:bn,useLayoutEffect:En,useMemo:bs,useReducer:dn,useRef:Ke,useState:function(){return dn(jt)},useDebugValue:ni,useDeferredValue:function(f,m){var E=Ge();return Wi===null?Ci(E,f,m):ps(E,Wi.memoizedState,f,m)},useTransition:function(){var f=dn(jt)[0],m=Ge().memoizedState;return[typeof f=="boolean"?f:Je(f),m]},useSyncExternalStore:wn,useId:Bs};Ql.useCacheRefresh=co,Ql.useMemoCache=Ot,Ql.useHostTransitionStatus=Kr,Ql.useFormState=de,Ql.useActionState=de,Ql.useOptimistic=function(f,m){var E=Ge();return Wi!==null?gt(E,Wi,f,m):(E.baseState=f,[f,E.queue.dispatch])};var gd={isMounted:function(f){return(f=f._reactInternals)?p(f)===f:!1},enqueueSetState:function(f,m,E){f=f._reactInternals;var L=ra(),$=bt(L);$.payload=m,E!=null&&($.callback=E),m=Jt(f,$,L),m!==null&&(aa(m,f,L),Tn(m,f,L))},enqueueReplaceState:function(f,m,E){f=f._reactInternals;var L=ra(),$=bt(L);$.tag=1,$.payload=m,E!=null&&($.callback=E),m=Jt(f,$,L),m!==null&&(aa(m,f,L),Tn(m,f,L))},enqueueForceUpdate:function(f,m){f=f._reactInternals;var E=ra(),L=bt(E);L.tag=2,m!=null&&(L.callback=m),m=Jt(f,L,E),m!==null&&(aa(m,f,E),Tn(m,f,E))}},Up=typeof reportError=="function"?reportError:function(f){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var m=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof f=="object"&&f!==null&&typeof f.message=="string"?String(f.message):String(f),error:f});if(!window.dispatchEvent(m))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",f);return}console.error(f)},qm=Error(s(461)),hr=!1,kr={dehydrated:null,treeContext:null,retryLane:0},Fa=S(null),Iu=null,sr=null,wh=typeof AbortController<"u"?AbortController:function(){var f=[],m=this.signal={aborted:!1,addEventListener:function(E,L){f.push(L)}};this.abort=function(){m.aborted=!0,f.forEach(function(E){return E()})}},Zl=Xr.unstable_scheduleCallback,xc=Xr.unstable_NormalPriority,ss={$$typeof:zo,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0},_d=Jn.S;Jn.S=function(f,m){typeof m=="object"&&m!==null&&typeof m.then=="function"&&at(f,m),_d!==null&&_d(f,m)};var eu=S(null),Br=!1,Ys=!1,Ou=!1,vd=typeof WeakSet=="function"?WeakSet:Set,rr=null,wc=!1,pr=null,Na=!1,Sa=null,Lu=8192,Eh={getCacheForType:function(f){var m=Ar(ss),E=m.data.get(f);return E===void 0&&(E=f(),m.data.set(f,E)),E}},Cf=0,Pf=1,Th=2,Vi=3,rs=4;if(typeof Symbol=="function"&&Symbol.for){var _i=Symbol.for;Cf=_i("selector.component"),Pf=_i("selector.has_pseudo_class"),Th=_i("selector.role"),Vi=_i("selector.test_id"),rs=_i("selector.text")}var Oi=typeof WeakMap=="function"?WeakMap:Map,jn=0,Si=null,pi=null,wi=0,xs=0,mr=null,qi=!1,no=!1,tu=!1,Ho=0,Hi=0,io=0,so=0,ca=0,za=0,nu=0,Li=null,Eo=null,Rf=!1,iu=0,ar=1/0,To=null,ro=null,So=!1,su=null,Ec=0,Df=0,Fu=null,yd=0,Aa=null;return Kn.attemptContinuousHydration=function(f){if(f.tag===13){var m=Fe(f,67108864);m!==null&&aa(m,f,67108864),np(f,67108864)}},Kn.attemptHydrationAtCurrentPriority=function(f){if(f.tag===13){var m=ra(),E=Fe(f,m);E!==null&&aa(E,f,m),np(f,m)}},Kn.attemptSynchronousHydration=function(f){switch(f.tag){case 3:if(f=f.stateNode,f.current.memoizedState.isDehydrated){var m=x(f.pendingLanes);if(m!==0){for(f.pendingLanes|=2,f.entangledLanes|=2;m;){var E=1<<31-xa(m);f.entanglements[1]|=E,m&=~E}Qe(f),(jn&6)===0&&(ar=Jr()+500,mt(0))}}break;case 13:m=Fe(f,2),m!==null&&aa(m,f,2),Yh(),np(f,2)}},Kn.batchedUpdates=function(f,m){return f(m)},Kn.createComponentSelector=function(f){return{$$typeof:Cf,value:f}},Kn.createContainer=function(f,m,E,L,$,ie,De,it,pt,Xt){return Rr(f,m,!1,null,E,L,ie,De,it,pt,Xt,null)},Kn.createHasPseudoClassSelector=function(f){return{$$typeof:Pf,value:f}},Kn.createHydrationContainer=function(f,m,E,L,$,ie,De,it,pt,Xt,mn,An,Rn){return f=Rr(E,L,!0,f,$,ie,it,pt,Xt,mn,An,Rn),f.context=nf(null),E=f.current,L=ra(),$=bt(L),$.callback=m??null,Jt(E,$,L),f.current.lanes=L,j(f,L),Qe(f),f},Kn.createPortal=function(f,m,E){var L=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:go,key:L==null?null:""+L,children:f,containerInfo:m,implementation:E}},Kn.createRoleSelector=function(f){return{$$typeof:Th,value:f}},Kn.createTestNameSelector=function(f){return{$$typeof:Vi,value:f}},Kn.createTextSelector=function(f){return{$$typeof:rs,value:f}},Kn.defaultOnCaughtError=function(f){console.error(f)},Kn.defaultOnRecoverableError=function(f){Up(f)},Kn.defaultOnUncaughtError=function(f){Up(f)},Kn.deferredUpdates=function(f){var m=Jn.T,E=Mr();try{return oa(32),Jn.T=null,f()}finally{oa(E),Jn.T=m}},Kn.discreteUpdates=function(f,m,E,L,$){var ie=Jn.T,De=Mr();try{return oa(2),Jn.T=null,f(m,E,L,$)}finally{oa(De),Jn.T=ie,jn===0&&(ar=Jr()+500)}},Kn.findAllNodes=_a,Kn.findBoundingRects=function(f,m){if(!gl)throw Error(s(363));m=_a(f,m),f=[];for(var E=0;E<m.length;E++)f.push(lh(m[E]));for(m=f.length-1;0<m;m--){E=f[m];for(var L=E.x,$=L+E.width,ie=E.y,De=ie+E.height,it=m-1;0<=it;it--)if(m!==it){var pt=f[it],Xt=pt.x,mn=Xt+pt.width,An=pt.y,Rn=An+pt.height;if(L>=Xt&&ie>=An&&$<=mn&&De<=Rn){f.splice(m,1);break}else if(L!==Xt||E.width!==pt.width||Rn<ie||An>De){if(!(ie!==An||E.height!==pt.height||mn<L||Xt>$)){Xt>L&&(pt.width+=Xt-L,pt.x=L),mn<$&&(pt.width=$-Xt),f.splice(m,1);break}}else{An>ie&&(pt.height+=An-ie,pt.y=ie),Rn<De&&(pt.height=De-An),f.splice(m,1);break}}}return f},Kn.findHostInstance=ep,Kn.findHostInstanceWithNoPortals=function(f){return f=v(f),f=f!==null?w(f):null,f===null?null:ad(f.stateNode)},Kn.findHostInstanceWithWarning=function(f){return ep(f)},Kn.flushPassiveEffects=Nr,Kn.flushSyncFromReconciler=function(f){var m=jn;jn|=1;var E=Jn.T,L=Mr();try{if(oa(2),Jn.T=null,f)return f()}finally{oa(L),Jn.T=E,jn=m,(jn&6)===0&&mt(0)}},Kn.flushSyncWork=Yh,Kn.focusWithin=function(f,m){if(!gl)throw Error(s(363));for(f=Xf(f),m=Mm(f,m),m=Array.from(m),f=0;f<m.length;){var E=m[f++],L=E.tag;if(!Uo(E)){if((L===5||L===26||L===27)&&tr(E.stateNode))return!0;for(E=E.child;E!==null;)m.push(E),E=E.sibling}}return!1},Kn.getFindAllNodesFailureDescription=function(f,m){if(!gl)throw Error(s(363));var E=0,L=[];f=[Xf(f),0];for(var $=0;$<f.length;){var ie=f[$++],De=ie.tag,it=f[$++],pt=m[it];if((De!==5&&De!==26&&De!==27||!Uo(ie))&&(Qc(ie,pt)&&(L.push(kl(pt)),it++,it>E&&(E=it)),it<m.length))for(ie=ie.child;ie!==null;)f.push(ie,it),ie=ie.sibling}if(E<m.length){for(f=[];E<m.length;E++)f.push(kl(m[E]));return`findAllNodes was able to match part of the selector:
  `+(L.join(" > ")+`

No matching component was found for:
  `)+f.join(" > ")}return null},Kn.getPublicRootInstance=function(f){if(f=f.current,!f.child)return null;switch(f.child.tag){case 27:case 5:return ad(f.child.stateNode);default:return f.child.stateNode}},Kn.injectIntoDevTools=function(){var f={bundleType:0,version:af,rendererPackageName:of,currentDispatcherRef:Jn,findFiberByHostInstance:uf,reconcilerVersion:"19.0.0"};if(lf!==null&&(f.rendererConfig=lf),typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")f=!1;else{var m=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(m.isDisabled||!m.supportsFiber)f=!0;else{try{dd=m.inject(f),Oa=m}catch{}f=!!m.checkDCE}}return f},Kn.isAlreadyRendering=function(){return!1},Kn.observeVisibleRects=function(f,m,E,L){if(!gl)throw Error(s(363));f=_a(f,m);var $=fp(f,E,L).disconnect;return{disconnect:function(){$()}}},Kn.shouldError=function(){return null},Kn.shouldSuspend=function(){return!1},Kn.startHostTransition=function(f,m,E,L){if(f.tag!==5)throw Error(s(476));var $=Wr(f).queue;Ws(f,$,m,Ia,E===null?i:function(){var ie=Wr(f).next.queue;return Fr(f,ie,{},ra()),E(L)})},Kn.updateContainer=function(f,m,E,L){var $=m.current,ie=ra();return tp($,ie,f,m,E,L),ie},Kn.updateContainerSync=function(f,m,E,L){return m.tag===0&&Nr(),tp(m.current,2,f,m,E,L),2},Kn},n.exports.default=n.exports,Object.defineProperty(n.exports,"__esModule",{value:!0})})(Jw)),Jw.exports}var e2;function W$(){return e2||(e2=1,Yw.exports=$$()),Yw.exports}var K$=W$();const q$=Wb(K$);var t2=bO();function tS(n,e,t){if(!n)return;if(t(n)===!0)return n;let i=e?n.return:n.child;for(;i;){const s=tS(i,e,t);if(s)return s;i=e?null:i.sibling}}function xO(n){try{return Object.defineProperties(n,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return n}}const nS=xO(Ft.createContext(null));class wO extends Ft.Component{render(){return Ft.createElement(nS.Provider,{value:this._reactInternals},this.props.children)}}function EO(){const n=Ft.useContext(nS);if(n===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const e=Ft.useId();return Ft.useMemo(()=>{for(const t of[n,n?.alternate]){if(!t)continue;const i=tS(t,!1,s=>{let r=s.memoizedState;for(;r;){if(r.memoizedState===e)return!0;r=r.next}});if(i)return i}},[n,e])}const X$=Symbol.for("react.context"),Y$=n=>n!==null&&typeof n=="object"&&"$$typeof"in n&&n.$$typeof===X$;function J$(){const n=EO(),[e]=Ft.useState(()=>new Map);e.clear();let t=n;for(;t;){const i=t.type;Y$(i)&&i!==nS&&!e.has(i)&&e.set(i,Ft.use(xO(i))),t=t.return}return e}function Q$(){const n=J$();return Ft.useMemo(()=>Array.from(n.keys()).reduce((e,t)=>i=>Ft.createElement(e,null,Ft.createElement(t.Provider,{...i,value:n.get(t)})),e=>Ft.createElement(wO,{...e})),[n])}function TO(n){let e=n.root;for(;e.getState().previousRoot;)e=e.getState().previousRoot;return e}const SO=n=>n&&n.isOrthographicCamera,Z$=n=>n&&n.hasOwnProperty("current"),e8=n=>n!=null&&(typeof n=="string"||typeof n=="number"||n.isColor),Zv=((n,e)=>typeof window<"u"&&(((n=window.document)==null?void 0:n.createElement)||((e=window.navigator)==null?void 0:e.product)==="ReactNative"))()?Ft.useLayoutEffect:Ft.useEffect;function AO(n){const e=Ft.useRef(n);return Zv(()=>void(e.current=n),[n]),e}function t8(){const n=EO(),e=Q$();return Ft.useMemo(()=>({children:t})=>{const s=!!tS(n,!0,r=>r.type===Ft.StrictMode)?Ft.StrictMode:Ft.Fragment;return zt.jsx(s,{children:zt.jsx(e,{children:t})})},[n,e])}function n8({set:n}){return Zv(()=>(n(new Promise(()=>null)),()=>n(!1)),[n]),null}const i8=(n=>(n=class extends Ft.Component{constructor(...t){super(...t),this.state={error:!1}}componentDidCatch(t){this.props.set(t)}render(){return this.state.error?null:this.props.children}},n.getDerivedStateFromError=()=>({error:!0}),n))();function CO(n){var e;const t=typeof window<"u"?(e=window.devicePixelRatio)!=null?e:2:1;return Array.isArray(n)?Math.min(Math.max(n[0],t),n[1]):n}function G_(n){var e;return(e=n.__r3f)==null?void 0:e.root.getState()}const Or={obj:n=>n===Object(n)&&!Or.arr(n)&&typeof n!="function",fun:n=>typeof n=="function",str:n=>typeof n=="string",num:n=>typeof n=="number",boo:n=>typeof n=="boolean",und:n=>n===void 0,nul:n=>n===null,arr:n=>Array.isArray(n),equ(n,e,{arrays:t="shallow",objects:i="reference",strict:s=!0}={}){if(typeof n!=typeof e||!!n!=!!e)return!1;if(Or.str(n)||Or.num(n)||Or.boo(n))return n===e;const r=Or.obj(n);if(r&&i==="reference")return n===e;const o=Or.arr(n);if(o&&t==="reference")return n===e;if((o||r)&&n===e)return!0;let l;for(l in n)if(!(l in e))return!1;if(r&&t==="shallow"&&i==="shallow"){for(l in s?e:n)if(!Or.equ(n[l],e[l],{strict:s,objects:"reference"}))return!1}else for(l in s?e:n)if(n[l]!==e[l])return!1;if(Or.und(l)){if(o&&n.length===0&&e.length===0||r&&Object.keys(n).length===0&&Object.keys(e).length===0)return!0;if(n!==e)return!1}return!0}};function s8(n){const e={nodes:{},materials:{},meshes:{}};return n&&n.traverse(t=>{t.name&&(e.nodes[t.name]=t),t.material&&!e.materials[t.material.name]&&(e.materials[t.material.name]=t.material),t.isMesh&&!e.meshes[t.name]&&(e.meshes[t.name]=t)}),e}function r8(n){n.type!=="Scene"&&(n.dispose==null||n.dispose());for(const e in n){const t=n[e];t?.type!=="Scene"&&(t==null||t.dispose==null||t.dispose())}}const PO=["children","key","ref"];function a8(n){const e={};for(const t in n)PO.includes(t)||(e[t]=n[t]);return e}function Bb(n,e,t,i){const s=n;let r=s?.__r3f;return r||(r={root:e,type:t,parent:null,children:[],props:a8(i),object:s,eventCount:0,handlers:{},isHidden:!1},s&&(s.__r3f=r)),r}function Gv(n,e){if(!e.includes("-"))return{root:n,key:e,target:n[e]};if(e in n)return{root:n,key:e,target:n[e]};let t=n;const i=e.split("-");for(const s of i){if(typeof t!="object"||t===null){if(t!==void 0){const r=i.slice(i.indexOf(s)).join("-");return{root:t,key:r,target:void 0}}return{root:n,key:e,target:void 0}}e=s,n=t,t=t[e]}return{root:n,key:e,target:t}}const n2=/-\d+$/;function Ib(n,e){if(Or.str(e.props.attach)){if(n2.test(e.props.attach)){const s=e.props.attach.replace(n2,""),{root:r,key:o}=Gv(n.object,s);Array.isArray(r[o])||(r[o]=[])}const{root:t,key:i}=Gv(n.object,e.props.attach);e.previousAttach=t[i],t[i]=e.object}else Or.fun(e.props.attach)&&(e.previousAttach=e.props.attach(n.object,e.object))}function Ob(n,e){if(Or.str(e.props.attach)){const{root:t,key:i}=Gv(n.object,e.props.attach),s=e.previousAttach;s===void 0?delete t[i]:t[i]=s}else e.previousAttach==null||e.previousAttach(n.object,e.object);delete e.previousAttach}const LE=[...PO,"args","dispose","attach","object","onUpdate","dispose"],i2=new Map;function o8(n){let e=i2.get(n.constructor);try{e||(e=new n.constructor,i2.set(n.constructor,e))}catch{}return e}function l8(n,e){const t={};for(const i in e)if(!LE.includes(i)&&!Or.equ(e[i],n.props[i])){t[i]=e[i];for(const s in e)s.startsWith(`${i}-`)&&(t[s]=e[s])}for(const i in n.props){if(LE.includes(i)||e.hasOwnProperty(i))continue;const{root:s,key:r}=Gv(n.object,i);if(s.constructor&&s.constructor.length===0){const o=o8(s);Or.und(o)||(t[r]=o[r])}else t[r]=0}return t}const u8=["map","emissiveMap","sheenColorMap","specularColorMap","envMap"],c8=/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;function lm(n,e){var t;const i=n.__r3f,s=i&&TO(i).getState(),r=i?.eventCount;for(const l in e){let c=e[l];if(LE.includes(l))continue;if(i&&c8.test(l)){typeof c=="function"?i.handlers[l]=c:delete i.handlers[l],i.eventCount=Object.keys(i.handlers).length;continue}if(c===void 0)continue;let{root:d,key:g,target:p}=Gv(n,l);if(p===void 0&&(typeof d!="object"||d===null))throw Error(`R3F: Cannot set "${l}". Ensure it is an object before setting "${g}".`);if(p instanceof l0&&c instanceof l0)p.mask=c.mask;else if(p instanceof Sn&&e8(c))p.set(c);else if(p!==null&&typeof p=="object"&&typeof p.set=="function"&&typeof p.copy=="function"&&c!=null&&c.constructor&&p.constructor===c.constructor)p.copy(c);else if(p!==null&&typeof p=="object"&&typeof p.set=="function"&&Array.isArray(c))typeof p.fromArray=="function"?p.fromArray(c):p.set(...c);else if(p!==null&&typeof p=="object"&&typeof p.set=="function"&&typeof c=="number")typeof p.setScalar=="function"?p.setScalar(c):p.set(c);else{var o;d[g]=c,s&&!s.linear&&u8.includes(g)&&(o=d[g])!=null&&o.isTexture&&d[g].format===Xo&&d[g].type===Ha&&(d[g].colorSpace=Rs)}}if(i!=null&&i.parent&&s!=null&&s.internal&&(t=i.object)!=null&&t.isObject3D&&r!==i.eventCount){const l=i.object,c=s.internal.interaction.indexOf(l);c>-1&&s.internal.interaction.splice(c,1),i.eventCount&&l.raycast!==null&&s.internal.interaction.push(l)}return i&&i.props.attach===void 0&&(i.object.isBufferGeometry?i.props.attach="geometry":i.object.isMaterial&&(i.props.attach="material")),i&&w0(i),n}function w0(n){var e;if(!n.parent)return;n.props.onUpdate==null||n.props.onUpdate(n.object);const t=(e=n.root)==null||e.getState==null?void 0:e.getState();t&&t.internal.frames===0&&t.invalidate()}function d8(n,e){n.manual||(SO(n)?(n.left=e.width/-2,n.right=e.width/2,n.top=e.height/2,n.bottom=e.height/-2):n.aspect=e.width/e.height,n.updateProjectionMatrix())}const Cl=n=>n?.isObject3D;function yM(n){return(n.eventObject||n.object).uuid+"/"+n.index+n.instanceId}function RO(n,e,t,i){const s=t.get(e);s&&(t.delete(e),t.size===0&&(n.delete(i),s.target.releasePointerCapture(i)))}function f8(n,e){const{internal:t}=n.getState();t.interaction=t.interaction.filter(i=>i!==e),t.initialHits=t.initialHits.filter(i=>i!==e),t.hovered.forEach((i,s)=>{(i.eventObject===e||i.object===e)&&t.hovered.delete(s)}),t.capturedMap.forEach((i,s)=>{RO(t.capturedMap,e,i,s)})}function h8(n){function e(c){const{internal:d}=n.getState(),g=c.offsetX-d.initialClick[0],p=c.offsetY-d.initialClick[1];return Math.round(Math.sqrt(g*g+p*p))}function t(c){return c.filter(d=>["Move","Over","Enter","Out","Leave"].some(g=>{var p;return(p=d.__r3f)==null?void 0:p.handlers["onPointer"+g]}))}function i(c,d){const g=n.getState(),p=new Set,h=[],v=d?d(g.internal.interaction):g.internal.interaction;for(let M=0;M<v.length;M++){const T=G_(v[M]);T&&(T.raycaster.camera=void 0)}g.previousRoot||g.events.compute==null||g.events.compute(c,g);function y(M){const T=G_(M);if(!T||!T.events.enabled||T.raycaster.camera===null)return[];if(T.raycaster.camera===void 0){var C;T.events.compute==null||T.events.compute(c,T,(C=T.previousRoot)==null?void 0:C.getState()),T.raycaster.camera===void 0&&(T.raycaster.camera=null)}return T.raycaster.camera?T.raycaster.intersectObject(M,!0):[]}let w=v.flatMap(y).sort((M,T)=>{const C=G_(M.object),x=G_(T.object);return!C||!x?M.distance-T.distance:x.events.priority-C.events.priority||M.distance-T.distance}).filter(M=>{const T=yM(M);return p.has(T)?!1:(p.add(T),!0)});g.events.filter&&(w=g.events.filter(w,g));for(const M of w){let T=M.object;for(;T;){var S;(S=T.__r3f)!=null&&S.eventCount&&h.push({...M,eventObject:T}),T=T.parent}}if("pointerId"in c&&g.internal.capturedMap.has(c.pointerId))for(let M of g.internal.capturedMap.get(c.pointerId).values())p.has(yM(M.intersection))||h.push(M.intersection);return h}function s(c,d,g,p){if(c.length){const h={stopped:!1};for(const v of c){let y=G_(v.object);if(y||v.object.traverseAncestors(w=>{const S=G_(w);if(S)return y=S,!1}),y){const{raycaster:w,pointer:S,camera:M,internal:T}=y,C=new Oe(S.x,S.y,0).unproject(M),x=U=>{var N,j;return(N=(j=T.capturedMap.get(U))==null?void 0:j.has(v.eventObject))!=null?N:!1},R=U=>{const N={intersection:v,target:d.target};T.capturedMap.has(U)?T.capturedMap.get(U).set(v.eventObject,N):T.capturedMap.set(U,new Map([[v.eventObject,N]])),d.target.setPointerCapture(U)},P=U=>{const N=T.capturedMap.get(U);N&&RO(T.capturedMap,v.eventObject,N,U)};let D={};for(let U in d){let N=d[U];typeof N!="function"&&(D[U]=N)}let z={...v,...D,pointer:S,intersections:c,stopped:h.stopped,delta:g,unprojectedPoint:C,ray:w.ray,camera:M,stopPropagation(){const U="pointerId"in d&&T.capturedMap.get(d.pointerId);if((!U||U.has(v.eventObject))&&(z.stopped=h.stopped=!0,T.hovered.size&&Array.from(T.hovered.values()).find(N=>N.eventObject===v.eventObject))){const N=c.slice(0,c.indexOf(v));r([...N,v])}},target:{hasPointerCapture:x,setPointerCapture:R,releasePointerCapture:P},currentTarget:{hasPointerCapture:x,setPointerCapture:R,releasePointerCapture:P},nativeEvent:d};if(p(z),h.stopped===!0)break}}}return c}function r(c){const{internal:d}=n.getState();for(const g of d.hovered.values())if(!c.length||!c.find(p=>p.object===g.object&&p.index===g.index&&p.instanceId===g.instanceId)){const h=g.eventObject.__r3f;if(d.hovered.delete(yM(g)),h!=null&&h.eventCount){const v=h.handlers,y={...g,intersections:c};v.onPointerOut==null||v.onPointerOut(y),v.onPointerLeave==null||v.onPointerLeave(y)}}}function o(c,d){for(let g=0;g<d.length;g++){const p=d[g].__r3f;p==null||p.handlers.onPointerMissed==null||p.handlers.onPointerMissed(c)}}function l(c){switch(c){case"onPointerLeave":case"onPointerCancel":return()=>r([]);case"onLostPointerCapture":return d=>{const{internal:g}=n.getState();"pointerId"in d&&g.capturedMap.has(d.pointerId)&&requestAnimationFrame(()=>{g.capturedMap.has(d.pointerId)&&(g.capturedMap.delete(d.pointerId),r([]))})}}return function(g){const{onPointerMissed:p,internal:h}=n.getState();h.lastEvent.current=g;const v=c==="onPointerMove",y=c==="onClick"||c==="onContextMenu"||c==="onDoubleClick",S=i(g,v?t:void 0),M=y?e(g):0;c==="onPointerDown"&&(h.initialClick=[g.offsetX,g.offsetY],h.initialHits=S.map(C=>C.eventObject)),y&&!S.length&&M<=2&&(o(g,h.interaction),p&&p(g)),v&&r(S);function T(C){const x=C.eventObject,R=x.__r3f;if(!(R!=null&&R.eventCount))return;const P=R.handlers;if(v){if(P.onPointerOver||P.onPointerEnter||P.onPointerOut||P.onPointerLeave){const D=yM(C),z=h.hovered.get(D);z?z.stopped&&C.stopPropagation():(h.hovered.set(D,C),P.onPointerOver==null||P.onPointerOver(C),P.onPointerEnter==null||P.onPointerEnter(C))}P.onPointerMove==null||P.onPointerMove(C)}else{const D=P[c];D?(!y||h.initialHits.includes(x))&&(o(g,h.interaction.filter(z=>!h.initialHits.includes(z))),D(C)):y&&h.initialHits.includes(x)&&o(g,h.interaction.filter(z=>!h.initialHits.includes(z)))}}s(S,g,M,T)}}return{handlePointer:l}}const s2=n=>!!(n!=null&&n.render),DO=Ft.createContext(null),p8=(n,e)=>{const t=U$((l,c)=>{const d=new Oe,g=new Oe,p=new Oe;function h(M=c().camera,T=g,C=c().size){const{width:x,height:R,top:P,left:D}=C,z=x/R;T.isVector3?p.copy(T):p.set(...T);const U=M.getWorldPosition(d).distanceTo(p);if(SO(M))return{width:x/M.zoom,height:R/M.zoom,top:P,left:D,factor:1,distance:U,aspect:z};{const N=M.fov*Math.PI/180,j=2*Math.tan(N/2)*U,J=j*(x/R);return{width:J,height:j,top:P,left:D,factor:x/J,distance:U,aspect:z}}}let v;const y=M=>l(T=>({performance:{...T.performance,current:M}})),w=new Gt;return{set:l,get:c,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},scene:null,xr:null,invalidate:(M=1)=>n(c(),M),advance:(M,T)=>e(M,T,c()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new YT,pointer:w,mouse:w,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const M=c();v&&clearTimeout(v),M.performance.current!==M.performance.min&&y(M.performance.min),v=setTimeout(()=>y(c().performance.max),M.performance.debounce)}},size:{width:0,height:0,top:0,left:0},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:h},setEvents:M=>l(T=>({...T,events:{...T.events,...M}})),setSize:(M,T,C=0,x=0)=>{const R=c().camera,P={width:M,height:T,top:C,left:x};l(D=>({size:P,viewport:{...D.viewport,...h(R,g,P)}}))},setDpr:M=>l(T=>{const C=CO(M);return{viewport:{...T.viewport,dpr:C,initialDpr:T.viewport.initialDpr||C}}}),setFrameloop:(M="always")=>{const T=c().clock;T.stop(),T.elapsedTime=0,M!=="never"&&(T.start(),T.elapsedTime=0),l(()=>({frameloop:M}))},previousRoot:void 0,internal:{interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,lastEvent:Ft.createRef(),active:!1,frames:0,priority:0,subscribe:(M,T,C)=>{const x=c().internal;return x.priority=x.priority+(T>0?1:0),x.subscribers.push({ref:M,priority:T,store:C}),x.subscribers=x.subscribers.sort((R,P)=>R.priority-P.priority),()=>{const R=c().internal;R!=null&&R.subscribers&&(R.priority=R.priority-(T>0?1:0),R.subscribers=R.subscribers.filter(P=>P.ref!==M))}}}}}),i=t.getState();let s=i.size,r=i.viewport.dpr,o=i.camera;return t.subscribe(()=>{const{camera:l,size:c,viewport:d,gl:g,set:p}=t.getState();if(c.width!==s.width||c.height!==s.height||d.dpr!==r){s=c,r=d.dpr,d8(l,c),d.dpr>0&&g.setPixelRatio(d.dpr);const h=typeof HTMLCanvasElement<"u"&&g.domElement instanceof HTMLCanvasElement;g.setSize(c.width,c.height,h)}l!==o&&(o=l,p(h=>({viewport:{...h.viewport,...h.viewport.getCurrentViewport(l)}})))}),t.subscribe(l=>n(l)),t};function BO(){const n=Ft.useContext(DO);if(!n)throw new Error("R3F: Hooks can only be used within the Canvas component!");return n}function ju(n=t=>t,e){return BO()(n,e)}function ey(n,e=0){const t=BO(),i=t.getState().internal.subscribe,s=AO(n);return Zv(()=>i(s,e,t),[e,i,t]),null}const r2=new WeakMap,m8=n=>{var e;return typeof n=="function"&&(n==null||(e=n.prototype)==null?void 0:e.constructor)===n};function IO(n,e){return function(t,...i){let s;return m8(t)?(s=r2.get(t),s||(s=new t,r2.set(t,s))):s=t,n&&n(s),Promise.all(i.map(r=>new Promise((o,l)=>s.load(r,c=>{Cl(c?.scene)&&Object.assign(c,s8(c.scene)),o(c)},e,c=>l(new Error(`Could not load ${r}: ${c?.message}`))))))}}function ty(n,e,t,i){const s=Array.isArray(e)?e:[e],r=G$(IO(t,i),[n,...s],{equal:Or.equ});return Array.isArray(e)?r:r[0]}ty.preload=function(n,e,t){const i=Array.isArray(e)?e:[e];return V$(IO(t),[n,...i])};ty.clear=function(n,e){const t=Array.isArray(e)?e:[e];return H$([n,...t])};function g8(n){const e=q$(n);return e.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:Ft.version}),e}const OO=0,f0={},_8=/^three(?=[A-Z])/,Cx=n=>`${n[0].toUpperCase()}${n.slice(1)}`;let v8=0;const y8=n=>typeof n=="function";function LO(n){if(y8(n)){const e=`${v8++}`;return f0[e]=n,e}else Object.assign(f0,n)}function FO(n,e){const t=Cx(n),i=f0[t];if(n!=="primitive"&&!i)throw new Error(`R3F: ${t} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(n==="primitive"&&!e.object)throw new Error("R3F: Primitives without 'object' are invalid!");if(e.args!==void 0&&!Array.isArray(e.args))throw new Error("R3F: The args prop must be an array!")}function M8(n,e,t){var i;return n=Cx(n)in f0?n:n.replace(_8,""),FO(n,e),n==="primitive"&&(i=e.object)!=null&&i.__r3f&&delete e.object.__r3f,Bb(e.object,t,n,e)}function b8(n){if(!n.isHidden){var e;n.props.attach&&(e=n.parent)!=null&&e.object?Ob(n.parent,n):Cl(n.object)&&(n.object.visible=!1),n.isHidden=!0,w0(n)}}function NO(n){if(n.isHidden){var e;n.props.attach&&(e=n.parent)!=null&&e.object?Ib(n.parent,n):Cl(n.object)&&n.props.visible!==!1&&(n.object.visible=!0),n.isHidden=!1,w0(n)}}function iS(n,e,t){const i=e.root.getState();if(!(!n.parent&&n.object!==i.scene)){if(!e.object){var s,r;const o=f0[Cx(e.type)];e.object=(s=e.props.object)!=null?s:new o(...(r=e.props.args)!=null?r:[]),e.object.__r3f=e}if(lm(e.object,e.props),e.props.attach)Ib(n,e);else if(Cl(e.object)&&Cl(n.object)){const o=n.object.children.indexOf(t?.object);if(t&&o!==-1){const l=n.object.children.indexOf(e.object);if(l!==-1){n.object.children.splice(l,1);const c=l<o?o-1:o;n.object.children.splice(c,0,e.object)}else e.object.parent=n.object,n.object.children.splice(o,0,e.object),e.object.dispatchEvent({type:"added"}),n.object.dispatchEvent({type:"childadded",child:e.object})}else n.object.add(e.object)}for(const o of e.children)iS(e,o);w0(e)}}function e1(n,e){e&&(e.parent=n,n.children.push(e),iS(n,e))}function a2(n,e,t){if(!e||!t)return;e.parent=n;const i=n.children.indexOf(t);i!==-1?n.children.splice(i,0,e):n.children.push(e),iS(n,e,t)}function zO(n){if(typeof n.dispose=="function"){const e=()=>{try{n.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT<"u"?e():t2.unstable_scheduleCallback(t2.unstable_IdlePriority,e)}}function FE(n,e,t){if(!e)return;e.parent=null;const i=n.children.indexOf(e);i!==-1&&n.children.splice(i,1),e.props.attach?Ob(n,e):Cl(e.object)&&Cl(n.object)&&(n.object.remove(e.object),f8(TO(e),e.object));const s=e.props.dispose!==null&&t!==!1;for(let r=e.children.length-1;r>=0;r--){const o=e.children[r];FE(e,o,s)}e.children.length=0,delete e.object.__r3f,s&&e.type!=="primitive"&&e.object.type!=="Scene"&&zO(e.object),t===void 0&&w0(e)}function x8(n,e){for(const t of[n,n.alternate])if(t!==null)if(typeof t.ref=="function"){t.refCleanup==null||t.refCleanup();const i=t.ref(e);typeof i=="function"&&(t.refCleanup=i)}else t.ref&&(t.ref.current=e)}const VM=[];function w8(){for(const[t]of VM){const i=t.parent;if(i){t.props.attach?Ob(i,t):Cl(t.object)&&Cl(i.object)&&i.object.remove(t.object);for(const s of t.children)s.props.attach?Ob(t,s):Cl(s.object)&&Cl(t.object)&&t.object.remove(s.object)}t.isHidden&&NO(t),t.object.__r3f&&delete t.object.__r3f,t.type!=="primitive"&&zO(t.object)}for(const[t,i,s]of VM){t.props=i;const r=t.parent;if(r){var n,e;const o=f0[Cx(t.type)];t.object=(n=t.props.object)!=null?n:new o(...(e=t.props.args)!=null?e:[]),t.object.__r3f=t,x8(s,t.object),lm(t.object,t.props),t.props.attach?Ib(r,t):Cl(t.object)&&Cl(r.object)&&r.object.add(t.object);for(const l of t.children)l.props.attach?Ib(t,l):Cl(l.object)&&Cl(t.object)&&t.object.add(l.object);w0(t)}}VM.length=0}const t1=()=>{},o2={};let MM=OO;const E8=0,T8=4,NE=g8({isPrimaryRenderer:!1,warnsIfNotActing:!1,supportsMutation:!0,supportsPersistence:!1,supportsHydration:!1,createInstance:M8,removeChild:FE,appendChild:e1,appendInitialChild:e1,insertBefore:a2,appendChildToContainer(n,e){const t=n.getState().scene.__r3f;!e||!t||e1(t,e)},removeChildFromContainer(n,e){const t=n.getState().scene.__r3f;!e||!t||FE(t,e)},insertInContainerBefore(n,e,t){const i=n.getState().scene.__r3f;!e||!t||!i||a2(i,e,t)},getRootHostContext:()=>o2,getChildHostContext:()=>o2,commitUpdate(n,e,t,i,s){var r,o,l;FO(e,i);let c=!1;if((n.type==="primitive"&&t.object!==i.object||((r=i.args)==null?void 0:r.length)!==((o=t.args)==null?void 0:o.length)||(l=i.args)!=null&&l.some((g,p)=>{var h;return g!==((h=t.args)==null?void 0:h[p])}))&&(c=!0),c)VM.push([n,{...i},s]);else{const g=l8(n,i);Object.keys(g).length&&(Object.assign(n.props,g),lm(n.object,g))}(s.sibling===null||(s.flags&T8)===E8)&&w8()},finalizeInitialChildren:()=>!1,commitMount(){},getPublicInstance:n=>n?.object,prepareForCommit:()=>null,preparePortalMount:n=>Bb(n.getState().scene,n,"",{}),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance:b8,unhideInstance:NO,createTextInstance:t1,hideTextInstance:t1,unhideTextInstance:t1,scheduleTimeout:typeof setTimeout=="function"?setTimeout:void 0,cancelTimeout:typeof clearTimeout=="function"?clearTimeout:void 0,noTimeout:-1,getInstanceFromNode:()=>null,beforeActiveInstanceBlur(){},afterActiveInstanceBlur(){},detachDeletedInstance(){},prepareScopeUpdate(){},getInstanceFromScope:()=>null,shouldAttemptEagerTransition:()=>!1,trackSchedulerEvent:()=>{},resolveEventType:()=>null,resolveEventTimeStamp:()=>-1.1,requestPostPaintCallback(){},maySuspendCommit:()=>!1,preloadInstance:()=>!0,startSuspendingCommit(){},suspendInstance(){},waitForCommitToBeReady:()=>null,NotPendingTransition:null,HostTransitionContext:Ft.createContext(null),setCurrentUpdatePriority(n){MM=n},getCurrentUpdatePriority(){return MM},resolveUpdatePriority(){var n;if(MM!==OO)return MM;switch(typeof window<"u"&&((n=window.event)==null?void 0:n.type)){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return zM.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return zM.ContinuousEventPriority;default:return zM.DefaultEventPriority}},resetFormInstance(){}}),Wg=new Map,V_={objects:"shallow",strict:!1};function S8(n,e){if(!e&&typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement&&n.parentElement){const{width:t,height:i,top:s,left:r}=n.parentElement.getBoundingClientRect();return{width:t,height:i,top:s,left:r}}else if(!e&&typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas)return{width:n.width,height:n.height,top:0,left:0};return{width:0,height:0,top:0,left:0,...e}}function A8(n){const e=Wg.get(n),t=e?.fiber,i=e?.store;e&&console.warn("R3F.createRoot should only be called once!");const s=typeof reportError=="function"?reportError:console.error,r=i||p8(kE,u2),o=t||NE.createContainer(r,zM.ConcurrentRoot,null,!1,null,"",s,s,s,null);e||Wg.set(n,{fiber:o,store:r});let l,c,d=!1,g=null;return{async configure(p={}){let h;g=new Promise(ee=>h=ee);let{gl:v,size:y,scene:w,events:S,onCreated:M,shadows:T=!1,linear:C=!1,flat:x=!1,legacy:R=!1,orthographic:P=!1,frameloop:D="always",dpr:z=[1,2],performance:U,raycaster:N,camera:j,onPointerMissed:J}=p,W=r.getState(),oe=W.gl;if(!W.gl){const ee={canvas:n,powerPreference:"high-performance",antialias:!0,alpha:!0},te=typeof v=="function"?await v(ee):v;s2(te)?oe=te:oe=new vO({...ee,...v}),W.set({gl:oe})}let ne=W.raycaster;ne||W.set({raycaster:ne=new uO});const{params:q,...le}=N||{};if(Or.equ(le,ne,V_)||lm(ne,{...le}),Or.equ(q,ne.params,V_)||lm(ne,{params:{...ne.params,...q}}),!W.camera||W.camera===c&&!Or.equ(c,j,V_)){c=j;const ee=j?.isCamera,te=ee?j:P?new Lc(0,0,0,0,.1,1e3):new Er(75,0,.1,1e3);ee||(te.position.z=5,j&&(lm(te,j),te.manual||("aspect"in j||"left"in j||"right"in j||"bottom"in j||"top"in j)&&(te.manual=!0,te.updateProjectionMatrix())),!W.camera&&!(j!=null&&j.rotation)&&te.lookAt(0,0,0)),W.set({camera:te}),ne.camera=te}if(!W.scene){let ee;w!=null&&w.isScene?(ee=w,Bb(ee,r,"",{})):(ee=new Fv,Bb(ee,r,"",{}),w&&lm(ee,w)),W.set({scene:ee})}S&&!W.events.handlers&&W.set({events:S(r)});const se=S8(n,y);if(Or.equ(se,W.size,V_)||W.setSize(se.width,se.height,se.top,se.left),z&&W.viewport.dpr!==CO(z)&&W.setDpr(z),W.frameloop!==D&&W.setFrameloop(D),W.onPointerMissed||W.set({onPointerMissed:J}),U&&!Or.equ(U,W.performance,V_)&&W.set(ee=>({performance:{...ee.performance,...U}})),!W.xr){var pe;const ee=(ae,ce)=>{const Be=r.getState();Be.frameloop!=="never"&&u2(ae,!0,Be,ce)},te=()=>{const ae=r.getState();ae.gl.xr.enabled=ae.gl.xr.isPresenting,ae.gl.xr.setAnimationLoop(ae.gl.xr.isPresenting?ee:null),ae.gl.xr.isPresenting||kE(ae)},ue={connect(){const ae=r.getState().gl;ae.xr.addEventListener("sessionstart",te),ae.xr.addEventListener("sessionend",te)},disconnect(){const ae=r.getState().gl;ae.xr.removeEventListener("sessionstart",te),ae.xr.removeEventListener("sessionend",te)}};typeof((pe=oe.xr)==null?void 0:pe.addEventListener)=="function"&&ue.connect(),W.set({xr:ue})}if(oe.shadowMap){const ee=oe.shadowMap.enabled,te=oe.shadowMap.type;if(oe.shadowMap.enabled=!!T,Or.boo(T))oe.shadowMap.type=_v;else if(Or.str(T)){var be;const ue={basic:AB,percentage:Kb,soft:_v,variance:Pd};oe.shadowMap.type=(be=ue[T])!=null?be:_v}else Or.obj(T)&&Object.assign(oe.shadowMap,T);(ee!==oe.shadowMap.enabled||te!==oe.shadowMap.type)&&(oe.shadowMap.needsUpdate=!0)}return us.enabled=!R,d||(oe.outputColorSpace=C?Gf:Rs,oe.toneMapping=x?Ld:dT),W.legacy!==R&&W.set(()=>({legacy:R})),W.linear!==C&&W.set(()=>({linear:C})),W.flat!==x&&W.set(()=>({flat:x})),v&&!Or.fun(v)&&!s2(v)&&!Or.equ(v,oe,V_)&&lm(oe,v),l=M,d=!0,h(),this},render(p){return!d&&!g&&this.configure(),g.then(()=>{NE.updateContainer(zt.jsx(C8,{store:r,children:p,onCreated:l,rootElement:n}),o,null,()=>{})}),r},unmount(){UO(n)}}}function C8({store:n,children:e,onCreated:t,rootElement:i}){return Zv(()=>{const s=n.getState();s.set(r=>({internal:{...r.internal,active:!0}})),t&&t(s),n.getState().events.connected||s.events.connect==null||s.events.connect(i)},[]),zt.jsx(DO.Provider,{value:n,children:e})}function UO(n,e){const t=Wg.get(n),i=t?.fiber;if(i){const s=t?.store.getState();s&&(s.internal.active=!1),NE.updateContainer(null,i,null,()=>{s&&setTimeout(()=>{try{var r,o,l,c;s.events.disconnect==null||s.events.disconnect(),(r=s.gl)==null||(o=r.renderLists)==null||o.dispose==null||o.dispose(),(l=s.gl)==null||l.forceContextLoss==null||l.forceContextLoss(),(c=s.gl)!=null&&c.xr&&s.xr.disconnect(),r8(s.scene),Wg.delete(n)}catch{}},500)})}}const P8=new Set,R8=new Set,D8=new Set;function n1(n,e){if(n.size)for(const{callback:t}of n.values())t(e)}function Sv(n,e){switch(n){case"before":return n1(P8,e);case"after":return n1(R8,e);case"tail":return n1(D8,e)}}let i1,s1;function zE(n,e,t){let i=e.clock.getDelta();e.frameloop==="never"&&typeof n=="number"&&(i=n-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=n),i1=e.internal.subscribers;for(let s=0;s<i1.length;s++)s1=i1[s],s1.ref.current(s1.store.getState(),i,t);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),e.frameloop==="always"?1:e.internal.frames}let Lb=!1,UE=!1,r1,l2,H_;function kO(n){l2=requestAnimationFrame(kO),Lb=!0,r1=0,Sv("before",n),UE=!0;for(const t of Wg.values()){var e;H_=t.store.getState(),H_.internal.active&&(H_.frameloop==="always"||H_.internal.frames>0)&&!((e=H_.gl.xr)!=null&&e.isPresenting)&&(r1+=zE(n,H_))}if(UE=!1,Sv("after",n),r1===0)return Sv("tail",n),Lb=!1,cancelAnimationFrame(l2)}function kE(n,e=1){var t;if(!n)return Wg.forEach(i=>kE(i.store.getState(),e));(t=n.gl.xr)!=null&&t.isPresenting||!n.internal.active||n.frameloop==="never"||(e>1?n.internal.frames=Math.min(60,n.internal.frames+e):UE?n.internal.frames=2:n.internal.frames=1,Lb||(Lb=!0,requestAnimationFrame(kO)))}function u2(n,e=!0,t,i){if(e&&Sv("before",n),t)zE(n,t,i);else for(const s of Wg.values())zE(n,s.store.getState());e&&Sv("after",n)}const a1={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function B8(n){const{handlePointer:e}=h8(n);return{priority:1,enabled:!0,compute(t,i,s){i.pointer.set(t.offsetX/i.size.width*2-1,-(t.offsetY/i.size.height)*2+1),i.raycaster.setFromCamera(i.pointer,i.camera)},connected:void 0,handlers:Object.keys(a1).reduce((t,i)=>({...t,[i]:e(i)}),{}),update:()=>{var t;const{events:i,internal:s}=n.getState();(t=s.lastEvent)!=null&&t.current&&i.handlers&&i.handlers.onPointerMove(s.lastEvent.current)},connect:t=>{const{set:i,events:s}=n.getState();if(s.disconnect==null||s.disconnect(),i(r=>({events:{...r.events,connected:t}})),s.handlers)for(const r in s.handlers){const o=s.handlers[r],[l,c]=a1[r];t.addEventListener(l,o,{passive:c})}},disconnect:()=>{const{set:t,events:i}=n.getState();if(i.connected){if(i.handlers)for(const s in i.handlers){const r=i.handlers[s],[o]=a1[s];i.connected.removeEventListener(o,r)}t(s=>({events:{...s.events,connected:void 0}}))}}}}function c2(n,e){let t;return(...i)=>{window.clearTimeout(t),t=window.setTimeout(()=>n(...i),e)}}function I8({debounce:n,scroll:e,polyfill:t,offsetSize:i}={debounce:0,scroll:!1,offsetSize:!1}){const s=t||(typeof window>"u"?class{}:window.ResizeObserver);if(!s)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[r,o]=Ft.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),l=Ft.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:r,orientationHandler:null}),c=n?typeof n=="number"?n:n.scroll:null,d=n?typeof n=="number"?n:n.resize:null,g=Ft.useRef(!1);Ft.useEffect(()=>(g.current=!0,()=>void(g.current=!1)));const[p,h,v]=Ft.useMemo(()=>{const M=()=>{if(!l.current.element)return;const{left:T,top:C,width:x,height:R,bottom:P,right:D,x:z,y:U}=l.current.element.getBoundingClientRect(),N={left:T,top:C,width:x,height:R,bottom:P,right:D,x:z,y:U};l.current.element instanceof HTMLElement&&i&&(N.height=l.current.element.offsetHeight,N.width=l.current.element.offsetWidth),Object.freeze(N),g.current&&!N8(l.current.lastBounds,N)&&o(l.current.lastBounds=N)};return[M,d?c2(M,d):M,c?c2(M,c):M]},[o,i,c,d]);function y(){l.current.scrollContainers&&(l.current.scrollContainers.forEach(M=>M.removeEventListener("scroll",v,!0)),l.current.scrollContainers=null),l.current.resizeObserver&&(l.current.resizeObserver.disconnect(),l.current.resizeObserver=null),l.current.orientationHandler&&("orientation"in screen&&"removeEventListener"in screen.orientation?screen.orientation.removeEventListener("change",l.current.orientationHandler):"onorientationchange"in window&&window.removeEventListener("orientationchange",l.current.orientationHandler))}function w(){l.current.element&&(l.current.resizeObserver=new s(v),l.current.resizeObserver.observe(l.current.element),e&&l.current.scrollContainers&&l.current.scrollContainers.forEach(M=>M.addEventListener("scroll",v,{capture:!0,passive:!0})),l.current.orientationHandler=()=>{v()},"orientation"in screen&&"addEventListener"in screen.orientation?screen.orientation.addEventListener("change",l.current.orientationHandler):"onorientationchange"in window&&window.addEventListener("orientationchange",l.current.orientationHandler))}const S=M=>{!M||M===l.current.element||(y(),l.current.element=M,l.current.scrollContainers=GO(M),w())};return L8(v,!!e),O8(h),Ft.useEffect(()=>{y(),w()},[e,v,h]),Ft.useEffect(()=>y,[]),[S,r,p]}function O8(n){Ft.useEffect(()=>{const e=n;return window.addEventListener("resize",e),()=>void window.removeEventListener("resize",e)},[n])}function L8(n,e){Ft.useEffect(()=>{if(e){const t=n;return window.addEventListener("scroll",t,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",t,!0)}},[n,e])}function GO(n){const e=[];if(!n||n===document.body)return e;const{overflow:t,overflowX:i,overflowY:s}=window.getComputedStyle(n);return[t,i,s].some(r=>r==="auto"||r==="scroll")&&e.push(n),[...e,...GO(n.parentElement)]}const F8=["x","y","top","bottom","left","right","width","height"],N8=(n,e)=>F8.every(t=>n[t]===e[t]);function z8({ref:n,children:e,fallback:t,resize:i,style:s,gl:r,events:o=B8,eventSource:l,eventPrefix:c,shadows:d,linear:g,flat:p,legacy:h,orthographic:v,frameloop:y,dpr:w,performance:S,raycaster:M,camera:T,scene:C,onPointerMissed:x,onCreated:R,...P}){Ft.useMemo(()=>LO(C$),[]);const D=t8(),[z,U]=I8({scroll:!0,debounce:{scroll:50,resize:0},...i}),N=Ft.useRef(null),j=Ft.useRef(null);Ft.useImperativeHandle(n,()=>N.current);const J=AO(x),[W,oe]=Ft.useState(!1),[ne,q]=Ft.useState(!1);if(W)throw W;if(ne)throw ne;const le=Ft.useRef(null);Zv(()=>{const pe=N.current;if(U.width>0&&U.height>0&&pe){le.current||(le.current=A8(pe));async function be(){await le.current.configure({gl:r,scene:C,events:o,shadows:d,linear:g,flat:p,legacy:h,orthographic:v,frameloop:y,dpr:w,performance:S,raycaster:M,camera:T,size:U,onPointerMissed:(...ee)=>J.current==null?void 0:J.current(...ee),onCreated:ee=>{ee.events.connect==null||ee.events.connect(l?Z$(l)?l.current:l:j.current),c&&ee.setEvents({compute:(te,ue)=>{const ae=te[c+"X"],ce=te[c+"Y"];ue.pointer.set(ae/ue.size.width*2-1,-(ce/ue.size.height)*2+1),ue.raycaster.setFromCamera(ue.pointer,ue.camera)}}),R?.(ee)}}),le.current.render(zt.jsx(D,{children:zt.jsx(i8,{set:q,children:zt.jsx(Ft.Suspense,{fallback:zt.jsx(n8,{set:oe}),children:e??null})})}))}be()}}),Ft.useEffect(()=>{const pe=N.current;if(pe)return()=>UO(pe)},[]);const se=l?"none":"auto";return zt.jsx("div",{ref:j,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:se,...s},...P,children:zt.jsx("div",{ref:z,style:{width:"100%",height:"100%"},children:zt.jsx("canvas",{ref:N,style:{display:"block"},children:t})})})}function U8(n){return zt.jsx(wO,{children:zt.jsx(z8,{...n})})}function Fb(){return Fb=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)({}).hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n},Fb.apply(null,arguments)}const ny=new Oe,sS=new Oe,k8=new Oe,d2=new Gt;function G8(n,e,t){const i=ny.setFromMatrixPosition(n.matrixWorld);i.project(e);const s=t.width/2,r=t.height/2;return[i.x*s+s,-(i.y*r)+r]}function V8(n,e){const t=ny.setFromMatrixPosition(n.matrixWorld),i=sS.setFromMatrixPosition(e.matrixWorld),s=t.sub(i),r=e.getWorldDirection(k8);return s.angleTo(r)>Math.PI/2}function H8(n,e,t,i){const s=ny.setFromMatrixPosition(n.matrixWorld),r=s.clone();r.project(e),d2.set(r.x,r.y),t.setFromCamera(d2,e);const o=t.intersectObjects(i,!0);if(o.length){const l=o[0].distance;return s.distanceTo(t.ray.origin)<l}return!0}function j8(n,e){if(e instanceof Lc)return e.zoom;if(e instanceof Er){const t=ny.setFromMatrixPosition(n.matrixWorld),i=sS.setFromMatrixPosition(e.matrixWorld),s=e.fov*Math.PI/180,r=t.distanceTo(i);return 1/(2*Math.tan(s/2)*r)}else return 1}function $8(n,e,t){if(e instanceof Er||e instanceof Lc){const i=ny.setFromMatrixPosition(n.matrixWorld),s=sS.setFromMatrixPosition(e.matrixWorld),r=i.distanceTo(s),o=(t[1]-t[0])/(e.far-e.near),l=t[1]-o*e.far;return Math.round(o*r+l)}}const GE=n=>Math.abs(n)<1e-10?0:n;function VO(n,e,t=""){let i="matrix3d(";for(let s=0;s!==16;s++)i+=GE(e[s]*n.elements[s])+(s!==15?",":")");return t+i}const W8=(n=>e=>VO(e,n))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),K8=(n=>(e,t)=>VO(e,n(t),"translate(-50%,-50%)"))(n=>[1/n,1/n,1/n,1,-1/n,-1/n,-1/n,-1,1/n,1/n,1/n,1,1,1,1,1]);function q8(n){return n&&typeof n=="object"&&"current"in n}const HO=Ft.forwardRef(({children:n,eps:e=.001,style:t,className:i,prepend:s,center:r,fullscreen:o,portal:l,distanceFactor:c,sprite:d=!1,transform:g=!1,occlude:p,onOcclude:h,castShadow:v,receiveShadow:y,material:w,geometry:S,zIndexRange:M=[16777271,0],calculatePosition:T=G8,as:C="div",wrapperClass:x,pointerEvents:R="auto",...P},D)=>{const{gl:z,camera:U,scene:N,size:j,raycaster:J,events:W,viewport:oe}=ju(),[ne]=Ft.useState(()=>document.createElement(C)),q=Ft.useRef(null),le=Ft.useRef(null),se=Ft.useRef(0),pe=Ft.useRef([0,0]),be=Ft.useRef(null),ee=Ft.useRef(null),te=l?.current||W.connected||z.domElement.parentNode,ue=Ft.useRef(null),ae=Ft.useRef(!1),ce=Ft.useMemo(()=>p&&p!=="blending"||Array.isArray(p)&&p.length&&q8(p[0]),[p]);Ft.useLayoutEffect(()=>{const tt=z.domElement;p&&p==="blending"?(tt.style.zIndex=`${Math.floor(M[0]/2)}`,tt.style.position="absolute",tt.style.pointerEvents="none"):(tt.style.zIndex=null,tt.style.position=null,tt.style.pointerEvents=null)},[p]),Ft.useLayoutEffect(()=>{if(le.current){const tt=q.current=EB.createRoot(ne);if(N.updateMatrixWorld(),g)ne.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const Ae=T(le.current,U,j);ne.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${Ae[0]}px,${Ae[1]}px,0);transform-origin:0 0;`}return te&&(s?te.prepend(ne):te.appendChild(ne)),()=>{te&&te.removeChild(ne),tt.unmount()}}},[te,g]),Ft.useLayoutEffect(()=>{x&&(ne.className=x)},[x]);const Be=Ft.useMemo(()=>g?{position:"absolute",top:0,left:0,width:j.width,height:j.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:r?"translate3d(-50%,-50%,0)":"none",...o&&{top:-j.height/2,left:-j.width/2,width:j.width,height:j.height},...t},[t,r,o,j,g]),He=Ft.useMemo(()=>({position:"absolute",pointerEvents:R}),[R]);Ft.useLayoutEffect(()=>{if(ae.current=!1,g){var tt;(tt=q.current)==null||tt.render(Ft.createElement("div",{ref:be,style:Be},Ft.createElement("div",{ref:ee,style:He},Ft.createElement("div",{ref:D,className:i,style:t,children:n}))))}else{var Ae;(Ae=q.current)==null||Ae.render(Ft.createElement("div",{ref:D,style:Be,className:i,children:n}))}});const Xe=Ft.useRef(!0);ey(tt=>{if(le.current){U.updateMatrixWorld(),le.current.updateWorldMatrix(!0,!1);const Ae=g?pe.current:T(le.current,U,j);if(g||Math.abs(se.current-U.zoom)>e||Math.abs(pe.current[0]-Ae[0])>e||Math.abs(pe.current[1]-Ae[1])>e){const ye=V8(le.current,U);let xe=!1;ce&&(Array.isArray(p)?xe=p.map(Fe=>Fe.current):p!=="blending"&&(xe=[N]));const ke=Xe.current;if(xe){const Fe=H8(le.current,U,J,xe);Xe.current=Fe&&!ye}else Xe.current=!ye;ke!==Xe.current&&(h?h(!Xe.current):ne.style.display=Xe.current?"block":"none");const ze=Math.floor(M[0]/2),je=p?ce?[M[0],ze]:[ze-1,0]:M;if(ne.style.zIndex=`${$8(le.current,U,je)}`,g){const[Fe,Ye]=[j.width/2,j.height/2],Ve=U.projectionMatrix.elements[5]*Ye,{isOrthographicCamera:Qe,top:mt,left:Tt,bottom:Me,right:me}=U,$e=W8(U.matrixWorldInverse),et=Qe?`scale(${Ve})translate(${GE(-(me+Tt)/2)}px,${GE((mt+Me)/2)}px)`:`translateZ(${Ve}px)`;let ht=le.current.matrixWorld;d&&(ht=U.matrixWorldInverse.clone().transpose().copyPosition(ht).scale(le.current.scale),ht.elements[3]=ht.elements[7]=ht.elements[11]=0,ht.elements[15]=1),ne.style.width=j.width+"px",ne.style.height=j.height+"px",ne.style.perspective=Qe?"":`${Ve}px`,be.current&&ee.current&&(be.current.style.transform=`${et}${$e}translate(${Fe}px,${Ye}px)`,ee.current.style.transform=K8(ht,1/((c||10)/400)))}else{const Fe=c===void 0?1:j8(le.current,U)*c;ne.style.transform=`translate3d(${Ae[0]}px,${Ae[1]}px,0) scale(${Fe})`}pe.current=Ae,se.current=U.zoom}}if(!ce&&ue.current&&!ae.current)if(g){if(be.current){const Ae=be.current.children[0];if(Ae!=null&&Ae.clientWidth&&Ae!=null&&Ae.clientHeight){const{isOrthographicCamera:ye}=U;if(ye||S)P.scale&&(Array.isArray(P.scale)?P.scale instanceof Oe?ue.current.scale.copy(P.scale.clone().divideScalar(1)):ue.current.scale.set(1/P.scale[0],1/P.scale[1],1/P.scale[2]):ue.current.scale.setScalar(1/P.scale));else{const xe=(c||10)/400,ke=Ae.clientWidth*xe,ze=Ae.clientHeight*xe;ue.current.scale.set(ke,ze,1)}ae.current=!0}}}else{const Ae=ne.children[0];if(Ae!=null&&Ae.clientWidth&&Ae!=null&&Ae.clientHeight){const ye=1/oe.factor,xe=Ae.clientWidth*ye,ke=Ae.clientHeight*ye;ue.current.scale.set(xe,ke,1),ae.current=!0}ue.current.lookAt(tt.camera.position)}});const ot=Ft.useMemo(()=>({vertexShader:g?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[g]);return Ft.createElement("group",Fb({},P,{ref:le}),p&&!ce&&Ft.createElement("mesh",{castShadow:v,receiveShadow:y,ref:ue},S||Ft.createElement("planeGeometry",null),w||Ft.createElement("shaderMaterial",{side:Ro,vertexShader:ot.vertexShader,fragmentShader:ot.fragmentShader})))}),X8=parseInt(Yg.replace(/\D+/g,""));function f2(n,e){if(e===sI)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),n;if(e===Ab||e===MT){let t=n.getIndex();if(t===null){const o=[],l=n.getAttribute("position");if(l!==void 0){for(let c=0;c<l.count;c++)o.push(c);n.setIndex(o),t=n.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n}const i=t.count-2,s=[];if(t)if(e===Ab)for(let o=1;o<=i;o++)s.push(t.getX(0)),s.push(t.getX(o)),s.push(t.getX(o+1));else for(let o=0;o<i;o++)o%2===0?(s.push(t.getX(o)),s.push(t.getX(o+1)),s.push(t.getX(o+2))):(s.push(t.getX(o+2)),s.push(t.getX(o+1)),s.push(t.getX(o)));s.length/3!==i&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=n.clone();return r.setIndex(s),r.clearGroups(),r}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),n}var Y8=Object.defineProperty,J8=(n,e,t)=>e in n?Y8(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,Q8=(n,e,t)=>(J8(n,e+"",t),t);class Z8{constructor(){Q8(this,"_listeners")}addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[e]===void 0&&(i[e]=[]),i[e].indexOf(t)===-1&&i[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const i=this._listeners;return i[e]!==void 0&&i[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const s=this._listeners[e];if(s!==void 0){const r=s.indexOf(t);r!==-1&&s.splice(r,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const i=this._listeners[e.type];if(i!==void 0){e.target=this;const s=i.slice(0);for(let r=0,o=s.length;r<o;r++)s[r].call(this,e);e.target=null}}}var e5=Object.defineProperty,t5=(n,e,t)=>e in n?e5(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,oi=(n,e,t)=>(t5(n,typeof e!="symbol"?e+"":e,t),t);const bM=new Qg,h2=new Uh,n5=Math.cos(70*(Math.PI/180)),p2=(n,e)=>(n%e+e)%e;let i5=class extends Z8{constructor(e,t){super(),oi(this,"object"),oi(this,"domElement"),oi(this,"enabled",!0),oi(this,"target",new Oe),oi(this,"minDistance",0),oi(this,"maxDistance",1/0),oi(this,"minZoom",0),oi(this,"maxZoom",1/0),oi(this,"minPolarAngle",0),oi(this,"maxPolarAngle",Math.PI),oi(this,"minAzimuthAngle",-1/0),oi(this,"maxAzimuthAngle",1/0),oi(this,"enableDamping",!1),oi(this,"dampingFactor",.05),oi(this,"enableZoom",!0),oi(this,"zoomSpeed",1),oi(this,"enableRotate",!0),oi(this,"rotateSpeed",1),oi(this,"enablePan",!0),oi(this,"panSpeed",1),oi(this,"screenSpacePanning",!0),oi(this,"keyPanSpeed",7),oi(this,"zoomToCursor",!1),oi(this,"autoRotate",!1),oi(this,"autoRotateSpeed",2),oi(this,"reverseOrbit",!1),oi(this,"reverseHorizontalOrbit",!1),oi(this,"reverseVerticalOrbit",!1),oi(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),oi(this,"mouseButtons",{LEFT:yg.ROTATE,MIDDLE:yg.DOLLY,RIGHT:yg.PAN}),oi(this,"touches",{ONE:Mg.ROTATE,TWO:Mg.DOLLY_PAN}),oi(this,"target0"),oi(this,"position0"),oi(this,"zoom0"),oi(this,"_domElementKeyEvents",null),oi(this,"getPolarAngle"),oi(this,"getAzimuthalAngle"),oi(this,"setPolarAngle"),oi(this,"setAzimuthalAngle"),oi(this,"getDistance"),oi(this,"getZoomScale"),oi(this,"listenToKeyEvents"),oi(this,"stopListenToKeyEvents"),oi(this,"saveState"),oi(this,"reset"),oi(this,"update"),oi(this,"connect"),oi(this,"dispose"),oi(this,"dollyIn"),oi(this,"dollyOut"),oi(this,"getScale"),oi(this,"setScale"),this.object=e,this.domElement=t,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>g.phi,this.getAzimuthalAngle=()=>g.theta,this.setPolarAngle=We=>{let vt=p2(We,2*Math.PI),Yt=g.phi;Yt<0&&(Yt+=2*Math.PI),vt<0&&(vt+=2*Math.PI);let qe=Math.abs(vt-Yt);2*Math.PI-qe<qe&&(vt<Yt?vt+=2*Math.PI:Yt+=2*Math.PI),p.phi=vt-Yt,i.update()},this.setAzimuthalAngle=We=>{let vt=p2(We,2*Math.PI),Yt=g.theta;Yt<0&&(Yt+=2*Math.PI),vt<0&&(vt+=2*Math.PI);let qe=Math.abs(vt-Yt);2*Math.PI-qe<qe&&(vt<Yt?vt+=2*Math.PI:Yt+=2*Math.PI),p.theta=vt-Yt,i.update()},this.getDistance=()=>i.object.position.distanceTo(i.target),this.listenToKeyEvents=We=>{We.addEventListener("keydown",at),this._domElementKeyEvents=We},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",at),this._domElementKeyEvents=null},this.saveState=()=>{i.target0.copy(i.target),i.position0.copy(i.object.position),i.zoom0=i.object.zoom},this.reset=()=>{i.target.copy(i.target0),i.object.position.copy(i.position0),i.object.zoom=i.zoom0,i.object.updateProjectionMatrix(),i.dispatchEvent(s),i.update(),c=l.NONE},this.update=(()=>{const We=new Oe,vt=new Oe(0,1,0),Yt=new lo().setFromUnitVectors(e.up,vt),qe=Yt.clone().invert(),Kt=new Oe,rn=new lo,fe=2*Math.PI;return function(){const I=i.object.position;Yt.setFromUnitVectors(e.up,vt),qe.copy(Yt).invert(),We.copy(I).sub(i.target),We.applyQuaternion(Yt),g.setFromVector3(We),i.autoRotate&&c===l.NONE&&oe(J()),i.enableDamping?(g.theta+=p.theta*i.dampingFactor,g.phi+=p.phi*i.dampingFactor):(g.theta+=p.theta,g.phi+=p.phi);let A=i.minAzimuthAngle,F=i.maxAzimuthAngle;isFinite(A)&&isFinite(F)&&(A<-Math.PI?A+=fe:A>Math.PI&&(A-=fe),F<-Math.PI?F+=fe:F>Math.PI&&(F-=fe),A<=F?g.theta=Math.max(A,Math.min(F,g.theta)):g.theta=g.theta>(A+F)/2?Math.max(A,g.theta):Math.min(F,g.theta)),g.phi=Math.max(i.minPolarAngle,Math.min(i.maxPolarAngle,g.phi)),g.makeSafe(),i.enableDamping===!0?i.target.addScaledVector(v,i.dampingFactor):i.target.add(v),i.zoomToCursor&&U||i.object.isOrthographicCamera?g.radius=ue(g.radius):g.radius=ue(g.radius*h),We.setFromSpherical(g),We.applyQuaternion(qe),I.copy(i.target).add(We),i.object.matrixAutoUpdate||i.object.updateMatrix(),i.object.lookAt(i.target),i.enableDamping===!0?(p.theta*=1-i.dampingFactor,p.phi*=1-i.dampingFactor,v.multiplyScalar(1-i.dampingFactor)):(p.set(0,0,0),v.set(0,0,0));let K=!1;if(i.zoomToCursor&&U){let Ee=null;if(i.object instanceof Er&&i.object.isPerspectiveCamera){const k=We.length();Ee=ue(k*h);const re=k-Ee;i.object.position.addScaledVector(D,re),i.object.updateMatrixWorld()}else if(i.object.isOrthographicCamera){const k=new Oe(z.x,z.y,0);k.unproject(i.object),i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom/h)),i.object.updateProjectionMatrix(),K=!0;const re=new Oe(z.x,z.y,0);re.unproject(i.object),i.object.position.sub(re).add(k),i.object.updateMatrixWorld(),Ee=We.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),i.zoomToCursor=!1;Ee!==null&&(i.screenSpacePanning?i.target.set(0,0,-1).transformDirection(i.object.matrix).multiplyScalar(Ee).add(i.object.position):(bM.origin.copy(i.object.position),bM.direction.set(0,0,-1).transformDirection(i.object.matrix),Math.abs(i.object.up.dot(bM.direction))<n5?e.lookAt(i.target):(h2.setFromNormalAndCoplanarPoint(i.object.up,i.target),bM.intersectPlane(h2,i.target))))}else i.object instanceof Lc&&i.object.isOrthographicCamera&&(K=h!==1,K&&(i.object.zoom=Math.max(i.minZoom,Math.min(i.maxZoom,i.object.zoom/h)),i.object.updateProjectionMatrix()));return h=1,U=!1,K||Kt.distanceToSquared(i.object.position)>d||8*(1-rn.dot(i.object.quaternion))>d?(i.dispatchEvent(s),Kt.copy(i.object.position),rn.copy(i.object.quaternion),K=!1,!0):!1}})(),this.connect=We=>{i.domElement=We,i.domElement.style.touchAction="none",i.domElement.addEventListener("contextmenu",Vt),i.domElement.addEventListener("pointerdown",Tt),i.domElement.addEventListener("pointercancel",me),i.domElement.addEventListener("wheel",ht)},this.dispose=()=>{var We,vt,Yt,qe,Kt,rn;i.domElement&&(i.domElement.style.touchAction="auto"),(We=i.domElement)==null||We.removeEventListener("contextmenu",Vt),(vt=i.domElement)==null||vt.removeEventListener("pointerdown",Tt),(Yt=i.domElement)==null||Yt.removeEventListener("pointercancel",me),(qe=i.domElement)==null||qe.removeEventListener("wheel",ht),(Kt=i.domElement)==null||Kt.ownerDocument.removeEventListener("pointermove",Me),(rn=i.domElement)==null||rn.ownerDocument.removeEventListener("pointerup",me),i._domElementKeyEvents!==null&&i._domElementKeyEvents.removeEventListener("keydown",at)};const i=this,s={type:"change"},r={type:"start"},o={type:"end"},l={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let c=l.NONE;const d=1e-6,g=new DE,p=new DE;let h=1;const v=new Oe,y=new Gt,w=new Gt,S=new Gt,M=new Gt,T=new Gt,C=new Gt,x=new Gt,R=new Gt,P=new Gt,D=new Oe,z=new Gt;let U=!1;const N=[],j={};function J(){return 2*Math.PI/60/60*i.autoRotateSpeed}function W(){return Math.pow(.95,i.zoomSpeed)}function oe(We){i.reverseOrbit||i.reverseHorizontalOrbit?p.theta+=We:p.theta-=We}function ne(We){i.reverseOrbit||i.reverseVerticalOrbit?p.phi+=We:p.phi-=We}const q=(()=>{const We=new Oe;return function(Yt,qe){We.setFromMatrixColumn(qe,0),We.multiplyScalar(-Yt),v.add(We)}})(),le=(()=>{const We=new Oe;return function(Yt,qe){i.screenSpacePanning===!0?We.setFromMatrixColumn(qe,1):(We.setFromMatrixColumn(qe,0),We.crossVectors(i.object.up,We)),We.multiplyScalar(Yt),v.add(We)}})(),se=(()=>{const We=new Oe;return function(Yt,qe){const Kt=i.domElement;if(Kt&&i.object instanceof Er&&i.object.isPerspectiveCamera){const rn=i.object.position;We.copy(rn).sub(i.target);let fe=We.length();fe*=Math.tan(i.object.fov/2*Math.PI/180),q(2*Yt*fe/Kt.clientHeight,i.object.matrix),le(2*qe*fe/Kt.clientHeight,i.object.matrix)}else Kt&&i.object instanceof Lc&&i.object.isOrthographicCamera?(q(Yt*(i.object.right-i.object.left)/i.object.zoom/Kt.clientWidth,i.object.matrix),le(qe*(i.object.top-i.object.bottom)/i.object.zoom/Kt.clientHeight,i.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),i.enablePan=!1)}})();function pe(We){i.object instanceof Er&&i.object.isPerspectiveCamera||i.object instanceof Lc&&i.object.isOrthographicCamera?h=We:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),i.enableZoom=!1)}function be(We){pe(h/We)}function ee(We){pe(h*We)}function te(We){if(!i.zoomToCursor||!i.domElement)return;U=!0;const vt=i.domElement.getBoundingClientRect(),Yt=We.clientX-vt.left,qe=We.clientY-vt.top,Kt=vt.width,rn=vt.height;z.x=Yt/Kt*2-1,z.y=-(qe/rn)*2+1,D.set(z.x,z.y,1).unproject(i.object).sub(i.object.position).normalize()}function ue(We){return Math.max(i.minDistance,Math.min(i.maxDistance,We))}function ae(We){y.set(We.clientX,We.clientY)}function ce(We){te(We),x.set(We.clientX,We.clientY)}function Be(We){M.set(We.clientX,We.clientY)}function He(We){w.set(We.clientX,We.clientY),S.subVectors(w,y).multiplyScalar(i.rotateSpeed);const vt=i.domElement;vt&&(oe(2*Math.PI*S.x/vt.clientHeight),ne(2*Math.PI*S.y/vt.clientHeight)),y.copy(w),i.update()}function Xe(We){R.set(We.clientX,We.clientY),P.subVectors(R,x),P.y>0?be(W()):P.y<0&&ee(W()),x.copy(R),i.update()}function ot(We){T.set(We.clientX,We.clientY),C.subVectors(T,M).multiplyScalar(i.panSpeed),se(C.x,C.y),M.copy(T),i.update()}function tt(We){te(We),We.deltaY<0?ee(W()):We.deltaY>0&&be(W()),i.update()}function Ae(We){let vt=!1;switch(We.code){case i.keys.UP:se(0,i.keyPanSpeed),vt=!0;break;case i.keys.BOTTOM:se(0,-i.keyPanSpeed),vt=!0;break;case i.keys.LEFT:se(i.keyPanSpeed,0),vt=!0;break;case i.keys.RIGHT:se(-i.keyPanSpeed,0),vt=!0;break}vt&&(We.preventDefault(),i.update())}function ye(){if(N.length==1)y.set(N[0].pageX,N[0].pageY);else{const We=.5*(N[0].pageX+N[1].pageX),vt=.5*(N[0].pageY+N[1].pageY);y.set(We,vt)}}function xe(){if(N.length==1)M.set(N[0].pageX,N[0].pageY);else{const We=.5*(N[0].pageX+N[1].pageX),vt=.5*(N[0].pageY+N[1].pageY);M.set(We,vt)}}function ke(){const We=N[0].pageX-N[1].pageX,vt=N[0].pageY-N[1].pageY,Yt=Math.sqrt(We*We+vt*vt);x.set(0,Yt)}function ze(){i.enableZoom&&ke(),i.enablePan&&xe()}function je(){i.enableZoom&&ke(),i.enableRotate&&ye()}function Fe(We){if(N.length==1)w.set(We.pageX,We.pageY);else{const Yt=Tn(We),qe=.5*(We.pageX+Yt.x),Kt=.5*(We.pageY+Yt.y);w.set(qe,Kt)}S.subVectors(w,y).multiplyScalar(i.rotateSpeed);const vt=i.domElement;vt&&(oe(2*Math.PI*S.x/vt.clientHeight),ne(2*Math.PI*S.y/vt.clientHeight)),y.copy(w)}function Ye(We){if(N.length==1)T.set(We.pageX,We.pageY);else{const vt=Tn(We),Yt=.5*(We.pageX+vt.x),qe=.5*(We.pageY+vt.y);T.set(Yt,qe)}C.subVectors(T,M).multiplyScalar(i.panSpeed),se(C.x,C.y),M.copy(T)}function Ve(We){const vt=Tn(We),Yt=We.pageX-vt.x,qe=We.pageY-vt.y,Kt=Math.sqrt(Yt*Yt+qe*qe);R.set(0,Kt),P.set(0,Math.pow(R.y/x.y,i.zoomSpeed)),be(P.y),x.copy(R)}function Qe(We){i.enableZoom&&Ve(We),i.enablePan&&Ye(We)}function mt(We){i.enableZoom&&Ve(We),i.enableRotate&&Fe(We)}function Tt(We){var vt,Yt;i.enabled!==!1&&(N.length===0&&((vt=i.domElement)==null||vt.ownerDocument.addEventListener("pointermove",Me),(Yt=i.domElement)==null||Yt.ownerDocument.addEventListener("pointerup",me)),an(We),We.pointerType==="touch"?Et(We):$e(We))}function Me(We){i.enabled!==!1&&(We.pointerType==="touch"?Dt(We):et(We))}function me(We){var vt,Yt,qe;bt(We),N.length===0&&((vt=i.domElement)==null||vt.releasePointerCapture(We.pointerId),(Yt=i.domElement)==null||Yt.ownerDocument.removeEventListener("pointermove",Me),(qe=i.domElement)==null||qe.ownerDocument.removeEventListener("pointerup",me)),i.dispatchEvent(o),c=l.NONE}function $e(We){let vt;switch(We.button){case 0:vt=i.mouseButtons.LEFT;break;case 1:vt=i.mouseButtons.MIDDLE;break;case 2:vt=i.mouseButtons.RIGHT;break;default:vt=-1}switch(vt){case yg.DOLLY:if(i.enableZoom===!1)return;ce(We),c=l.DOLLY;break;case yg.ROTATE:if(We.ctrlKey||We.metaKey||We.shiftKey){if(i.enablePan===!1)return;Be(We),c=l.PAN}else{if(i.enableRotate===!1)return;ae(We),c=l.ROTATE}break;case yg.PAN:if(We.ctrlKey||We.metaKey||We.shiftKey){if(i.enableRotate===!1)return;ae(We),c=l.ROTATE}else{if(i.enablePan===!1)return;Be(We),c=l.PAN}break;default:c=l.NONE}c!==l.NONE&&i.dispatchEvent(r)}function et(We){if(i.enabled!==!1)switch(c){case l.ROTATE:if(i.enableRotate===!1)return;He(We);break;case l.DOLLY:if(i.enableZoom===!1)return;Xe(We);break;case l.PAN:if(i.enablePan===!1)return;ot(We);break}}function ht(We){i.enabled===!1||i.enableZoom===!1||c!==l.NONE&&c!==l.ROTATE||(We.preventDefault(),i.dispatchEvent(r),tt(We),i.dispatchEvent(o))}function at(We){i.enabled===!1||i.enablePan===!1||Ae(We)}function Et(We){switch(Jt(We),N.length){case 1:switch(i.touches.ONE){case Mg.ROTATE:if(i.enableRotate===!1)return;ye(),c=l.TOUCH_ROTATE;break;case Mg.PAN:if(i.enablePan===!1)return;xe(),c=l.TOUCH_PAN;break;default:c=l.NONE}break;case 2:switch(i.touches.TWO){case Mg.DOLLY_PAN:if(i.enableZoom===!1&&i.enablePan===!1)return;ze(),c=l.TOUCH_DOLLY_PAN;break;case Mg.DOLLY_ROTATE:if(i.enableZoom===!1&&i.enableRotate===!1)return;je(),c=l.TOUCH_DOLLY_ROTATE;break;default:c=l.NONE}break;default:c=l.NONE}c!==l.NONE&&i.dispatchEvent(r)}function Dt(We){switch(Jt(We),c){case l.TOUCH_ROTATE:if(i.enableRotate===!1)return;Fe(We),i.update();break;case l.TOUCH_PAN:if(i.enablePan===!1)return;Ye(We),i.update();break;case l.TOUCH_DOLLY_PAN:if(i.enableZoom===!1&&i.enablePan===!1)return;Qe(We),i.update();break;case l.TOUCH_DOLLY_ROTATE:if(i.enableZoom===!1&&i.enableRotate===!1)return;mt(We),i.update();break;default:c=l.NONE}}function Vt(We){i.enabled!==!1&&We.preventDefault()}function an(We){N.push(We)}function bt(We){delete j[We.pointerId];for(let vt=0;vt<N.length;vt++)if(N[vt].pointerId==We.pointerId){N.splice(vt,1);return}}function Jt(We){let vt=j[We.pointerId];vt===void 0&&(vt=new Gt,j[We.pointerId]=vt),vt.set(We.pageX,We.pageY)}function Tn(We){const vt=We.pointerId===N[0].pointerId?N[1]:N[0];return j[vt.pointerId]}this.dollyIn=(We=W())=>{ee(We),i.update()},this.dollyOut=(We=W())=>{be(We),i.update()},this.getScale=()=>h,this.setScale=We=>{pe(We),i.update()},this.getZoomScale=()=>W(),t!==void 0&&this.connect(t),this.update()}};function Nb(n){if(typeof TextDecoder<"u")return new TextDecoder().decode(n);let e="";for(let t=0,i=n.length;t<i;t++)e+=String.fromCharCode(n[t]);try{return decodeURIComponent(escape(e))}catch{return e}}const Bg="srgb",$h="srgb-linear",m2=3001,s5=3e3;class rS extends Zo{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new u5(t)}),this.register(function(t){return new c5(t)}),this.register(function(t){return new y5(t)}),this.register(function(t){return new M5(t)}),this.register(function(t){return new b5(t)}),this.register(function(t){return new f5(t)}),this.register(function(t){return new h5(t)}),this.register(function(t){return new p5(t)}),this.register(function(t){return new m5(t)}),this.register(function(t){return new l5(t)}),this.register(function(t){return new g5(t)}),this.register(function(t){return new d5(t)}),this.register(function(t){return new v5(t)}),this.register(function(t){return new _5(t)}),this.register(function(t){return new a5(t)}),this.register(function(t){return new x5(t)}),this.register(function(t){return new w5(t)})}load(e,t,i,s){const r=this;let o;if(this.resourcePath!=="")o=this.resourcePath;else if(this.path!==""){const d=cm.extractUrlBase(e);o=cm.resolveURL(d,this.path)}else o=cm.extractUrlBase(e);this.manager.itemStart(e);const l=function(d){s?s(d):console.error(d),r.manager.itemError(e),r.manager.itemEnd(e)},c=new Qu(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(e,function(d){try{r.parse(d,o,function(g){t(g),r.manager.itemEnd(e)},l)}catch(g){l(g)}},i,l)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,i,s){let r;const o={},l={};if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(Nb(new Uint8Array(e.slice(0,4)))===jO){try{o[Qi.KHR_BINARY_GLTF]=new E5(e)}catch(g){s&&s(g);return}r=JSON.parse(o[Qi.KHR_BINARY_GLTF].content)}else r=JSON.parse(Nb(new Uint8Array(e)));else r=e;if(r.asset===void 0||r.asset.version[0]<2){s&&s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new N5(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let d=0;d<this.pluginCallbacks.length;d++){const g=this.pluginCallbacks[d](c);g.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),l[g.name]=g,o[g.name]=!0}if(r.extensionsUsed)for(let d=0;d<r.extensionsUsed.length;++d){const g=r.extensionsUsed[d],p=r.extensionsRequired||[];switch(g){case Qi.KHR_MATERIALS_UNLIT:o[g]=new o5;break;case Qi.KHR_DRACO_MESH_COMPRESSION:o[g]=new T5(r,this.dracoLoader);break;case Qi.KHR_TEXTURE_TRANSFORM:o[g]=new S5;break;case Qi.KHR_MESH_QUANTIZATION:o[g]=new A5;break;default:p.indexOf(g)>=0&&l[g]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+g+'".')}}c.setExtensions(o),c.setPlugins(l),c.parse(i,s)}parseAsync(e,t){const i=this;return new Promise(function(s,r){i.parse(e,t,s,r)})}}function r5(){let n={};return{get:function(e){return n[e]},add:function(e,t){n[e]=t},remove:function(e){delete n[e]},removeAll:function(){n={}}}}const Qi={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class a5{constructor(e){this.parser=e,this.name=Qi.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let i=0,s=t.length;i<s;i++){const r=t[i];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,i="light:"+e;let s=t.cache.get(i);if(s)return s;const r=t.json,c=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let d;const g=new Sn(16777215);c.color!==void 0&&g.setRGB(c.color[0],c.color[1],c.color[2],$h);const p=c.range!==void 0?c.range:0;switch(c.type){case"directional":d=new qT(g),d.target.position.set(0,0,-1),d.add(d.target);break;case"point":d=new KT(g),d.distance=p;break;case"spot":d=new WT(g),d.distance=p,c.spot=c.spot||{},c.spot.innerConeAngle=c.spot.innerConeAngle!==void 0?c.spot.innerConeAngle:0,c.spot.outerConeAngle=c.spot.outerConeAngle!==void 0?c.spot.outerConeAngle:Math.PI/4,d.angle=c.spot.outerConeAngle,d.penumbra=1-c.spot.innerConeAngle/c.spot.outerConeAngle,d.target.position.set(0,0,-1),d.add(d.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+c.type)}return d.position.set(0,0,0),d.decay=2,zh(d,c),c.intensity!==void 0&&(d.intensity=c.intensity),d.name=t.createUniqueName(c.name||"light_"+e),s=Promise.resolve(d),t.cache.add(i,s),s}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,i=this.parser,r=i.json.nodes[e],l=(r.extensions&&r.extensions[this.name]||{}).light;return l===void 0?null:this._loadLight(l).then(function(c){return i._getNodeRef(t.cache,l,c)})}}class o5{constructor(){this.name=Qi.KHR_MATERIALS_UNLIT}getMaterialType(){return qu}extendParams(e,t,i){const s=[];e.color=new Sn(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const o=r.baseColorFactor;e.color.setRGB(o[0],o[1],o[2],$h),e.opacity=o[3]}r.baseColorTexture!==void 0&&s.push(i.assignTexture(e,"map",r.baseColorTexture,Bg))}return Promise.all(s)}}class l5{constructor(e){this.parser=e,this.name=Qi.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=s.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}class u5{constructor(e){this.parser=e,this.name=Qi.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Nc}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],o=s.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&r.push(i.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&r.push(i.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(r.push(i.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const l=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Gt(l,l)}return Promise.all(r)}}class c5{constructor(e){this.parser=e,this.name=Qi.KHR_MATERIALS_DISPERSION}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Nc}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=s.extensions[this.name];return t.dispersion=r.dispersion!==void 0?r.dispersion:0,Promise.resolve()}}class d5{constructor(e){this.parser=e,this.name=Qi.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Nc}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],o=s.extensions[this.name];return o.iridescenceFactor!==void 0&&(t.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&r.push(i.assignTexture(t,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(t.iridescenceIOR=o.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&r.push(i.assignTexture(t,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(r)}}class f5{constructor(e){this.parser=e,this.name=Qi.KHR_MATERIALS_SHEEN}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Nc}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new Sn(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=s.extensions[this.name];if(o.sheenColorFactor!==void 0){const l=o.sheenColorFactor;t.sheenColor.setRGB(l[0],l[1],l[2],$h)}return o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&r.push(i.assignTexture(t,"sheenColorMap",o.sheenColorTexture,Bg)),o.sheenRoughnessTexture!==void 0&&r.push(i.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(r)}}class h5{constructor(e){this.parser=e,this.name=Qi.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Nc}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],o=s.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&r.push(i.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(r)}}class p5{constructor(e){this.parser=e,this.name=Qi.KHR_MATERIALS_VOLUME}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Nc}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],o=s.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&r.push(i.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||1/0;const l=o.attenuationColor||[1,1,1];return t.attenuationColor=new Sn().setRGB(l[0],l[1],l[2],$h),Promise.all(r)}}class m5{constructor(e){this.parser=e,this.name=Qi.KHR_MATERIALS_IOR}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Nc}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=s.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class g5{constructor(e){this.parser=e,this.name=Qi.KHR_MATERIALS_SPECULAR}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Nc}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],o=s.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&r.push(i.assignTexture(t,"specularIntensityMap",o.specularTexture));const l=o.specularColorFactor||[1,1,1];return t.specularColor=new Sn().setRGB(l[0],l[1],l[2],$h),o.specularColorTexture!==void 0&&r.push(i.assignTexture(t,"specularColorMap",o.specularColorTexture,Bg)),Promise.all(r)}}class _5{constructor(e){this.parser=e,this.name=Qi.EXT_MATERIALS_BUMP}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Nc}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],o=s.extensions[this.name];return t.bumpScale=o.bumpFactor!==void 0?o.bumpFactor:1,o.bumpTexture!==void 0&&r.push(i.assignTexture(t,"bumpMap",o.bumpTexture)),Promise.all(r)}}class v5{constructor(e){this.parser=e,this.name=Qi.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const i=this.parser.json.materials[e];return!i.extensions||!i.extensions[this.name]?null:Nc}extendMaterialParams(e,t){const i=this.parser,s=i.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const r=[],o=s.extensions[this.name];return o.anisotropyStrength!==void 0&&(t.anisotropy=o.anisotropyStrength),o.anisotropyRotation!==void 0&&(t.anisotropyRotation=o.anisotropyRotation),o.anisotropyTexture!==void 0&&r.push(i.assignTexture(t,"anisotropyMap",o.anisotropyTexture)),Promise.all(r)}}class y5{constructor(e){this.parser=e,this.name=Qi.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,i=t.json,s=i.textures[e];if(!s.extensions||!s.extensions[this.name])return null;const r=s.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,o)}}class M5{constructor(e){this.parser=e,this.name=Qi.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,i=this.parser,s=i.json,r=s.textures[e];if(!r.extensions||!r.extensions[t])return null;const o=r.extensions[t],l=s.images[o.source];let c=i.textureLoader;if(l.uri){const d=i.options.manager.getHandler(l.uri);d!==null&&(c=d)}return this.detectSupport().then(function(d){if(d)return i.loadTextureImage(e,o.source,c);if(s.extensionsRequired&&s.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return i.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class b5{constructor(e){this.parser=e,this.name=Qi.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,i=this.parser,s=i.json,r=s.textures[e];if(!r.extensions||!r.extensions[t])return null;const o=r.extensions[t],l=s.images[o.source];let c=i.textureLoader;if(l.uri){const d=i.options.manager.getHandler(l.uri);d!==null&&(c=d)}return this.detectSupport().then(function(d){if(d)return i.loadTextureImage(e,o.source,c);if(s.extensionsRequired&&s.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return i.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class x5{constructor(e){this.name=Qi.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,i=t.bufferViews[e];if(i.extensions&&i.extensions[this.name]){const s=i.extensions[this.name],r=this.parser.getDependency("buffer",s.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(l){const c=s.byteOffset||0,d=s.byteLength||0,g=s.count,p=s.byteStride,h=new Uint8Array(l,c,d);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(g,p,h,s.mode,s.filter).then(function(v){return v.buffer}):o.ready.then(function(){const v=new ArrayBuffer(g*p);return o.decodeGltfBuffer(new Uint8Array(v),g,p,h,s.mode,s.filter),v})})}else return null}}class w5{constructor(e){this.name=Qi.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,i=t.nodes[e];if(!i.extensions||!i.extensions[this.name]||i.mesh===void 0)return null;const s=t.meshes[i.mesh];for(const d of s.primitives)if(d.mode!==Dc.TRIANGLES&&d.mode!==Dc.TRIANGLE_STRIP&&d.mode!==Dc.TRIANGLE_FAN&&d.mode!==void 0)return null;const o=i.extensions[this.name].attributes,l=[],c={};for(const d in o)l.push(this.parser.getDependency("accessor",o[d]).then(g=>(c[d]=g,c[d])));return l.length<1?null:(l.push(this.parser.createNodeMesh(e)),Promise.all(l).then(d=>{const g=d.pop(),p=g.isGroup?g.children:[g],h=d[0].count,v=[];for(const y of p){const w=new li,S=new Oe,M=new lo,T=new Oe(1,1,1),C=new CT(y.geometry,y.material,h);for(let x=0;x<h;x++)c.TRANSLATION&&S.fromBufferAttribute(c.TRANSLATION,x),c.ROTATION&&M.fromBufferAttribute(c.ROTATION,x),c.SCALE&&T.fromBufferAttribute(c.SCALE,x),C.setMatrixAt(x,w.compose(S,M,T));for(const x in c)if(x==="_COLOR_0"){const R=c[x];C.instanceColor=new Gg(R.array,R.itemSize,R.normalized)}else x!=="TRANSLATION"&&x!=="ROTATION"&&x!=="SCALE"&&y.geometry.setAttribute(x,c[x]);fs.prototype.copy.call(C,y),this.parser.assignFinalMaterial(C),v.push(C)}return g.isGroup?(g.clear(),g.add(...v),g):v[0]}))}}const jO="glTF",Q0=12,g2={JSON:1313821514,BIN:5130562};class E5{constructor(e){this.name=Qi.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Q0);if(this.header={magic:Nb(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==jO)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-Q0,s=new DataView(e,Q0);let r=0;for(;r<i;){const o=s.getUint32(r,!0);r+=4;const l=s.getUint32(r,!0);if(r+=4,l===g2.JSON){const c=new Uint8Array(e,Q0+r,o);this.content=Nb(c)}else if(l===g2.BIN){const c=Q0+r;this.body=e.slice(c,c+o)}r+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class T5{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Qi.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const i=this.json,s=this.dracoLoader,r=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,l={},c={},d={};for(const g in o){const p=VE[g]||g.toLowerCase();l[p]=o[g]}for(const g in e.attributes){const p=VE[g]||g.toLowerCase();if(o[g]!==void 0){const h=i.accessors[e.attributes[g]],v=e0[h.componentType];d[p]=v.name,c[p]=h.normalized===!0}}return t.getDependency("bufferView",r).then(function(g){return new Promise(function(p,h){s.decodeDracoFile(g,function(v){for(const y in v.attributes){const w=v.attributes[y],S=c[y];S!==void 0&&(w.normalized=S)}p(v)},l,d,$h,h)})})}}class S5{constructor(){this.name=Qi.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class A5{constructor(){this.name=Qi.KHR_MESH_QUANTIZATION}}class $O extends b0{constructor(e,t,i,s){super(e,t,i,s)}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,s=this.valueSize,r=e*s*3+s;for(let o=0;o!==s;o++)t[o]=i[r+o];return t}interpolate_(e,t,i,s){const r=this.resultBuffer,o=this.sampleValues,l=this.valueSize,c=l*2,d=l*3,g=s-t,p=(i-t)/g,h=p*p,v=h*p,y=e*d,w=y-d,S=-2*v+3*h,M=v-h,T=1-S,C=M-h+p;for(let x=0;x!==l;x++){const R=o[w+x+l],P=o[w+x+c]*g,D=o[y+x+l],z=o[y+x]*g;r[x]=T*R+C*P+S*D+M*z}return r}}const C5=new lo;class P5 extends $O{interpolate_(e,t,i,s){const r=super.interpolate_(e,t,i,s);return C5.fromArray(r).normalize().toArray(r),r}}const Dc={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},e0={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},_2={9728:ta,9729:Tr,9984:Xb,9985:J_,9986:Ag,9987:Oc},v2={33071:Wu,33648:t0,10497:fm},o1={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},VE={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...X8>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},nm={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},R5={CUBICSPLINE:void 0,LINEAR:r0,STEP:s0},l1={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function D5(n){return n.DefaultMaterial===void 0&&(n.DefaultMaterial=new M0({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Nd})),n.DefaultMaterial}function pg(n,e,t){for(const i in t.extensions)n[i]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[i]=t.extensions[i])}function zh(n,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(n.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function B5(n,e,t){let i=!1,s=!1,r=!1;for(let d=0,g=e.length;d<g;d++){const p=e[d];if(p.POSITION!==void 0&&(i=!0),p.NORMAL!==void 0&&(s=!0),p.COLOR_0!==void 0&&(r=!0),i&&s&&r)break}if(!i&&!s&&!r)return Promise.resolve(n);const o=[],l=[],c=[];for(let d=0,g=e.length;d<g;d++){const p=e[d];if(i){const h=p.POSITION!==void 0?t.getDependency("accessor",p.POSITION):n.attributes.position;o.push(h)}if(s){const h=p.NORMAL!==void 0?t.getDependency("accessor",p.NORMAL):n.attributes.normal;l.push(h)}if(r){const h=p.COLOR_0!==void 0?t.getDependency("accessor",p.COLOR_0):n.attributes.color;c.push(h)}}return Promise.all([Promise.all(o),Promise.all(l),Promise.all(c)]).then(function(d){const g=d[0],p=d[1],h=d[2];return i&&(n.morphAttributes.position=g),s&&(n.morphAttributes.normal=p),r&&(n.morphAttributes.color=h),n.morphTargetsRelative=!0,n})}function I5(n,e){if(n.updateMorphTargets(),e.weights!==void 0)for(let t=0,i=e.weights.length;t<i;t++)n.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(n.morphTargetInfluences.length===t.length){n.morphTargetDictionary={};for(let i=0,s=t.length;i<s;i++)n.morphTargetDictionary[t[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function O5(n){let e;const t=n.extensions&&n.extensions[Qi.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+u1(t.attributes):e=n.indices+":"+u1(n.attributes)+":"+n.mode,n.targets!==void 0)for(let i=0,s=n.targets.length;i<s;i++)e+=":"+u1(n.targets[i]);return e}function u1(n){let e="";const t=Object.keys(n).sort();for(let i=0,s=t.length;i<s;i++)e+=t[i]+":"+n[t[i]]+";";return e}function HE(n){switch(n){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function L5(n){return n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0?"image/jpeg":n.search(/\.webp($|\?)/i)>0||n.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const F5=new li;class N5{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new r5,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let i=!1,s=!1,r=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(i=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,s=navigator.userAgent.indexOf("Firefox")>-1,r=s?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||i||s&&r<98?this.textureLoader=new YI(this.options.manager):this.textureLoader=new sO(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Qu(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const i=this,s=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([i.getDependencies("scene"),i.getDependencies("animation"),i.getDependencies("camera")])}).then(function(o){const l={scene:o[0][s.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:s.asset,parser:i,userData:{}};return pg(r,l,s),zh(l,s),Promise.all(i._invokeAll(function(c){return c.afterRoot&&c.afterRoot(l)})).then(function(){for(const c of l.scenes)c.updateMatrixWorld();e(l)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],i=this.json.meshes||[];for(let s=0,r=t.length;s<r;s++){const o=t[s].joints;for(let l=0,c=o.length;l<c;l++)e[o[l]].isBone=!0}for(let s=0,r=e.length;s<r;s++){const o=e[s];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(i[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,i){if(e.refs[t]<=1)return i;const s=i.clone(),r=(o,l)=>{const c=this.associations.get(o);c!=null&&this.associations.set(l,c);for(const[d,g]of o.children.entries())r(g,l.children[d])};return r(i,s),s.name+="_instance_"+e.uses[t]++,s}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let i=0;i<t.length;i++){const s=e(t[i]);if(s)return s}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const i=[];for(let s=0;s<t.length;s++){const r=e(t[s]);r&&i.push(r)}return i}getDependency(e,t){const i=e+":"+t;let s=this.cache.get(i);if(!s){switch(e){case"scene":s=this.loadScene(t);break;case"node":s=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":s=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":s=this.loadAccessor(t);break;case"bufferView":s=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":s=this.loadBuffer(t);break;case"material":s=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":s=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":s=this.loadSkin(t);break;case"animation":s=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":s=this.loadCamera(t);break;default:if(s=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!s)throw new Error("Unknown type: "+e);break}this.cache.add(i,s)}return s}getDependencies(e){let t=this.cache.get(e);if(!t){const i=this,s=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(s.map(function(r,o){return i.getDependency(e,o)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],i=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[Qi.KHR_BINARY_GLTF].body);const s=this.options;return new Promise(function(r,o){i.load(cm.resolveURL(t.uri,s.path),r,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(i){const s=t.byteLength||0,r=t.byteOffset||0;return i.slice(r,r+s)})}loadAccessor(e){const t=this,i=this.json,s=this.json.accessors[e];if(s.bufferView===void 0&&s.sparse===void 0){const o=o1[s.type],l=e0[s.componentType],c=s.normalized===!0,d=new l(s.count*o);return Promise.resolve(new hs(d,o,c))}const r=[];return s.bufferView!==void 0?r.push(this.getDependency("bufferView",s.bufferView)):r.push(null),s.sparse!==void 0&&(r.push(this.getDependency("bufferView",s.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",s.sparse.values.bufferView))),Promise.all(r).then(function(o){const l=o[0],c=o1[s.type],d=e0[s.componentType],g=d.BYTES_PER_ELEMENT,p=g*c,h=s.byteOffset||0,v=s.bufferView!==void 0?i.bufferViews[s.bufferView].byteStride:void 0,y=s.normalized===!0;let w,S;if(v&&v!==p){const M=Math.floor(h/v),T="InterleavedBuffer:"+s.bufferView+":"+s.componentType+":"+M+":"+s.count;let C=t.cache.get(T);C||(w=new d(l,M*v,s.count*v/g),C=new qv(w,v/g),t.cache.add(T,C)),S=new hm(C,c,h%v/g,y)}else l===null?w=new d(s.count*c):w=new d(l,h,s.count*c),S=new hs(w,c,y);if(s.sparse!==void 0){const M=o1.SCALAR,T=e0[s.sparse.indices.componentType],C=s.sparse.indices.byteOffset||0,x=s.sparse.values.byteOffset||0,R=new T(o[1],C,s.sparse.count*M),P=new d(o[2],x,s.sparse.count*c);l!==null&&(S=new hs(S.array.slice(),S.itemSize,S.normalized));for(let D=0,z=R.length;D<z;D++){const U=R[D];if(S.setX(U,P[D*c]),c>=2&&S.setY(U,P[D*c+1]),c>=3&&S.setZ(U,P[D*c+2]),c>=4&&S.setW(U,P[D*c+3]),c>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return S})}loadTexture(e){const t=this.json,i=this.options,r=t.textures[e].source,o=t.images[r];let l=this.textureLoader;if(o.uri){const c=i.manager.getHandler(o.uri);c!==null&&(l=c)}return this.loadTextureImage(e,r,l)}loadTextureImage(e,t,i){const s=this,r=this.json,o=r.textures[e],l=r.images[t],c=(l.uri||l.bufferView)+":"+o.sampler;if(this.textureCache[c])return this.textureCache[c];const d=this.loadImageSource(t,i).then(function(g){g.flipY=!1,g.name=o.name||l.name||"",g.name===""&&typeof l.uri=="string"&&l.uri.startsWith("data:image/")===!1&&(g.name=l.uri);const h=(r.samplers||{})[o.sampler]||{};return g.magFilter=_2[h.magFilter]||Tr,g.minFilter=_2[h.minFilter]||Oc,g.wrapS=v2[h.wrapS]||fm,g.wrapT=v2[h.wrapT]||fm,s.associations.set(g,{textures:e}),g}).catch(function(){return null});return this.textureCache[c]=d,d}loadImageSource(e,t){const i=this,s=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(p=>p.clone());const o=s.images[e],l=self.URL||self.webkitURL;let c=o.uri||"",d=!1;if(o.bufferView!==void 0)c=i.getDependency("bufferView",o.bufferView).then(function(p){d=!0;const h=new Blob([p],{type:o.mimeType});return c=l.createObjectURL(h),c});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const g=Promise.resolve(c).then(function(p){return new Promise(function(h,v){let y=h;t.isImageBitmapLoader===!0&&(y=function(w){const S=new vr(w);S.needsUpdate=!0,h(S)}),t.load(cm.resolveURL(p,r.path),y,void 0,v)})}).then(function(p){return d===!0&&l.revokeObjectURL(c),zh(p,o),p.userData.mimeType=o.mimeType||L5(o.uri),p}).catch(function(p){throw console.error("THREE.GLTFLoader: Couldn't load texture",c),p});return this.sourceCache[e]=g,g}assignTexture(e,t,i,s){const r=this;return this.getDependency("texture",i.index).then(function(o){if(!o)return null;if(i.texCoord!==void 0&&i.texCoord>0&&(o=o.clone(),o.channel=i.texCoord),r.extensions[Qi.KHR_TEXTURE_TRANSFORM]){const l=i.extensions!==void 0?i.extensions[Qi.KHR_TEXTURE_TRANSFORM]:void 0;if(l){const c=r.associations.get(o);o=r.extensions[Qi.KHR_TEXTURE_TRANSFORM].extendTexture(o,l),r.associations.set(o,c)}}return s!==void 0&&(typeof s=="number"&&(s=s===m2?Bg:$h),"colorSpace"in o?o.colorSpace=s:o.encoding=s===Bg?m2:s5),e[t]=o,o})}assignFinalMaterial(e){const t=e.geometry;let i=e.material;const s=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(e.isPoints){const l="PointsMaterial:"+i.uuid;let c=this.cache.get(l);c||(c=new cx,pa.prototype.copy.call(c,i),c.color.copy(i.color),c.map=i.map,c.sizeAttenuation=!1,this.cache.add(l,c)),i=c}else if(e.isLine){const l="LineBasicMaterial:"+i.uuid;let c=this.cache.get(l);c||(c=new Qo,pa.prototype.copy.call(c,i),c.color.copy(i.color),c.map=i.map,this.cache.add(l,c)),i=c}if(s||r||o){let l="ClonedMaterial:"+i.uuid+":";s&&(l+="derivative-tangents:"),r&&(l+="vertex-colors:"),o&&(l+="flat-shading:");let c=this.cache.get(l);c||(c=i.clone(),r&&(c.vertexColors=!0),o&&(c.flatShading=!0),s&&(c.normalScale&&(c.normalScale.y*=-1),c.clearcoatNormalScale&&(c.clearcoatNormalScale.y*=-1)),this.cache.add(l,c),this.associations.set(c,this.associations.get(i))),i=c}e.material=i}getMaterialType(){return M0}loadMaterial(e){const t=this,i=this.json,s=this.extensions,r=i.materials[e];let o;const l={},c=r.extensions||{},d=[];if(c[Qi.KHR_MATERIALS_UNLIT]){const p=s[Qi.KHR_MATERIALS_UNLIT];o=p.getMaterialType(),d.push(p.extendParams(l,r,t))}else{const p=r.pbrMetallicRoughness||{};if(l.color=new Sn(1,1,1),l.opacity=1,Array.isArray(p.baseColorFactor)){const h=p.baseColorFactor;l.color.setRGB(h[0],h[1],h[2],$h),l.opacity=h[3]}p.baseColorTexture!==void 0&&d.push(t.assignTexture(l,"map",p.baseColorTexture,Bg)),l.metalness=p.metallicFactor!==void 0?p.metallicFactor:1,l.roughness=p.roughnessFactor!==void 0?p.roughnessFactor:1,p.metallicRoughnessTexture!==void 0&&(d.push(t.assignTexture(l,"metalnessMap",p.metallicRoughnessTexture)),d.push(t.assignTexture(l,"roughnessMap",p.metallicRoughnessTexture))),o=this._invokeOne(function(h){return h.getMaterialType&&h.getMaterialType(e)}),d.push(Promise.all(this._invokeAll(function(h){return h.extendMaterialParams&&h.extendMaterialParams(e,l)})))}r.doubleSided===!0&&(l.side=Ro);const g=r.alphaMode||l1.OPAQUE;if(g===l1.BLEND?(l.transparent=!0,l.depthWrite=!1):(l.transparent=!1,g===l1.MASK&&(l.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&o!==qu&&(d.push(t.assignTexture(l,"normalMap",r.normalTexture)),l.normalScale=new Gt(1,1),r.normalTexture.scale!==void 0)){const p=r.normalTexture.scale;l.normalScale.set(p,p)}if(r.occlusionTexture!==void 0&&o!==qu&&(d.push(t.assignTexture(l,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(l.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&o!==qu){const p=r.emissiveFactor;l.emissive=new Sn().setRGB(p[0],p[1],p[2],$h)}return r.emissiveTexture!==void 0&&o!==qu&&d.push(t.assignTexture(l,"emissiveMap",r.emissiveTexture,Bg)),Promise.all(d).then(function(){const p=new o(l);return r.name&&(p.name=r.name),zh(p,r),t.associations.set(p,{materials:e}),r.extensions&&pg(s,p,r),p})}createUniqueName(e){const t=ys.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,i=this.extensions,s=this.primitiveCache;function r(l){return i[Qi.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(l,t).then(function(c){return y2(c,l,t)})}const o=[];for(let l=0,c=e.length;l<c;l++){const d=e[l],g=O5(d),p=s[g];if(p)o.push(p.promise);else{let h;d.extensions&&d.extensions[Qi.KHR_DRACO_MESH_COMPRESSION]?h=r(d):h=y2(new xi,d,t),s[g]={primitive:d,promise:h},o.push(h)}}return Promise.all(o)}loadMesh(e){const t=this,i=this.json,s=this.extensions,r=i.meshes[e],o=r.primitives,l=[];for(let c=0,d=o.length;c<d;c++){const g=o[c].material===void 0?D5(this.cache):this.getDependency("material",o[c].material);l.push(g)}return l.push(t.loadGeometries(o)),Promise.all(l).then(function(c){const d=c.slice(0,c.length-1),g=c[c.length-1],p=[];for(let v=0,y=g.length;v<y;v++){const w=g[v],S=o[v];let M;const T=d[v];if(S.mode===Dc.TRIANGLES||S.mode===Dc.TRIANGLE_STRIP||S.mode===Dc.TRIANGLE_FAN||S.mode===void 0)M=r.isSkinnedMesh===!0?new AT(w,T):new ea(w,T),M.isSkinnedMesh===!0&&M.normalizeSkinWeights(),S.mode===Dc.TRIANGLE_STRIP?M.geometry=f2(M.geometry,MT):S.mode===Dc.TRIANGLE_FAN&&(M.geometry=f2(M.geometry,Ab));else if(S.mode===Dc.LINES)M=new Ud(w,T);else if(S.mode===Dc.LINE_STRIP)M=new Kh(w,T);else if(S.mode===Dc.LINE_LOOP)M=new PT(w,T);else if(S.mode===Dc.POINTS)M=new RT(w,T);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+S.mode);Object.keys(M.geometry.morphAttributes).length>0&&I5(M,r),M.name=t.createUniqueName(r.name||"mesh_"+e),zh(M,r),S.extensions&&pg(s,M,S),t.assignFinalMaterial(M),p.push(M)}for(let v=0,y=p.length;v<y;v++)t.associations.set(p[v],{meshes:e,primitives:v});if(p.length===1)return r.extensions&&pg(s,p[0],r),p[0];const h=new Hh;r.extensions&&pg(s,h,r),t.associations.set(h,{meshes:e});for(let v=0,y=p.length;v<y;v++)h.add(p[v]);return h})}loadCamera(e){let t;const i=this.json.cameras[e],s=i[i.type];if(!s){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return i.type==="perspective"?t=new Er(Vh.radToDeg(s.yfov),s.aspectRatio||1,s.znear||1,s.zfar||2e6):i.type==="orthographic"&&(t=new Lc(-s.xmag,s.xmag,s.ymag,-s.ymag,s.znear,s.zfar)),i.name&&(t.name=this.createUniqueName(i.name)),zh(t,i),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],i=[];for(let s=0,r=t.joints.length;s<r;s++)i.push(this._loadNodeShallow(t.joints[s]));return t.inverseBindMatrices!==void 0?i.push(this.getDependency("accessor",t.inverseBindMatrices)):i.push(null),Promise.all(i).then(function(s){const r=s.pop(),o=s,l=[],c=[];for(let d=0,g=o.length;d<g;d++){const p=o[d];if(p){l.push(p);const h=new li;r!==null&&h.fromArray(r.array,d*16),c.push(h)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[d])}return new Xv(l,c)})}loadAnimation(e){const t=this.json,i=this,s=t.animations[e],r=s.name?s.name:"animation_"+e,o=[],l=[],c=[],d=[],g=[];for(let p=0,h=s.channels.length;p<h;p++){const v=s.channels[p],y=s.samplers[v.sampler],w=v.target,S=w.node,M=s.parameters!==void 0?s.parameters[y.input]:y.input,T=s.parameters!==void 0?s.parameters[y.output]:y.output;w.node!==void 0&&(o.push(this.getDependency("node",S)),l.push(this.getDependency("accessor",M)),c.push(this.getDependency("accessor",T)),d.push(y),g.push(w))}return Promise.all([Promise.all(o),Promise.all(l),Promise.all(c),Promise.all(d),Promise.all(g)]).then(function(p){const h=p[0],v=p[1],y=p[2],w=p[3],S=p[4],M=[];for(let T=0,C=h.length;T<C;T++){const x=h[T],R=v[T],P=y[T],D=w[T],z=S[T];if(x===void 0)continue;x.updateMatrix&&x.updateMatrix();const U=i._createAnimationTracks(x,R,P,D,z);if(U)for(let N=0;N<U.length;N++)M.push(U[N])}return new d0(r,void 0,M)})}createNodeMesh(e){const t=this.json,i=this,s=t.nodes[e];return s.mesh===void 0?null:i.getDependency("mesh",s.mesh).then(function(r){const o=i._getNodeRef(i.meshCache,s.mesh,r);return s.weights!==void 0&&o.traverse(function(l){if(l.isMesh)for(let c=0,d=s.weights.length;c<d;c++)l.morphTargetInfluences[c]=s.weights[c]}),o})}loadNode(e){const t=this.json,i=this,s=t.nodes[e],r=i._loadNodeShallow(e),o=[],l=s.children||[];for(let d=0,g=l.length;d<g;d++)o.push(i.getDependency("node",l[d]));const c=s.skin===void 0?Promise.resolve(null):i.getDependency("skin",s.skin);return Promise.all([r,Promise.all(o),c]).then(function(d){const g=d[0],p=d[1],h=d[2];h!==null&&g.traverse(function(v){v.isSkinnedMesh&&v.bind(h,F5)});for(let v=0,y=p.length;v<y;v++)g.add(p[v]);return g})}_loadNodeShallow(e){const t=this.json,i=this.extensions,s=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],o=r.name?s.createUniqueName(r.name):"",l=[],c=s._invokeOne(function(d){return d.createNodeMesh&&d.createNodeMesh(e)});return c&&l.push(c),r.camera!==void 0&&l.push(s.getDependency("camera",r.camera).then(function(d){return s._getNodeRef(s.cameraCache,r.camera,d)})),s._invokeAll(function(d){return d.createNodeAttachment&&d.createNodeAttachment(e)}).forEach(function(d){l.push(d)}),this.nodeCache[e]=Promise.all(l).then(function(d){let g;if(r.isBone===!0?g=new lx:d.length>1?g=new Hh:d.length===1?g=d[0]:g=new fs,g!==d[0])for(let p=0,h=d.length;p<h;p++)g.add(d[p]);if(r.name&&(g.userData.name=r.name,g.name=o),zh(g,r),r.extensions&&pg(i,g,r),r.matrix!==void 0){const p=new li;p.fromArray(r.matrix),g.applyMatrix4(p)}else r.translation!==void 0&&g.position.fromArray(r.translation),r.rotation!==void 0&&g.quaternion.fromArray(r.rotation),r.scale!==void 0&&g.scale.fromArray(r.scale);return s.associations.has(g)||s.associations.set(g,{}),s.associations.get(g).nodes=e,g}),this.nodeCache[e]}loadScene(e){const t=this.extensions,i=this.json.scenes[e],s=this,r=new Hh;i.name&&(r.name=s.createUniqueName(i.name)),zh(r,i),i.extensions&&pg(t,r,i);const o=i.nodes||[],l=[];for(let c=0,d=o.length;c<d;c++)l.push(s.getDependency("node",o[c]));return Promise.all(l).then(function(c){for(let g=0,p=c.length;g<p;g++)r.add(c[g]);const d=g=>{const p=new Map;for(const[h,v]of s.associations)(h instanceof pa||h instanceof vr)&&p.set(h,v);return g.traverse(h=>{const v=s.associations.get(h);v!=null&&p.set(h,v)}),p};return s.associations=d(r),r})}_createAnimationTracks(e,t,i,s,r){const o=[],l=e.name?e.name:e.uuid,c=[];nm[r.path]===nm.weights?e.traverse(function(h){h.morphTargetInfluences&&c.push(h.name?h.name:h.uuid)}):c.push(l);let d;switch(nm[r.path]){case nm.weights:d=Hg;break;case nm.rotation:d=jg;break;case nm.position:case nm.scale:d=$g;break;default:switch(i.itemSize){case 1:d=Hg;break;case 2:case 3:default:d=$g;break}break}const g=s.interpolation!==void 0?R5[s.interpolation]:r0,p=this._getArrayFromAccessor(i);for(let h=0,v=c.length;h<v;h++){const y=new d(c[h]+"."+nm[r.path],t.array,p,g);s.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(y),o.push(y)}return o}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const i=HE(t.constructor),s=new Float32Array(t.length);for(let r=0,o=t.length;r<o;r++)s[r]=t[r]*i;t=s}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(i){const s=this instanceof jg?P5:$O;return new s(this.times,this.values,this.getValueSize()/3,i)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function z5(n,e,t){const i=e.attributes,s=new Ra;if(i.POSITION!==void 0){const l=t.json.accessors[i.POSITION],c=l.min,d=l.max;if(c!==void 0&&d!==void 0){if(s.set(new Oe(c[0],c[1],c[2]),new Oe(d[0],d[1],d[2])),l.normalized){const g=HE(e0[l.componentType]);s.min.multiplyScalar(g),s.max.multiplyScalar(g)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const l=new Oe,c=new Oe;for(let d=0,g=r.length;d<g;d++){const p=r[d];if(p.POSITION!==void 0){const h=t.json.accessors[p.POSITION],v=h.min,y=h.max;if(v!==void 0&&y!==void 0){if(c.setX(Math.max(Math.abs(v[0]),Math.abs(y[0]))),c.setY(Math.max(Math.abs(v[1]),Math.abs(y[1]))),c.setZ(Math.max(Math.abs(v[2]),Math.abs(y[2]))),h.normalized){const w=HE(e0[h.componentType]);c.multiplyScalar(w)}l.max(c)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}s.expandByVector(l)}n.boundingBox=s;const o=new uo;s.getCenter(o.center),o.radius=s.min.distanceTo(s.max)/2,n.boundingSphere=o}function y2(n,e,t){const i=e.attributes,s=[];function r(o,l){return t.getDependency("accessor",o).then(function(c){n.setAttribute(l,c)})}for(const o in i){const l=VE[o]||o.toLowerCase();l in n.attributes||s.push(r(i[o],l))}if(e.indices!==void 0&&!n.index){const o=t.getDependency("accessor",e.indices).then(function(l){n.setIndex(l)});s.push(o)}return zh(n,e),z5(n,e,t),Promise.all(s).then(function(){return e.targets!==void 0?B5(n,e.targets,t):n})}const c1=new WeakMap;class U5 extends Zo{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,i,s){const r=new Qu(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,o=>{const l={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(o,l).then(t).catch(s)},i,s)}decodeDracoFile(e,t,i,s){const r={attributeIDs:i||this.defaultAttributeIDs,attributeTypes:s||this.defaultAttributeTypes,useUniqueIDs:!!i};this.decodeGeometry(e,r).then(t)}decodeGeometry(e,t){for(const c in t.attributeTypes){const d=t.attributeTypes[c];d.BYTES_PER_ELEMENT!==void 0&&(t.attributeTypes[c]=d.name)}const i=JSON.stringify(t);if(c1.has(e)){const c=c1.get(e);if(c.key===i)return c.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let s;const r=this.workerNextTaskID++,o=e.byteLength,l=this._getWorker(r,o).then(c=>(s=c,new Promise((d,g)=>{s._callbacks[r]={resolve:d,reject:g},s.postMessage({type:"decode",id:r,taskConfig:t,buffer:e},[e])}))).then(c=>this._createGeometry(c.geometry));return l.catch(()=>!0).then(()=>{s&&r&&this._releaseTask(s,r)}),c1.set(e,{key:i,promise:l}),l}_createGeometry(e){const t=new xi;e.index&&t.setIndex(new hs(e.index.array,1));for(let i=0;i<e.attributes.length;i++){const s=e.attributes[i],r=s.name,o=s.array,l=s.itemSize;t.setAttribute(r,new hs(o,l))}return t}_loadLibrary(e,t){const i=new Qu(this.manager);return i.setPath(this.decoderPath),i.setResponseType(t),i.setWithCredentials(this.withCredentials),new Promise((s,r)=>{i.load(e,s,void 0,r)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(i=>{const s=i[0];e||(this.decoderConfig.wasmBinary=i[1]);const r=k5.toString(),o=["/* draco decoder */",s,"","/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([o]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const s=new Worker(this.workerSourceURL);s._callbacks={},s._taskCosts={},s._taskLoad=0,s.postMessage({type:"init",decoderConfig:this.decoderConfig}),s.onmessage=function(r){const o=r.data;switch(o.type){case"decode":s._callbacks[o.id].resolve(o);break;case"error":s._callbacks[o.id].reject(o);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+o.type+'"')}},this.workerPool.push(s)}else this.workerPool.sort(function(s,r){return s._taskLoad>r._taskLoad?-1:1});const i=this.workerPool[this.workerPool.length-1];return i._taskCosts[e]=t,i._taskLoad+=t,i})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function k5(){let n,e;onmessage=function(o){const l=o.data;switch(l.type){case"init":n=l.decoderConfig,e=new Promise(function(g){n.onModuleLoaded=function(p){g({draco:p})},DracoDecoderModule(n)});break;case"decode":const c=l.buffer,d=l.taskConfig;e.then(g=>{const p=g.draco,h=new p.Decoder,v=new p.DecoderBuffer;v.Init(new Int8Array(c),c.byteLength);try{const y=t(p,h,v,d),w=y.attributes.map(S=>S.array.buffer);y.index&&w.push(y.index.array.buffer),self.postMessage({type:"decode",id:l.id,geometry:y},w)}catch(y){console.error(y),self.postMessage({type:"error",id:l.id,error:y.message})}finally{p.destroy(v),p.destroy(h)}});break}};function t(o,l,c,d){const g=d.attributeIDs,p=d.attributeTypes;let h,v;const y=l.GetEncodedGeometryType(c);if(y===o.TRIANGULAR_MESH)h=new o.Mesh,v=l.DecodeBufferToMesh(c,h);else if(y===o.POINT_CLOUD)h=new o.PointCloud,v=l.DecodeBufferToPointCloud(c,h);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!v.ok()||h.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+v.error_msg());const w={index:null,attributes:[]};for(const S in g){const M=self[p[S]];let T,C;if(d.useUniqueIDs)C=g[S],T=l.GetAttributeByUniqueId(h,C);else{if(C=l.GetAttributeId(h,o[g[S]]),C===-1)continue;T=l.GetAttribute(h,C)}w.attributes.push(s(o,l,h,S,M,T))}return y===o.TRIANGULAR_MESH&&(w.index=i(o,l,h)),o.destroy(h),w}function i(o,l,c){const g=c.num_faces()*3,p=g*4,h=o._malloc(p);l.GetTrianglesUInt32Array(c,p,h);const v=new Uint32Array(o.HEAPF32.buffer,h,g).slice();return o._free(h),{array:v,itemSize:1}}function s(o,l,c,d,g,p){const h=p.num_components(),y=c.num_points()*h,w=y*g.BYTES_PER_ELEMENT,S=r(o,g),M=o._malloc(w);l.GetAttributeDataArrayForAllPoints(c,p,S,w,M);const T=new g(o.HEAPF32.buffer,M,y).slice();return o._free(M),{name:d,array:T,itemSize:h}}function r(o,l){switch(l){case Float32Array:return o.DT_FLOAT32;case Int8Array:return o.DT_INT8;case Int16Array:return o.DT_INT16;case Int32Array:return o.DT_INT32;case Uint8Array:return o.DT_UINT8;case Uint16Array:return o.DT_UINT16;case Uint32Array:return o.DT_UINT32}}}let xM;const d1=()=>{if(xM)return xM;const n="B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",e="B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",t=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),i=new Uint8Array([32,0,65,253,3,1,2,34,4,106,6,5,11,8,7,20,13,33,12,16,128,9,116,64,19,113,127,15,10,21,22,14,255,66,24,54,136,107,18,23,192,26,114,118,132,17,77,101,130,144,27,87,131,44,45,74,156,154,70,167]);if(typeof WebAssembly!="object")return{supported:!1};let s=n;WebAssembly.validate(t)&&(s=e);let r;const o=WebAssembly.instantiate(l(s),{}).then(p=>{r=p.instance,r.exports.__wasm_call_ctors()});function l(p){const h=new Uint8Array(p.length);for(let y=0;y<p.length;++y){const w=p.charCodeAt(y);h[y]=w>96?w-71:w>64?w-65:w>47?w+4:w>46?63:62}let v=0;for(let y=0;y<p.length;++y)h[v++]=h[y]<60?i[h[y]]:(h[y]-60)*64+h[++y];return h.buffer.slice(0,v)}function c(p,h,v,y,w,S){const M=r.exports.sbrk,T=v+3&-4,C=M(T*y),x=M(w.length),R=new Uint8Array(r.exports.memory.buffer);R.set(w,x);const P=p(C,v,y,x,w.length);if(P===0&&S&&S(C,T,y),h.set(R.subarray(C,C+v*y)),M(C-M(0)),P!==0)throw new Error(`Malformed buffer data: ${P}`)}const d={0:"",1:"meshopt_decodeFilterOct",2:"meshopt_decodeFilterQuat",3:"meshopt_decodeFilterExp",NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},g={0:"meshopt_decodeVertexBuffer",1:"meshopt_decodeIndexBuffer",2:"meshopt_decodeIndexSequence",ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"};return xM={ready:o,supported:!0,decodeVertexBuffer(p,h,v,y,w){c(r.exports.meshopt_decodeVertexBuffer,p,h,v,y,r.exports[d[w]])},decodeIndexBuffer(p,h,v,y){c(r.exports.meshopt_decodeIndexBuffer,p,h,v,y)},decodeIndexSequence(p,h,v,y){c(r.exports.meshopt_decodeIndexSequence,p,h,v,y)},decodeGltfBuffer(p,h,v,y,w,S){c(r.exports[g[w]],p,h,v,y,r.exports[d[S]])}},xM};let wM=null,WO="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function KO(n=!0,e=!0,t){return i=>{t&&t(i),n&&(wM||(wM=new U5),wM.setDecoderPath(typeof n=="string"?n:WO),i.setDRACOLoader(wM)),e&&i.setMeshoptDecoder(typeof d1=="function"?d1():d1)}}const Px=(n,e,t,i)=>ty(rS,n,KO(e,t,i));Px.preload=(n,e,t,i)=>ty.preload(rS,n,KO(e,t,i));Px.clear=n=>ty.clear(rS,n);Px.setDecoderPath=n=>{WO=n};const G5=Ft.forwardRef(({makeDefault:n,camera:e,regress:t,domElement:i,enableDamping:s=!0,keyEvents:r=!1,onChange:o,onStart:l,onEnd:c,...d},g)=>{const p=ju(P=>P.invalidate),h=ju(P=>P.camera),v=ju(P=>P.gl),y=ju(P=>P.events),w=ju(P=>P.setEvents),S=ju(P=>P.set),M=ju(P=>P.get),T=ju(P=>P.performance),C=e||h,x=i||y.connected||v.domElement,R=Ft.useMemo(()=>new i5(C),[C]);return ey(()=>{R.enabled&&R.update()},-1),Ft.useEffect(()=>(r&&R.connect(r===!0?x:r),R.connect(x),()=>void R.dispose()),[r,x,t,R,p]),Ft.useEffect(()=>{const P=U=>{p(),t&&T.regress(),o&&o(U)},D=U=>{l&&l(U)},z=U=>{c&&c(U)};return R.addEventListener("change",P),R.addEventListener("start",D),R.addEventListener("end",z),()=>{R.removeEventListener("start",D),R.removeEventListener("end",z),R.removeEventListener("change",P)}},[o,l,c,R,p,w]),Ft.useEffect(()=>{if(n){const P=M().controls;return S({controls:R}),()=>S({controls:P})}},[n,R]),Ft.createElement("primitive",Fb({ref:g,object:R,enableDamping:s},d))});var f1=1/1e3,V5=1e3,H5=class{constructor(){this.startTime=performance.now(),this.previousTime=0,this.currentTime=0,this._delta=0,this._elapsed=0,this._fixedDelta=1e3/60,this.timescale=1,this.useFixedDelta=!1,this._autoReset=!1}get autoReset(){return this._autoReset}set autoReset(n){typeof document<"u"&&document.hidden!==void 0&&(n?document.addEventListener("visibilitychange",this):document.removeEventListener("visibilitychange",this),this._autoReset=n)}get delta(){return this._delta*f1}get fixedDelta(){return this._fixedDelta*f1}set fixedDelta(n){this._fixedDelta=n*V5}get elapsed(){return this._elapsed*f1}update(n){this.useFixedDelta?this._delta=this.fixedDelta:(this.previousTime=this.currentTime,this.currentTime=(n!==void 0?n:performance.now())-this.startTime,this._delta=this.currentTime-this.previousTime),this._delta*=this.timescale,this._elapsed+=this._delta}reset(){this._delta=0,this._elapsed=0,this.currentTime=performance.now()-this.startTime}getDelta(){return this.delta}getElapsed(){return this.elapsed}handleEvent(n){document.hidden||(this.currentTime=performance.now()-this.startTime)}dispose(){this.autoReset=!1}},j5=(()=>{const n=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),e=new Float32Array([0,0,2,0,0,2]),t=new xi;return t.setAttribute("position",new hs(n,3)),t.setAttribute("uv",new hs(e,2)),t})(),lu=class jE{static get fullscreenGeometry(){return j5}constructor(e="Pass",t=new Fv,i=new Lc){this.name=e,this.renderer=null,this.scene=t,this.camera=i,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(e){if(this.rtt===e){const t=this.fullscreenMaterial;t!==null&&(t.needsUpdate=!0),this.rtt=!e}}set mainScene(e){}set mainCamera(e){}setRenderer(e){this.renderer=e}isEnabled(){return this.enabled}setEnabled(e){this.enabled=e}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(e){let t=this.screen;t!==null?t.material=e:(t=new ea(jE.fullscreenGeometry,e),t.frustumCulled=!1,this.scene===null&&(this.scene=new Fv),this.scene.add(t),this.screen=t)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(e){this.fullscreenMaterial=e}getDepthTexture(){return null}setDepthTexture(e,t=mm){}render(e,t,i,s,r){throw new Error("Render method not implemented!")}setSize(e,t){}initialize(e,t,i){}dispose(){for(const e of Object.keys(this)){const t=this[e];(t instanceof Da||t instanceof pa||t instanceof vr||t instanceof jE)&&this[e].dispose()}this.fullscreenMaterial!==null&&this.fullscreenMaterial.dispose()}},$5=class extends lu{constructor(){super("ClearMaskPass",null,null),this.needsSwap=!1}render(n,e,t,i,s){const r=n.state.buffers.stencil;r.setLocked(!1),r.setTest(!1)}},W5=`#ifdef COLOR_WRITE
#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#endif
#ifdef DEPTH_WRITE
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}
#endif
#ifdef USE_WEIGHTS
uniform vec4 channelWeights;
#endif
uniform float opacity;varying vec2 vUv;void main(){
#ifdef COLOR_WRITE
vec4 texel=texture2D(inputBuffer,vUv);
#ifdef USE_WEIGHTS
texel*=channelWeights;
#endif
gl_FragColor=opacity*texel;
#ifdef COLOR_SPACE_CONVERSION
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
#else
gl_FragColor=vec4(0.0);
#endif
#ifdef DEPTH_WRITE
gl_FragDepth=readDepth(vUv);
#endif
}`,qO="varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",XO=class extends ja{constructor(){super({name:"CopyMaterial",defines:{DEPTH_PACKING:"0",COLOR_WRITE:"1"},uniforms:{inputBuffer:new cs(null),depthBuffer:new cs(null),channelWeights:new cs(null),opacity:new cs(1)},blending:Jo,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:W5,vertexShader:qO}),this.depthFunc=Pv}get inputBuffer(){return this.uniforms.inputBuffer.value}set inputBuffer(n){const e=n!==null;this.colorWrite!==e&&(e?this.defines.COLOR_WRITE=!0:delete this.defines.COLOR_WRITE,this.colorWrite=e,this.needsUpdate=!0),this.uniforms.inputBuffer.value=n}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(n){const e=n!==null;this.depthWrite!==e&&(e?this.defines.DEPTH_WRITE=!0:delete this.defines.DEPTH_WRITE,this.depthTest=e,this.depthWrite=e,this.needsUpdate=!0),this.uniforms.depthBuffer.value=n}set depthPacking(n){this.defines.DEPTH_PACKING=n.toFixed(0),this.needsUpdate=!0}get channelWeights(){return this.uniforms.channelWeights.value}set channelWeights(n){n!==null?(this.defines.USE_WEIGHTS="1",this.uniforms.channelWeights.value=n):delete this.defines.USE_WEIGHTS,this.needsUpdate=!0}setInputBuffer(n){this.uniforms.inputBuffer.value=n}getOpacity(n){return this.uniforms.opacity.value}setOpacity(n){this.uniforms.opacity.value=n}},K5=class extends lu{constructor(n,e=!0){super("CopyPass"),this.fullscreenMaterial=new XO,this.needsSwap=!1,this.renderTarget=n,n===void 0&&(this.renderTarget=new Da(1,1,{minFilter:Tr,magFilter:Tr,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="CopyPass.Target"),this.autoResize=e}get resize(){return this.autoResize}set resize(n){this.autoResize=n}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}setAutoResizeEnabled(n){this.autoResize=n}render(n,e,t,i,s){this.fullscreenMaterial.inputBuffer=e.texture,n.setRenderTarget(this.renderToScreen?null:this.renderTarget),n.render(this.scene,this.camera)}setSize(n,e){this.autoResize&&this.renderTarget.setSize(n,e)}initialize(n,e,t){t!==void 0&&(this.renderTarget.texture.type=t,t!==Ha?this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1":n!==null&&n.outputColorSpace===Rs&&(this.renderTarget.texture.colorSpace=Rs))}},M2=new Sn,YO=class extends lu{constructor(n=!0,e=!0,t=!1){super("ClearPass",null,null),this.needsSwap=!1,this.color=n,this.depth=e,this.stencil=t,this.overrideClearColor=null,this.overrideClearAlpha=-1}setClearFlags(n,e,t){this.color=n,this.depth=e,this.stencil=t}getOverrideClearColor(){return this.overrideClearColor}setOverrideClearColor(n){this.overrideClearColor=n}getOverrideClearAlpha(){return this.overrideClearAlpha}setOverrideClearAlpha(n){this.overrideClearAlpha=n}render(n,e,t,i,s){const r=this.overrideClearColor,o=this.overrideClearAlpha,l=n.getClearAlpha(),c=r!==null,d=o>=0;c?(n.getClearColor(M2),n.setClearColor(r,d?o:l)):d&&n.setClearAlpha(o),n.setRenderTarget(this.renderToScreen?null:e),n.clear(this.color,this.depth,this.stencil),c?n.setClearColor(M2,l):d&&n.setClearAlpha(l)}},q5=class extends lu{constructor(n,e){super("MaskPass",n,e),this.needsSwap=!1,this.clearPass=new YO(!1,!1,!0),this.inverse=!1}set mainScene(n){this.scene=n}set mainCamera(n){this.camera=n}get inverted(){return this.inverse}set inverted(n){this.inverse=n}get clear(){return this.clearPass.enabled}set clear(n){this.clearPass.enabled=n}getClearPass(){return this.clearPass}isInverted(){return this.inverted}setInverted(n){this.inverted=n}render(n,e,t,i,s){const r=n.getContext(),o=n.state.buffers,l=this.scene,c=this.camera,d=this.clearPass,g=this.inverted?0:1,p=1-g;o.color.setMask(!1),o.depth.setMask(!1),o.color.setLocked(!0),o.depth.setLocked(!0),o.stencil.setTest(!0),o.stencil.setOp(r.REPLACE,r.REPLACE,r.REPLACE),o.stencil.setFunc(r.ALWAYS,g,4294967295),o.stencil.setClear(p),o.stencil.setLocked(!0),this.clearPass.enabled&&(this.renderToScreen?d.render(n,null):(d.render(n,e),d.render(n,t))),this.renderToScreen?(n.setRenderTarget(null),n.render(l,c)):(n.setRenderTarget(e),n.render(l,c),n.setRenderTarget(t),n.render(l,c)),o.color.setLocked(!1),o.depth.setLocked(!1),o.stencil.setLocked(!1),o.stencil.setFunc(r.EQUAL,1,4294967295),o.stencil.setOp(r.KEEP,r.KEEP,r.KEEP),o.stencil.setLocked(!0)}},X5=class{constructor(n=null,{depthBuffer:e=!0,stencilBuffer:t=!1,multisampling:i=0,frameBufferType:s}={}){this.renderer=null,this.inputBuffer=this.createBuffer(e,t,s,i),this.outputBuffer=this.inputBuffer.clone(),this.copyPass=new K5,this.depthTexture=null,this.passes=[],this.timer=new H5,this.autoRenderToScreen=!0,this.setRenderer(n)}get multisampling(){return this.inputBuffer.samples||0}set multisampling(n){const e=this.inputBuffer,t=this.multisampling;t>0&&n>0?(this.inputBuffer.samples=n,this.outputBuffer.samples=n,this.inputBuffer.dispose(),this.outputBuffer.dispose()):t!==n&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(e.depthBuffer,e.stencilBuffer,e.texture.type,n),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}getTimer(){return this.timer}getRenderer(){return this.renderer}setRenderer(n){if(this.renderer=n,n!==null){const e=n.getSize(new Gt),t=n.getContext().getContextAttributes().alpha,i=this.inputBuffer.texture.type;i===Ha&&n.outputColorSpace===Rs&&(this.inputBuffer.texture.colorSpace=Rs,this.outputBuffer.texture.colorSpace=Rs,this.inputBuffer.dispose(),this.outputBuffer.dispose()),n.autoClear=!1,this.setSize(e.width,e.height);for(const s of this.passes)s.initialize(n,t,i)}}replaceRenderer(n,e=!0){const t=this.renderer,i=t.domElement.parentNode;return this.setRenderer(n),e&&i!==null&&(i.removeChild(t.domElement),i.appendChild(n.domElement)),t}createDepthTexture(){const n=this.depthTexture=new fx;return this.inputBuffer.depthTexture=n,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(n.format=kg,n.type=Ug):n.type=kf,n}deleteDepthTexture(){if(this.depthTexture!==null){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();for(const n of this.passes)n.setDepthTexture(null)}}createBuffer(n,e,t,i){const s=this.renderer,r=s===null?new Gt:s.getDrawingBufferSize(new Gt),o={minFilter:Tr,magFilter:Tr,stencilBuffer:e,depthBuffer:n,type:t},l=new Da(r.width,r.height,o);return i>0&&(l.samples=i),t===Ha&&s!==null&&s.outputColorSpace===Rs&&(l.texture.colorSpace=Rs),l.texture.name="EffectComposer.Buffer",l.texture.generateMipmaps=!1,l}setMainScene(n){for(const e of this.passes)e.mainScene=n}setMainCamera(n){for(const e of this.passes)e.mainCamera=n}addPass(n,e){const t=this.passes,i=this.renderer,s=i.getDrawingBufferSize(new Gt),r=i.getContext().getContextAttributes().alpha,o=this.inputBuffer.texture.type;if(n.setRenderer(i),n.setSize(s.width,s.height),n.initialize(i,r,o),this.autoRenderToScreen&&(t.length>0&&(t[t.length-1].renderToScreen=!1),n.renderToScreen&&(this.autoRenderToScreen=!1)),e!==void 0?t.splice(e,0,n):t.push(n),this.autoRenderToScreen&&(t[t.length-1].renderToScreen=!0),n.needsDepthTexture||this.depthTexture!==null)if(this.depthTexture===null){const l=this.createDepthTexture();for(n of t)n.setDepthTexture(l)}else n.setDepthTexture(this.depthTexture)}removePass(n){const e=this.passes,t=e.indexOf(n);if(t!==-1&&e.splice(t,1).length>0){if(this.depthTexture!==null){const r=(l,c)=>l||c.needsDepthTexture;e.reduce(r,!1)||(n.getDepthTexture()===this.depthTexture&&n.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&t===e.length&&(n.renderToScreen=!1,e.length>0&&(e[e.length-1].renderToScreen=!0))}}removeAllPasses(){const n=this.passes;this.deleteDepthTexture(),n.length>0&&(this.autoRenderToScreen&&(n[n.length-1].renderToScreen=!1),this.passes=[])}render(n){const e=this.renderer,t=this.copyPass;let i=this.inputBuffer,s=this.outputBuffer,r=!1,o,l,c;n===void 0&&(this.timer.update(),n=this.timer.getDelta());for(const d of this.passes)d.enabled&&(d.render(e,i,s,n,r),d.needsSwap&&(r&&(t.renderToScreen=d.renderToScreen,o=e.getContext(),l=e.state.buffers.stencil,l.setFunc(o.NOTEQUAL,1,4294967295),t.render(e,i,s,n,r),l.setFunc(o.EQUAL,1,4294967295)),c=i,i=s,s=c),d instanceof q5?r=!0:d instanceof $5&&(r=!1))}setSize(n,e,t){const i=this.renderer,s=i.getSize(new Gt);(n===void 0||e===void 0)&&(n=s.width,e=s.height),(s.width!==n||s.height!==e)&&i.setSize(n,e,t);const r=i.getDrawingBufferSize(new Gt);this.inputBuffer.setSize(r.width,r.height),this.outputBuffer.setSize(r.width,r.height);for(const o of this.passes)o.setSize(r.width,r.height)}reset(){this.dispose(),this.autoRenderToScreen=!0}dispose(){for(const n of this.passes)n.dispose();this.passes=[],this.inputBuffer!==null&&this.inputBuffer.dispose(),this.outputBuffer!==null&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose(),this.timer.dispose(),lu.fullscreenGeometry.dispose()}},Ng={NONE:0,DEPTH:1,CONVOLUTION:2},Ps={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},Y5=class{constructor(){this.shaderParts=new Map([[Ps.FRAGMENT_HEAD,null],[Ps.FRAGMENT_MAIN_UV,null],[Ps.FRAGMENT_MAIN_IMAGE,null],[Ps.VERTEX_HEAD,null],[Ps.VERTEX_MAIN_SUPPORT,null]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.extensions=new Set,this.attributes=Ng.NONE,this.varyings=new Set,this.uvTransformation=!1,this.readDepth=!1,this.colorSpace=Gf}},h1=!1,b2=class{constructor(n=null){this.originalMaterials=new Map,this.material=null,this.materials=null,this.materialsBackSide=null,this.materialsDoubleSide=null,this.materialsFlatShaded=null,this.materialsFlatShadedBackSide=null,this.materialsFlatShadedDoubleSide=null,this.setMaterial(n),this.meshCount=0,this.replaceMaterial=e=>{if(e.isMesh){let t;if(e.material.flatShading)switch(e.material.side){case Ro:t=this.materialsFlatShadedDoubleSide;break;case Ga:t=this.materialsFlatShadedBackSide;break;default:t=this.materialsFlatShaded;break}else switch(e.material.side){case Ro:t=this.materialsDoubleSide;break;case Ga:t=this.materialsBackSide;break;default:t=this.materials;break}this.originalMaterials.set(e,e.material),e.isSkinnedMesh?e.material=t[2]:e.isInstancedMesh?e.material=t[1]:e.material=t[0],++this.meshCount}}}cloneMaterial(n){if(!(n instanceof ja))return n.clone();const e=n.uniforms,t=new Map;for(const s in e){const r=e[s].value;r.isRenderTargetTexture&&(e[s].value=null,t.set(s,r))}const i=n.clone();for(const s of t)e[s[0]].value=s[1],i.uniforms[s[0]].value=s[1];return i}setMaterial(n){if(this.disposeMaterials(),this.material=n,n!==null){const e=this.materials=[this.cloneMaterial(n),this.cloneMaterial(n),this.cloneMaterial(n)];for(const t of e)t.uniforms=Object.assign({},n.uniforms),t.side=Nd;e[2].skinning=!0,this.materialsBackSide=e.map(t=>{const i=this.cloneMaterial(t);return i.uniforms=Object.assign({},n.uniforms),i.side=Ga,i}),this.materialsDoubleSide=e.map(t=>{const i=this.cloneMaterial(t);return i.uniforms=Object.assign({},n.uniforms),i.side=Ro,i}),this.materialsFlatShaded=e.map(t=>{const i=this.cloneMaterial(t);return i.uniforms=Object.assign({},n.uniforms),i.flatShading=!0,i}),this.materialsFlatShadedBackSide=e.map(t=>{const i=this.cloneMaterial(t);return i.uniforms=Object.assign({},n.uniforms),i.flatShading=!0,i.side=Ga,i}),this.materialsFlatShadedDoubleSide=e.map(t=>{const i=this.cloneMaterial(t);return i.uniforms=Object.assign({},n.uniforms),i.flatShading=!0,i.side=Ro,i})}}render(n,e,t){const i=n.shadowMap.enabled;if(n.shadowMap.enabled=!1,h1){const s=this.originalMaterials;this.meshCount=0,e.traverse(this.replaceMaterial),n.render(e,t);for(const r of s)r[0].material=r[1];this.meshCount!==s.size&&s.clear()}else{const s=e.overrideMaterial;e.overrideMaterial=this.material,n.render(e,t),e.overrideMaterial=s}n.shadowMap.enabled=i}disposeMaterials(){if(this.material!==null){const n=this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);for(const e of n)e.dispose()}}dispose(){this.originalMaterials.clear(),this.disposeMaterials()}static get workaroundEnabled(){return h1}static set workaroundEnabled(n){h1=n}},im=-1,Yo=class extends Zu{constructor(n,e=im,t=im,i=1){super(),this.resizable=n,this.baseSize=new Gt(1,1),this.preferredSize=new Gt(e,t),this.target=this.preferredSize,this.s=i,this.effectiveSize=new Gt,this.addEventListener("change",()=>this.updateEffectiveSize()),this.updateEffectiveSize()}updateEffectiveSize(){const n=this.baseSize,e=this.preferredSize,t=this.effectiveSize,i=this.scale;e.width!==im?t.width=e.width:e.height!==im?t.width=Math.round(e.height*(n.width/Math.max(n.height,1))):t.width=Math.round(n.width*i),e.height!==im?t.height=e.height:e.width!==im?t.height=Math.round(e.width/Math.max(n.width/Math.max(n.height,1),1)):t.height=Math.round(n.height*i)}get width(){return this.effectiveSize.width}set width(n){this.preferredWidth=n}get height(){return this.effectiveSize.height}set height(n){this.preferredHeight=n}getWidth(){return this.width}getHeight(){return this.height}get scale(){return this.s}set scale(n){this.s!==n&&(this.s=n,this.preferredSize.setScalar(im),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getScale(){return this.scale}setScale(n){this.scale=n}get baseWidth(){return this.baseSize.width}set baseWidth(n){this.baseSize.width!==n&&(this.baseSize.width=n,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseWidth(){return this.baseWidth}setBaseWidth(n){this.baseWidth=n}get baseHeight(){return this.baseSize.height}set baseHeight(n){this.baseSize.height!==n&&(this.baseSize.height=n,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseHeight(){return this.baseHeight}setBaseHeight(n){this.baseHeight=n}setBaseSize(n,e){(this.baseSize.width!==n||this.baseSize.height!==e)&&(this.baseSize.set(n,e),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}get preferredWidth(){return this.preferredSize.width}set preferredWidth(n){this.preferredSize.width!==n&&(this.preferredSize.width=n,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredWidth(){return this.preferredWidth}setPreferredWidth(n){this.preferredWidth=n}get preferredHeight(){return this.preferredSize.height}set preferredHeight(n){this.preferredSize.height!==n&&(this.preferredSize.height=n,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredHeight(){return this.preferredHeight}setPreferredHeight(n){this.preferredHeight=n}setPreferredSize(n,e){(this.preferredSize.width!==n||this.preferredSize.height!==e)&&(this.preferredSize.set(n,e),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}copy(n){this.s=n.scale,this.baseSize.set(n.baseWidth,n.baseHeight),this.preferredSize.set(n.preferredWidth,n.preferredHeight),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height)}static get AUTO_SIZE(){return im}},ls={ADD:0,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},J5="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb,y.a),y.a*opacity);}",Q5="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb)*0.5,y.a),y.a*opacity);}",Z5="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.xy,xHSL.z));return mix(x,vec4(z,y.a),y.a*opacity);}",e6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/b)),vec3(1.0),step(1.0,a));return mix(x,vec4(z,y.a),y.a*opacity);}",t6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(x,vec4(z,y.a),y.a*opacity);}",n6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb,y.rgb),y.a),y.a*opacity);}",i6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(abs(x.rgb-y.rgb),y.a),y.a*opacity);}",s6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb/max(y.rgb,1e-12),y.a),y.a*opacity);}",r6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb-2.0*x.rgb*y.rgb),y.a),y.a*opacity);}",a6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=min(x.rgb,1.0);vec3 b=min(y.rgb,1.0);vec3 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(x,vec4(z,y.a),y.a*opacity);}",o6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(step(1.0,x.rgb+y.rgb),y.a),y.a*opacity);}",l6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.x,xHSL.yz));return mix(x,vec4(z,y.a),y.a*opacity);}",u6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-y.rgb,y.a),y.a*opacity);}",c6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(y.rgb*(1.0-x.rgb),y.a),y.a*opacity);}",d6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb,y.rgb),y.a),y.a*opacity);}",f6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(y.rgb+x.rgb-1.0,0.0,1.0),y.a),y.a*opacity);}",h6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb+y.rgb,1.0),y.a),y.a*opacity);}",p6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(2.0*y.rgb+x.rgb-1.0,0.0,1.0),y.a),y.a*opacity);}",m6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.xy,yHSL.z));return mix(x,vec4(z,y.a),y.a*opacity);}",g6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb*y.rgb,y.a),y.a*opacity);}",_6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-abs(1.0-x.rgb-y.rgb),y.a),y.a*opacity);}",v6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,y.a*opacity);}",y6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(2.0*y.rgb*x.rgb,1.0-2.0*(1.0-y.rgb)*(1.0-x.rgb),step(0.5,x.rgb));return mix(x,vec4(z,y.a),y.a*opacity);}",M6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 y2=2.0*y.rgb;vec3 z=mix(mix(y2,x.rgb,step(0.5*x.rgb,y.rgb)),max(y2-1.0,vec3(0.0)),step(x.rgb,y2-1.0));return mix(x,vec4(z,y.a),y.a*opacity);}",b6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(min(x.rgb*x.rgb/max(1.0-y.rgb,1e-12),1.0),y.rgb,step(1.0,y.rgb));return mix(x,vec4(z,y.a),y.a*opacity);}",x6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.x,yHSL.y,xHSL.z));return mix(x,vec4(z,y.a),y.a*opacity);}",w6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb-min(x.rgb*y.rgb,1.0),y.a),y.a*opacity);}",E6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb;vec3 b=y.rgb;vec3 y2=2.0*b;vec3 w=step(0.5,b);vec3 c=a-(1.0-y2)*a*(1.0-a);vec3 d=mix(a+(y2-1.0)*(sqrt(a)-a),a+(y2-1.0)*a*((16.0*a-12.0)*a+3.0),w*(1.0-step(0.25,a)));vec3 z=mix(c,d,w);return mix(x,vec4(z,y.a),y.a*opacity);}",T6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",S6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb+y.rgb-1.0,0.0),y.a),y.a*opacity);}",A6="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(max(1.0-min((1.0-x.rgb)/(2.0*y.rgb),1.0),0.0),min(x.rgb/(2.0*(1.0-y.rgb)),1.0),step(0.5,y.rgb));return mix(x,vec4(z,y.a),y.a*opacity);}",C6=new Map([[ls.ADD,J5],[ls.AVERAGE,Q5],[ls.COLOR,Z5],[ls.COLOR_BURN,e6],[ls.COLOR_DODGE,t6],[ls.DARKEN,n6],[ls.DIFFERENCE,i6],[ls.DIVIDE,s6],[ls.DST,null],[ls.EXCLUSION,r6],[ls.HARD_LIGHT,a6],[ls.HARD_MIX,o6],[ls.HUE,l6],[ls.INVERT,u6],[ls.INVERT_RGB,c6],[ls.LIGHTEN,d6],[ls.LINEAR_BURN,f6],[ls.LINEAR_DODGE,h6],[ls.LINEAR_LIGHT,p6],[ls.LUMINOSITY,m6],[ls.MULTIPLY,g6],[ls.NEGATION,_6],[ls.NORMAL,v6],[ls.OVERLAY,y6],[ls.PIN_LIGHT,M6],[ls.REFLECT,b6],[ls.SATURATION,x6],[ls.SCREEN,w6],[ls.SOFT_LIGHT,E6],[ls.SRC,T6],[ls.SUBTRACT,S6],[ls.VIVID_LIGHT,A6]]),P6=class extends Zu{constructor(n,e=1){super(),this._blendFunction=n,this.opacity=new cs(e)}getOpacity(){return this.opacity.value}setOpacity(n){this.opacity.value=n}get blendFunction(){return this._blendFunction}set blendFunction(n){this._blendFunction=n,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(n){this.blendFunction=n}getShaderCode(){return C6.get(this.blendFunction)}},$E=class extends Zu{constructor(n,e,{attributes:t=Ng.NONE,blendFunction:i=ls.NORMAL,defines:s=new Map,uniforms:r=new Map,extensions:o=null,vertexShader:l=null}={}){super(),this.name=n,this.renderer=null,this.attributes=t,this.fragmentShader=e,this.vertexShader=l,this.defines=s,this.uniforms=r,this.extensions=o,this.blendMode=new P6(i),this.blendMode.addEventListener("change",c=>this.setChanged()),this._inputColorSpace=Gf,this._outputColorSpace=Bd}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(n){this._inputColorSpace=n,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(n){this._outputColorSpace=n,this.setChanged()}set mainScene(n){}set mainCamera(n){}getName(){return this.name}setRenderer(n){this.renderer=n}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(n){this.attributes=n,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(n){this.fragmentShader=n,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(n){this.vertexShader=n,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(n,e=mm){}update(n,e,t){}setSize(n,e){}initialize(n,e,t){}dispose(){for(const n of Object.keys(this)){const e=this[n];(e instanceof Da||e instanceof pa||e instanceof vr||e instanceof lu)&&this[n].dispose()}}},aS={MEDIUM:2,LARGE:3},R6=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`,D6="uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",B6=[new Float32Array([0,0]),new Float32Array([0,1,1]),new Float32Array([0,1,1,2]),new Float32Array([0,1,2,2,3]),new Float32Array([0,1,2,3,4,4,5]),new Float32Array([0,1,2,3,4,5,7,8,9,10])],I6=class extends ja{constructor(n=new ds){super({name:"KawaseBlurMaterial",uniforms:{inputBuffer:new cs(null),texelSize:new cs(new ds),scale:new cs(1),kernel:new cs(0)},blending:Jo,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:R6,vertexShader:D6}),this.setTexelSize(n.x,n.y),this.kernelSize=aS.MEDIUM}set inputBuffer(n){this.uniforms.inputBuffer.value=n}setInputBuffer(n){this.inputBuffer=n}get kernelSequence(){return B6[this.kernelSize]}get scale(){return this.uniforms.scale.value}set scale(n){this.uniforms.scale.value=n}getScale(){return this.uniforms.scale.value}setScale(n){this.uniforms.scale.value=n}getKernel(){return null}get kernel(){return this.uniforms.kernel.value}set kernel(n){this.uniforms.kernel.value=n}setKernel(n){this.kernel=n}setTexelSize(n,e){this.uniforms.texelSize.value.set(n,e,n*.5,e*.5)}setSize(n,e){const t=1/n,i=1/e;this.uniforms.texelSize.value.set(t,i,t*.5,i*.5)}},O6=class extends lu{constructor({kernelSize:n=aS.MEDIUM,resolutionScale:e=.5,width:t=Yo.AUTO_SIZE,height:i=Yo.AUTO_SIZE,resolutionX:s=t,resolutionY:r=i}={}){super("KawaseBlurPass"),this.renderTargetA=new Da(1,1,{depthBuffer:!1}),this.renderTargetA.texture.name="Blur.Target.A",this.renderTargetB=this.renderTargetA.clone(),this.renderTargetB.texture.name="Blur.Target.B";const o=this.resolution=new Yo(this,s,r,e);o.addEventListener("change",l=>this.setSize(o.baseWidth,o.baseHeight)),this._blurMaterial=new I6,this._blurMaterial.kernelSize=n,this.copyMaterial=new XO}getResolution(){return this.resolution}get blurMaterial(){return this._blurMaterial}set blurMaterial(n){this._blurMaterial=n}get dithering(){return this.copyMaterial.dithering}set dithering(n){this.copyMaterial.dithering=n}get kernelSize(){return this.blurMaterial.kernelSize}set kernelSize(n){this.blurMaterial.kernelSize=n}get width(){return this.resolution.width}set width(n){this.resolution.preferredWidth=n}get height(){return this.resolution.height}set height(n){this.resolution.preferredHeight=n}get scale(){return this.blurMaterial.scale}set scale(n){this.blurMaterial.scale=n}getScale(){return this.blurMaterial.scale}setScale(n){this.blurMaterial.scale=n}getKernelSize(){return this.kernelSize}setKernelSize(n){this.kernelSize=n}getResolutionScale(){return this.resolution.scale}setResolutionScale(n){this.resolution.scale=n}render(n,e,t,i,s){const r=this.scene,o=this.camera,l=this.renderTargetA,c=this.renderTargetB,d=this.blurMaterial,g=d.kernelSequence;let p=e;this.fullscreenMaterial=d;for(let h=0,v=g.length;h<v;++h){const y=(h&1)===0?l:c;d.kernel=g[h],d.inputBuffer=p.texture,n.setRenderTarget(y),n.render(r,o),p=y}this.fullscreenMaterial=this.copyMaterial,this.copyMaterial.inputBuffer=p.texture,n.setRenderTarget(this.renderToScreen?null:t),n.render(r,o)}setSize(n,e){const t=this.resolution;t.setBaseSize(n,e);const i=t.width,s=t.height;this.renderTargetA.setSize(i,s),this.renderTargetB.setSize(i,s),this.blurMaterial.setSize(n,e)}initialize(n,e,t){t!==void 0&&(this.renderTargetA.texture.type=t,this.renderTargetB.texture.type=t,t!==Ha?(this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1"):n!==null&&n.outputColorSpace===Rs&&(this.renderTargetA.texture.colorSpace=Rs,this.renderTargetB.texture.colorSpace=Rs))}static get AUTO_SIZE(){return Yo.AUTO_SIZE}},L6=`#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);float mask=1.0;
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);mask=low*high;
#elif defined(THRESHOLD)
mask=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=texel*mask;
#else
gl_FragColor=vec4(l*mask);
#endif
}`,F6=class extends ja{constructor(n=!1,e=null){super({name:"LuminanceMaterial",defines:{THREE_REVISION:Yg.replace(/\D+/g,"")},uniforms:{inputBuffer:new cs(null),threshold:new cs(0),smoothing:new cs(1),range:new cs(null)},blending:Jo,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:L6,vertexShader:qO}),this.colorOutput=n,this.luminanceRange=e}set inputBuffer(n){this.uniforms.inputBuffer.value=n}setInputBuffer(n){this.uniforms.inputBuffer.value=n}get threshold(){return this.uniforms.threshold.value}set threshold(n){this.smoothing>0||n>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.threshold.value=n}getThreshold(){return this.threshold}setThreshold(n){this.threshold=n}get smoothing(){return this.uniforms.smoothing.value}set smoothing(n){this.threshold>0||n>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.smoothing.value=n}getSmoothingFactor(){return this.smoothing}setSmoothingFactor(n){this.smoothing=n}get useThreshold(){return this.threshold>0||this.smoothing>0}set useThreshold(n){}get colorOutput(){return this.defines.COLOR!==void 0}set colorOutput(n){n?this.defines.COLOR="1":delete this.defines.COLOR,this.needsUpdate=!0}isColorOutputEnabled(n){return this.colorOutput}setColorOutputEnabled(n){this.colorOutput=n}get useRange(){return this.luminanceRange!==null}set useRange(n){this.luminanceRange=null}get luminanceRange(){return this.uniforms.range.value}set luminanceRange(n){n!==null?this.defines.RANGE="1":delete this.defines.RANGE,this.uniforms.range.value=n,this.needsUpdate=!0}getLuminanceRange(){return this.luminanceRange}setLuminanceRange(n){this.luminanceRange=n}},N6=class extends lu{constructor({renderTarget:n,luminanceRange:e,colorOutput:t,resolutionScale:i=1,width:s=Yo.AUTO_SIZE,height:r=Yo.AUTO_SIZE,resolutionX:o=s,resolutionY:l=r}={}){super("LuminancePass"),this.fullscreenMaterial=new F6(t,e),this.needsSwap=!1,this.renderTarget=n,this.renderTarget===void 0&&(this.renderTarget=new Da(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="LuminancePass.Target");const c=this.resolution=new Yo(this,o,l,i);c.addEventListener("change",d=>this.setSize(c.baseWidth,c.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}render(n,e,t,i,s){const r=this.fullscreenMaterial;r.inputBuffer=e.texture,n.setRenderTarget(this.renderToScreen?null:this.renderTarget),n.render(this.scene,this.camera)}setSize(n,e){const t=this.resolution;t.setBaseSize(n,e),this.renderTarget.setSize(t.width,t.height)}initialize(n,e,t){t!==void 0&&t!==Ha&&(this.renderTarget.texture.type=t,this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},z6=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <colorspace_fragment>
}`,U6="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}",k6=class extends ja{constructor(){super({name:"DownsamplingMaterial",uniforms:{inputBuffer:new cs(null),texelSize:new cs(new Gt)},blending:Jo,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:z6,vertexShader:U6})}set inputBuffer(n){this.uniforms.inputBuffer.value=n}setSize(n,e){this.uniforms.texelSize.value.set(1/n,1/e)}},G6=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <colorspace_fragment>
}`,V6="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}",H6=class extends ja{constructor(){super({name:"UpsamplingMaterial",uniforms:{inputBuffer:new cs(null),supportBuffer:new cs(null),texelSize:new cs(new Gt),radius:new cs(.85)},blending:Jo,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:G6,vertexShader:V6})}set inputBuffer(n){this.uniforms.inputBuffer.value=n}set supportBuffer(n){this.uniforms.supportBuffer.value=n}get radius(){return this.uniforms.radius.value}set radius(n){this.uniforms.radius.value=n}setSize(n,e){this.uniforms.texelSize.value.set(1/n,1/e)}},j6=class extends lu{constructor(){super("MipmapBlurPass"),this.needsSwap=!1,this.renderTarget=new Da(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Upsampling.Mipmap0",this.downsamplingMipmaps=[],this.upsamplingMipmaps=[],this.downsamplingMaterial=new k6,this.upsamplingMaterial=new H6,this.resolution=new Gt}get texture(){return this.renderTarget.texture}get levels(){return this.downsamplingMipmaps.length}set levels(n){if(this.levels!==n){const e=this.renderTarget;this.dispose(),this.downsamplingMipmaps=[],this.upsamplingMipmaps=[];for(let t=0;t<n;++t){const i=e.clone();i.texture.name="Downsampling.Mipmap"+t,this.downsamplingMipmaps.push(i)}this.upsamplingMipmaps.push(e);for(let t=1,i=n-1;t<i;++t){const s=e.clone();s.texture.name="Upsampling.Mipmap"+t,this.upsamplingMipmaps.push(s)}this.setSize(this.resolution.x,this.resolution.y)}}get radius(){return this.upsamplingMaterial.radius}set radius(n){this.upsamplingMaterial.radius=n}render(n,e,t,i,s){const{scene:r,camera:o}=this,{downsamplingMaterial:l,upsamplingMaterial:c}=this,{downsamplingMipmaps:d,upsamplingMipmaps:g}=this;let p=e;this.fullscreenMaterial=l;for(let h=0,v=d.length;h<v;++h){const y=d[h];l.setSize(p.width,p.height),l.inputBuffer=p.texture,n.setRenderTarget(y),n.render(r,o),p=y}this.fullscreenMaterial=c;for(let h=g.length-1;h>=0;--h){const v=g[h];c.setSize(p.width,p.height),c.inputBuffer=p.texture,c.supportBuffer=d[h].texture,n.setRenderTarget(v),n.render(r,o),p=v}}setSize(n,e){const t=this.resolution;t.set(n,e);let i=t.width,s=t.height;for(let r=0,o=this.downsamplingMipmaps.length;r<o;++r)i=Math.round(i*.5),s=Math.round(s*.5),this.downsamplingMipmaps[r].setSize(i,s),r<this.upsamplingMipmaps.length&&this.upsamplingMipmaps[r].setSize(i,s)}initialize(n,e,t){if(t!==void 0){const i=this.downsamplingMipmaps.concat(this.upsamplingMipmaps);for(const s of i)s.texture.type=t;if(t!==Ha)this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1";else if(n!==null&&n.outputColorSpace===Rs)for(const s of i)s.texture.colorSpace=Rs}}dispose(){super.dispose();for(const n of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))n.dispose()}},$6=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,max(inputColor.a,texel.a));}`,W6=class extends $E{constructor({blendFunction:n=ls.SCREEN,luminanceThreshold:e=1,luminanceSmoothing:t=.03,mipmapBlur:i=!0,intensity:s=1,radius:r=.85,levels:o=8,kernelSize:l=aS.LARGE,resolutionScale:c=.5,width:d=Yo.AUTO_SIZE,height:g=Yo.AUTO_SIZE,resolutionX:p=d,resolutionY:h=g}={}){super("BloomEffect",$6,{blendFunction:n,uniforms:new Map([["map",new cs(null)],["intensity",new cs(s)]])}),this.renderTarget=new Da(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Bloom.Target",this.blurPass=new O6({kernelSize:l}),this.luminancePass=new N6({colorOutput:!0}),this.luminanceMaterial.threshold=e,this.luminanceMaterial.smoothing=t,this.mipmapBlurPass=new j6,this.mipmapBlurPass.enabled=i,this.mipmapBlurPass.radius=r,this.mipmapBlurPass.levels=o,this.uniforms.get("map").value=i?this.mipmapBlurPass.texture:this.renderTarget.texture;const v=this.resolution=new Yo(this,p,h,c);v.addEventListener("change",y=>this.setSize(v.baseWidth,v.baseHeight))}get texture(){return this.mipmapBlurPass.enabled?this.mipmapBlurPass.texture:this.renderTarget.texture}getTexture(){return this.texture}getResolution(){return this.resolution}getBlurPass(){return this.blurPass}getLuminancePass(){return this.luminancePass}get luminanceMaterial(){return this.luminancePass.fullscreenMaterial}getLuminanceMaterial(){return this.luminancePass.fullscreenMaterial}get width(){return this.resolution.width}set width(n){this.resolution.preferredWidth=n}get height(){return this.resolution.height}set height(n){this.resolution.preferredHeight=n}get dithering(){return this.blurPass.dithering}set dithering(n){this.blurPass.dithering=n}get kernelSize(){return this.blurPass.kernelSize}set kernelSize(n){this.blurPass.kernelSize=n}get distinction(){return console.warn(this.name,"distinction was removed"),1}set distinction(n){console.warn(this.name,"distinction was removed")}get intensity(){return this.uniforms.get("intensity").value}set intensity(n){this.uniforms.get("intensity").value=n}getIntensity(){return this.intensity}setIntensity(n){this.intensity=n}getResolutionScale(){return this.resolution.scale}setResolutionScale(n){this.resolution.scale=n}update(n,e,t){const i=this.renderTarget,s=this.luminancePass;s.enabled?(s.render(n,e),this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(n,s.renderTarget):this.blurPass.render(n,s.renderTarget,i)):this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(n,e):this.blurPass.render(n,e,i)}setSize(n,e){const t=this.resolution;t.setBaseSize(n,e),this.renderTarget.setSize(t.width,t.height),this.blurPass.resolution.copy(t),this.luminancePass.setSize(n,e),this.mipmapBlurPass.setSize(n,e)}initialize(n,e,t){this.blurPass.initialize(n,e,t),this.luminancePass.initialize(n,e,t),this.mipmapBlurPass.initialize(n,e,t),t!==void 0&&(this.renderTarget.texture.type=t,n!==null&&n.outputColorSpace===Rs&&(this.renderTarget.texture.colorSpace=Rs))}},JO=class extends lu{constructor(n,e,t=null){super("RenderPass",n,e),this.needsSwap=!1,this.clearPass=new YO,this.overrideMaterialManager=t===null?null:new b2(t),this.ignoreBackground=!1,this.skipShadowMapUpdate=!1,this.selection=null}set mainScene(n){this.scene=n}set mainCamera(n){this.camera=n}get renderToScreen(){return super.renderToScreen}set renderToScreen(n){super.renderToScreen=n,this.clearPass.renderToScreen=n}get overrideMaterial(){const n=this.overrideMaterialManager;return n!==null?n.material:null}set overrideMaterial(n){const e=this.overrideMaterialManager;n!==null?e!==null?e.setMaterial(n):this.overrideMaterialManager=new b2(n):e!==null&&(e.dispose(),this.overrideMaterialManager=null)}getOverrideMaterial(){return this.overrideMaterial}setOverrideMaterial(n){this.overrideMaterial=n}get clear(){return this.clearPass.enabled}set clear(n){this.clearPass.enabled=n}getSelection(){return this.selection}setSelection(n){this.selection=n}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(n){this.ignoreBackground=n}isShadowMapDisabled(){return this.skipShadowMapUpdate}setShadowMapDisabled(n){this.skipShadowMapUpdate=n}getClearPass(){return this.clearPass}render(n,e,t,i,s){const r=this.scene,o=this.camera,l=this.selection,c=o.layers.mask,d=r.background,g=n.shadowMap.autoUpdate,p=this.renderToScreen?null:e;l!==null&&o.layers.set(l.getLayer()),this.skipShadowMapUpdate&&(n.shadowMap.autoUpdate=!1),(this.ignoreBackground||this.clearPass.overrideClearColor!==null)&&(r.background=null),this.clearPass.enabled&&this.clearPass.render(n,e),n.setRenderTarget(p),this.overrideMaterialManager!==null?this.overrideMaterialManager.render(n,r,o):n.render(r,o),o.layers.mask=c,r.background=d,n.shadowMap.autoUpdate=g}},K6=`#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
gl_FragColor=vec4(n[index],d[index]);}`,q6="uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",X6=class extends ja{constructor(){super({name:"DepthDownsamplingMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new cs(null),normalBuffer:new cs(null),texelSize:new cs(new Gt)},blending:Jo,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:K6,vertexShader:q6})}set depthBuffer(n){this.uniforms.depthBuffer.value=n}set depthPacking(n){this.defines.DEPTH_PACKING=n.toFixed(0),this.needsUpdate=!0}setDepthBuffer(n,e=mm){this.depthBuffer=n,this.depthPacking=e}set normalBuffer(n){this.uniforms.normalBuffer.value=n,n!==null?this.defines.DOWNSAMPLE_NORMALS="1":delete this.defines.DOWNSAMPLE_NORMALS,this.needsUpdate=!0}setNormalBuffer(n){this.normalBuffer=n}setTexelSize(n,e){this.uniforms.texelSize.value.set(n,e)}setSize(n,e){this.uniforms.texelSize.value.set(1/n,1/e)}},Y6=class extends lu{constructor({normalBuffer:n=null,resolutionScale:e=.5,width:t=Yo.AUTO_SIZE,height:i=Yo.AUTO_SIZE,resolutionX:s=t,resolutionY:r=i}={}){super("DepthDownsamplingPass");const o=new X6;o.normalBuffer=n,this.fullscreenMaterial=o,this.needsDepthTexture=!0,this.needsSwap=!1,this.renderTarget=new Da(1,1,{minFilter:ta,magFilter:ta,depthBuffer:!1,type:Rl}),this.renderTarget.texture.name="DepthDownsamplingPass.Target",this.renderTarget.texture.generateMipmaps=!1;const l=this.resolution=new Yo(this,s,r,e);l.addEventListener("change",c=>this.setSize(l.baseWidth,l.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}setDepthTexture(n,e=mm){this.fullscreenMaterial.depthBuffer=n,this.fullscreenMaterial.depthPacking=e}render(n,e,t,i,s){n.setRenderTarget(this.renderToScreen?null:this.renderTarget),n.render(this.scene,this.camera)}setSize(n,e){const t=this.resolution;t.setBaseSize(n,e),this.renderTarget.setSize(t.width,t.height),this.fullscreenMaterial.setSize(n,e)}initialize(n,e,t){const i=n.getContext();if(!(i.getExtension("EXT_color_buffer_float")||i.getExtension("EXT_color_buffer_half_float")))throw new Error("Rendering to float texture is not supported.")}},J6=`#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
float depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
float depth=texture2D(depthBuffer,uv).r;
#endif
#if defined(USE_LOGARITHMIC_DEPTH_BUFFER) || defined(LOG_DEPTH)
float d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;
#elif defined(USE_REVERSED_DEPTH_BUFFER)
depth=1.0-depth;
#endif
return depth;}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,Q6="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",Z6=class extends ja{constructor(n,e,t,i,s=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:Yg.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new cs(null),depthBuffer:new cs(null),resolution:new cs(new Gt),texelSize:new cs(new Gt),cameraNear:new cs(.3),cameraFar:new cs(1e3),aspect:new cs(1),time:new cs(0)},blending:Jo,toneMapped:!1,depthWrite:!1,depthTest:!1,dithering:s}),n&&this.setShaderParts(n),e&&this.setDefines(e),t&&this.setUniforms(t),this.copyCameraSettings(i)}set inputBuffer(n){this.uniforms.inputBuffer.value=n}setInputBuffer(n){this.uniforms.inputBuffer.value=n}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(n){this.uniforms.depthBuffer.value=n}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(n){this.defines.DEPTH_PACKING=n.toFixed(0),this.needsUpdate=!0}setDepthBuffer(n,e=mm){this.depthBuffer=n,this.depthPacking=e}setShaderData(n){this.setShaderParts(n.shaderParts),this.setDefines(n.defines),this.setUniforms(n.uniforms),this.setExtensions(n.extensions)}setShaderParts(n){return this.fragmentShader=J6.replace(Ps.FRAGMENT_HEAD,n.get(Ps.FRAGMENT_HEAD)||"").replace(Ps.FRAGMENT_MAIN_UV,n.get(Ps.FRAGMENT_MAIN_UV)||"").replace(Ps.FRAGMENT_MAIN_IMAGE,n.get(Ps.FRAGMENT_MAIN_IMAGE)||""),this.vertexShader=Q6.replace(Ps.VERTEX_HEAD,n.get(Ps.VERTEX_HEAD)||"").replace(Ps.VERTEX_MAIN_SUPPORT,n.get(Ps.VERTEX_MAIN_SUPPORT)||""),this.needsUpdate=!0,this}setDefines(n){for(const e of n.entries())this.defines[e[0]]=e[1];return this.needsUpdate=!0,this}setUniforms(n){for(const e of n.entries())this.uniforms[e[0]]=e[1];return this}setExtensions(n){this.extensions={};for(const e of n)this.extensions[e]=!0;return this}get encodeOutput(){return this.defines.ENCODE_OUTPUT!==void 0}set encodeOutput(n){this.encodeOutput!==n&&(n?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(n){return this.encodeOutput}setOutputEncodingEnabled(n){this.encodeOutput=n}get time(){return this.uniforms.time.value}set time(n){this.uniforms.time.value=n}setDeltaTime(n){this.uniforms.time.value+=n}adoptCameraSettings(n){this.copyCameraSettings(n)}copyCameraSettings(n){n&&(this.uniforms.cameraNear.value=n.near,this.uniforms.cameraFar.value=n.far,n instanceof Er?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(n,e){const t=this.uniforms;t.resolution.value.set(n,e),t.texelSize.value.set(1/n,1/e),t.aspect.value=n/e}static get Section(){return Ps}};function x2(n,e,t){for(const i of e){const s="$1"+n+i.charAt(0).toUpperCase()+i.slice(1),r=new RegExp("([^\\.])(\\b"+i+"\\b)","g");for(const o of t.entries())o[1]!==null&&t.set(o[0],o[1].replace(r,s))}}function e9(n,e,t){let i=e.getFragmentShader(),s=e.getVertexShader();const r=i!==void 0&&/mainImage/.test(i),o=i!==void 0&&/mainUv/.test(i);if(t.attributes|=e.getAttributes(),i===void 0)throw new Error(`Missing fragment shader (${e.name})`);if(o&&(t.attributes&Ng.CONVOLUTION)!==0)throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e.name})`);if(!r&&!o)throw new Error(`Could not find mainImage or mainUv function (${e.name})`);{const l=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,c=t.shaderParts;let d=c.get(Ps.FRAGMENT_HEAD)||"",g=c.get(Ps.FRAGMENT_MAIN_UV)||"",p=c.get(Ps.FRAGMENT_MAIN_IMAGE)||"",h=c.get(Ps.VERTEX_HEAD)||"",v=c.get(Ps.VERTEX_MAIN_SUPPORT)||"";const y=new Set,w=new Set;if(o&&(g+=`	${n}MainUv(UV);
`,t.uvTransformation=!0),s!==null&&/mainSupport/.test(s)){const T=/mainSupport *\([\w\s]*?uv\s*?\)/.test(s);v+=`	${n}MainSupport(`,v+=T?`vUv);
`:`);
`;for(const C of s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))for(const x of C[1].split(/\s*,\s*/))t.varyings.add(x),y.add(x),w.add(x);for(const C of s.matchAll(l))w.add(C[1])}for(const T of i.matchAll(l))w.add(T[1]);for(const T of e.defines.keys())w.add(T.replace(/\([\w\s,]*\)/g,""));for(const T of e.uniforms.keys())w.add(T);w.delete("while"),w.delete("for"),w.delete("if"),e.uniforms.forEach((T,C)=>t.uniforms.set(n+C.charAt(0).toUpperCase()+C.slice(1),T)),e.defines.forEach((T,C)=>t.defines.set(n+C.charAt(0).toUpperCase()+C.slice(1),T));const S=new Map([["fragment",i],["vertex",s]]);x2(n,w,t.defines),x2(n,w,S),i=S.get("fragment"),s=S.get("vertex");const M=e.blendMode;if(t.blendModes.set(M.blendFunction,M),r){e.inputColorSpace!==null&&e.inputColorSpace!==t.colorSpace&&(p+=e.inputColorSpace===Rs?`color0 = sRGBTransferOETF(color0);
	`:`color0 = sRGBToLinear(color0);
	`),e.outputColorSpace!==Bd?t.colorSpace=e.outputColorSpace:e.inputColorSpace!==null&&(t.colorSpace=e.inputColorSpace);const T=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;p+=`${n}MainImage(color0, UV, `,(t.attributes&Ng.DEPTH)!==0&&T.test(i)&&(p+="depth, ",t.readDepth=!0),p+=`color1);
	`;const C=n+"BlendOpacity";t.uniforms.set(C,M.opacity),p+=`color0 = blend${M.blendFunction}(color0, color1, ${C});

	`,d+=`uniform float ${C};

`}if(d+=i+`
`,s!==null&&(h+=s+`
`),c.set(Ps.FRAGMENT_HEAD,d),c.set(Ps.FRAGMENT_MAIN_UV,g),c.set(Ps.FRAGMENT_MAIN_IMAGE,p),c.set(Ps.VERTEX_HEAD,h),c.set(Ps.VERTEX_MAIN_SUPPORT,v),e.extensions!==null)for(const T of e.extensions)t.extensions.add(T)}}var t9=class extends lu{constructor(n,...e){super("EffectPass"),this.fullscreenMaterial=new Z6(null,null,null,n),this.listener=t=>this.handleEvent(t),this.effects=[],this.setEffects(e),this.skipRendering=!1,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY,this.timeScale=1}set mainScene(n){for(const e of this.effects)e.mainScene=n}set mainCamera(n){this.fullscreenMaterial.copyCameraSettings(n);for(const e of this.effects)e.mainCamera=n}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(n){this.fullscreenMaterial.encodeOutput=n}get dithering(){return this.fullscreenMaterial.dithering}set dithering(n){const e=this.fullscreenMaterial;e.dithering=n,e.needsUpdate=!0}setEffects(n){for(const e of this.effects)e.removeEventListener("change",this.listener);this.effects=n.sort((e,t)=>t.attributes-e.attributes);for(const e of this.effects)e.addEventListener("change",this.listener)}updateMaterial(){const n=new Y5;let e=0;for(const o of this.effects)if(o.blendMode.blendFunction===ls.DST)n.attributes|=o.getAttributes()&Ng.DEPTH;else{if((n.attributes&o.getAttributes()&Ng.CONVOLUTION)!==0)throw new Error(`Convolution effects cannot be merged (${o.name})`);e9("e"+e++,o,n)}let t=n.shaderParts.get(Ps.FRAGMENT_HEAD),i=n.shaderParts.get(Ps.FRAGMENT_MAIN_IMAGE),s=n.shaderParts.get(Ps.FRAGMENT_MAIN_UV);const r=/\bblend\b/g;for(const o of n.blendModes.values())t+=o.getShaderCode().replace(r,`blend${o.blendFunction}`)+`
`;(n.attributes&Ng.DEPTH)!==0?(n.readDepth&&(i=`float depth = readDepth(UV);

	`+i),this.needsDepthTexture=this.getDepthTexture()===null):this.needsDepthTexture=!1,n.colorSpace===Rs&&(i+=`color0 = sRGBToLinear(color0);
	`),n.uvTransformation?(s=`vec2 transformedUv = vUv;
`+s,n.defines.set("UV","transformedUv")):n.defines.set("UV","vUv"),n.shaderParts.set(Ps.FRAGMENT_HEAD,t),n.shaderParts.set(Ps.FRAGMENT_MAIN_IMAGE,i),n.shaderParts.set(Ps.FRAGMENT_MAIN_UV,s);for(const[o,l]of n.shaderParts)l!==null&&n.shaderParts.set(o,l.trim().replace(/^#/,`
#`));this.skipRendering=e===0,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderData(n)}recompile(){this.updateMaterial()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(n,e=mm){this.fullscreenMaterial.depthBuffer=n,this.fullscreenMaterial.depthPacking=e;for(const t of this.effects)t.setDepthTexture(n,e)}render(n,e,t,i,s){for(const r of this.effects)r.update(n,e,i);if(!this.skipRendering||this.renderToScreen){const r=this.fullscreenMaterial;r.inputBuffer=e.texture,r.time+=i*this.timeScale,n.setRenderTarget(this.renderToScreen?null:t),n.render(this.scene,this.camera)}}setSize(n,e){this.fullscreenMaterial.setSize(n,e);for(const t of this.effects)t.setSize(n,e)}initialize(n,e,t){this.renderer=n;for(const i of this.effects)i.initialize(n,e,t);this.updateMaterial(),t!==void 0&&t!==Ha&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(const n of this.effects)n.removeEventListener("change",this.listener),n.dispose()}handleEvent(n){switch(n.type){case"change":this.recompile();break}}},n9=class extends lu{constructor(n,e,{renderTarget:t,resolutionScale:i=1,width:s=Yo.AUTO_SIZE,height:r=Yo.AUTO_SIZE,resolutionX:o=s,resolutionY:l=r}={}){super("NormalPass"),this.needsSwap=!1,this.renderPass=new JO(n,e,new zT);const c=this.renderPass;c.ignoreBackground=!0,c.skipShadowMapUpdate=!0;const d=c.getClearPass();d.overrideClearColor=new Sn(7829503),d.overrideClearAlpha=1,this.renderTarget=t,this.renderTarget===void 0&&(this.renderTarget=new Da(1,1,{minFilter:ta,magFilter:ta}),this.renderTarget.texture.name="NormalPass.Target");const g=this.resolution=new Yo(this,o,l,i);g.addEventListener("change",p=>this.setSize(g.baseWidth,g.baseHeight))}set mainScene(n){this.renderPass.mainScene=n}set mainCamera(n){this.renderPass.mainCamera=n}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(n){this.resolution.scale=n}render(n,e,t,i,s){const r=this.renderToScreen?null:this.renderTarget;this.renderPass.render(n,r,r)}setSize(n,e){const t=this.resolution;t.setBaseSize(n,e),this.renderTarget.setSize(t.width,t.height)}};function Av(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}new Gt;new Gt;function QO(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}var Pc=function n(e,t,i){var s=this;QO(this,n),Av(this,"dot2",function(r,o){return s.x*r+s.y*o}),Av(this,"dot3",function(r,o,l){return s.x*r+s.y*o+s.z*l}),this.x=e,this.y=t,this.z=i},i9=[new Pc(1,1,0),new Pc(-1,1,0),new Pc(1,-1,0),new Pc(-1,-1,0),new Pc(1,0,1),new Pc(-1,0,1),new Pc(1,0,-1),new Pc(-1,0,-1),new Pc(0,1,1),new Pc(0,-1,1),new Pc(0,1,-1),new Pc(0,-1,-1)],w2=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],E2=new Array(512),T2=new Array(512),s9=function(e){e>0&&e<1&&(e*=65536),e=Math.floor(e),e<256&&(e|=e<<8);for(var t=0;t<256;t++){var i;t&1?i=w2[t]^e&255:i=w2[t]^e>>8&255,E2[t]=E2[t+256]=i,T2[t]=T2[t+256]=i9[i%12]}};s9(0);function r9(n){if(typeof n=="number")n=Math.abs(n);else if(typeof n=="string"){var e=n;n=0;for(var t=0;t<e.length;t++)n=(n+(t+1)*(e.charCodeAt(t)%96))%2147483647}return n===0&&(n=311),n}function S2(n){var e=r9(n);return function(){var t=e*48271%2147483647;return e=t,t/2147483647}}var a9=function n(e){var t=this;QO(this,n),Av(this,"seed",0),Av(this,"init",function(i){t.seed=i,t.value=S2(i)}),Av(this,"value",S2(this.seed)),this.init(e)};new a9(Math.random());const o9=Ft.createContext(null),A2=n=>(n.getAttributes()&2)===2,l9=Ft.memo(Ft.forwardRef(({children:n,camera:e,scene:t,resolutionScale:i,enabled:s=!0,renderPriority:r=1,autoClear:o=!0,depthBuffer:l,enableNormalPass:c,stencilBuffer:d,multisampling:g=8,frameBufferType:p=Jg},h)=>{const{gl:v,scene:y,camera:w,size:S}=ju(),M=t||y,T=e||w,[C,x,R]=Ft.useMemo(()=>{const z=new X5(v,{depthBuffer:l,stencilBuffer:d,multisampling:g,frameBufferType:p});z.addPass(new JO(M,T));let U=null,N=null;return c&&(N=new n9(M,T),N.enabled=!1,z.addPass(N),i!==void 0&&(U=new Y6({normalBuffer:N.texture,resolutionScale:i}),U.enabled=!1,z.addPass(U))),[z,N,U]},[T,v,l,d,g,p,M,c,i]);Ft.useEffect(()=>C?.setSize(S.width,S.height),[C,S]),ey((z,U)=>{if(s){const N=v.autoClear;v.autoClear=o,d&&!o&&v.clearStencil(),C.render(U),v.autoClear=N}},s?r:0);const P=Ft.useRef(null);Ft.useLayoutEffect(()=>{const z=[],U=P.current.__r3f;if(U&&C){const N=U.children;for(let j=0;j<N.length;j++){const J=N[j].object;if(J instanceof $E){const W=[J];if(!A2(J)){let ne=null;for(;(ne=N[j+1]?.object)instanceof $E&&!A2(ne);)W.push(ne),j++}const oe=new t9(T,...W);z.push(oe)}else J instanceof lu&&z.push(J)}for(const j of z)C?.addPass(j);x&&(x.enabled=!0),R&&(R.enabled=!0)}return()=>{for(const N of z)C?.removePass(N);x&&(x.enabled=!1),R&&(R.enabled=!1)}},[C,n,T,x,R]),Ft.useEffect(()=>{const z=v.toneMapping;return v.toneMapping=Ld,()=>{v.toneMapping=z}},[v]);const D=Ft.useMemo(()=>({composer:C,normalPass:x,downSamplingPass:R,resolutionScale:i,camera:T,scene:M}),[C,x,R,i,T,M]);return Ft.useImperativeHandle(h,()=>C,[C]),zt.jsx(o9.Provider,{value:D,children:zt.jsx("group",{ref:P,children:n})})}));let u9=0;const C2=new WeakMap,c9=(n,e)=>function({blendFunction:t=e?.blendFunction,opacity:i=e?.opacity,...s}){let r=C2.get(n);if(!r){const c=`@react-three/postprocessing/${n.name}-${u9++}`;LO({[c]:n}),C2.set(n,r=c)}const o=ju(c=>c.camera),l=wB.useMemo(()=>[...e?.args??[],...s.args??[{...e,...s}]],[JSON.stringify(s)]);return zt.jsx(r,{camera:o,"blendMode-blendFunction":t,"blendMode-opacity-value":i,...s,args:l})},d9=c9(W6,{blendFunction:0});var p1={},ws={},Vr={},as={},P2;function iy(){if(P2)return as;P2=1;var n=as&&as.__values||function(S){var M=typeof Symbol=="function"&&Symbol.iterator,T=M&&S[M],C=0;if(T)return T.call(S);if(S&&typeof S.length=="number")return{next:function(){return S&&C>=S.length&&(S=void 0),{value:S&&S[C++],done:!S}}};throw new TypeError(M?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(as,"__esModule",{value:!0}),as.reshape2d=as.rejectionSample=as.max2d=as.max=as.mean=as.sum=as.linear=as.ones=as.zeros=as.filled=as.range=as.empty=as.norm=as.tauRand=as.tauRandInt=void 0;function e(S,M){return Math.floor(M()*S)}as.tauRandInt=e;function t(S){return S()}as.tauRand=t;function i(S){var M,T,C=0;try{for(var x=n(S),R=x.next();!R.done;R=x.next()){var P=R.value;C+=Math.pow(P,2)}}catch(D){M={error:D}}finally{try{R&&!R.done&&(T=x.return)&&T.call(x)}finally{if(M)throw M.error}}return Math.sqrt(C)}as.norm=i;function s(S){for(var M=[],T=0;T<S;T++)M.push(void 0);return M}as.empty=s;function r(S){return s(S).map(function(M,T){return T})}as.range=r;function o(S,M){return s(S).map(function(){return M})}as.filled=o;function l(S){return o(S,0)}as.zeros=l;function c(S){return o(S,1)}as.ones=c;function d(S,M,T){return s(T).map(function(C,x){return S+x*((M-S)/(T-1))})}as.linear=d;function g(S){return S.reduce(function(M,T){return M+T})}as.sum=g;function p(S){return g(S)/S.length}as.mean=p;function h(S){for(var M=0,T=0;T<S.length;T++)M=S[T]>M?S[T]:M;return M}as.max=h;function v(S){for(var M=0,T=0;T<S.length;T++)for(var C=0;C<S[T].length;C++)M=S[T][C]>M?S[T][C]:M;return M}as.max2d=v;function y(S,M,T){for(var C=l(S),x=0;x<S;x++)for(var R=!0;R;){for(var P=e(M,T),D=!1,z=0;z<x;z++)if(P===C[z]){D=!0;break}D||(R=!1),C[x]=P}return C}as.rejectionSample=y;function w(S,M,T){var C=[],x=0;if(S.length!==M*T)throw new Error("Array dimensions must match input length.");for(var R=0;R<M;R++){for(var P=[],D=0;D<T;D++)P.push(S[x]),x+=1;C.push(P)}return C}return as.reshape2d=w,as}var R2;function ZO(){if(R2)return Vr;R2=1;var n=Vr&&Vr.__createBinding||(Object.create?(function(h,v,y,w){w===void 0&&(w=y),Object.defineProperty(h,w,{enumerable:!0,get:function(){return v[y]}})}):(function(h,v,y,w){w===void 0&&(w=y),h[w]=v[y]})),e=Vr&&Vr.__setModuleDefault||(Object.create?(function(h,v){Object.defineProperty(h,"default",{enumerable:!0,value:v})}):function(h,v){h.default=v}),t=Vr&&Vr.__importStar||function(h){if(h&&h.__esModule)return h;var v={};if(h!=null)for(var y in h)y!=="default"&&Object.hasOwnProperty.call(h,y)&&n(v,h,y);return e(v,h),v};Object.defineProperty(Vr,"__esModule",{value:!0}),Vr.smallestFlagged=Vr.deheapSort=Vr.buildCandidates=Vr.uncheckedHeapPush=Vr.heapPush=Vr.rejectionSample=Vr.makeHeap=void 0;var i=t(iy());function s(h,v){var y=function(S){return i.empty(h).map(function(){return i.filled(v,S)})},w=[];return w.push(y(-1)),w.push(y(1/0)),w.push(y(0)),w}Vr.makeHeap=s;function r(h,v,y){for(var w=i.zeros(h),S=0;S<h;S++){for(var M=!0,T=0;M;){T=i.tauRandInt(v,y);for(var C=!1,x=0;x<S;x++)if(T===w[x]){C=!0;break}C||(M=!1)}w[S]=T}return w}Vr.rejectionSample=r;function o(h,v,y,w,S){v=Math.floor(v);var M=h[0][v],T=h[1][v];if(h[2][v],y>=T[0])return 0;for(var C=0;C<M.length;C++)if(w===M[C])return 0;return l(h,v,y,w,S)}Vr.heapPush=o;function l(h,v,y,w,S){var M=h[0][v],T=h[1][v],C=h[2][v];if(y>=T[0])return 0;T[0]=y,M[0]=w,C[0]=S;for(var x=0,R=0;;){var P=2*x+1,D=P+1,z=h[0][0].length;if(P>=z)break;if(D>=z)if(T[P]>y)R=P;else break;else if(T[P]>=T[D])if(y<T[P])R=P;else break;else if(y<T[D])R=D;else break;T[x]=T[R],M[x]=M[R],C[x]=C[R],x=R}return T[x]=y,M[x]=w,C[x]=S,1}Vr.uncheckedHeapPush=l;function c(h,v,y,w,S){for(var M=s(v,w),T=0;T<v;T++)for(var C=0;C<y;C++)if(!(h[0][T][C]<0)){var x=h[0][T][C],R=h[2][T][C],P=i.tauRand(S);o(M,T,P,x,R),o(M,x,P,T,R),h[2][T][C]=0}return M}Vr.buildCandidates=c;function d(h){for(var v=h[0],y=h[1],w=0;w<v.length;w++)for(var S=v[w],M=y[w],T=0;T<S.length-1;T++){var C=S.length-T-1,x=M.length-T-1,R=S[0];S[0]=S[C],S[C]=R;var P=M[0];M[0]=M[x],M[x]=P,g(M,S,x,0)}return{indices:v,weights:y}}Vr.deheapSort=d;function g(h,v,y,w){for(;w*2+1<y;){var S=w*2+1,M=S+1,T=w;if(h[T]<h[S]&&(T=S),M<y&&h[T]<h[M]&&(T=M),T===w)break;var C=h[w];h[w]=h[T],h[T]=C;var x=v[w];v[w]=v[T],v[T]=x,w=T}}function p(h,v){for(var y=h[0][v],w=h[1][v],S=h[2][v],M=1/0,T=-1,C=0;C>y.length;C++)S[C]===1&&w[C]<M&&(M=w[C],T=C);return T>=0?(S[T]=0,Math.floor(y[T])):-1}return Vr.smallestFlagged=p,Vr}var os={},D2;function e3(){if(D2)return os;D2=1;var n=os&&os.__createBinding||(Object.create?(function(x,R,P,D){D===void 0&&(D=P),Object.defineProperty(x,D,{enumerable:!0,get:function(){return R[P]}})}):(function(x,R,P,D){D===void 0&&(D=P),x[D]=R[P]})),e=os&&os.__setModuleDefault||(Object.create?(function(x,R){Object.defineProperty(x,"default",{enumerable:!0,value:R})}):function(x,R){x.default=R}),t=os&&os.__importStar||function(x){if(x&&x.__esModule)return x;var R={};if(x!=null)for(var P in x)P!=="default"&&Object.hasOwnProperty.call(x,P)&&n(R,x,P);return e(R,x),R},i=os&&os.__read||function(x,R){var P=typeof Symbol=="function"&&x[Symbol.iterator];if(!P)return x;var D=P.call(x),z,U=[],N;try{for(;(R===void 0||R-- >0)&&!(z=D.next()).done;)U.push(z.value)}catch(j){N={error:j}}finally{try{z&&!z.done&&(P=D.return)&&P.call(D)}finally{if(N)throw N.error}}return U},s=os&&os.__values||function(x){var R=typeof Symbol=="function"&&Symbol.iterator,P=R&&x[R],D=0;if(P)return P.call(x);if(x&&typeof x.length=="number")return{next:function(){return x&&D>=x.length&&(x=void 0),{value:x&&x[D++],done:!x}}};throw new TypeError(R?"Object is not iterable.":"Symbol.iterator is not defined.")},r;Object.defineProperty(os,"__esModule",{value:!0}),os.getCSR=os.normalize=os.eliminateZeros=os.multiplyScalar=os.maximum=os.subtract=os.add=os.pairwiseMultiply=os.identity=os.transpose=os.SparseMatrix=void 0;var o=t(iy()),l=(function(){function x(R,P,D,z){if(this.entries=new Map,this.nRows=0,this.nCols=0,R.length!==P.length||R.length!==D.length)throw new Error("rows, cols and values arrays must all have the same length");this.nRows=z[0],this.nCols=z[1];for(var U=0;U<D.length;U++){var N=R[U],j=P[U];this.checkDims(N,j);var J=this.makeKey(N,j);this.entries.set(J,{value:D[U],row:N,col:j})}}return x.prototype.makeKey=function(R,P){return R+":"+P},x.prototype.checkDims=function(R,P){var D=R<this.nRows&&P<this.nCols;if(!D)throw new Error("row and/or col specified outside of matrix dimensions")},x.prototype.set=function(R,P,D){this.checkDims(R,P);var z=this.makeKey(R,P);this.entries.has(z)?this.entries.get(z).value=D:this.entries.set(z,{value:D,row:R,col:P})},x.prototype.get=function(R,P,D){D===void 0&&(D=0),this.checkDims(R,P);var z=this.makeKey(R,P);return this.entries.has(z)?this.entries.get(z).value:D},x.prototype.getAll=function(R){R===void 0&&(R=!0);var P=[];return this.entries.forEach(function(D){P.push(D)}),R&&P.sort(function(D,z){return D.row===z.row?D.col-z.col:D.row-z.row}),P},x.prototype.getDims=function(){return[this.nRows,this.nCols]},x.prototype.getRows=function(){return Array.from(this.entries,function(R){var P=i(R,2);P[0];var D=P[1];return D.row})},x.prototype.getCols=function(){return Array.from(this.entries,function(R){var P=i(R,2);P[0];var D=P[1];return D.col})},x.prototype.getValues=function(){return Array.from(this.entries,function(R){var P=i(R,2);P[0];var D=P[1];return D.value})},x.prototype.forEach=function(R){this.entries.forEach(function(P){return R(P.value,P.row,P.col)})},x.prototype.map=function(R){var P=[];this.entries.forEach(function(z){P.push(R(z.value,z.row,z.col))});var D=[this.nRows,this.nCols];return new x(this.getRows(),this.getCols(),P,D)},x.prototype.toArray=function(){var R=this,P=o.empty(this.nRows),D=P.map(function(){return o.zeros(R.nCols)});return this.entries.forEach(function(z){D[z.row][z.col]=z.value}),D},x})();os.SparseMatrix=l;function c(x){var R=[],P=[],D=[];x.forEach(function(U,N,j){R.push(N),P.push(j),D.push(U)});var z=[x.nCols,x.nRows];return new l(P,R,D,z)}os.transpose=c;function d(x){for(var R=i(x,1),P=R[0],D=new l([],[],[],x),z=0;z<P;z++)D.set(z,z,1);return D}os.identity=d;function g(x,R){return T(x,R,function(P,D){return P*D})}os.pairwiseMultiply=g;function p(x,R){return T(x,R,function(P,D){return P+D})}os.add=p;function h(x,R){return T(x,R,function(P,D){return P-D})}os.subtract=h;function v(x,R){return T(x,R,function(P,D){return P>D?P:D})}os.maximum=v;function y(x,R){return x.map(function(P){return P*R})}os.multiplyScalar=y;function w(x){for(var R=new Set,P=x.getValues(),D=x.getRows(),z=x.getCols(),U=0;U<P.length;U++)P[U]===0&&R.add(U);var N=function(oe,ne){return!R.has(ne)},j=P.filter(N),J=D.filter(N),W=z.filter(N);return new l(J,W,j,x.getDims())}os.eliminateZeros=w;function S(x,R){var P,D;R===void 0&&(R="l2");var z=M[R],U=new Map;x.forEach(function(ne,q,le){var se=U.get(q)||[];se.push(le),U.set(q,se)});var N=new l([],[],[],x.getDims()),j=function(ne){for(var q=U.get(ne).sort(),le=q.map(function(be){return x.get(ne,be)}),se=z(le),pe=0;pe<se.length;pe++)N.set(ne,q[pe],se[pe])};try{for(var J=s(U.keys()),W=J.next();!W.done;W=J.next()){var oe=W.value;j(oe)}}catch(ne){P={error:ne}}finally{try{W&&!W.done&&(D=J.return)&&D.call(J)}finally{if(P)throw P.error}}return N}os.normalize=S;var M=(r={},r.max=function(x){for(var R=-1/0,P=0;P<x.length;P++)R=x[P]>R?x[P]:R;return x.map(function(D){return D/R})},r.l1=function(x){for(var R=0,P=0;P<x.length;P++)R+=x[P];return x.map(function(D){return D/R})},r.l2=function(x){for(var R=0,P=0;P<x.length;P++)R+=Math.pow(x[P],2);return x.map(function(D){return Math.sqrt(Math.pow(D,2)/R)})},r);function T(x,R,P){for(var D=new Set,z=[],U=[],N=[],j=function(ue,ae){z.push(ue),U.push(ae);var ce=P(x.get(ue,ae),R.get(ue,ae));N.push(ce)},J=x.getValues(),W=x.getRows(),oe=x.getCols(),ne=0;ne<J.length;ne++){var q=W[ne],le=oe[ne],se=q+":"+le;D.add(se),j(q,le)}for(var pe=R.getValues(),be=R.getRows(),ee=R.getCols(),ne=0;ne<pe.length;ne++){var q=be[ne],le=ee[ne],se=q+":"+le;D.has(se)||j(q,le)}var te=[x.nRows,x.nCols];return new l(z,U,N,te)}function C(x){var R=[];x.forEach(function(ne,q,le){R.push({value:ne,row:q,col:le})}),R.sort(function(ne,q){return ne.row===q.row?ne.col-q.col:ne.row-q.row});for(var P=[],D=[],z=[],U=-1,N=0;N<R.length;N++){var j=R[N],J=j.row,W=j.col,oe=j.value;J!==U&&(U=J,z.push(N)),P.push(W),D.push(oe)}return{indices:P,values:D,indptr:z}}return os.getCSR=C,os}var ka={},Hr={},B2;function t3(){if(B2)return Hr;B2=1;var n=Hr&&Hr.__createBinding||(Object.create?(function(C,x,R,P){P===void 0&&(P=R),Object.defineProperty(C,P,{enumerable:!0,get:function(){return x[R]}})}):(function(C,x,R,P){P===void 0&&(P=R),C[P]=x[R]})),e=Hr&&Hr.__setModuleDefault||(Object.create?(function(C,x){Object.defineProperty(C,"default",{enumerable:!0,value:x})}):function(C,x){C.default=x}),t=Hr&&Hr.__importStar||function(C){if(C&&C.__esModule)return C;var x={};if(C!=null)for(var R in C)R!=="default"&&Object.hasOwnProperty.call(C,R)&&n(x,C,R);return e(x,C),x},i=Hr&&Hr.__read||function(C,x){var R=typeof Symbol=="function"&&C[Symbol.iterator];if(!R)return C;var P=R.call(C),D,z=[],U;try{for(;(x===void 0||x-- >0)&&!(D=P.next()).done;)z.push(D.value)}catch(N){U={error:N}}finally{try{D&&!D.done&&(R=P.return)&&R.call(P)}finally{if(U)throw U.error}}return z},s=Hr&&Hr.__spread||function(){for(var C=[],x=0;x<arguments.length;x++)C=C.concat(i(arguments[x]));return C},r=Hr&&Hr.__values||function(C){var x=typeof Symbol=="function"&&Symbol.iterator,R=x&&C[x],P=0;if(R)return R.call(C);if(C&&typeof C.length=="number")return{next:function(){return C&&P>=C.length&&(C=void 0),{value:C&&C[P++],done:!C}}};throw new TypeError(x?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(Hr,"__esModule",{value:!0}),Hr.searchFlatTree=Hr.makeLeafArray=Hr.makeForest=Hr.FlatTree=void 0;var o=t(iy()),l=(function(){function C(x,R,P,D){this.hyperplanes=x,this.offsets=R,this.children=P,this.indices=D}return C})();Hr.FlatTree=l;function c(C,x,R,P){var D=Math.max(10,x),z=o.range(R).map(function(N,j){return d(C,D,j,P)}),U=z.map(function(N){return h(N,D)});return U}Hr.makeForest=c;function d(C,x,R,P){x===void 0&&(x=30);var D=o.range(C.length),z=g(C,D,x,R,P);return z}function g(C,x,R,P,D){if(R===void 0&&(R=30),x.length>R){var z=p(C,x,D),U=z.indicesLeft,N=z.indicesRight,j=z.hyperplane,J=z.offset,W=g(C,U,R,P+1,D),oe=g(C,N,R,P+1,D),ne={leftChild:W,rightChild:oe,isLeaf:!1,hyperplane:j,offset:J};return ne}else{var ne={indices:x,isLeaf:!0};return ne}}function p(C,x,R){var P=C[0].length,D=o.tauRandInt(x.length,R),z=o.tauRandInt(x.length,R);z+=D===z?1:0,z=z%x.length;for(var U=x[D],N=x[z],j=0,J=o.zeros(P),W=0;W<J.length;W++)J[W]=C[U][W]-C[N][W],j-=J[W]*(C[U][W]+C[N][W])/2;for(var oe=0,ne=0,q=o.zeros(x.length),W=0;W<x.length;W++){for(var le=j,se=0;se<P;se++)le+=J[se]*C[x[W]][se];le===0?(q[W]=o.tauRandInt(2,R),q[W]===0?oe+=1:ne+=1):le>0?(q[W]=0,oe+=1):(q[W]=1,ne+=1)}var pe=o.zeros(oe),be=o.zeros(ne);oe=0,ne=0;for(var W=0;W<q.length;W++)q[W]===0?(pe[oe]=x[W],oe+=1):(be[ne]=x[W],ne+=1);return{indicesLeft:pe,indicesRight:be,hyperplane:J,offset:j}}function h(C,x){var R=y(C),P=w(C),D=o.range(R).map(function(){return o.zeros(C.hyperplane?C.hyperplane.length:0)}),z=o.zeros(R),U=o.range(R).map(function(){return[-1,-1]}),N=o.range(P).map(function(){return o.range(x).map(function(){return-1})});return v(C,D,z,U,N,0,0),new l(D,z,U,N)}function v(C,x,R,P,D,z,U){var N;if(C.isLeaf)return P[z][0]=-U,(N=D[U]).splice.apply(N,s([0,C.indices.length],C.indices)),U+=1,{nodeNum:z,leafNum:U};x[z]=C.hyperplane,R[z]=C.offset,P[z][0]=z+1;var j=z,J=v(C.leftChild,x,R,P,D,z+1,U);return z=J.nodeNum,U=J.leafNum,P[j][1]=z+1,J=v(C.rightChild,x,R,P,D,z+1,U),{nodeNum:J.nodeNum,leafNum:J.leafNum}}function y(C){return C.isLeaf?1:1+y(C.leftChild)+y(C.rightChild)}function w(C){return C.isLeaf?1:w(C.leftChild)+w(C.rightChild)}function S(C){var x,R;if(C.length>0){var P=[];try{for(var D=r(C),z=D.next();!z.done;z=D.next()){var U=z.value;P.push.apply(P,s(U.indices))}}catch(N){x={error:N}}finally{try{z&&!z.done&&(R=D.return)&&R.call(D)}finally{if(x)throw x.error}}return P}else return[[-1]]}Hr.makeLeafArray=S;function M(C,x,R,P){for(var D=x,z=0;z<R.length;z++)D+=C[z]*R[z];if(D===0){var U=o.tauRandInt(2,P);return U}else return D>0?0:1}function T(C,x,R){for(var P=0;x.children[P][0]>0;){var D=M(x.hyperplanes[P],x.offsets[P],C,R);D===0?P=x.children[P][0]:P=x.children[P][1]}var z=-1*x.children[P][0];return x.indices[z]}return Hr.searchFlatTree=T,Hr}var I2;function f9(){if(I2)return ka;I2=1;var n=ka&&ka.__createBinding||(Object.create?(function(h,v,y,w){w===void 0&&(w=y),Object.defineProperty(h,w,{enumerable:!0,get:function(){return v[y]}})}):(function(h,v,y,w){w===void 0&&(w=y),h[w]=v[y]})),e=ka&&ka.__setModuleDefault||(Object.create?(function(h,v){Object.defineProperty(h,"default",{enumerable:!0,value:v})}):function(h,v){h.default=v}),t=ka&&ka.__importStar||function(h){if(h&&h.__esModule)return h;var v={};if(h!=null)for(var y in h)y!=="default"&&Object.hasOwnProperty.call(h,y)&&n(v,h,y);return e(v,h),v},i=ka&&ka.__values||function(h){var v=typeof Symbol=="function"&&Symbol.iterator,y=v&&h[v],w=0;if(y)return y.call(h);if(h&&typeof h.length=="number")return{next:function(){return h&&w>=h.length&&(h=void 0),{value:h&&h[w++],done:!h}}};throw new TypeError(v?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(ka,"__esModule",{value:!0}),ka.initializeSearch=ka.makeInitializedNNSearch=ka.makeInitializations=ka.makeNNDescent=void 0;var s=t(ZO()),r=t(e3()),o=t(t3()),l=t(iy());function c(h,v){return function(w,S,M,T,C,x,R,P){T===void 0&&(T=10),C===void 0&&(C=50),x===void 0&&(x=.001),R===void 0&&(R=.5),P===void 0&&(P=!0);for(var D=w.length,z=s.makeHeap(w.length,M),U=0;U<w.length;U++)for(var N=s.rejectionSample(M,w.length,v),j=0;j<N.length;j++){var J=h(w[U],w[N[j]]);s.heapPush(z,U,J,N[j],1),s.heapPush(z,N[j],J,U,1)}if(P)for(var W=0;W<S.length;W++)for(var U=0;U<S[W].length&&!(S[W][U]<0);U++)for(var j=U+1;j<S[W].length&&!(S[W][j]<0);j++){var J=h(w[S[W][U]],w[S[W][j]]);s.heapPush(z,S[W][U],J,S[W][j],1),s.heapPush(z,S[W][j],J,S[W][U],1)}for(var W=0;W<T;W++){for(var oe=s.buildCandidates(z,D,M,C,v),ne=0,U=0;U<D;U++)for(var j=0;j<C;j++){var q=Math.floor(oe[0][U][j]);if(!(q<0||l.tauRand(v)<R))for(var le=0;le<C;le++){var se=Math.floor(oe[0][U][le]),pe=oe[2][U][j],be=oe[2][U][le];if(!(se<0||!pe&&!be)){var J=h(w[q],w[se]);ne+=s.heapPush(z,q,J,se,1),ne+=s.heapPush(z,se,J,q,1)}}}if(ne<=x*M*w.length)break}var ee=s.deheapSort(z);return ee}}ka.makeNNDescent=c;function d(h){function v(w,S,M,T,C){for(var x=0;x<M.length;x++)for(var R=l.rejectionSample(w,S.length,C),P=0;P<R.length;P++)if(!(R[P]<0)){var D=h(S[R[P]],M[x]);s.heapPush(T,x,D,R[P],1)}}function y(w,S,M,T,C){for(var x=0;x<M.length;x++)for(var R=o.searchFlatTree(M[x],w,C),P=0;P<R.length;P++){if(R[P]<0)return;var D=h(S[R[P]],M[x]);s.heapPush(T,x,D,R[P],1)}}return{initFromRandom:v,initFromTree:y}}ka.makeInitializations=d;function g(h){return function(y,w,S,M){for(var T,C,x=r.getCSR(w),R=x.indices,P=x.indptr,D=0;D<M.length;D++)for(var z=new Set(S[0][D]);;){var U=s.smallestFlagged(S,D);if(U===-1)break;var N=R.slice(P[U],P[U+1]);try{for(var j=(T=void 0,i(N)),J=j.next();!J.done;J=j.next()){var W=J.value;if(!(W===U||W===-1||z.has(W))){var oe=h(y[W],M[D]);s.uncheckedHeapPush(S,D,oe,W,1),z.add(W)}}}catch(ne){T={error:ne}}finally{try{J&&!J.done&&(C=j.return)&&C.call(j)}finally{if(T)throw T.error}}}return S}}ka.makeInitializedNNSearch=g;function p(h,v,y,w,S,M,T){var C,x,R=s.makeHeap(y.length,w);if(S(w,v,y,R,T),h)try{for(var P=i(h),D=P.next();!D.done;D=P.next()){var z=D.value;M(z,v,y,R,T)}}catch(U){C={error:U}}finally{try{D&&!D.done&&(x=P.return)&&x.call(P)}finally{if(C)throw C.error}}return R}return ka.initializeSearch=p,ka}const h9=Object.prototype.toString;function m1(n){return h9.call(n).endsWith("Array]")}function O2(n,e,t){let i=0;const s=t(e);for(let r=0;r<n.x.length;r++)i+=Math.abs(n.y[r]-s(n.x[r]));return i}var ji={};const p9=Object.prototype.toString;function m9(n){const e=p9.call(n);return e.endsWith("Array]")&&!e.includes("Big")}const g9=Object.freeze(Object.defineProperty({__proto__:null,isAnyArray:m9},Symbol.toStringTag,{value:"Module"})),_9=cT(g9),v9=Object.prototype.toString;function L2(n){const e=v9.call(n);return e.endsWith("Array]")&&!e.includes("Big")}const y9=Object.prototype.toString;function M9(n){const e=y9.call(n);return e.endsWith("Array]")&&!e.includes("Big")}function b9(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!M9(n))throw new TypeError("input must be an array");if(n.length===0)throw new TypeError("input must not be empty");var t=e.fromIndex,i=t===void 0?0:t,s=e.toIndex,r=s===void 0?n.length:s;if(i<0||i>=n.length||!Number.isInteger(i))throw new Error("fromIndex must be a positive integer smaller than length");if(r<=i||r>n.length||!Number.isInteger(r))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var o=n[i],l=i+1;l<r;l++)n[l]>o&&(o=n[l]);return o}const x9=Object.prototype.toString;function w9(n){const e=x9.call(n);return e.endsWith("Array]")&&!e.includes("Big")}function E9(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!w9(n))throw new TypeError("input must be an array");if(n.length===0)throw new TypeError("input must not be empty");var t=e.fromIndex,i=t===void 0?0:t,s=e.toIndex,r=s===void 0?n.length:s;if(i<0||i>=n.length||!Number.isInteger(i))throw new Error("fromIndex must be a positive integer smaller than length");if(r<=i||r>n.length||!Number.isInteger(r))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var o=n[i],l=i+1;l<r;l++)n[l]<o&&(o=n[l]);return o}function T9(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(L2(n)){if(n.length===0)throw new TypeError("input must not be empty")}else throw new TypeError("input must be an array");var t;if(e.output!==void 0){if(!L2(e.output))throw new TypeError("output option must be an array if specified");t=e.output}else t=new Array(n.length);var i=E9(n),s=b9(n);if(i===s)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var r=e.min,o=r===void 0?e.autoMinMax?i:0:r,l=e.max,c=l===void 0?e.autoMinMax?s:1:l;if(o>=c)throw new RangeError("min option must be smaller than max option");for(var d=(c-o)/(s-i),g=0;g<n.length;g++)t[g]=(n[g]-i)*d+o;return t}const S9=Object.freeze(Object.defineProperty({__proto__:null,default:T9},Symbol.toStringTag,{value:"Module"})),A9=cT(S9);var F2;function C9(){if(F2)return ji;F2=1,Object.defineProperty(ji,"__esModule",{value:!0});var n=_9,e=A9;const t=" ".repeat(2),i=" ".repeat(4);function s(){return r(this)}function r(fe,B={}){const{maxRows:I=15,maxColumns:A=10,maxNumSize:F=8,padMinus:K="auto"}=B;return`${fe.constructor.name} {
${t}[
${i}${o(fe,I,A,F,K)}
${t}]
${t}rows: ${fe.rows}
${t}columns: ${fe.columns}
}`}function o(fe,B,I,A,F){const{rows:K,columns:Ee}=fe,k=Math.min(K,B),re=Math.min(Ee,I),Q=[];if(F==="auto"){F=!1;e:for(let ve=0;ve<k;ve++)for(let ge=0;ge<re;ge++)if(fe.get(ve,ge)<0){F=!0;break e}}for(let ve=0;ve<k;ve++){let ge=[];for(let Le=0;Le<re;Le++)ge.push(l(fe.get(ve,Le),A,F));Q.push(`${ge.join(" ")}`)}return re!==Ee&&(Q[Q.length-1]+=` ... ${Ee-I} more columns`),k!==K&&Q.push(`... ${K-B} more rows`),Q.join(`
${i}`)}function l(fe,B,I){return(fe>=0&&I?` ${c(fe,B-1)}`:c(fe,B)).padEnd(B)}function c(fe,B){let I=fe.toString();if(I.length<=B)return I;let A=fe.toFixed(B);if(A.length>B&&(A=fe.toFixed(Math.max(0,B-(A.length-B)))),A.length<=B&&!A.startsWith("0.000")&&!A.startsWith("-0.000"))return A;let F=fe.toExponential(B);return F.length>B&&(F=fe.toExponential(Math.max(0,B-(F.length-B)))),F.slice(0)}function d(fe,B){fe.prototype.add=function(A){return typeof A=="number"?this.addS(A):this.addM(A)},fe.prototype.addS=function(A){for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)+A);return this},fe.prototype.addM=function(A){if(A=B.checkMatrix(A),this.rows!==A.rows||this.columns!==A.columns)throw new RangeError("Matrices dimensions must be equal");for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)+A.get(F,K));return this},fe.add=function(A,F){return new B(A).add(F)},fe.prototype.sub=function(A){return typeof A=="number"?this.subS(A):this.subM(A)},fe.prototype.subS=function(A){for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)-A);return this},fe.prototype.subM=function(A){if(A=B.checkMatrix(A),this.rows!==A.rows||this.columns!==A.columns)throw new RangeError("Matrices dimensions must be equal");for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)-A.get(F,K));return this},fe.sub=function(A,F){return new B(A).sub(F)},fe.prototype.subtract=fe.prototype.sub,fe.prototype.subtractS=fe.prototype.subS,fe.prototype.subtractM=fe.prototype.subM,fe.subtract=fe.sub,fe.prototype.mul=function(A){return typeof A=="number"?this.mulS(A):this.mulM(A)},fe.prototype.mulS=function(A){for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)*A);return this},fe.prototype.mulM=function(A){if(A=B.checkMatrix(A),this.rows!==A.rows||this.columns!==A.columns)throw new RangeError("Matrices dimensions must be equal");for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)*A.get(F,K));return this},fe.mul=function(A,F){return new B(A).mul(F)},fe.prototype.multiply=fe.prototype.mul,fe.prototype.multiplyS=fe.prototype.mulS,fe.prototype.multiplyM=fe.prototype.mulM,fe.multiply=fe.mul,fe.prototype.div=function(A){return typeof A=="number"?this.divS(A):this.divM(A)},fe.prototype.divS=function(A){for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)/A);return this},fe.prototype.divM=function(A){if(A=B.checkMatrix(A),this.rows!==A.rows||this.columns!==A.columns)throw new RangeError("Matrices dimensions must be equal");for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)/A.get(F,K));return this},fe.div=function(A,F){return new B(A).div(F)},fe.prototype.divide=fe.prototype.div,fe.prototype.divideS=fe.prototype.divS,fe.prototype.divideM=fe.prototype.divM,fe.divide=fe.div,fe.prototype.mod=function(A){return typeof A=="number"?this.modS(A):this.modM(A)},fe.prototype.modS=function(A){for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)%A);return this},fe.prototype.modM=function(A){if(A=B.checkMatrix(A),this.rows!==A.rows||this.columns!==A.columns)throw new RangeError("Matrices dimensions must be equal");for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)%A.get(F,K));return this},fe.mod=function(A,F){return new B(A).mod(F)},fe.prototype.modulus=fe.prototype.mod,fe.prototype.modulusS=fe.prototype.modS,fe.prototype.modulusM=fe.prototype.modM,fe.modulus=fe.mod,fe.prototype.and=function(A){return typeof A=="number"?this.andS(A):this.andM(A)},fe.prototype.andS=function(A){for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)&A);return this},fe.prototype.andM=function(A){if(A=B.checkMatrix(A),this.rows!==A.rows||this.columns!==A.columns)throw new RangeError("Matrices dimensions must be equal");for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)&A.get(F,K));return this},fe.and=function(A,F){return new B(A).and(F)},fe.prototype.or=function(A){return typeof A=="number"?this.orS(A):this.orM(A)},fe.prototype.orS=function(A){for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)|A);return this},fe.prototype.orM=function(A){if(A=B.checkMatrix(A),this.rows!==A.rows||this.columns!==A.columns)throw new RangeError("Matrices dimensions must be equal");for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)|A.get(F,K));return this},fe.or=function(A,F){return new B(A).or(F)},fe.prototype.xor=function(A){return typeof A=="number"?this.xorS(A):this.xorM(A)},fe.prototype.xorS=function(A){for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)^A);return this},fe.prototype.xorM=function(A){if(A=B.checkMatrix(A),this.rows!==A.rows||this.columns!==A.columns)throw new RangeError("Matrices dimensions must be equal");for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)^A.get(F,K));return this},fe.xor=function(A,F){return new B(A).xor(F)},fe.prototype.leftShift=function(A){return typeof A=="number"?this.leftShiftS(A):this.leftShiftM(A)},fe.prototype.leftShiftS=function(A){for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)<<A);return this},fe.prototype.leftShiftM=function(A){if(A=B.checkMatrix(A),this.rows!==A.rows||this.columns!==A.columns)throw new RangeError("Matrices dimensions must be equal");for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)<<A.get(F,K));return this},fe.leftShift=function(A,F){return new B(A).leftShift(F)},fe.prototype.signPropagatingRightShift=function(A){return typeof A=="number"?this.signPropagatingRightShiftS(A):this.signPropagatingRightShiftM(A)},fe.prototype.signPropagatingRightShiftS=function(A){for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)>>A);return this},fe.prototype.signPropagatingRightShiftM=function(A){if(A=B.checkMatrix(A),this.rows!==A.rows||this.columns!==A.columns)throw new RangeError("Matrices dimensions must be equal");for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)>>A.get(F,K));return this},fe.signPropagatingRightShift=function(A,F){return new B(A).signPropagatingRightShift(F)},fe.prototype.rightShift=function(A){return typeof A=="number"?this.rightShiftS(A):this.rightShiftM(A)},fe.prototype.rightShiftS=function(A){for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)>>>A);return this},fe.prototype.rightShiftM=function(A){if(A=B.checkMatrix(A),this.rows!==A.rows||this.columns!==A.columns)throw new RangeError("Matrices dimensions must be equal");for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)>>>A.get(F,K));return this},fe.rightShift=function(A,F){return new B(A).rightShift(F)},fe.prototype.zeroFillRightShift=fe.prototype.rightShift,fe.prototype.zeroFillRightShiftS=fe.prototype.rightShiftS,fe.prototype.zeroFillRightShiftM=fe.prototype.rightShiftM,fe.zeroFillRightShift=fe.rightShift,fe.prototype.not=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,~this.get(A,F));return this},fe.not=function(A){return new B(A).not()},fe.prototype.abs=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.abs(this.get(A,F)));return this},fe.abs=function(A){return new B(A).abs()},fe.prototype.acos=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.acos(this.get(A,F)));return this},fe.acos=function(A){return new B(A).acos()},fe.prototype.acosh=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.acosh(this.get(A,F)));return this},fe.acosh=function(A){return new B(A).acosh()},fe.prototype.asin=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.asin(this.get(A,F)));return this},fe.asin=function(A){return new B(A).asin()},fe.prototype.asinh=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.asinh(this.get(A,F)));return this},fe.asinh=function(A){return new B(A).asinh()},fe.prototype.atan=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.atan(this.get(A,F)));return this},fe.atan=function(A){return new B(A).atan()},fe.prototype.atanh=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.atanh(this.get(A,F)));return this},fe.atanh=function(A){return new B(A).atanh()},fe.prototype.cbrt=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.cbrt(this.get(A,F)));return this},fe.cbrt=function(A){return new B(A).cbrt()},fe.prototype.ceil=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.ceil(this.get(A,F)));return this},fe.ceil=function(A){return new B(A).ceil()},fe.prototype.clz32=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.clz32(this.get(A,F)));return this},fe.clz32=function(A){return new B(A).clz32()},fe.prototype.cos=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.cos(this.get(A,F)));return this},fe.cos=function(A){return new B(A).cos()},fe.prototype.cosh=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.cosh(this.get(A,F)));return this},fe.cosh=function(A){return new B(A).cosh()},fe.prototype.exp=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.exp(this.get(A,F)));return this},fe.exp=function(A){return new B(A).exp()},fe.prototype.expm1=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.expm1(this.get(A,F)));return this},fe.expm1=function(A){return new B(A).expm1()},fe.prototype.floor=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.floor(this.get(A,F)));return this},fe.floor=function(A){return new B(A).floor()},fe.prototype.fround=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.fround(this.get(A,F)));return this},fe.fround=function(A){return new B(A).fround()},fe.prototype.log=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.log(this.get(A,F)));return this},fe.log=function(A){return new B(A).log()},fe.prototype.log1p=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.log1p(this.get(A,F)));return this},fe.log1p=function(A){return new B(A).log1p()},fe.prototype.log10=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.log10(this.get(A,F)));return this},fe.log10=function(A){return new B(A).log10()},fe.prototype.log2=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.log2(this.get(A,F)));return this},fe.log2=function(A){return new B(A).log2()},fe.prototype.round=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.round(this.get(A,F)));return this},fe.round=function(A){return new B(A).round()},fe.prototype.sign=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.sign(this.get(A,F)));return this},fe.sign=function(A){return new B(A).sign()},fe.prototype.sin=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.sin(this.get(A,F)));return this},fe.sin=function(A){return new B(A).sin()},fe.prototype.sinh=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.sinh(this.get(A,F)));return this},fe.sinh=function(A){return new B(A).sinh()},fe.prototype.sqrt=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.sqrt(this.get(A,F)));return this},fe.sqrt=function(A){return new B(A).sqrt()},fe.prototype.tan=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.tan(this.get(A,F)));return this},fe.tan=function(A){return new B(A).tan()},fe.prototype.tanh=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.tanh(this.get(A,F)));return this},fe.tanh=function(A){return new B(A).tanh()},fe.prototype.trunc=function(){for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.set(A,F,Math.trunc(this.get(A,F)));return this},fe.trunc=function(A){return new B(A).trunc()},fe.pow=function(A,F){return new B(A).pow(F)},fe.prototype.pow=function(A){return typeof A=="number"?this.powS(A):this.powM(A)},fe.prototype.powS=function(A){for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)**A);return this},fe.prototype.powM=function(A){if(A=B.checkMatrix(A),this.rows!==A.rows||this.columns!==A.columns)throw new RangeError("Matrices dimensions must be equal");for(let F=0;F<this.rows;F++)for(let K=0;K<this.columns;K++)this.set(F,K,this.get(F,K)**A.get(F,K));return this}}function g(fe,B,I){let A=I?fe.rows:fe.rows-1;if(B<0||B>A)throw new RangeError("Row index out of range")}function p(fe,B,I){let A=I?fe.columns:fe.columns-1;if(B<0||B>A)throw new RangeError("Column index out of range")}function h(fe,B){if(B.to1DArray&&(B=B.to1DArray()),B.length!==fe.columns)throw new RangeError("vector size must be the same as the number of columns");return B}function v(fe,B){if(B.to1DArray&&(B=B.to1DArray()),B.length!==fe.rows)throw new RangeError("vector size must be the same as the number of rows");return B}function y(fe,B){if(!n.isAnyArray(B))throw new TypeError("row indices must be an array");for(let I=0;I<B.length;I++)if(B[I]<0||B[I]>=fe.rows)throw new RangeError("row indices are out of range")}function w(fe,B){if(!n.isAnyArray(B))throw new TypeError("column indices must be an array");for(let I=0;I<B.length;I++)if(B[I]<0||B[I]>=fe.columns)throw new RangeError("column indices are out of range")}function S(fe,B,I,A,F){if(arguments.length!==5)throw new RangeError("expected 4 arguments");if(T("startRow",B),T("endRow",I),T("startColumn",A),T("endColumn",F),B>I||A>F||B<0||B>=fe.rows||I<0||I>=fe.rows||A<0||A>=fe.columns||F<0||F>=fe.columns)throw new RangeError("Submatrix indices are out of range")}function M(fe,B=0){let I=[];for(let A=0;A<fe;A++)I.push(B);return I}function T(fe,B){if(typeof B!="number")throw new TypeError(`${fe} must be a number`)}function C(fe){if(fe.isEmpty())throw new Error("Empty matrix has no elements to index")}function x(fe){let B=M(fe.rows);for(let I=0;I<fe.rows;++I)for(let A=0;A<fe.columns;++A)B[I]+=fe.get(I,A);return B}function R(fe){let B=M(fe.columns);for(let I=0;I<fe.rows;++I)for(let A=0;A<fe.columns;++A)B[A]+=fe.get(I,A);return B}function P(fe){let B=0;for(let I=0;I<fe.rows;I++)for(let A=0;A<fe.columns;A++)B+=fe.get(I,A);return B}function D(fe){let B=M(fe.rows,1);for(let I=0;I<fe.rows;++I)for(let A=0;A<fe.columns;++A)B[I]*=fe.get(I,A);return B}function z(fe){let B=M(fe.columns,1);for(let I=0;I<fe.rows;++I)for(let A=0;A<fe.columns;++A)B[A]*=fe.get(I,A);return B}function U(fe){let B=1;for(let I=0;I<fe.rows;I++)for(let A=0;A<fe.columns;A++)B*=fe.get(I,A);return B}function N(fe,B,I){const A=fe.rows,F=fe.columns,K=[];for(let Ee=0;Ee<A;Ee++){let k=0,re=0,Q=0;for(let ve=0;ve<F;ve++)Q=fe.get(Ee,ve)-I[Ee],k+=Q,re+=Q*Q;B?K.push((re-k*k/F)/(F-1)):K.push((re-k*k/F)/F)}return K}function j(fe,B,I){const A=fe.rows,F=fe.columns,K=[];for(let Ee=0;Ee<F;Ee++){let k=0,re=0,Q=0;for(let ve=0;ve<A;ve++)Q=fe.get(ve,Ee)-I[Ee],k+=Q,re+=Q*Q;B?K.push((re-k*k/A)/(A-1)):K.push((re-k*k/A)/A)}return K}function J(fe,B,I){const A=fe.rows,F=fe.columns,K=A*F;let Ee=0,k=0,re=0;for(let Q=0;Q<A;Q++)for(let ve=0;ve<F;ve++)re=fe.get(Q,ve)-I,Ee+=re,k+=re*re;return B?(k-Ee*Ee/K)/(K-1):(k-Ee*Ee/K)/K}function W(fe,B){for(let I=0;I<fe.rows;I++)for(let A=0;A<fe.columns;A++)fe.set(I,A,fe.get(I,A)-B[I])}function oe(fe,B){for(let I=0;I<fe.rows;I++)for(let A=0;A<fe.columns;A++)fe.set(I,A,fe.get(I,A)-B[A])}function ne(fe,B){for(let I=0;I<fe.rows;I++)for(let A=0;A<fe.columns;A++)fe.set(I,A,fe.get(I,A)-B)}function q(fe){const B=[];for(let I=0;I<fe.rows;I++){let A=0;for(let F=0;F<fe.columns;F++)A+=fe.get(I,F)**2/(fe.columns-1);B.push(Math.sqrt(A))}return B}function le(fe,B){for(let I=0;I<fe.rows;I++)for(let A=0;A<fe.columns;A++)fe.set(I,A,fe.get(I,A)/B[I])}function se(fe){const B=[];for(let I=0;I<fe.columns;I++){let A=0;for(let F=0;F<fe.rows;F++)A+=fe.get(F,I)**2/(fe.rows-1);B.push(Math.sqrt(A))}return B}function pe(fe,B){for(let I=0;I<fe.rows;I++)for(let A=0;A<fe.columns;A++)fe.set(I,A,fe.get(I,A)/B[A])}function be(fe){const B=fe.size-1;let I=0;for(let A=0;A<fe.columns;A++)for(let F=0;F<fe.rows;F++)I+=fe.get(F,A)**2/B;return Math.sqrt(I)}function ee(fe,B){for(let I=0;I<fe.rows;I++)for(let A=0;A<fe.columns;A++)fe.set(I,A,fe.get(I,A)/B)}class te{static from1DArray(B,I,A){if(B*I!==A.length)throw new RangeError("data length does not match given dimensions");let K=new ce(B,I);for(let Ee=0;Ee<B;Ee++)for(let k=0;k<I;k++)K.set(Ee,k,A[Ee*I+k]);return K}static rowVector(B){let I=new ce(1,B.length);for(let A=0;A<B.length;A++)I.set(0,A,B[A]);return I}static columnVector(B){let I=new ce(B.length,1);for(let A=0;A<B.length;A++)I.set(A,0,B[A]);return I}static zeros(B,I){return new ce(B,I)}static ones(B,I){return new ce(B,I).fill(1)}static rand(B,I,A={}){if(typeof A!="object")throw new TypeError("options must be an object");const{random:F=Math.random}=A;let K=new ce(B,I);for(let Ee=0;Ee<B;Ee++)for(let k=0;k<I;k++)K.set(Ee,k,F());return K}static randInt(B,I,A={}){if(typeof A!="object")throw new TypeError("options must be an object");const{min:F=0,max:K=1e3,random:Ee=Math.random}=A;if(!Number.isInteger(F))throw new TypeError("min must be an integer");if(!Number.isInteger(K))throw new TypeError("max must be an integer");if(F>=K)throw new RangeError("min must be smaller than max");let k=K-F,re=new ce(B,I);for(let Q=0;Q<B;Q++)for(let ve=0;ve<I;ve++){let ge=F+Math.round(Ee()*k);re.set(Q,ve,ge)}return re}static eye(B,I,A){I===void 0&&(I=B),A===void 0&&(A=1);let F=Math.min(B,I),K=this.zeros(B,I);for(let Ee=0;Ee<F;Ee++)K.set(Ee,Ee,A);return K}static diag(B,I,A){let F=B.length;I===void 0&&(I=F),A===void 0&&(A=I);let K=Math.min(F,I,A),Ee=this.zeros(I,A);for(let k=0;k<K;k++)Ee.set(k,k,B[k]);return Ee}static min(B,I){B=this.checkMatrix(B),I=this.checkMatrix(I);let A=B.rows,F=B.columns,K=new ce(A,F);for(let Ee=0;Ee<A;Ee++)for(let k=0;k<F;k++)K.set(Ee,k,Math.min(B.get(Ee,k),I.get(Ee,k)));return K}static max(B,I){B=this.checkMatrix(B),I=this.checkMatrix(I);let A=B.rows,F=B.columns,K=new this(A,F);for(let Ee=0;Ee<A;Ee++)for(let k=0;k<F;k++)K.set(Ee,k,Math.max(B.get(Ee,k),I.get(Ee,k)));return K}static checkMatrix(B){return te.isMatrix(B)?B:new ce(B)}static isMatrix(B){return B!=null&&B.klass==="Matrix"}get size(){return this.rows*this.columns}apply(B){if(typeof B!="function")throw new TypeError("callback must be a function");for(let I=0;I<this.rows;I++)for(let A=0;A<this.columns;A++)B.call(this,I,A);return this}to1DArray(){let B=[];for(let I=0;I<this.rows;I++)for(let A=0;A<this.columns;A++)B.push(this.get(I,A));return B}to2DArray(){let B=[];for(let I=0;I<this.rows;I++){B.push([]);for(let A=0;A<this.columns;A++)B[I].push(this.get(I,A))}return B}toJSON(){return this.to2DArray()}isRowVector(){return this.rows===1}isColumnVector(){return this.columns===1}isVector(){return this.rows===1||this.columns===1}isSquare(){return this.rows===this.columns}isEmpty(){return this.rows===0||this.columns===0}isSymmetric(){if(this.isSquare()){for(let B=0;B<this.rows;B++)for(let I=0;I<=B;I++)if(this.get(B,I)!==this.get(I,B))return!1;return!0}return!1}isDistance(){if(!this.isSymmetric())return!1;for(let B=0;B<this.rows;B++)if(this.get(B,B)!==0)return!1;return!0}isEchelonForm(){let B=0,I=0,A=-1,F=!0,K=!1;for(;B<this.rows&&F;){for(I=0,K=!1;I<this.columns&&K===!1;)this.get(B,I)===0?I++:this.get(B,I)===1&&I>A?(K=!0,A=I):(F=!1,K=!0);B++}return F}isReducedEchelonForm(){let B=0,I=0,A=-1,F=!0,K=!1;for(;B<this.rows&&F;){for(I=0,K=!1;I<this.columns&&K===!1;)this.get(B,I)===0?I++:this.get(B,I)===1&&I>A?(K=!0,A=I):(F=!1,K=!0);for(let Ee=I+1;Ee<this.rows;Ee++)this.get(B,Ee)!==0&&(F=!1);B++}return F}echelonForm(){let B=this.clone(),I=0,A=0;for(;I<B.rows&&A<B.columns;){let F=I;for(let K=I;K<B.rows;K++)B.get(K,A)>B.get(F,A)&&(F=K);if(B.get(F,A)===0)A++;else{B.swapRows(I,F);let K=B.get(I,A);for(let Ee=A;Ee<B.columns;Ee++)B.set(I,Ee,B.get(I,Ee)/K);for(let Ee=I+1;Ee<B.rows;Ee++){let k=B.get(Ee,A)/B.get(I,A);B.set(Ee,A,0);for(let re=A+1;re<B.columns;re++)B.set(Ee,re,B.get(Ee,re)-B.get(I,re)*k)}I++,A++}}return B}reducedEchelonForm(){let B=this.echelonForm(),I=B.columns,A=B.rows,F=A-1;for(;F>=0;)if(B.maxRow(F)===0)F--;else{let K=0,Ee=!1;for(;K<A&&Ee===!1;)B.get(F,K)===1?Ee=!0:K++;for(let k=0;k<F;k++){let re=B.get(k,K);for(let Q=K;Q<I;Q++){let ve=B.get(k,Q)-re*B.get(F,Q);B.set(k,Q,ve)}}F--}return B}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(B={}){if(typeof B!="object")throw new TypeError("options must be an object");const{rows:I=1,columns:A=1}=B;if(!Number.isInteger(I)||I<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(A)||A<=0)throw new TypeError("columns must be a positive integer");let F=new ce(this.rows*I,this.columns*A);for(let K=0;K<I;K++)for(let Ee=0;Ee<A;Ee++)F.setSubMatrix(this,this.rows*K,this.columns*Ee);return F}fill(B){for(let I=0;I<this.rows;I++)for(let A=0;A<this.columns;A++)this.set(I,A,B);return this}neg(){return this.mulS(-1)}getRow(B){g(this,B);let I=[];for(let A=0;A<this.columns;A++)I.push(this.get(B,A));return I}getRowVector(B){return ce.rowVector(this.getRow(B))}setRow(B,I){g(this,B),I=h(this,I);for(let A=0;A<this.columns;A++)this.set(B,A,I[A]);return this}swapRows(B,I){g(this,B),g(this,I);for(let A=0;A<this.columns;A++){let F=this.get(B,A);this.set(B,A,this.get(I,A)),this.set(I,A,F)}return this}getColumn(B){p(this,B);let I=[];for(let A=0;A<this.rows;A++)I.push(this.get(A,B));return I}getColumnVector(B){return ce.columnVector(this.getColumn(B))}setColumn(B,I){p(this,B),I=v(this,I);for(let A=0;A<this.rows;A++)this.set(A,B,I[A]);return this}swapColumns(B,I){p(this,B),p(this,I);for(let A=0;A<this.rows;A++){let F=this.get(A,B);this.set(A,B,this.get(A,I)),this.set(A,I,F)}return this}addRowVector(B){B=h(this,B);for(let I=0;I<this.rows;I++)for(let A=0;A<this.columns;A++)this.set(I,A,this.get(I,A)+B[A]);return this}subRowVector(B){B=h(this,B);for(let I=0;I<this.rows;I++)for(let A=0;A<this.columns;A++)this.set(I,A,this.get(I,A)-B[A]);return this}mulRowVector(B){B=h(this,B);for(let I=0;I<this.rows;I++)for(let A=0;A<this.columns;A++)this.set(I,A,this.get(I,A)*B[A]);return this}divRowVector(B){B=h(this,B);for(let I=0;I<this.rows;I++)for(let A=0;A<this.columns;A++)this.set(I,A,this.get(I,A)/B[A]);return this}addColumnVector(B){B=v(this,B);for(let I=0;I<this.rows;I++)for(let A=0;A<this.columns;A++)this.set(I,A,this.get(I,A)+B[I]);return this}subColumnVector(B){B=v(this,B);for(let I=0;I<this.rows;I++)for(let A=0;A<this.columns;A++)this.set(I,A,this.get(I,A)-B[I]);return this}mulColumnVector(B){B=v(this,B);for(let I=0;I<this.rows;I++)for(let A=0;A<this.columns;A++)this.set(I,A,this.get(I,A)*B[I]);return this}divColumnVector(B){B=v(this,B);for(let I=0;I<this.rows;I++)for(let A=0;A<this.columns;A++)this.set(I,A,this.get(I,A)/B[I]);return this}mulRow(B,I){g(this,B);for(let A=0;A<this.columns;A++)this.set(B,A,this.get(B,A)*I);return this}mulColumn(B,I){p(this,B);for(let A=0;A<this.rows;A++)this.set(A,B,this.get(A,B)*I);return this}max(B){if(this.isEmpty())return NaN;switch(B){case"row":{const I=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.get(A,F)>I[A]&&(I[A]=this.get(A,F));return I}case"column":{const I=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.get(A,F)>I[F]&&(I[F]=this.get(A,F));return I}case void 0:{let I=this.get(0,0);for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.get(A,F)>I&&(I=this.get(A,F));return I}default:throw new Error(`invalid option: ${B}`)}}maxIndex(){C(this);let B=this.get(0,0),I=[0,0];for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.get(A,F)>B&&(B=this.get(A,F),I[0]=A,I[1]=F);return I}min(B){if(this.isEmpty())return NaN;switch(B){case"row":{const I=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.get(A,F)<I[A]&&(I[A]=this.get(A,F));return I}case"column":{const I=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.get(A,F)<I[F]&&(I[F]=this.get(A,F));return I}case void 0:{let I=this.get(0,0);for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.get(A,F)<I&&(I=this.get(A,F));return I}default:throw new Error(`invalid option: ${B}`)}}minIndex(){C(this);let B=this.get(0,0),I=[0,0];for(let A=0;A<this.rows;A++)for(let F=0;F<this.columns;F++)this.get(A,F)<B&&(B=this.get(A,F),I[0]=A,I[1]=F);return I}maxRow(B){if(g(this,B),this.isEmpty())return NaN;let I=this.get(B,0);for(let A=1;A<this.columns;A++)this.get(B,A)>I&&(I=this.get(B,A));return I}maxRowIndex(B){g(this,B),C(this);let I=this.get(B,0),A=[B,0];for(let F=1;F<this.columns;F++)this.get(B,F)>I&&(I=this.get(B,F),A[1]=F);return A}minRow(B){if(g(this,B),this.isEmpty())return NaN;let I=this.get(B,0);for(let A=1;A<this.columns;A++)this.get(B,A)<I&&(I=this.get(B,A));return I}minRowIndex(B){g(this,B),C(this);let I=this.get(B,0),A=[B,0];for(let F=1;F<this.columns;F++)this.get(B,F)<I&&(I=this.get(B,F),A[1]=F);return A}maxColumn(B){if(p(this,B),this.isEmpty())return NaN;let I=this.get(0,B);for(let A=1;A<this.rows;A++)this.get(A,B)>I&&(I=this.get(A,B));return I}maxColumnIndex(B){p(this,B),C(this);let I=this.get(0,B),A=[0,B];for(let F=1;F<this.rows;F++)this.get(F,B)>I&&(I=this.get(F,B),A[0]=F);return A}minColumn(B){if(p(this,B),this.isEmpty())return NaN;let I=this.get(0,B);for(let A=1;A<this.rows;A++)this.get(A,B)<I&&(I=this.get(A,B));return I}minColumnIndex(B){p(this,B),C(this);let I=this.get(0,B),A=[0,B];for(let F=1;F<this.rows;F++)this.get(F,B)<I&&(I=this.get(F,B),A[0]=F);return A}diag(){let B=Math.min(this.rows,this.columns),I=[];for(let A=0;A<B;A++)I.push(this.get(A,A));return I}norm(B="frobenius"){switch(B){case"max":return this.max();case"frobenius":return Math.sqrt(this.dot(this));default:throw new RangeError(`unknown norm type: ${B}`)}}cumulativeSum(){let B=0;for(let I=0;I<this.rows;I++)for(let A=0;A<this.columns;A++)B+=this.get(I,A),this.set(I,A,B);return this}dot(B){te.isMatrix(B)&&(B=B.to1DArray());let I=this.to1DArray();if(I.length!==B.length)throw new RangeError("vectors do not have the same size");let A=0;for(let F=0;F<I.length;F++)A+=I[F]*B[F];return A}mmul(B){B=ce.checkMatrix(B);let I=this.rows,A=this.columns,F=B.columns,K=new ce(I,F),Ee=new Float64Array(A);for(let k=0;k<F;k++){for(let re=0;re<A;re++)Ee[re]=B.get(re,k);for(let re=0;re<I;re++){let Q=0;for(let ve=0;ve<A;ve++)Q+=this.get(re,ve)*Ee[ve];K.set(re,k,Q)}}return K}mpow(B){if(!this.isSquare())throw new RangeError("Matrix must be square");if(!Number.isInteger(B)||B<0)throw new RangeError("Exponent must be a non-negative integer");let I=ce.eye(this.rows),A=this;for(let F=B;F>=1;F/=2)(F&1)!==0&&(I=I.mmul(A)),A=A.mmul(A);return I}strassen2x2(B){B=ce.checkMatrix(B);let I=new ce(2,2);const A=this.get(0,0),F=B.get(0,0),K=this.get(0,1),Ee=B.get(0,1),k=this.get(1,0),re=B.get(1,0),Q=this.get(1,1),ve=B.get(1,1),ge=(A+Q)*(F+ve),Le=(k+Q)*F,rt=A*(Ee-ve),nt=Q*(re-F),ft=(A+K)*ve,yt=(k-A)*(F+Ee),Ne=(K-Q)*(re+ve),Bt=ge+nt-ft+Ne,on=rt+ft,xn=Le+nt,Bn=ge-Le+rt+yt;return I.set(0,0,Bt),I.set(0,1,on),I.set(1,0,xn),I.set(1,1,Bn),I}strassen3x3(B){B=ce.checkMatrix(B);let I=new ce(3,3);const A=this.get(0,0),F=this.get(0,1),K=this.get(0,2),Ee=this.get(1,0),k=this.get(1,1),re=this.get(1,2),Q=this.get(2,0),ve=this.get(2,1),ge=this.get(2,2),Le=B.get(0,0),rt=B.get(0,1),nt=B.get(0,2),ft=B.get(1,0),yt=B.get(1,1),Ne=B.get(1,2),Bt=B.get(2,0),on=B.get(2,1),xn=B.get(2,2),Bn=(A+F+K-Ee-k-ve-ge)*yt,bi=(A-Ee)*(-rt+yt),gn=k*(-Le+rt+ft-yt-Ne-Bt+xn),Mn=(-A+Ee+k)*(Le-rt+yt),Se=(Ee+k)*(-Le+rt),we=A*Le,Ge=(-A+Q+ve)*(Le-nt+Ne),Je=(-A+Q)*(nt-Ne),Ue=(Q+ve)*(-Le+nt),Ot=(A+F+K-k-re-Q-ve)*Ne,jt=ve*(-Le+nt+ft-yt-Ne-Bt+on),tn=(-K+ve+ge)*(yt+Bt-on),en=(K-ge)*(yt-on),dn=K*Bt,wn=(ve+ge)*(-Bt+on),_n=(-K+k+re)*(Ne+Bt-xn),Fn=(K-re)*(Ne-xn),ti=(k+re)*(-Bt+xn),Pn=F*ft,Ln=re*on,Ct=Ee*nt,gt=Q*rt,Qt=ge*xn,Nn=we+dn+Pn,Ss=Bn+Mn+Se+we+tn+dn+wn,yr=we+Ge+Ue+Ot+dn+_n+ti,$i=bi+gn+Mn+we+dn+_n+Fn,ma=bi+Mn+Se+we+Ln,fi=dn+_n+Fn+ti+Ct,ks=we+Ge+Je+jt+tn+en+dn,$s=tn+en+dn+wn+gt,Ds=we+Ge+Je+Ue+Qt;return I.set(0,0,Nn),I.set(0,1,Ss),I.set(0,2,yr),I.set(1,0,$i),I.set(1,1,ma),I.set(1,2,fi),I.set(2,0,ks),I.set(2,1,$s),I.set(2,2,Ds),I}mmulStrassen(B){B=ce.checkMatrix(B);let I=this.clone(),A=I.rows,F=I.columns,K=B.rows,Ee=B.columns;F!==K&&console.warn(`Multiplying ${A} x ${F} and ${K} x ${Ee} matrix: dimensions do not match.`);function k(ge,Le,rt){let nt=ge.rows,ft=ge.columns;if(nt===Le&&ft===rt)return ge;{let yt=te.zeros(Le,rt);return yt=yt.setSubMatrix(ge,0,0),yt}}let re=Math.max(A,K),Q=Math.max(F,Ee);I=k(I,re,Q),B=k(B,re,Q);function ve(ge,Le,rt,nt){if(rt<=512||nt<=512)return ge.mmul(Le);rt%2===1&&nt%2===1?(ge=k(ge,rt+1,nt+1),Le=k(Le,rt+1,nt+1)):rt%2===1?(ge=k(ge,rt+1,nt),Le=k(Le,rt+1,nt)):nt%2===1&&(ge=k(ge,rt,nt+1),Le=k(Le,rt,nt+1));let ft=parseInt(ge.rows/2,10),yt=parseInt(ge.columns/2,10),Ne=ge.subMatrix(0,ft-1,0,yt-1),Bt=Le.subMatrix(0,ft-1,0,yt-1),on=ge.subMatrix(0,ft-1,yt,ge.columns-1),xn=Le.subMatrix(0,ft-1,yt,Le.columns-1),Bn=ge.subMatrix(ft,ge.rows-1,0,yt-1),bi=Le.subMatrix(ft,Le.rows-1,0,yt-1),gn=ge.subMatrix(ft,ge.rows-1,yt,ge.columns-1),Mn=Le.subMatrix(ft,Le.rows-1,yt,Le.columns-1),Se=ve(te.add(Ne,gn),te.add(Bt,Mn),ft,yt),we=ve(te.add(Bn,gn),Bt,ft,yt),Ge=ve(Ne,te.sub(xn,Mn),ft,yt),Je=ve(gn,te.sub(bi,Bt),ft,yt),Ue=ve(te.add(Ne,on),Mn,ft,yt),Ot=ve(te.sub(Bn,Ne),te.add(Bt,xn),ft,yt),jt=ve(te.sub(on,gn),te.add(bi,Mn),ft,yt),tn=te.add(Se,Je);tn.sub(Ue),tn.add(jt);let en=te.add(Ge,Ue),dn=te.add(we,Je),wn=te.sub(Se,we);wn.add(Ge),wn.add(Ot);let _n=te.zeros(2*tn.rows,2*tn.columns);return _n=_n.setSubMatrix(tn,0,0),_n=_n.setSubMatrix(en,tn.rows,0),_n=_n.setSubMatrix(dn,0,tn.columns),_n=_n.setSubMatrix(wn,tn.rows,tn.columns),_n.subMatrix(0,rt-1,0,nt-1)}return ve(I,B,re,Q)}scaleRows(B={}){if(typeof B!="object")throw new TypeError("options must be an object");const{min:I=0,max:A=1}=B;if(!Number.isFinite(I))throw new TypeError("min must be a number");if(!Number.isFinite(A))throw new TypeError("max must be a number");if(I>=A)throw new RangeError("min must be smaller than max");let F=new ce(this.rows,this.columns);for(let K=0;K<this.rows;K++){const Ee=this.getRow(K);Ee.length>0&&e(Ee,{min:I,max:A,output:Ee}),F.setRow(K,Ee)}return F}scaleColumns(B={}){if(typeof B!="object")throw new TypeError("options must be an object");const{min:I=0,max:A=1}=B;if(!Number.isFinite(I))throw new TypeError("min must be a number");if(!Number.isFinite(A))throw new TypeError("max must be a number");if(I>=A)throw new RangeError("min must be smaller than max");let F=new ce(this.rows,this.columns);for(let K=0;K<this.columns;K++){const Ee=this.getColumn(K);Ee.length&&e(Ee,{min:I,max:A,output:Ee}),F.setColumn(K,Ee)}return F}flipRows(){const B=Math.ceil(this.columns/2);for(let I=0;I<this.rows;I++)for(let A=0;A<B;A++){let F=this.get(I,A),K=this.get(I,this.columns-1-A);this.set(I,A,K),this.set(I,this.columns-1-A,F)}return this}flipColumns(){const B=Math.ceil(this.rows/2);for(let I=0;I<this.columns;I++)for(let A=0;A<B;A++){let F=this.get(A,I),K=this.get(this.rows-1-A,I);this.set(A,I,K),this.set(this.rows-1-A,I,F)}return this}kroneckerProduct(B){B=ce.checkMatrix(B);let I=this.rows,A=this.columns,F=B.rows,K=B.columns,Ee=new ce(I*F,A*K);for(let k=0;k<I;k++)for(let re=0;re<A;re++)for(let Q=0;Q<F;Q++)for(let ve=0;ve<K;ve++)Ee.set(F*k+Q,K*re+ve,this.get(k,re)*B.get(Q,ve));return Ee}kroneckerSum(B){if(B=ce.checkMatrix(B),!this.isSquare()||!B.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let I=this.rows,A=B.rows,F=this.kroneckerProduct(ce.eye(A,A)),K=ce.eye(I,I).kroneckerProduct(B);return F.add(K)}transpose(){let B=new ce(this.columns,this.rows);for(let I=0;I<this.rows;I++)for(let A=0;A<this.columns;A++)B.set(A,I,this.get(I,A));return B}sortRows(B=ue){for(let I=0;I<this.rows;I++)this.setRow(I,this.getRow(I).sort(B));return this}sortColumns(B=ue){for(let I=0;I<this.columns;I++)this.setColumn(I,this.getColumn(I).sort(B));return this}subMatrix(B,I,A,F){S(this,B,I,A,F);let K=new ce(I-B+1,F-A+1);for(let Ee=B;Ee<=I;Ee++)for(let k=A;k<=F;k++)K.set(Ee-B,k-A,this.get(Ee,k));return K}subMatrixRow(B,I,A){if(I===void 0&&(I=0),A===void 0&&(A=this.columns-1),I>A||I<0||I>=this.columns||A<0||A>=this.columns)throw new RangeError("Argument out of range");let F=new ce(B.length,A-I+1);for(let K=0;K<B.length;K++)for(let Ee=I;Ee<=A;Ee++){if(B[K]<0||B[K]>=this.rows)throw new RangeError(`Row index out of range: ${B[K]}`);F.set(K,Ee-I,this.get(B[K],Ee))}return F}subMatrixColumn(B,I,A){if(I===void 0&&(I=0),A===void 0&&(A=this.rows-1),I>A||I<0||I>=this.rows||A<0||A>=this.rows)throw new RangeError("Argument out of range");let F=new ce(A-I+1,B.length);for(let K=0;K<B.length;K++)for(let Ee=I;Ee<=A;Ee++){if(B[K]<0||B[K]>=this.columns)throw new RangeError(`Column index out of range: ${B[K]}`);F.set(Ee-I,K,this.get(Ee,B[K]))}return F}setSubMatrix(B,I,A){if(B=ce.checkMatrix(B),B.isEmpty())return this;let F=I+B.rows-1,K=A+B.columns-1;S(this,I,F,A,K);for(let Ee=0;Ee<B.rows;Ee++)for(let k=0;k<B.columns;k++)this.set(I+Ee,A+k,B.get(Ee,k));return this}selection(B,I){y(this,B),w(this,I);let A=new ce(B.length,I.length);for(let F=0;F<B.length;F++){let K=B[F];for(let Ee=0;Ee<I.length;Ee++){let k=I[Ee];A.set(F,Ee,this.get(K,k))}}return A}trace(){let B=Math.min(this.rows,this.columns),I=0;for(let A=0;A<B;A++)I+=this.get(A,A);return I}clone(){return this.constructor.copy(this,new ce(this.rows,this.columns))}static copy(B,I){for(const[A,F,K]of B.entries())I.set(A,F,K);return I}sum(B){switch(B){case"row":return x(this);case"column":return R(this);case void 0:return P(this);default:throw new Error(`invalid option: ${B}`)}}product(B){switch(B){case"row":return D(this);case"column":return z(this);case void 0:return U(this);default:throw new Error(`invalid option: ${B}`)}}mean(B){const I=this.sum(B);switch(B){case"row":{for(let A=0;A<this.rows;A++)I[A]/=this.columns;return I}case"column":{for(let A=0;A<this.columns;A++)I[A]/=this.rows;return I}case void 0:return I/this.size;default:throw new Error(`invalid option: ${B}`)}}variance(B,I={}){if(typeof B=="object"&&(I=B,B=void 0),typeof I!="object")throw new TypeError("options must be an object");const{unbiased:A=!0,mean:F=this.mean(B)}=I;if(typeof A!="boolean")throw new TypeError("unbiased must be a boolean");switch(B){case"row":{if(!n.isAnyArray(F))throw new TypeError("mean must be an array");return N(this,A,F)}case"column":{if(!n.isAnyArray(F))throw new TypeError("mean must be an array");return j(this,A,F)}case void 0:{if(typeof F!="number")throw new TypeError("mean must be a number");return J(this,A,F)}default:throw new Error(`invalid option: ${B}`)}}standardDeviation(B,I){typeof B=="object"&&(I=B,B=void 0);const A=this.variance(B,I);if(B===void 0)return Math.sqrt(A);for(let F=0;F<A.length;F++)A[F]=Math.sqrt(A[F]);return A}center(B,I={}){if(typeof B=="object"&&(I=B,B=void 0),typeof I!="object")throw new TypeError("options must be an object");const{center:A=this.mean(B)}=I;switch(B){case"row":{if(!n.isAnyArray(A))throw new TypeError("center must be an array");return W(this,A),this}case"column":{if(!n.isAnyArray(A))throw new TypeError("center must be an array");return oe(this,A),this}case void 0:{if(typeof A!="number")throw new TypeError("center must be a number");return ne(this,A),this}default:throw new Error(`invalid option: ${B}`)}}scale(B,I={}){if(typeof B=="object"&&(I=B,B=void 0),typeof I!="object")throw new TypeError("options must be an object");let A=I.scale;switch(B){case"row":{if(A===void 0)A=q(this);else if(!n.isAnyArray(A))throw new TypeError("scale must be an array");return le(this,A),this}case"column":{if(A===void 0)A=se(this);else if(!n.isAnyArray(A))throw new TypeError("scale must be an array");return pe(this,A),this}case void 0:{if(A===void 0)A=be(this);else if(typeof A!="number")throw new TypeError("scale must be a number");return ee(this,A),this}default:throw new Error(`invalid option: ${B}`)}}toString(B){return r(this,B)}[Symbol.iterator](){return this.entries()}*entries(){for(let B=0;B<this.rows;B++)for(let I=0;I<this.columns;I++)yield[B,I,this.get(B,I)]}*values(){for(let B=0;B<this.rows;B++)for(let I=0;I<this.columns;I++)yield this.get(B,I)}}te.prototype.klass="Matrix",typeof Symbol<"u"&&(te.prototype[Symbol.for("nodejs.util.inspect.custom")]=s);function ue(fe,B){return fe-B}function ae(fe){return fe.every(B=>typeof B=="number")}te.random=te.rand,te.randomInt=te.randInt,te.diagonal=te.diag,te.prototype.diagonal=te.prototype.diag,te.identity=te.eye,te.prototype.negate=te.prototype.neg,te.prototype.tensorProduct=te.prototype.kroneckerProduct;class ce extends te{data;#e(B,I){if(this.data=[],Number.isInteger(I)&&I>=0)for(let A=0;A<B;A++)this.data.push(new Float64Array(I));else throw new TypeError("nColumns must be a positive integer");this.rows=B,this.columns=I}constructor(B,I){if(super(),ce.isMatrix(B))this.#e(B.rows,B.columns),ce.copy(B,this);else if(Number.isInteger(B)&&B>=0)this.#e(B,I);else if(n.isAnyArray(B)){const A=B;if(B=A.length,I=B?A[0].length:0,typeof I!="number")throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let F=0;F<B;F++){if(A[F].length!==I)throw new RangeError("Inconsistent array dimensions");if(!ae(A[F]))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(A[F]))}this.rows=B,this.columns=I}else throw new TypeError("First argument must be a positive number or an array")}set(B,I,A){return this.data[B][I]=A,this}get(B,I){return this.data[B][I]}removeRow(B){return g(this,B),this.data.splice(B,1),this.rows-=1,this}addRow(B,I){return I===void 0&&(I=B,B=this.rows),g(this,B,!0),I=Float64Array.from(h(this,I)),this.data.splice(B,0,I),this.rows+=1,this}removeColumn(B){p(this,B);for(let I=0;I<this.rows;I++){const A=new Float64Array(this.columns-1);for(let F=0;F<B;F++)A[F]=this.data[I][F];for(let F=B+1;F<this.columns;F++)A[F-1]=this.data[I][F];this.data[I]=A}return this.columns-=1,this}addColumn(B,I){typeof I>"u"&&(I=B,B=this.columns),p(this,B,!0),I=v(this,I);for(let A=0;A<this.rows;A++){const F=new Float64Array(this.columns+1);let K=0;for(;K<B;K++)F[K]=this.data[A][K];for(F[K++]=I[A];K<this.columns+1;K++)F[K]=this.data[A][K-1];this.data[A]=F}return this.columns+=1,this}}d(te,ce);class Be extends te{#e;get size(){return this.#e.size}get rows(){return this.#e.rows}get columns(){return this.#e.columns}get diagonalSize(){return this.rows}static isSymmetricMatrix(B){return ce.isMatrix(B)&&B.klassType==="SymmetricMatrix"}static zeros(B){return new this(B)}static ones(B){return new this(B).fill(1)}constructor(B){if(super(),ce.isMatrix(B)){if(!B.isSymmetric())throw new TypeError("not symmetric data");this.#e=ce.copy(B,new ce(B.rows,B.rows))}else if(Number.isInteger(B)&&B>=0)this.#e=new ce(B,B);else if(this.#e=new ce(B),!this.isSymmetric())throw new TypeError("not symmetric data")}clone(){const B=new Be(this.diagonalSize);for(const[I,A,F]of this.upperRightEntries())B.set(I,A,F);return B}toMatrix(){return new ce(this)}get(B,I){return this.#e.get(B,I)}set(B,I,A){return this.#e.set(B,I,A),this.#e.set(I,B,A),this}removeCross(B){return this.#e.removeRow(B),this.#e.removeColumn(B),this}addCross(B,I){I===void 0&&(I=B,B=this.diagonalSize);const A=I.slice();return A.splice(B,1),this.#e.addRow(B,A),this.#e.addColumn(B,I),this}applyMask(B){if(B.length!==this.diagonalSize)throw new RangeError("Mask size do not match with matrix size");const I=[];for(const[A,F]of B.entries())F||I.push(A);I.reverse();for(const A of I)this.removeCross(A);return this}toCompact(){const{diagonalSize:B}=this,I=new Array(B*(B+1)/2);for(let A=0,F=0,K=0;K<I.length;K++)I[K]=this.get(F,A),++A>=B&&(A=++F);return I}static fromCompact(B){const I=B.length,A=(Math.sqrt(8*I+1)-1)/2;if(!Number.isInteger(A))throw new TypeError(`This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(B)}`);const F=new Be(A);for(let K=0,Ee=0,k=0;k<I;k++)F.set(K,Ee,B[k]),++K>=A&&(K=++Ee);return F}*upperRightEntries(){for(let B=0,I=0;B<this.diagonalSize;void 0){const A=this.get(B,I);yield[B,I,A],++I>=this.diagonalSize&&(I=++B)}}*upperRightValues(){for(let B=0,I=0;B<this.diagonalSize;void 0)yield this.get(B,I),++I>=this.diagonalSize&&(I=++B)}}Be.prototype.klassType="SymmetricMatrix";class He extends Be{static isDistanceMatrix(B){return Be.isSymmetricMatrix(B)&&B.klassSubType==="DistanceMatrix"}constructor(B){if(super(B),!this.isDistance())throw new TypeError("Provided arguments do no produce a distance matrix")}set(B,I,A){return B===I&&(A=0),super.set(B,I,A)}addCross(B,I){return I===void 0&&(I=B,B=this.diagonalSize),I=I.slice(),I[B]=0,super.addCross(B,I)}toSymmetricMatrix(){return new Be(this)}clone(){const B=new He(this.diagonalSize);for(const[I,A,F]of this.upperRightEntries())I!==A&&B.set(I,A,F);return B}toCompact(){const{diagonalSize:B}=this,I=(B-1)*B/2,A=new Array(I);for(let F=1,K=0,Ee=0;Ee<A.length;Ee++)A[Ee]=this.get(K,F),++F>=B&&(F=++K+1);return A}static fromCompact(B){const I=B.length;if(I===0)return new this(0);const A=(Math.sqrt(8*I+1)+1)/2;if(!Number.isInteger(A))throw new TypeError(`This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(B)}`);const F=new this(A);for(let K=1,Ee=0,k=0;k<I;k++)F.set(K,Ee,B[k]),++K>=A&&(K=++Ee+1);return F}}He.prototype.klassSubType="DistanceMatrix";class Xe extends te{constructor(B,I,A){super(),this.matrix=B,this.rows=I,this.columns=A}}class ot extends Xe{constructor(B,I){p(B,I),super(B,B.rows,1),this.column=I}set(B,I,A){return this.matrix.set(B,this.column,A),this}get(B){return this.matrix.get(B,this.column)}}class tt extends Xe{constructor(B,I){w(B,I),super(B,B.rows,I.length),this.columnIndices=I}set(B,I,A){return this.matrix.set(B,this.columnIndices[I],A),this}get(B,I){return this.matrix.get(B,this.columnIndices[I])}}class Ae extends Xe{constructor(B){super(B,B.rows,B.columns)}set(B,I,A){return this.matrix.set(B,this.columns-I-1,A),this}get(B,I){return this.matrix.get(B,this.columns-I-1)}}class ye extends Xe{constructor(B){super(B,B.rows,B.columns)}set(B,I,A){return this.matrix.set(this.rows-B-1,I,A),this}get(B,I){return this.matrix.get(this.rows-B-1,I)}}class xe extends Xe{constructor(B,I){g(B,I),super(B,1,B.columns),this.row=I}set(B,I,A){return this.matrix.set(this.row,I,A),this}get(B,I){return this.matrix.get(this.row,I)}}class ke extends Xe{constructor(B,I){y(B,I),super(B,I.length,B.columns),this.rowIndices=I}set(B,I,A){return this.matrix.set(this.rowIndices[B],I,A),this}get(B,I){return this.matrix.get(this.rowIndices[B],I)}}class ze extends Xe{constructor(B,I,A){y(B,I),w(B,A),super(B,I.length,A.length),this.rowIndices=I,this.columnIndices=A}set(B,I,A){return this.matrix.set(this.rowIndices[B],this.columnIndices[I],A),this}get(B,I){return this.matrix.get(this.rowIndices[B],this.columnIndices[I])}}class je extends Xe{constructor(B,I,A,F,K){S(B,I,A,F,K),super(B,A-I+1,K-F+1),this.startRow=I,this.startColumn=F}set(B,I,A){return this.matrix.set(this.startRow+B,this.startColumn+I,A),this}get(B,I){return this.matrix.get(this.startRow+B,this.startColumn+I)}}class Fe extends Xe{constructor(B){super(B,B.columns,B.rows)}set(B,I,A){return this.matrix.set(I,B,A),this}get(B,I){return this.matrix.get(I,B)}}class Ye extends te{constructor(B,I={}){const{rows:A=1}=I;if(B.length%A!==0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=A,this.columns=B.length/A,this.data=B}set(B,I,A){let F=this._calculateIndex(B,I);return this.data[F]=A,this}get(B,I){let A=this._calculateIndex(B,I);return this.data[A]}_calculateIndex(B,I){return B*this.columns+I}}class Ve extends te{constructor(B){super(),this.data=B,this.rows=B.length,this.columns=B[0].length}set(B,I,A){return this.data[B][I]=A,this}get(B,I){return this.data[B][I]}}function Qe(fe,B){if(n.isAnyArray(fe))return fe[0]&&n.isAnyArray(fe[0])?new Ve(fe):new Ye(fe,B);throw new Error("the argument is not an array")}class mt{constructor(B){B=Ve.checkMatrix(B);let I=B.clone(),A=I.rows,F=I.columns,K=new Float64Array(A),Ee=1,k,re,Q,ve,ge,Le,rt,nt,ft;for(k=0;k<A;k++)K[k]=k;for(nt=new Float64Array(A),re=0;re<F;re++){for(k=0;k<A;k++)nt[k]=I.get(k,re);for(k=0;k<A;k++){for(ft=Math.min(k,re),ge=0,Q=0;Q<ft;Q++)ge+=I.get(k,Q)*nt[Q];nt[k]-=ge,I.set(k,re,nt[k])}for(ve=re,k=re+1;k<A;k++)Math.abs(nt[k])>Math.abs(nt[ve])&&(ve=k);if(ve!==re){for(Q=0;Q<F;Q++)Le=I.get(ve,Q),I.set(ve,Q,I.get(re,Q)),I.set(re,Q,Le);rt=K[ve],K[ve]=K[re],K[re]=rt,Ee=-Ee}if(re<A&&I.get(re,re)!==0)for(k=re+1;k<A;k++)I.set(k,re,I.get(k,re)/I.get(re,re))}this.LU=I,this.pivotVector=K,this.pivotSign=Ee}isSingular(){let B=this.LU,I=B.columns;for(let A=0;A<I;A++)if(B.get(A,A)===0)return!0;return!1}solve(B){B=ce.checkMatrix(B);let I=this.LU;if(I.rows!==B.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let F=B.columns,K=B.subMatrixRow(this.pivotVector,0,F-1),Ee=I.columns,k,re,Q;for(Q=0;Q<Ee;Q++)for(k=Q+1;k<Ee;k++)for(re=0;re<F;re++)K.set(k,re,K.get(k,re)-K.get(Q,re)*I.get(k,Q));for(Q=Ee-1;Q>=0;Q--){for(re=0;re<F;re++)K.set(Q,re,K.get(Q,re)/I.get(Q,Q));for(k=0;k<Q;k++)for(re=0;re<F;re++)K.set(k,re,K.get(k,re)-K.get(Q,re)*I.get(k,Q))}return K}get determinant(){let B=this.LU;if(!B.isSquare())throw new Error("Matrix must be square");let I=this.pivotSign,A=B.columns;for(let F=0;F<A;F++)I*=B.get(F,F);return I}get lowerTriangularMatrix(){let B=this.LU,I=B.rows,A=B.columns,F=new ce(I,A);for(let K=0;K<I;K++)for(let Ee=0;Ee<A;Ee++)K>Ee?F.set(K,Ee,B.get(K,Ee)):K===Ee?F.set(K,Ee,1):F.set(K,Ee,0);return F}get upperTriangularMatrix(){let B=this.LU,I=B.rows,A=B.columns,F=new ce(I,A);for(let K=0;K<I;K++)for(let Ee=0;Ee<A;Ee++)K<=Ee?F.set(K,Ee,B.get(K,Ee)):F.set(K,Ee,0);return F}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function Tt(fe,B){let I=0;return Math.abs(fe)>Math.abs(B)?(I=B/fe,Math.abs(fe)*Math.sqrt(1+I*I)):B!==0?(I=fe/B,Math.abs(B)*Math.sqrt(1+I*I)):0}class Me{constructor(B){B=Ve.checkMatrix(B);let I=B.clone(),A=B.rows,F=B.columns,K=new Float64Array(F),Ee,k,re,Q;for(re=0;re<F;re++){let ve=0;for(Ee=re;Ee<A;Ee++)ve=Tt(ve,I.get(Ee,re));if(ve!==0){for(I.get(re,re)<0&&(ve=-ve),Ee=re;Ee<A;Ee++)I.set(Ee,re,I.get(Ee,re)/ve);for(I.set(re,re,I.get(re,re)+1),k=re+1;k<F;k++){for(Q=0,Ee=re;Ee<A;Ee++)Q+=I.get(Ee,re)*I.get(Ee,k);for(Q=-Q/I.get(re,re),Ee=re;Ee<A;Ee++)I.set(Ee,k,I.get(Ee,k)+Q*I.get(Ee,re))}}K[re]=-ve}this.QR=I,this.Rdiag=K}solve(B){B=ce.checkMatrix(B);let I=this.QR,A=I.rows;if(B.rows!==A)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let F=B.columns,K=B.clone(),Ee=I.columns,k,re,Q,ve;for(Q=0;Q<Ee;Q++)for(re=0;re<F;re++){for(ve=0,k=Q;k<A;k++)ve+=I.get(k,Q)*K.get(k,re);for(ve=-ve/I.get(Q,Q),k=Q;k<A;k++)K.set(k,re,K.get(k,re)+ve*I.get(k,Q))}for(Q=Ee-1;Q>=0;Q--){for(re=0;re<F;re++)K.set(Q,re,K.get(Q,re)/this.Rdiag[Q]);for(k=0;k<Q;k++)for(re=0;re<F;re++)K.set(k,re,K.get(k,re)-K.get(Q,re)*I.get(k,Q))}return K.subMatrix(0,Ee-1,0,F-1)}isFullRank(){let B=this.QR.columns;for(let I=0;I<B;I++)if(this.Rdiag[I]===0)return!1;return!0}get upperTriangularMatrix(){let B=this.QR,I=B.columns,A=new ce(I,I),F,K;for(F=0;F<I;F++)for(K=0;K<I;K++)F<K?A.set(F,K,B.get(F,K)):F===K?A.set(F,K,this.Rdiag[F]):A.set(F,K,0);return A}get orthogonalMatrix(){let B=this.QR,I=B.rows,A=B.columns,F=new ce(I,A),K,Ee,k,re;for(k=A-1;k>=0;k--){for(K=0;K<I;K++)F.set(K,k,0);for(F.set(k,k,1),Ee=k;Ee<A;Ee++)if(B.get(k,k)!==0){for(re=0,K=k;K<I;K++)re+=B.get(K,k)*F.get(K,Ee);for(re=-re/B.get(k,k),K=k;K<I;K++)F.set(K,Ee,F.get(K,Ee)+re*B.get(K,k))}}return F}}class me{constructor(B,I={}){if(B=Ve.checkMatrix(B),B.isEmpty())throw new Error("Matrix must be non-empty");let A=B.rows,F=B.columns;const{computeLeftSingularVectors:K=!0,computeRightSingularVectors:Ee=!0,autoTranspose:k=!1}=I;let re=!!K,Q=!!Ee,ve=!1,ge;if(A<F)if(!k)ge=B.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else{ge=B.transpose(),A=ge.rows,F=ge.columns,ve=!0;let we=re;re=Q,Q=we}else ge=B.clone();let Le=Math.min(A,F),rt=Math.min(A+1,F),nt=new Float64Array(rt),ft=new ce(A,Le),yt=new ce(F,F),Ne=new Float64Array(F),Bt=new Float64Array(A),on=new Float64Array(rt);for(let we=0;we<rt;we++)on[we]=we;let xn=Math.min(A-1,F),Bn=Math.max(0,Math.min(F-2,A)),bi=Math.max(xn,Bn);for(let we=0;we<bi;we++){if(we<xn){nt[we]=0;for(let Ge=we;Ge<A;Ge++)nt[we]=Tt(nt[we],ge.get(Ge,we));if(nt[we]!==0){ge.get(we,we)<0&&(nt[we]=-nt[we]);for(let Ge=we;Ge<A;Ge++)ge.set(Ge,we,ge.get(Ge,we)/nt[we]);ge.set(we,we,ge.get(we,we)+1)}nt[we]=-nt[we]}for(let Ge=we+1;Ge<F;Ge++){if(we<xn&&nt[we]!==0){let Je=0;for(let Ue=we;Ue<A;Ue++)Je+=ge.get(Ue,we)*ge.get(Ue,Ge);Je=-Je/ge.get(we,we);for(let Ue=we;Ue<A;Ue++)ge.set(Ue,Ge,ge.get(Ue,Ge)+Je*ge.get(Ue,we))}Ne[Ge]=ge.get(we,Ge)}if(re&&we<xn)for(let Ge=we;Ge<A;Ge++)ft.set(Ge,we,ge.get(Ge,we));if(we<Bn){Ne[we]=0;for(let Ge=we+1;Ge<F;Ge++)Ne[we]=Tt(Ne[we],Ne[Ge]);if(Ne[we]!==0){Ne[we+1]<0&&(Ne[we]=0-Ne[we]);for(let Ge=we+1;Ge<F;Ge++)Ne[Ge]/=Ne[we];Ne[we+1]+=1}if(Ne[we]=-Ne[we],we+1<A&&Ne[we]!==0){for(let Ge=we+1;Ge<A;Ge++)Bt[Ge]=0;for(let Ge=we+1;Ge<A;Ge++)for(let Je=we+1;Je<F;Je++)Bt[Ge]+=Ne[Je]*ge.get(Ge,Je);for(let Ge=we+1;Ge<F;Ge++){let Je=-Ne[Ge]/Ne[we+1];for(let Ue=we+1;Ue<A;Ue++)ge.set(Ue,Ge,ge.get(Ue,Ge)+Je*Bt[Ue])}}if(Q)for(let Ge=we+1;Ge<F;Ge++)yt.set(Ge,we,Ne[Ge])}}let gn=Math.min(F,A+1);if(xn<F&&(nt[xn]=ge.get(xn,xn)),A<gn&&(nt[gn-1]=0),Bn+1<gn&&(Ne[Bn]=ge.get(Bn,gn-1)),Ne[gn-1]=0,re){for(let we=xn;we<Le;we++){for(let Ge=0;Ge<A;Ge++)ft.set(Ge,we,0);ft.set(we,we,1)}for(let we=xn-1;we>=0;we--)if(nt[we]!==0){for(let Ge=we+1;Ge<Le;Ge++){let Je=0;for(let Ue=we;Ue<A;Ue++)Je+=ft.get(Ue,we)*ft.get(Ue,Ge);Je=-Je/ft.get(we,we);for(let Ue=we;Ue<A;Ue++)ft.set(Ue,Ge,ft.get(Ue,Ge)+Je*ft.get(Ue,we))}for(let Ge=we;Ge<A;Ge++)ft.set(Ge,we,-ft.get(Ge,we));ft.set(we,we,1+ft.get(we,we));for(let Ge=0;Ge<we-1;Ge++)ft.set(Ge,we,0)}else{for(let Ge=0;Ge<A;Ge++)ft.set(Ge,we,0);ft.set(we,we,1)}}if(Q)for(let we=F-1;we>=0;we--){if(we<Bn&&Ne[we]!==0)for(let Ge=we+1;Ge<F;Ge++){let Je=0;for(let Ue=we+1;Ue<F;Ue++)Je+=yt.get(Ue,we)*yt.get(Ue,Ge);Je=-Je/yt.get(we+1,we);for(let Ue=we+1;Ue<F;Ue++)yt.set(Ue,Ge,yt.get(Ue,Ge)+Je*yt.get(Ue,we))}for(let Ge=0;Ge<F;Ge++)yt.set(Ge,we,0);yt.set(we,we,1)}let Mn=gn-1,Se=Number.EPSILON;for(;gn>0;){let we,Ge;for(we=gn-2;we>=-1&&we!==-1;we--){const Je=Number.MIN_VALUE+Se*Math.abs(nt[we]+Math.abs(nt[we+1]));if(Math.abs(Ne[we])<=Je||Number.isNaN(Ne[we])){Ne[we]=0;break}}if(we===gn-2)Ge=4;else{let Je;for(Je=gn-1;Je>=we&&Je!==we;Je--){let Ue=(Je!==gn?Math.abs(Ne[Je]):0)+(Je!==we+1?Math.abs(Ne[Je-1]):0);if(Math.abs(nt[Je])<=Se*Ue){nt[Je]=0;break}}Je===we?Ge=3:Je===gn-1?Ge=1:(Ge=2,we=Je)}switch(we++,Ge){case 1:{let Je=Ne[gn-2];Ne[gn-2]=0;for(let Ue=gn-2;Ue>=we;Ue--){let Ot=Tt(nt[Ue],Je),jt=nt[Ue]/Ot,tn=Je/Ot;if(nt[Ue]=Ot,Ue!==we&&(Je=-tn*Ne[Ue-1],Ne[Ue-1]=jt*Ne[Ue-1]),Q)for(let en=0;en<F;en++)Ot=jt*yt.get(en,Ue)+tn*yt.get(en,gn-1),yt.set(en,gn-1,-tn*yt.get(en,Ue)+jt*yt.get(en,gn-1)),yt.set(en,Ue,Ot)}break}case 2:{let Je=Ne[we-1];Ne[we-1]=0;for(let Ue=we;Ue<gn;Ue++){let Ot=Tt(nt[Ue],Je),jt=nt[Ue]/Ot,tn=Je/Ot;if(nt[Ue]=Ot,Je=-tn*Ne[Ue],Ne[Ue]=jt*Ne[Ue],re)for(let en=0;en<A;en++)Ot=jt*ft.get(en,Ue)+tn*ft.get(en,we-1),ft.set(en,we-1,-tn*ft.get(en,Ue)+jt*ft.get(en,we-1)),ft.set(en,Ue,Ot)}break}case 3:{const Je=Math.max(Math.abs(nt[gn-1]),Math.abs(nt[gn-2]),Math.abs(Ne[gn-2]),Math.abs(nt[we]),Math.abs(Ne[we])),Ue=nt[gn-1]/Je,Ot=nt[gn-2]/Je,jt=Ne[gn-2]/Je,tn=nt[we]/Je,en=Ne[we]/Je,dn=((Ot+Ue)*(Ot-Ue)+jt*jt)/2,wn=Ue*jt*(Ue*jt);let _n=0;(dn!==0||wn!==0)&&(dn<0?_n=0-Math.sqrt(dn*dn+wn):_n=Math.sqrt(dn*dn+wn),_n=wn/(dn+_n));let Fn=(tn+Ue)*(tn-Ue)+_n,ti=tn*en;for(let Pn=we;Pn<gn-1;Pn++){let Ln=Tt(Fn,ti);Ln===0&&(Ln=Number.MIN_VALUE);let Ct=Fn/Ln,gt=ti/Ln;if(Pn!==we&&(Ne[Pn-1]=Ln),Fn=Ct*nt[Pn]+gt*Ne[Pn],Ne[Pn]=Ct*Ne[Pn]-gt*nt[Pn],ti=gt*nt[Pn+1],nt[Pn+1]=Ct*nt[Pn+1],Q)for(let Qt=0;Qt<F;Qt++)Ln=Ct*yt.get(Qt,Pn)+gt*yt.get(Qt,Pn+1),yt.set(Qt,Pn+1,-gt*yt.get(Qt,Pn)+Ct*yt.get(Qt,Pn+1)),yt.set(Qt,Pn,Ln);if(Ln=Tt(Fn,ti),Ln===0&&(Ln=Number.MIN_VALUE),Ct=Fn/Ln,gt=ti/Ln,nt[Pn]=Ln,Fn=Ct*Ne[Pn]+gt*nt[Pn+1],nt[Pn+1]=-gt*Ne[Pn]+Ct*nt[Pn+1],ti=gt*Ne[Pn+1],Ne[Pn+1]=Ct*Ne[Pn+1],re&&Pn<A-1)for(let Qt=0;Qt<A;Qt++)Ln=Ct*ft.get(Qt,Pn)+gt*ft.get(Qt,Pn+1),ft.set(Qt,Pn+1,-gt*ft.get(Qt,Pn)+Ct*ft.get(Qt,Pn+1)),ft.set(Qt,Pn,Ln)}Ne[gn-2]=Fn;break}case 4:{if(nt[we]<=0&&(nt[we]=nt[we]<0?-nt[we]:0,Q))for(let Je=0;Je<=Mn;Je++)yt.set(Je,we,-yt.get(Je,we));for(;we<Mn&&!(nt[we]>=nt[we+1]);){let Je=nt[we];if(nt[we]=nt[we+1],nt[we+1]=Je,Q&&we<F-1)for(let Ue=0;Ue<F;Ue++)Je=yt.get(Ue,we+1),yt.set(Ue,we+1,yt.get(Ue,we)),yt.set(Ue,we,Je);if(re&&we<A-1)for(let Ue=0;Ue<A;Ue++)Je=ft.get(Ue,we+1),ft.set(Ue,we+1,ft.get(Ue,we)),ft.set(Ue,we,Je);we++}gn--;break}}}if(ve){let we=yt;yt=ft,ft=we}this.m=A,this.n=F,this.s=nt,this.U=ft,this.V=yt}solve(B){let I=B,A=this.threshold,F=this.s.length,K=ce.zeros(F,F);for(let Le=0;Le<F;Le++)Math.abs(this.s[Le])<=A?K.set(Le,Le,0):K.set(Le,Le,1/this.s[Le]);let Ee=this.U,k=this.rightSingularVectors,re=k.mmul(K),Q=k.rows,ve=Ee.rows,ge=ce.zeros(Q,ve);for(let Le=0;Le<Q;Le++)for(let rt=0;rt<ve;rt++){let nt=0;for(let ft=0;ft<F;ft++)nt+=re.get(Le,ft)*Ee.get(rt,ft);ge.set(Le,rt,nt)}return ge.mmul(I)}solveForDiagonal(B){return this.solve(ce.diag(B))}inverse(){let B=this.V,I=this.threshold,A=B.rows,F=B.columns,K=new ce(A,this.s.length);for(let ve=0;ve<A;ve++)for(let ge=0;ge<F;ge++)Math.abs(this.s[ge])>I&&K.set(ve,ge,B.get(ve,ge)/this.s[ge]);let Ee=this.U,k=Ee.rows,re=Ee.columns,Q=new ce(A,k);for(let ve=0;ve<A;ve++)for(let ge=0;ge<k;ge++){let Le=0;for(let rt=0;rt<re;rt++)Le+=K.get(ve,rt)*Ee.get(ge,rt);Q.set(ve,ge,Le)}return Q}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let B=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,I=0,A=this.s;for(let F=0,K=A.length;F<K;F++)A[F]>B&&I++;return I}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return ce.diag(this.s)}}function $e(fe,B=!1){return fe=Ve.checkMatrix(fe),B?new me(fe).inverse():et(fe,ce.eye(fe.rows))}function et(fe,B,I=!1){return fe=Ve.checkMatrix(fe),B=Ve.checkMatrix(B),I?new me(fe).solve(B):fe.isSquare()?new mt(fe).solve(B):new Me(fe).solve(B)}function ht(fe){if(fe=ce.checkMatrix(fe),fe.isSquare()){if(fe.columns===0)return 1;let B,I,A,F;if(fe.columns===2)return B=fe.get(0,0),I=fe.get(0,1),A=fe.get(1,0),F=fe.get(1,1),B*F-I*A;if(fe.columns===3){let K,Ee,k;return K=new ze(fe,[1,2],[1,2]),Ee=new ze(fe,[1,2],[0,2]),k=new ze(fe,[1,2],[0,1]),B=fe.get(0,0),I=fe.get(0,1),A=fe.get(0,2),B*ht(K)-I*ht(Ee)+A*ht(k)}else return new mt(fe).determinant}else throw Error("determinant can only be calculated for a square matrix")}function at(fe,B){let I=[];for(let A=0;A<fe;A++)A!==B&&I.push(A);return I}function Et(fe,B,I,A=1e-9,F=1e-9){if(fe>F)return new Array(B.rows+1).fill(0);{let K=B.addRow(I,[0]);for(let Ee=0;Ee<K.rows;Ee++)Math.abs(K.get(Ee,0))<A&&K.set(Ee,0,0);return K.to1DArray()}}function Dt(fe,B={}){const{thresholdValue:I=1e-9,thresholdError:A=1e-9}=B;fe=ce.checkMatrix(fe);let F=fe.rows,K=new ce(F,F);for(let Ee=0;Ee<F;Ee++){let k=ce.columnVector(fe.getRow(Ee)),re=fe.subMatrixRow(at(F,Ee)).transpose(),ve=new me(re).solve(k),ge=ce.sub(k,re.mmul(ve)).abs().max();K.setRow(Ee,Et(ge,ve,Ee,I,A))}return K}function Vt(fe,B=Number.EPSILON){if(fe=ce.checkMatrix(fe),fe.isEmpty())return fe.transpose();let I=new me(fe,{autoTranspose:!0}),A=I.leftSingularVectors,F=I.rightSingularVectors,K=I.diagonal;for(let Ee=0;Ee<K.length;Ee++)Math.abs(K[Ee])>B?K[Ee]=1/K[Ee]:K[Ee]=0;return F.mmul(ce.diag(K).mmul(A.transpose()))}function an(fe,B=fe,I={}){fe=new ce(fe);let A=!1;if(typeof B=="object"&&!ce.isMatrix(B)&&!n.isAnyArray(B)?(I=B,B=fe,A=!0):B=new ce(B),fe.rows!==B.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:F=!0}=I;F&&(fe=fe.center("column"),A||(B=B.center("column")));const K=fe.transpose().mmul(B);for(let Ee=0;Ee<K.rows;Ee++)for(let k=0;k<K.columns;k++)K.set(Ee,k,K.get(Ee,k)*(1/(fe.rows-1)));return K}function bt(fe,B=fe,I={}){fe=new ce(fe);let A=!1;if(typeof B=="object"&&!ce.isMatrix(B)&&!n.isAnyArray(B)?(I=B,B=fe,A=!0):B=new ce(B),fe.rows!==B.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:F=!0,scale:K=!0}=I;F&&(fe.center("column"),A||B.center("column")),K&&(fe.scale("column"),A||B.scale("column"));const Ee=fe.standardDeviation("column",{unbiased:!0}),k=A?Ee:B.standardDeviation("column",{unbiased:!0}),re=fe.transpose().mmul(B);for(let Q=0;Q<re.rows;Q++)for(let ve=0;ve<re.columns;ve++)re.set(Q,ve,re.get(Q,ve)*(1/(Ee[Q]*k[ve]))*(1/(fe.rows-1)));return re}class Jt{constructor(B,I={}){const{assumeSymmetric:A=!1}=I;if(B=Ve.checkMatrix(B),!B.isSquare())throw new Error("Matrix is not a square matrix");if(B.isEmpty())throw new Error("Matrix must be non-empty");let F=B.columns,K=new ce(F,F),Ee=new Float64Array(F),k=new Float64Array(F),re=B,Q,ve,ge=!1;if(A?ge=!0:ge=B.isSymmetric(),ge){for(Q=0;Q<F;Q++)for(ve=0;ve<F;ve++)K.set(Q,ve,re.get(Q,ve));Tn(F,k,Ee,K),We(F,k,Ee,K)}else{let Le=new ce(F,F),rt=new Float64Array(F);for(ve=0;ve<F;ve++)for(Q=0;Q<F;Q++)Le.set(Q,ve,re.get(Q,ve));vt(F,Le,rt,K),Yt(F,k,Ee,K,Le)}this.n=F,this.e=k,this.d=Ee,this.V=K}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let B=this.n,I=this.e,A=this.d,F=new ce(B,B),K,Ee;for(K=0;K<B;K++){for(Ee=0;Ee<B;Ee++)F.set(K,Ee,0);F.set(K,K,A[K]),I[K]>0?F.set(K,K+1,I[K]):I[K]<0&&F.set(K,K-1,I[K])}return F}}function Tn(fe,B,I,A){let F,K,Ee,k,re,Q,ve,ge;for(re=0;re<fe;re++)I[re]=A.get(fe-1,re);for(k=fe-1;k>0;k--){for(ge=0,Ee=0,Q=0;Q<k;Q++)ge=ge+Math.abs(I[Q]);if(ge===0)for(B[k]=I[k-1],re=0;re<k;re++)I[re]=A.get(k-1,re),A.set(k,re,0),A.set(re,k,0);else{for(Q=0;Q<k;Q++)I[Q]/=ge,Ee+=I[Q]*I[Q];for(F=I[k-1],K=Math.sqrt(Ee),F>0&&(K=-K),B[k]=ge*K,Ee=Ee-F*K,I[k-1]=F-K,re=0;re<k;re++)B[re]=0;for(re=0;re<k;re++){for(F=I[re],A.set(re,k,F),K=B[re]+A.get(re,re)*F,Q=re+1;Q<=k-1;Q++)K+=A.get(Q,re)*I[Q],B[Q]+=A.get(Q,re)*F;B[re]=K}for(F=0,re=0;re<k;re++)B[re]/=Ee,F+=B[re]*I[re];for(ve=F/(Ee+Ee),re=0;re<k;re++)B[re]-=ve*I[re];for(re=0;re<k;re++){for(F=I[re],K=B[re],Q=re;Q<=k-1;Q++)A.set(Q,re,A.get(Q,re)-(F*B[Q]+K*I[Q]));I[re]=A.get(k-1,re),A.set(k,re,0)}}I[k]=Ee}for(k=0;k<fe-1;k++){if(A.set(fe-1,k,A.get(k,k)),A.set(k,k,1),Ee=I[k+1],Ee!==0){for(Q=0;Q<=k;Q++)I[Q]=A.get(Q,k+1)/Ee;for(re=0;re<=k;re++){for(K=0,Q=0;Q<=k;Q++)K+=A.get(Q,k+1)*A.get(Q,re);for(Q=0;Q<=k;Q++)A.set(Q,re,A.get(Q,re)-K*I[Q])}}for(Q=0;Q<=k;Q++)A.set(Q,k+1,0)}for(re=0;re<fe;re++)I[re]=A.get(fe-1,re),A.set(fe-1,re,0);A.set(fe-1,fe-1,1),B[0]=0}function We(fe,B,I,A){let F,K,Ee,k,re,Q,ve,ge,Le,rt,nt,ft,yt,Ne,Bt,on;for(Ee=1;Ee<fe;Ee++)B[Ee-1]=B[Ee];B[fe-1]=0;let xn=0,Bn=0,bi=Number.EPSILON;for(Q=0;Q<fe;Q++){for(Bn=Math.max(Bn,Math.abs(I[Q])+Math.abs(B[Q])),ve=Q;ve<fe&&!(Math.abs(B[ve])<=bi*Bn);)ve++;if(ve>Q)do{for(F=I[Q],ge=(I[Q+1]-F)/(2*B[Q]),Le=Tt(ge,1),ge<0&&(Le=-Le),I[Q]=B[Q]/(ge+Le),I[Q+1]=B[Q]*(ge+Le),rt=I[Q+1],K=F-I[Q],Ee=Q+2;Ee<fe;Ee++)I[Ee]-=K;for(xn=xn+K,ge=I[ve],nt=1,ft=nt,yt=nt,Ne=B[Q+1],Bt=0,on=0,Ee=ve-1;Ee>=Q;Ee--)for(yt=ft,ft=nt,on=Bt,F=nt*B[Ee],K=nt*ge,Le=Tt(ge,B[Ee]),B[Ee+1]=Bt*Le,Bt=B[Ee]/Le,nt=ge/Le,ge=nt*I[Ee]-Bt*F,I[Ee+1]=K+Bt*(nt*F+Bt*I[Ee]),re=0;re<fe;re++)K=A.get(re,Ee+1),A.set(re,Ee+1,Bt*A.get(re,Ee)+nt*K),A.set(re,Ee,nt*A.get(re,Ee)-Bt*K);ge=-Bt*on*yt*Ne*B[Q]/rt,B[Q]=Bt*ge,I[Q]=nt*ge}while(Math.abs(B[Q])>bi*Bn);I[Q]=I[Q]+xn,B[Q]=0}for(Ee=0;Ee<fe-1;Ee++){for(re=Ee,ge=I[Ee],k=Ee+1;k<fe;k++)I[k]<ge&&(re=k,ge=I[k]);if(re!==Ee)for(I[re]=I[Ee],I[Ee]=ge,k=0;k<fe;k++)ge=A.get(k,Ee),A.set(k,Ee,A.get(k,re)),A.set(k,re,ge)}}function vt(fe,B,I,A){let F=0,K=fe-1,Ee,k,re,Q,ve,ge,Le;for(ge=F+1;ge<=K-1;ge++){for(Le=0,Q=ge;Q<=K;Q++)Le=Le+Math.abs(B.get(Q,ge-1));if(Le!==0){for(re=0,Q=K;Q>=ge;Q--)I[Q]=B.get(Q,ge-1)/Le,re+=I[Q]*I[Q];for(k=Math.sqrt(re),I[ge]>0&&(k=-k),re=re-I[ge]*k,I[ge]=I[ge]-k,ve=ge;ve<fe;ve++){for(Ee=0,Q=K;Q>=ge;Q--)Ee+=I[Q]*B.get(Q,ve);for(Ee=Ee/re,Q=ge;Q<=K;Q++)B.set(Q,ve,B.get(Q,ve)-Ee*I[Q])}for(Q=0;Q<=K;Q++){for(Ee=0,ve=K;ve>=ge;ve--)Ee+=I[ve]*B.get(Q,ve);for(Ee=Ee/re,ve=ge;ve<=K;ve++)B.set(Q,ve,B.get(Q,ve)-Ee*I[ve])}I[ge]=Le*I[ge],B.set(ge,ge-1,Le*k)}}for(Q=0;Q<fe;Q++)for(ve=0;ve<fe;ve++)A.set(Q,ve,Q===ve?1:0);for(ge=K-1;ge>=F+1;ge--)if(B.get(ge,ge-1)!==0){for(Q=ge+1;Q<=K;Q++)I[Q]=B.get(Q,ge-1);for(ve=ge;ve<=K;ve++){for(k=0,Q=ge;Q<=K;Q++)k+=I[Q]*A.get(Q,ve);for(k=k/I[ge]/B.get(ge,ge-1),Q=ge;Q<=K;Q++)A.set(Q,ve,A.get(Q,ve)+k*I[Q])}}}function Yt(fe,B,I,A,F){let K=fe-1,Ee=0,k=fe-1,re=Number.EPSILON,Q=0,ve=0,ge=0,Le=0,rt=0,nt=0,ft=0,yt=0,Ne,Bt,on,xn,Bn,bi,gn,Mn,Se,we,Ge,Je,Ue,Ot,jt;for(Ne=0;Ne<fe;Ne++)for((Ne<Ee||Ne>k)&&(I[Ne]=F.get(Ne,Ne),B[Ne]=0),Bt=Math.max(Ne-1,0);Bt<fe;Bt++)ve=ve+Math.abs(F.get(Ne,Bt));for(;K>=Ee;){for(xn=K;xn>Ee&&(nt=Math.abs(F.get(xn-1,xn-1))+Math.abs(F.get(xn,xn)),nt===0&&(nt=ve),!(Math.abs(F.get(xn,xn-1))<re*nt));)xn--;if(xn===K)F.set(K,K,F.get(K,K)+Q),I[K]=F.get(K,K),B[K]=0,K--,yt=0;else if(xn===K-1){if(gn=F.get(K,K-1)*F.get(K-1,K),ge=(F.get(K-1,K-1)-F.get(K,K))/2,Le=ge*ge+gn,ft=Math.sqrt(Math.abs(Le)),F.set(K,K,F.get(K,K)+Q),F.set(K-1,K-1,F.get(K-1,K-1)+Q),Mn=F.get(K,K),Le>=0){for(ft=ge>=0?ge+ft:ge-ft,I[K-1]=Mn+ft,I[K]=I[K-1],ft!==0&&(I[K]=Mn-gn/ft),B[K-1]=0,B[K]=0,Mn=F.get(K,K-1),nt=Math.abs(Mn)+Math.abs(ft),ge=Mn/nt,Le=ft/nt,rt=Math.sqrt(ge*ge+Le*Le),ge=ge/rt,Le=Le/rt,Bt=K-1;Bt<fe;Bt++)ft=F.get(K-1,Bt),F.set(K-1,Bt,Le*ft+ge*F.get(K,Bt)),F.set(K,Bt,Le*F.get(K,Bt)-ge*ft);for(Ne=0;Ne<=K;Ne++)ft=F.get(Ne,K-1),F.set(Ne,K-1,Le*ft+ge*F.get(Ne,K)),F.set(Ne,K,Le*F.get(Ne,K)-ge*ft);for(Ne=Ee;Ne<=k;Ne++)ft=A.get(Ne,K-1),A.set(Ne,K-1,Le*ft+ge*A.get(Ne,K)),A.set(Ne,K,Le*A.get(Ne,K)-ge*ft)}else I[K-1]=Mn+ge,I[K]=Mn+ge,B[K-1]=ft,B[K]=-ft;K=K-2,yt=0}else{if(Mn=F.get(K,K),Se=0,gn=0,xn<K&&(Se=F.get(K-1,K-1),gn=F.get(K,K-1)*F.get(K-1,K)),yt===10){for(Q+=Mn,Ne=Ee;Ne<=K;Ne++)F.set(Ne,Ne,F.get(Ne,Ne)-Mn);nt=Math.abs(F.get(K,K-1))+Math.abs(F.get(K-1,K-2)),Mn=Se=.75*nt,gn=-.4375*nt*nt}if(yt===30&&(nt=(Se-Mn)/2,nt=nt*nt+gn,nt>0)){for(nt=Math.sqrt(nt),Se<Mn&&(nt=-nt),nt=Mn-gn/((Se-Mn)/2+nt),Ne=Ee;Ne<=K;Ne++)F.set(Ne,Ne,F.get(Ne,Ne)-nt);Q+=nt,Mn=Se=gn=.964}for(yt=yt+1,Bn=K-2;Bn>=xn&&(ft=F.get(Bn,Bn),rt=Mn-ft,nt=Se-ft,ge=(rt*nt-gn)/F.get(Bn+1,Bn)+F.get(Bn,Bn+1),Le=F.get(Bn+1,Bn+1)-ft-rt-nt,rt=F.get(Bn+2,Bn+1),nt=Math.abs(ge)+Math.abs(Le)+Math.abs(rt),ge=ge/nt,Le=Le/nt,rt=rt/nt,!(Bn===xn||Math.abs(F.get(Bn,Bn-1))*(Math.abs(Le)+Math.abs(rt))<re*(Math.abs(ge)*(Math.abs(F.get(Bn-1,Bn-1))+Math.abs(ft)+Math.abs(F.get(Bn+1,Bn+1))))));)Bn--;for(Ne=Bn+2;Ne<=K;Ne++)F.set(Ne,Ne-2,0),Ne>Bn+2&&F.set(Ne,Ne-3,0);for(on=Bn;on<=K-1&&(Ot=on!==K-1,on!==Bn&&(ge=F.get(on,on-1),Le=F.get(on+1,on-1),rt=Ot?F.get(on+2,on-1):0,Mn=Math.abs(ge)+Math.abs(Le)+Math.abs(rt),Mn!==0&&(ge=ge/Mn,Le=Le/Mn,rt=rt/Mn)),Mn!==0);on++)if(nt=Math.sqrt(ge*ge+Le*Le+rt*rt),ge<0&&(nt=-nt),nt!==0){for(on!==Bn?F.set(on,on-1,-nt*Mn):xn!==Bn&&F.set(on,on-1,-F.get(on,on-1)),ge=ge+nt,Mn=ge/nt,Se=Le/nt,ft=rt/nt,Le=Le/ge,rt=rt/ge,Bt=on;Bt<fe;Bt++)ge=F.get(on,Bt)+Le*F.get(on+1,Bt),Ot&&(ge=ge+rt*F.get(on+2,Bt),F.set(on+2,Bt,F.get(on+2,Bt)-ge*ft)),F.set(on,Bt,F.get(on,Bt)-ge*Mn),F.set(on+1,Bt,F.get(on+1,Bt)-ge*Se);for(Ne=0;Ne<=Math.min(K,on+3);Ne++)ge=Mn*F.get(Ne,on)+Se*F.get(Ne,on+1),Ot&&(ge=ge+ft*F.get(Ne,on+2),F.set(Ne,on+2,F.get(Ne,on+2)-ge*rt)),F.set(Ne,on,F.get(Ne,on)-ge),F.set(Ne,on+1,F.get(Ne,on+1)-ge*Le);for(Ne=Ee;Ne<=k;Ne++)ge=Mn*A.get(Ne,on)+Se*A.get(Ne,on+1),Ot&&(ge=ge+ft*A.get(Ne,on+2),A.set(Ne,on+2,A.get(Ne,on+2)-ge*rt)),A.set(Ne,on,A.get(Ne,on)-ge),A.set(Ne,on+1,A.get(Ne,on+1)-ge*Le)}}}if(ve!==0){for(K=fe-1;K>=0;K--)if(ge=I[K],Le=B[K],Le===0)for(xn=K,F.set(K,K,1),Ne=K-1;Ne>=0;Ne--){for(gn=F.get(Ne,Ne)-ge,rt=0,Bt=xn;Bt<=K;Bt++)rt=rt+F.get(Ne,Bt)*F.get(Bt,K);if(B[Ne]<0)ft=gn,nt=rt;else if(xn=Ne,B[Ne]===0?F.set(Ne,K,gn!==0?-rt/gn:-rt/(re*ve)):(Mn=F.get(Ne,Ne+1),Se=F.get(Ne+1,Ne),Le=(I[Ne]-ge)*(I[Ne]-ge)+B[Ne]*B[Ne],bi=(Mn*nt-ft*rt)/Le,F.set(Ne,K,bi),F.set(Ne+1,K,Math.abs(Mn)>Math.abs(ft)?(-rt-gn*bi)/Mn:(-nt-Se*bi)/ft)),bi=Math.abs(F.get(Ne,K)),re*bi*bi>1)for(Bt=Ne;Bt<=K;Bt++)F.set(Bt,K,F.get(Bt,K)/bi)}else if(Le<0)for(xn=K-1,Math.abs(F.get(K,K-1))>Math.abs(F.get(K-1,K))?(F.set(K-1,K-1,Le/F.get(K,K-1)),F.set(K-1,K,-(F.get(K,K)-ge)/F.get(K,K-1))):(jt=qe(0,-F.get(K-1,K),F.get(K-1,K-1)-ge,Le),F.set(K-1,K-1,jt[0]),F.set(K-1,K,jt[1])),F.set(K,K-1,0),F.set(K,K,1),Ne=K-2;Ne>=0;Ne--){for(we=0,Ge=0,Bt=xn;Bt<=K;Bt++)we=we+F.get(Ne,Bt)*F.get(Bt,K-1),Ge=Ge+F.get(Ne,Bt)*F.get(Bt,K);if(gn=F.get(Ne,Ne)-ge,B[Ne]<0)ft=gn,rt=we,nt=Ge;else if(xn=Ne,B[Ne]===0?(jt=qe(-we,-Ge,gn,Le),F.set(Ne,K-1,jt[0]),F.set(Ne,K,jt[1])):(Mn=F.get(Ne,Ne+1),Se=F.get(Ne+1,Ne),Je=(I[Ne]-ge)*(I[Ne]-ge)+B[Ne]*B[Ne]-Le*Le,Ue=(I[Ne]-ge)*2*Le,Je===0&&Ue===0&&(Je=re*ve*(Math.abs(gn)+Math.abs(Le)+Math.abs(Mn)+Math.abs(Se)+Math.abs(ft))),jt=qe(Mn*rt-ft*we+Le*Ge,Mn*nt-ft*Ge-Le*we,Je,Ue),F.set(Ne,K-1,jt[0]),F.set(Ne,K,jt[1]),Math.abs(Mn)>Math.abs(ft)+Math.abs(Le)?(F.set(Ne+1,K-1,(-we-gn*F.get(Ne,K-1)+Le*F.get(Ne,K))/Mn),F.set(Ne+1,K,(-Ge-gn*F.get(Ne,K)-Le*F.get(Ne,K-1))/Mn)):(jt=qe(-rt-Se*F.get(Ne,K-1),-nt-Se*F.get(Ne,K),ft,Le),F.set(Ne+1,K-1,jt[0]),F.set(Ne+1,K,jt[1]))),bi=Math.max(Math.abs(F.get(Ne,K-1)),Math.abs(F.get(Ne,K))),re*bi*bi>1)for(Bt=Ne;Bt<=K;Bt++)F.set(Bt,K-1,F.get(Bt,K-1)/bi),F.set(Bt,K,F.get(Bt,K)/bi)}for(Ne=0;Ne<fe;Ne++)if(Ne<Ee||Ne>k)for(Bt=Ne;Bt<fe;Bt++)A.set(Ne,Bt,F.get(Ne,Bt));for(Bt=fe-1;Bt>=Ee;Bt--)for(Ne=Ee;Ne<=k;Ne++){for(ft=0,on=Ee;on<=Math.min(Bt,k);on++)ft=ft+A.get(Ne,on)*F.get(on,Bt);A.set(Ne,Bt,ft)}}}function qe(fe,B,I,A){let F,K;return Math.abs(I)>Math.abs(A)?(F=A/I,K=I+F*A,[(fe+F*B)/K,(B-F*fe)/K]):(F=I/A,K=A+F*I,[(F*fe+B)/K,(F*B-fe)/K])}class Kt{constructor(B){if(B=Ve.checkMatrix(B),!B.isSymmetric())throw new Error("Matrix is not symmetric");let I=B,A=I.rows,F=new ce(A,A),K=!0,Ee,k,re;for(k=0;k<A;k++){let Q=0;for(re=0;re<k;re++){let ve=0;for(Ee=0;Ee<re;Ee++)ve+=F.get(re,Ee)*F.get(k,Ee);ve=(I.get(k,re)-ve)/F.get(re,re),F.set(k,re,ve),Q=Q+ve*ve}for(Q=I.get(k,k)-Q,K&&=Q>0,F.set(k,k,Math.sqrt(Math.max(Q,0))),re=k+1;re<A;re++)F.set(k,re,0)}this.L=F,this.positiveDefinite=K}isPositiveDefinite(){return this.positiveDefinite}solve(B){B=Ve.checkMatrix(B);let I=this.L,A=I.rows;if(B.rows!==A)throw new Error("Matrix dimensions do not match");if(this.isPositiveDefinite()===!1)throw new Error("Matrix is not positive definite");let F=B.columns,K=B.clone(),Ee,k,re;for(re=0;re<A;re++)for(k=0;k<F;k++){for(Ee=0;Ee<re;Ee++)K.set(re,k,K.get(re,k)-K.get(Ee,k)*I.get(re,Ee));K.set(re,k,K.get(re,k)/I.get(re,re))}for(re=A-1;re>=0;re--)for(k=0;k<F;k++){for(Ee=re+1;Ee<A;Ee++)K.set(re,k,K.get(re,k)-K.get(Ee,k)*I.get(Ee,re));K.set(re,k,K.get(re,k)/I.get(re,re))}return K}get lowerTriangularMatrix(){return this.L}}class rn{constructor(B,I={}){B=Ve.checkMatrix(B);let{Y:A}=I;const{scaleScores:F=!1,maxIterations:K=1e3,terminationCriteria:Ee=1e-10}=I;let k;if(A){if(n.isAnyArray(A)&&typeof A[0]=="number"?A=ce.columnVector(A):A=Ve.checkMatrix(A),A.rows!==B.rows)throw new Error("Y should have the same number of rows as X");k=A.getColumnVector(0)}else k=B.getColumnVector(0);let re=1,Q,ve,ge,Le;for(let rt=0;rt<K&&re>Ee;rt++)ge=B.transpose().mmul(k).div(k.transpose().mmul(k).get(0,0)),ge=ge.div(ge.norm()),Q=B.mmul(ge).div(ge.transpose().mmul(ge).get(0,0)),rt>0&&(re=Q.clone().sub(Le).pow(2).sum()),Le=Q.clone(),A?(ve=A.transpose().mmul(Q).div(Q.transpose().mmul(Q).get(0,0)),ve=ve.div(ve.norm()),k=A.mmul(ve).div(ve.transpose().mmul(ve).get(0,0))):k=Q;if(A){let rt=B.transpose().mmul(Q).div(Q.transpose().mmul(Q).get(0,0));rt=rt.div(rt.norm());let nt=B.clone().sub(Q.clone().mmul(rt.transpose())),ft=k.transpose().mmul(Q).div(Q.transpose().mmul(Q).get(0,0)),yt=A.clone().sub(Q.clone().mulS(ft.get(0,0)).mmul(ve.transpose()));this.t=Q,this.p=rt.transpose(),this.w=ge.transpose(),this.q=ve,this.u=k,this.s=Q.transpose().mmul(Q),this.xResidual=nt,this.yResidual=yt,this.betas=ft}else this.w=ge.transpose(),this.s=Q.transpose().mmul(Q).sqrt(),F?this.t=Q.clone().div(this.s.get(0,0)):this.t=Q,this.xResidual=B.sub(Q.mmul(ge.transpose()))}}return ji.AbstractMatrix=te,ji.CHO=Kt,ji.CholeskyDecomposition=Kt,ji.DistanceMatrix=He,ji.EVD=Jt,ji.EigenvalueDecomposition=Jt,ji.LU=mt,ji.LuDecomposition=mt,ji.Matrix=ce,ji.MatrixColumnSelectionView=tt,ji.MatrixColumnView=ot,ji.MatrixFlipColumnView=Ae,ji.MatrixFlipRowView=ye,ji.MatrixRowSelectionView=ke,ji.MatrixRowView=xe,ji.MatrixSelectionView=ze,ji.MatrixSubView=je,ji.MatrixTransposeView=Fe,ji.NIPALS=rn,ji.Nipals=rn,ji.QR=Me,ji.QrDecomposition=Me,ji.SVD=me,ji.SingularValueDecomposition=me,ji.SymmetricMatrix=Be,ji.WrapperMatrix1D=Ye,ji.WrapperMatrix2D=Ve,ji.correlation=bt,ji.covariance=an,ji.default=ce,ji.determinant=ht,ji.inverse=$e,ji.linearDependencies=Dt,ji.pseudoInverse=Vt,ji.solve=et,ji.wrap=Qe,ji}var Rx=C9();const N2=Wb(Rx),zb=Rx.Matrix;N2.Matrix?N2.Matrix:Rx.Matrix;const P9=Rx.inverse;function R9(n,e,t,i,s){const r=t.length,o=n.x.length;let l=new Array(r);for(let c=0;c<r;c++){l[c]=new Array(o);let d=t.slice();d[c]+=i;let g=s(d);for(let p=0;p<o;p++)l[c][p]=e[p]-g(n.x[p])}return new zb(l)}function D9(n,e){const t=n.x.length;let i=new Array(t);for(let s=0;s<t;s++)i[s]=[n.y[s]-e[s]];return new zb(i)}function B9(n,e,t,i,s){let r=t*i*i,o=zb.eye(e.length,e.length,r);const l=s(e);let c=new Float64Array(n.x.length);for(let h=0;h<n.x.length;h++)c[h]=l(n.x[h]);let d=R9(n,c,e,i,s),g=D9(n,c),p=P9(o.add(d.mmul(d.transpose())));return e=new zb([e]),e=e.sub(p.mmul(d).mmul(g).mul(i).transpose()),e.to1DArray()}function I9(n,e,t={}){let{maxIterations:i=100,gradientDifference:s=.1,damping:r=0,errorTolerance:o=.01,minValues:l,maxValues:c,initialValues:d}=t;if(r<=0)throw new Error("The damping option must be a positive number");if(!n.x||!n.y)throw new Error("The data parameter must have x and y elements");if(!m1(n.x)||n.x.length<2||!m1(n.y)||n.y.length<2)throw new Error("The data parameter elements must be an array with more than 2 points");if(n.x.length!==n.y.length)throw new Error("The data parameter elements must have the same size");let g=d||new Array(e.length).fill(1),p=g.length;if(c=c||new Array(p).fill(Number.MAX_SAFE_INTEGER),l=l||new Array(p).fill(Number.MIN_SAFE_INTEGER),c.length!==l.length)throw new Error("minValues and maxValues must be the same size");if(!m1(g))throw new Error("initialValues must be an array");let h=O2(n,g,e),v=h<=o,y;for(y=0;y<i&&!v;y++){g=B9(n,g,r,s,e);for(let w=0;w<p;w++)g[w]=Math.min(Math.max(l[w],g[w]),c[w]);if(h=O2(n,g,e),isNaN(h))break;v=h<=o}return{parameterValues:g,parameterError:h,iterations:y}}const O9=Object.freeze(Object.defineProperty({__proto__:null,default:I9},Symbol.toStringTag,{value:"Module"})),L9=cT(O9);var z2;function F9(){if(z2)return ws;z2=1;var n=ws&&ws.__createBinding||(Object.create?(function(N,j,J,W){W===void 0&&(W=J),Object.defineProperty(N,W,{enumerable:!0,get:function(){return j[J]}})}):(function(N,j,J,W){W===void 0&&(W=J),N[W]=j[J]})),e=ws&&ws.__setModuleDefault||(Object.create?(function(N,j){Object.defineProperty(N,"default",{enumerable:!0,value:j})}):function(N,j){N.default=j}),t=ws&&ws.__importStar||function(N){if(N&&N.__esModule)return N;var j={};if(N!=null)for(var J in N)J!=="default"&&Object.hasOwnProperty.call(N,J)&&n(j,N,J);return e(j,N),j},i=ws&&ws.__awaiter||function(N,j,J,W){function oe(ne){return ne instanceof J?ne:new J(function(q){q(ne)})}return new(J||(J=Promise))(function(ne,q){function le(be){try{pe(W.next(be))}catch(ee){q(ee)}}function se(be){try{pe(W.throw(be))}catch(ee){q(ee)}}function pe(be){be.done?ne(be.value):oe(be.value).then(le,se)}pe((W=W.apply(N,j||[])).next())})},s=ws&&ws.__generator||function(N,j){var J={label:0,sent:function(){if(ne[0]&1)throw ne[1];return ne[1]},trys:[],ops:[]},W,oe,ne,q;return q={next:le(0),throw:le(1),return:le(2)},typeof Symbol=="function"&&(q[Symbol.iterator]=function(){return this}),q;function le(pe){return function(be){return se([pe,be])}}function se(pe){if(W)throw new TypeError("Generator is already executing.");for(;J;)try{if(W=1,oe&&(ne=pe[0]&2?oe.return:pe[0]?oe.throw||((ne=oe.return)&&ne.call(oe),0):oe.next)&&!(ne=ne.call(oe,pe[1])).done)return ne;switch(oe=0,ne&&(pe=[pe[0]&2,ne.value]),pe[0]){case 0:case 1:ne=pe;break;case 4:return J.label++,{value:pe[1],done:!1};case 5:J.label++,oe=pe[1],pe=[0];continue;case 7:pe=J.ops.pop(),J.trys.pop();continue;default:if(ne=J.trys,!(ne=ne.length>0&&ne[ne.length-1])&&(pe[0]===6||pe[0]===2)){J=0;continue}if(pe[0]===3&&(!ne||pe[1]>ne[0]&&pe[1]<ne[3])){J.label=pe[1];break}if(pe[0]===6&&J.label<ne[1]){J.label=ne[1],ne=pe;break}if(ne&&J.label<ne[2]){J.label=ne[2],J.ops.push(pe);break}ne[2]&&J.ops.pop(),J.trys.pop();continue}pe=j.call(N,J)}catch(be){pe=[6,be],oe=0}finally{W=ne=0}if(pe[0]&5)throw pe[1];return{value:pe[0]?pe[1]:void 0,done:!0}}},r=ws&&ws.__read||function(N,j){var J=typeof Symbol=="function"&&N[Symbol.iterator];if(!J)return N;var W=J.call(N),oe,ne=[],q;try{for(;(j===void 0||j-- >0)&&!(oe=W.next()).done;)ne.push(oe.value)}catch(le){q={error:le}}finally{try{oe&&!oe.done&&(J=W.return)&&J.call(W)}finally{if(q)throw q.error}}return ne},o=ws&&ws.__spread||function(){for(var N=[],j=0;j<arguments.length;j++)N=N.concat(r(arguments[j]));return N},l=ws&&ws.__importDefault||function(N){return N&&N.__esModule?N:{default:N}};Object.defineProperty(ws,"__esModule",{value:!0}),ws.initTransform=ws.resetLocalConnectivity=ws.fastIntersection=ws.findABParams=ws.cosine=ws.euclidean=ws.UMAP=void 0;var c=t(ZO()),d=t(e3()),g=t(f9()),p=t(t3()),h=t(iy()),v=l(L9),y=1e-5,w=.001,S=(function(){function N(j){var J=this;j===void 0&&(j={}),this.learningRate=1,this.localConnectivity=1,this.minDist=.1,this.nComponents=2,this.nEpochs=0,this.nNeighbors=15,this.negativeSampleRate=5,this.random=Math.random,this.repulsionStrength=1,this.setOpMixRatio=1,this.spread=1,this.transformQueueSize=4,this.targetMetric="categorical",this.targetWeight=.5,this.targetNNeighbors=this.nNeighbors,this.distanceFn=M,this.isInitialized=!1,this.rpForest=[],this.embedding=[],this.optimizationState=new C;var W=function(oe){j[oe]!==void 0&&(J[oe]=j[oe])};W("distanceFn"),W("learningRate"),W("localConnectivity"),W("minDist"),W("nComponents"),W("nEpochs"),W("nNeighbors"),W("negativeSampleRate"),W("random"),W("repulsionStrength"),W("setOpMixRatio"),W("spread"),W("transformQueueSize")}return N.prototype.fit=function(j){return this.initializeFit(j),this.optimizeLayout(),this.embedding},N.prototype.fitAsync=function(j,J){return J===void 0&&(J=function(){return!0}),i(this,void 0,void 0,function(){return s(this,function(W){switch(W.label){case 0:return this.initializeFit(j),[4,this.optimizeLayoutAsync(J)];case 1:return W.sent(),[2,this.embedding]}})})},N.prototype.setSupervisedProjection=function(j,J){J===void 0&&(J={}),this.Y=j,this.targetMetric=J.targetMetric||this.targetMetric,this.targetWeight=J.targetWeight||this.targetWeight,this.targetNNeighbors=J.targetNNeighbors||this.targetNNeighbors},N.prototype.setPrecomputedKNN=function(j,J){this.knnIndices=j,this.knnDistances=J},N.prototype.initializeFit=function(j){if(j.length<=this.nNeighbors)throw new Error("Not enough data points ("+j.length+") to create nNeighbors: "+this.nNeighbors+".  Add more data points or adjust the configuration.");if(this.X===j&&this.isInitialized)return this.getNEpochs();if(this.X=j,!this.knnIndices&&!this.knnDistances){var J=this.nearestNeighbors(j);this.knnIndices=J.knnIndices,this.knnDistances=J.knnDistances}this.graph=this.fuzzySimplicialSet(j,this.nNeighbors,this.setOpMixRatio),this.makeSearchFns(),this.searchGraph=this.makeSearchGraph(j),this.processGraphForSupervisedProjection();var W=this.initializeSimplicialSetEmbedding(),oe=W.head,ne=W.tail,q=W.epochsPerSample;return this.optimizationState.head=oe,this.optimizationState.tail=ne,this.optimizationState.epochsPerSample=q,this.initializeOptimization(),this.prepareForOptimizationLoop(),this.isInitialized=!0,this.getNEpochs()},N.prototype.makeSearchFns=function(){var j=g.makeInitializations(this.distanceFn),J=j.initFromTree,W=j.initFromRandom;this.initFromTree=J,this.initFromRandom=W,this.search=g.makeInitializedNNSearch(this.distanceFn)},N.prototype.makeSearchGraph=function(j){for(var J=this.knnIndices,W=this.knnDistances,oe=[j.length,j.length],ne=new d.SparseMatrix([],[],[],oe),q=0;q<J.length;q++)for(var le=J[q],se=W[q],pe=0;pe<le.length;pe++){var be=le[pe],ee=se[pe];ee>0&&ne.set(q,be,ee)}var te=d.transpose(ne);return d.maximum(ne,te)},N.prototype.transform=function(j){var J=this,W=this.X;if(W===void 0||W.length===0)throw new Error("No data has been fit.");var oe=Math.floor(this.nNeighbors*this.transformQueueSize);oe=Math.min(W.length,oe);var ne=g.initializeSearch(this.rpForest,W,j,oe,this.initFromRandom,this.initFromTree,this.random),q=this.search(W,this.searchGraph,ne,j),le=c.deheapSort(q),se=le.indices,pe=le.weights;se=se.map(function(mt){return mt.slice(0,J.nNeighbors)}),pe=pe.map(function(mt){return mt.slice(0,J.nNeighbors)});var be=Math.max(0,this.localConnectivity-1),ee=this.smoothKNNDistance(pe,this.nNeighbors,be),te=ee.sigmas,ue=ee.rhos,ae=this.computeMembershipStrengths(se,pe,te,ue),ce=ae.rows,Be=ae.cols,He=ae.vals,Xe=[j.length,W.length],ot=new d.SparseMatrix(ce,Be,He,Xe),tt=d.normalize(ot,"l1"),Ae=d.getCSR(tt),ye=j.length,xe=h.reshape2d(Ae.indices,ye,this.nNeighbors),ke=h.reshape2d(Ae.values,ye,this.nNeighbors),ze=U(xe,ke,this.embedding),je=this.nEpochs?this.nEpochs/3:ot.nRows<=1e4?100:30,Fe=ot.getValues().reduce(function(mt,Tt){return Tt>mt?Tt:mt},0);ot=ot.map(function(mt){return mt<Fe/je?0:mt}),ot=d.eliminateZeros(ot);var Ye=this.makeEpochsPerSample(ot.getValues(),je),Ve=ot.getRows(),Qe=ot.getCols();return this.assignOptimizationStateParameters({headEmbedding:ze,tailEmbedding:this.embedding,head:Ve,tail:Qe,currentEpoch:0,nEpochs:je,nVertices:ot.getDims()[1],epochsPerSample:Ye}),this.prepareForOptimizationLoop(),this.optimizeLayout()},N.prototype.processGraphForSupervisedProjection=function(){var j=this,J=j.Y,W=j.X;if(J){if(J.length!==W.length)throw new Error("Length of X and y must be equal");if(this.targetMetric==="categorical"){var oe=this.targetWeight<1,ne=oe?2.5*(1/(1-this.targetWeight)):1e12;this.graph=this.categoricalSimplicialSetIntersection(this.graph,J,ne)}}},N.prototype.step=function(){var j=this.optimizationState.currentEpoch;return j<this.getNEpochs()&&this.optimizeLayoutStep(j),this.optimizationState.currentEpoch},N.prototype.getEmbedding=function(){return this.embedding},N.prototype.nearestNeighbors=function(j){var J=this,W=J.distanceFn,oe=J.nNeighbors,ne=function(ae){return Math.log(ae)/Math.log(2)},q=g.makeNNDescent(W,this.random),le=function(ae){return ae===.5?0:Math.round(ae)},se=5+Math.floor(le(Math.pow(j.length,.5)/20)),pe=Math.max(5,Math.floor(Math.round(ne(j.length))));this.rpForest=p.makeForest(j,oe,se,this.random);var be=p.makeLeafArray(this.rpForest),ee=q(j,be,oe,pe),te=ee.indices,ue=ee.weights;return{knnIndices:te,knnDistances:ue}},N.prototype.fuzzySimplicialSet=function(j,J,W){W===void 0&&(W=1);var oe=this,ne=oe.knnIndices,q=ne===void 0?[]:ne,le=oe.knnDistances,se=le===void 0?[]:le,pe=oe.localConnectivity,be=this.smoothKNNDistance(se,J,pe),ee=be.sigmas,te=be.rhos,ue=this.computeMembershipStrengths(q,se,ee,te),ae=ue.rows,ce=ue.cols,Be=ue.vals,He=[j.length,j.length],Xe=new d.SparseMatrix(ae,ce,Be,He),ot=d.transpose(Xe),tt=d.pairwiseMultiply(Xe,ot),Ae=d.subtract(d.add(Xe,ot),tt),ye=d.multiplyScalar(Ae,W),xe=d.multiplyScalar(tt,1-W),ke=d.add(ye,xe);return ke},N.prototype.categoricalSimplicialSetIntersection=function(j,J,W,oe){oe===void 0&&(oe=1);var ne=D(j,J,oe,W);return ne=d.eliminateZeros(ne),z(ne)},N.prototype.smoothKNNDistance=function(j,J,W,oe,ne){W===void 0&&(W=1),oe===void 0&&(oe=64),ne===void 0&&(ne=1);for(var q=Math.log(J)/Math.log(2)*ne,le=h.zeros(j.length),se=h.zeros(j.length),pe=0;pe<j.length;pe++){var be=0,ee=1/0,te=1,ue=j[pe],ae=ue.filter(function(xe){return xe>0});if(ae.length>=W){var ce=Math.floor(W),Be=W-ce;ce>0?(le[pe]=ae[ce-1],Be>y&&(le[pe]+=Be*(ae[ce]-ae[ce-1]))):le[pe]=Be*ae[0]}else ae.length>0&&(le[pe]=h.max(ae));for(var He=0;He<oe;He++){for(var Xe=0,ot=1;ot<j[pe].length;ot++){var tt=j[pe][ot]-le[pe];tt>0?Xe+=Math.exp(-(tt/te)):Xe+=1}if(Math.abs(Xe-q)<y)break;Xe>q?(ee=te,te=(be+ee)/2):(be=te,ee===1/0?te*=2:te=(be+ee)/2)}if(se[pe]=te,le[pe]>0){var Ae=h.mean(ue);se[pe]<w*Ae&&(se[pe]=w*Ae)}else{var ye=h.mean(j.map(h.mean));se[pe]<w*ye&&(se[pe]=w*ye)}}return{sigmas:se,rhos:le}},N.prototype.computeMembershipStrengths=function(j,J,W,oe){for(var ne=j.length,q=j[0].length,le=h.zeros(ne*q),se=h.zeros(ne*q),pe=h.zeros(ne*q),be=0;be<ne;be++)for(var ee=0;ee<q;ee++){var te=0;j[be][ee]!==-1&&(j[be][ee]===be?te=0:J[be][ee]-oe[be]<=0?te=1:te=Math.exp(-((J[be][ee]-oe[be])/W[be])),le[be*q+ee]=be,se[be*q+ee]=j[be][ee],pe[be*q+ee]=te)}return{rows:le,cols:se,vals:pe}},N.prototype.initializeSimplicialSetEmbedding=function(){for(var j=this,J=this.getNEpochs(),W=this.nComponents,oe=this.graph.getValues(),ne=0,q=0;q<oe.length;q++){var le=oe[q];ne<oe[q]&&(ne=le)}var se=this.graph.map(function(ce){return ce<ne/J?0:ce});this.embedding=h.zeros(se.nRows).map(function(){return h.zeros(W).map(function(){return h.tauRand(j.random)*20+-10})});for(var pe=[],be=[],ee=[],te=se.getAll(),q=0;q<te.length;q++){var ue=te[q];ue.value&&(pe.push(ue.value),ee.push(ue.row),be.push(ue.col))}var ae=this.makeEpochsPerSample(pe,J);return{head:be,tail:ee,epochsPerSample:ae}},N.prototype.makeEpochsPerSample=function(j,J){var W=h.filled(j.length,-1),oe=h.max(j),ne=j.map(function(q){return q/oe*J});return ne.forEach(function(q,le){q>0&&(W[le]=J/ne[le])}),W},N.prototype.assignOptimizationStateParameters=function(j){Object.assign(this.optimizationState,j)},N.prototype.prepareForOptimizationLoop=function(){var j=this,J=j.repulsionStrength,W=j.learningRate,oe=j.negativeSampleRate,ne=this.optimizationState,q=ne.epochsPerSample,le=ne.headEmbedding,se=ne.tailEmbedding,pe=le[0].length,be=le.length===se.length,ee=q.map(function(ae){return ae/oe}),te=o(ee),ue=o(q);this.assignOptimizationStateParameters({epochOfNextSample:ue,epochOfNextNegativeSample:te,epochsPerNegativeSample:ee,moveOther:be,initialAlpha:W,alpha:W,gamma:J,dim:pe})},N.prototype.initializeOptimization=function(){var j=this.embedding,J=this.embedding,W=this.optimizationState,oe=W.head,ne=W.tail,q=W.epochsPerSample,le=this.getNEpochs(),se=this.graph.nCols,pe=P(this.spread,this.minDist),be=pe.a,ee=pe.b;this.assignOptimizationStateParameters({headEmbedding:j,tailEmbedding:J,head:oe,tail:ne,epochsPerSample:q,a:be,b:ee,nEpochs:le,nVertices:se})},N.prototype.optimizeLayoutStep=function(j){for(var J=this.optimizationState,W=J.head,oe=J.tail,ne=J.headEmbedding,q=J.tailEmbedding,le=J.epochsPerSample,se=J.epochOfNextSample,pe=J.epochOfNextNegativeSample,be=J.epochsPerNegativeSample,ee=J.moveOther,te=J.initialAlpha,ue=J.alpha,ae=J.gamma,ce=J.a,Be=J.b,He=J.dim,Xe=J.nEpochs,ot=J.nVertices,tt=4,Ae=0;Ae<le.length;Ae++)if(!(se[Ae]>j)){var ye=W[Ae],xe=oe[Ae],ke=ne[ye],ze=q[xe],je=R(ke,ze),Fe=0;je>0&&(Fe=-2*ce*Be*Math.pow(je,Be-1),Fe/=ce*Math.pow(je,Be)+1);for(var Ye=0;Ye<He;Ye++){var Ve=x(Fe*(ke[Ye]-ze[Ye]),tt);ke[Ye]+=Ve*ue,ee&&(ze[Ye]+=-Ve*ue)}se[Ae]+=le[Ae];for(var Qe=Math.floor((j-pe[Ae])/be[Ae]),mt=0;mt<Qe;mt++){var Tt=h.tauRandInt(ot,this.random),Me=q[Tt],me=R(ke,Me),$e=0;if(me>0)$e=2*ae*Be,$e/=(.001+me)*(ce*Math.pow(me,Be)+1);else if(ye===Tt)continue;for(var Ye=0;Ye<He;Ye++){var Ve=4;$e>0&&(Ve=x($e*(ke[Ye]-Me[Ye]),tt)),ke[Ye]+=Ve*ue}}pe[Ae]+=Qe*be[Ae]}return J.alpha=te*(1-j/Xe),J.currentEpoch+=1,ne},N.prototype.optimizeLayoutAsync=function(j){var J=this;return j===void 0&&(j=function(){return!0}),new Promise(function(W,oe){var ne=function(){return i(J,void 0,void 0,function(){var q,le,se,pe,be,ee;return s(this,function(te){try{if(q=this.optimizationState,le=q.nEpochs,se=q.currentEpoch,this.embedding=this.optimizeLayoutStep(se),pe=this.optimizationState.currentEpoch,be=j(pe)===!1,ee=pe===le,!be&&!ee)setTimeout(function(){return ne()},0);else return[2,W(ee)]}catch(ue){oe(ue)}return[2]})})};setTimeout(function(){return ne()},0)})},N.prototype.optimizeLayout=function(j){j===void 0&&(j=function(){return!0});for(var J=!1,W=[];!J;){var oe=this.optimizationState,ne=oe.nEpochs,q=oe.currentEpoch;W=this.optimizeLayoutStep(q);var le=this.optimizationState.currentEpoch,se=j(le)===!1;J=le===ne||se}return W},N.prototype.getNEpochs=function(){var j=this.graph;if(this.nEpochs>0)return this.nEpochs;var J=j.nRows;return J<=2500?500:J<=5e3?400:J<=7500?300:200},N})();ws.UMAP=S;function M(N,j){for(var J=0,W=0;W<N.length;W++)J+=Math.pow(N[W]-j[W],2);return Math.sqrt(J)}ws.euclidean=M;function T(N,j){for(var J=0,W=0,oe=0,ne=0;ne<N.length;ne++)J+=N[ne]*j[ne],W+=Math.pow(N[ne],2),oe+=Math.pow(j[ne],2);return W===0&&oe===0?0:W===0||oe===0?1:1-J/Math.sqrt(W*oe)}ws.cosine=T;var C=(function(){function N(){this.currentEpoch=0,this.headEmbedding=[],this.tailEmbedding=[],this.head=[],this.tail=[],this.epochsPerSample=[],this.epochOfNextSample=[],this.epochOfNextNegativeSample=[],this.epochsPerNegativeSample=[],this.moveOther=!0,this.initialAlpha=1,this.alpha=1,this.gamma=1,this.a=1.5769434603113077,this.b=.8950608779109733,this.dim=2,this.nEpochs=500,this.nVertices=0}return N})();function x(N,j){return N>j?j:N<-j?-j:N}function R(N,j){for(var J=0,W=0;W<N.length;W++)J+=Math.pow(N[W]-j[W],2);return J}function P(N,j){var J=function(te){var ue=r(te,2),ae=ue[0],ce=ue[1];return function(Be){return 1/(1+ae*Math.pow(Be,2*ce))}},W=h.linear(0,N*3,300).map(function(te){return te<j?1:te}),oe=h.zeros(W.length).map(function(te,ue){var ae=W[ue]>=j;return ae?Math.exp(-(W[ue]-j)/N):te}),ne=[.5,.5],q={x:W,y:oe},le={damping:1.5,initialValues:ne,gradientDifference:.1,maxIterations:100,errorTolerance:.01},se=v.default(q,J,le).parameterValues,pe=r(se,2),be=pe[0],ee=pe[1];return{a:be,b:ee}}ws.findABParams=P;function D(N,j,J,W){return J===void 0&&(J=1),W===void 0&&(W=5),N.map(function(oe,ne,q){return j[ne]===-1||j[q]===-1?oe*Math.exp(-J):j[ne]!==j[q]?oe*Math.exp(-W):oe})}ws.fastIntersection=D;function z(N){N=d.normalize(N,"max");var j=d.transpose(N),J=d.pairwiseMultiply(j,N);return N=d.add(N,d.subtract(j,J)),d.eliminateZeros(N)}ws.resetLocalConnectivity=z;function U(N,j,J){for(var W=h.zeros(N.length).map(function(se){return h.zeros(J[0].length)}),oe=0;oe<N.length;oe++)for(var ne=0;ne<N[0].length;ne++)for(var q=0;q<J[0].length;q++){var le=N[oe][ne];W[oe][q]+=j[oe][ne]*J[le][q]}return W}return ws.initTransform=U,ws}var U2;function N9(){return U2||(U2=1,(function(n){Object.defineProperty(n,"__esModule",{value:!0});var e=F9();Object.defineProperty(n,"UMAP",{enumerable:!0,get:function(){return e.UMAP}})})(p1)),p1}var z9=N9();const HM=new Map,wg=[],U9=(n,e,t)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){const i=HM.get(n);if(i===void 0)HM.set(n,{backend:e,priority:t});else{if(i.priority>t)return;if(i.priority===t&&i.backend!==e)throw new Error(`cannot register backend "${n}" using priority ${t}`)}if(t>=0){const s=wg.indexOf(n);s!==-1&&wg.splice(s,1);for(let r=0;r<wg.length;r++)if(HM.get(wg[r]).priority<=t){wg.splice(r,0,n);return}wg.push(n)}return}throw new TypeError("not a valid backend")},k9=async n=>{const e=HM.get(n);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{const t=!!e.initPromise;try{return t||(e.initPromise=e.backend.init(n)),await e.initPromise,e.initialized=!0,e.backend}catch(i){return t||(e.error=`${i}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},G9=async n=>{const e=n.executionProviders||[],t=e.map(c=>typeof c=="string"?c:c.name),i=t.length===0?wg:t;let s;const r=[],o=new Set;for(const c of i){const d=await k9(c);typeof d=="string"?r.push({name:c,err:d}):(s||(s=d),s===d&&o.add(c))}if(!s)throw new Error(`no available backend found. ERR: ${r.map(c=>`[${c.name}] ${c.err}`).join(", ")}`);for(const{name:c,err:d}of r)t.includes(c)&&console.warn(`removing requested execution provider "${c}" from session options because it is not available: ${d}`);const l=e.filter(c=>o.has(typeof c=="string"?c:c.name));return[s,new Proxy(n,{get:(c,d)=>d==="executionProviders"?l:Reflect.get(c,d)})]},V9="1.21.0";let k2="warning";const Fd={wasm:{},webgl:{},webgpu:{},versions:{common:V9},set logLevel(n){if(n!==void 0){if(typeof n!="string"||["verbose","info","warning","error","fatal"].indexOf(n)===-1)throw new Error(`Unsupported logging level: ${n}`);k2=n}},get logLevel(){return k2}};Object.defineProperty(Fd,"logLevel",{enumerable:!0});const H9=Fd,j9=(n,e)=>{const t=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);t.width=n.dims[3],t.height=n.dims[2];const i=t.getContext("2d");if(i!=null){let s,r;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(s=n.dims[2],r=n.dims[3]):(s=n.dims[3],r=n.dims[2]);const o=e?.format!==void 0?e.format:"RGB",l=e?.norm;let c,d;l===void 0||l.mean===void 0?c=[255,255,255,255]:typeof l.mean=="number"?c=[l.mean,l.mean,l.mean,l.mean]:(c=[l.mean[0],l.mean[1],l.mean[2],0],l.mean[3]!==void 0&&(c[3]=l.mean[3])),l===void 0||l.bias===void 0?d=[0,0,0,0]:typeof l.bias=="number"?d=[l.bias,l.bias,l.bias,l.bias]:(d=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(d[3]=l.bias[3]));const g=r*s;let p=0,h=g,v=g*2,y=-1;o==="RGBA"?(p=0,h=g,v=g*2,y=g*3):o==="RGB"?(p=0,h=g,v=g*2):o==="RBG"&&(p=0,v=g,h=g*2);for(let w=0;w<r;w++)for(let S=0;S<s;S++){const M=(n.data[p++]-d[0])*c[0],T=(n.data[h++]-d[1])*c[1],C=(n.data[v++]-d[2])*c[2],x=y===-1?255:(n.data[y++]-d[3])*c[3];i.fillStyle="rgba("+M+","+T+","+C+","+x+")",i.fillRect(S,w,1,1)}if("toDataURL"in t)return t.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},$9=(n,e)=>{const t=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let i;if(t!=null){let s,r,o;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(s=n.dims[2],r=n.dims[1],o=n.dims[3]):(s=n.dims[3],r=n.dims[2],o=n.dims[1]);const l=e!==void 0&&e.format!==void 0?e.format:"RGB",c=e?.norm;let d,g;c===void 0||c.mean===void 0?d=[255,255,255,255]:typeof c.mean=="number"?d=[c.mean,c.mean,c.mean,c.mean]:(d=[c.mean[0],c.mean[1],c.mean[2],255],c.mean[3]!==void 0&&(d[3]=c.mean[3])),c===void 0||c.bias===void 0?g=[0,0,0,0]:typeof c.bias=="number"?g=[c.bias,c.bias,c.bias,c.bias]:(g=[c.bias[0],c.bias[1],c.bias[2],0],c.bias[3]!==void 0&&(g[3]=c.bias[3]));const p=r*s;if(e!==void 0&&(e.format!==void 0&&o===4&&e.format!=="RGBA"||o===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const h=4;let v=0,y=1,w=2,S=3,M=0,T=p,C=p*2,x=-1;l==="RGBA"?(M=0,T=p,C=p*2,x=p*3):l==="RGB"?(M=0,T=p,C=p*2):l==="RBG"&&(M=0,C=p,T=p*2),i=t.createImageData(s,r);for(let R=0;R<r*s;v+=h,y+=h,w+=h,S+=h,R++)i.data[v]=(n.data[M++]-g[0])*d[0],i.data[y]=(n.data[T++]-g[1])*d[1],i.data[w]=(n.data[C++]-g[2])*d[2],i.data[S]=x===-1?255:(n.data[x++]-g[3])*d[3]}else throw new Error("Can not access image data");return i},g1=(n,e)=>{if(n===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:t,width:i}=e,s=e.norm??{mean:255,bias:0};let r,o;typeof s.mean=="number"?r=[s.mean,s.mean,s.mean,s.mean]:r=[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],typeof s.bias=="number"?o=[s.bias,s.bias,s.bias,s.bias]:o=[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];const l=e.format!==void 0?e.format:"RGBA",c=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",d=t*i,g=c==="RGBA"?new Float32Array(d*4):new Float32Array(d*3);let p=4,h=0,v=1,y=2,w=3,S=0,M=d,T=d*2,C=-1;l==="RGB"&&(p=3,h=0,v=1,y=2,w=-1),c==="RGBA"?C=d*3:c==="RBG"?(S=0,T=d,M=d*2):c==="BGR"&&(T=0,M=d,S=d*2);for(let R=0;R<d;R++,h+=p,y+=p,v+=p,w+=p)g[S++]=(n[h]+o[0])/r[0],g[M++]=(n[v]+o[1])/r[1],g[T++]=(n[y]+o[2])/r[2],C!==-1&&w!==-1&&(g[C++]=(n[w]+o[3])/r[3]);return c==="RGBA"?new Ic("float32",g,[1,4,t,i]):new Ic("float32",g,[1,3,t,i])},W9=async(n,e)=>{const t=typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement,i=typeof ImageData<"u"&&n instanceof ImageData,s=typeof ImageBitmap<"u"&&n instanceof ImageBitmap,r=typeof n=="string";let o,l=e??{};const c=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},d=g=>typeof HTMLCanvasElement<"u"&&g instanceof HTMLCanvasElement||g instanceof OffscreenCanvas?g.getContext("2d"):null;if(t){const g=c();g.width=n.width,g.height=n.height;const p=d(g);if(p!=null){let h=n.height,v=n.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(h=e.resizedHeight,v=e.resizedWidth),e!==void 0){if(l=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");l.tensorFormat="RGBA",l.height=h,l.width=v}else l.tensorFormat="RGBA",l.height=h,l.width=v;p.drawImage(n,0,0),o=p.getImageData(0,0,v,h).data}else throw new Error("Can not access image data")}else if(i){let g,p;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(g=e.resizedHeight,p=e.resizedWidth):(g=n.height,p=n.width),e!==void 0&&(l=e),l.format="RGBA",l.height=g,l.width=p,e!==void 0){const h=c();h.width=p,h.height=g;const v=d(h);if(v!=null)v.putImageData(n,0,0),o=v.getImageData(0,0,p,g).data;else throw new Error("Can not access image data")}else o=n.data}else if(s){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");const g=c();g.width=n.width,g.height=n.height;const p=d(g);if(p!=null){const h=n.height,v=n.width;return p.drawImage(n,0,0,v,h),o=p.getImageData(0,0,v,h).data,l.height=h,l.width=v,g1(o,l)}else throw new Error("Can not access image data")}else{if(r)return new Promise((g,p)=>{const h=c(),v=d(h);if(!n||!v)return p();const y=new Image;y.crossOrigin="Anonymous",y.src=n,y.onload=()=>{h.width=y.width,h.height=y.height,v.drawImage(y,0,0,h.width,h.height);const w=v.getImageData(0,0,h.width,h.height);l.height=h.height,l.width=h.width,g(g1(w.data,l))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(o!==void 0)return g1(o,l);throw new Error("Input data provided is not supported - aborted tensor creation")},K9=(n,e)=>{const{width:t,height:i,download:s,dispose:r}=e,o=[1,i,t,4];return new Ic({location:"texture",type:"float32",texture:n,dims:o,download:s,dispose:r})},q9=(n,e)=>{const{dataType:t,dims:i,download:s,dispose:r}=e;return new Ic({location:"gpu-buffer",type:t??"float32",gpuBuffer:n,dims:i,download:s,dispose:r})},X9=(n,e)=>{const{dataType:t,dims:i,download:s,dispose:r}=e;return new Ic({location:"ml-tensor",type:t??"float32",mlTensor:n,dims:i,download:s,dispose:r})},Y9=(n,e,t)=>new Ic({location:"cpu-pinned",type:n,data:e,dims:t??[e.length]}),X_=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),jM=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let G2=!1;const J9=()=>{if(!G2){G2=!0;const n=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,t=globalThis.Float16Array,i=typeof t<"u"&&t.from;n&&(X_.set("int64",BigInt64Array),jM.set(BigInt64Array,"int64")),e&&(X_.set("uint64",BigUint64Array),jM.set(BigUint64Array,"uint64")),i?(X_.set("float16",t),jM.set(t,"float16")):X_.set("float16",Uint16Array)}},Q9=n=>{let e=1;for(let t=0;t<n.length;t++){const i=n[t];if(typeof i!="number"||!Number.isSafeInteger(i))throw new TypeError(`dims[${t}] must be an integer, got: ${i}`);if(i<0)throw new RangeError(`dims[${t}] must be a non-negative integer, got: ${i}`);e*=i}return e},Z9=(n,e)=>{switch(n.location){case"cpu":return new Ic(n.type,n.data,e);case"cpu-pinned":return new Ic({location:"cpu-pinned",data:n.data,type:n.type,dims:e});case"texture":return new Ic({location:"texture",texture:n.texture,type:n.type,dims:e});case"gpu-buffer":return new Ic({location:"gpu-buffer",gpuBuffer:n.gpuBuffer,type:n.type,dims:e});case"ml-tensor":return new Ic({location:"ml-tensor",mlTensor:n.mlTensor,type:n.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${n.location} is not supported`)}};let Ic=class{constructor(e,t,i){J9();let s,r;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,s=e.type,r=e.dims,e.location){case"cpu-pinned":{const l=X_.get(s);if(!l)throw new TypeError(`unsupported type "${s}" to create tensor from pinned buffer`);if(!(e.data instanceof l))throw new TypeError(`buffer should be of type ${l.name}`);this.cpuData=e.data;break}case"texture":{if(s!=="float32")throw new TypeError(`unsupported type "${s}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(s!=="float32"&&s!=="float16"&&s!=="int32"&&s!=="int64"&&s!=="uint32"&&s!=="uint64"&&s!=="int8"&&s!=="uint8"&&s!=="bool"&&s!=="uint4"&&s!=="int4")throw new TypeError(`unsupported type "${s}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let l,c;if(typeof e=="string")if(s=e,c=i,e==="string"){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");l=t}else{const d=X_.get(e);if(d===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if(e==="float16"&&d===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${d.name} as data.`);e==="uint64"||e==="int64"?l=d.from(t,BigInt):l=d.from(t)}else if(t instanceof d)l=t;else if(t instanceof Uint8ClampedArray)if(e==="uint8")l=Uint8Array.from(t);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(e==="float16"&&t instanceof Uint16Array&&d!==Uint16Array)l=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw new TypeError(`A ${s} tensor's data must be type of ${d}`)}else if(c=t,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const d=typeof e[0];if(d==="string")s="string",l=e;else if(d==="boolean")s="bool",l=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${d}.`)}else if(e instanceof Uint8ClampedArray)s="uint8",l=Uint8Array.from(e);else{const d=jM.get(e.constructor);if(d===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);s=d,l=e}if(c===void 0)c=[l.length];else if(!Array.isArray(c))throw new TypeError("A tensor's dims must be a number array");r=c,this.cpuData=l,this.dataLocation="cpu"}const o=Q9(r);if(this.cpuData&&o!==this.cpuData.length&&!((s==="uint4"||s==="int4")&&Math.ceil(o/2)===this.cpuData.length))throw new Error(`Tensor's size(${o}) does not match data length(${this.cpuData.length}).`);this.type=s,this.dims=r,this.size=o}static async fromImage(e,t){return W9(e,t)}static fromTexture(e,t){return K9(e,t)}static fromGpuBuffer(e,t){return q9(e,t)}static fromMLTensor(e,t){return X9(e,t)}static fromPinnedBuffer(e,t,i){return Y9(e,t,i)}toDataURL(e){return j9(this,e)}toImageData(e){return $9(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Z9(this,e)}};const $_=Ic,n3=(n,e)=>{(typeof Fd.trace>"u"?!Fd.wasm.trace:!Fd.trace)||console.timeStamp(`${n}::ORT::${e}`)},i3=(n,e)=>{const t=new Error().stack?.split(/\r\n|\r|\n/g)||[];let i=!1;for(let s=0;s<t.length;s++){if(i&&!t[s].includes("TRACE_FUNC")){let r=`FUNC_${n}::${t[s].trim().split(" ")[1]}`;e&&(r+=`::${e}`),n3("CPU",r);return}t[s].includes("TRACE_FUNC")&&(i=!0)}},WE=n=>{(typeof Fd.trace>"u"?!Fd.wasm.trace:!Fd.trace)||i3("BEGIN",n)},KE=n=>{(typeof Fd.trace>"u"?!Fd.wasm.trace:!Fd.trace)||i3("END",n)};let eW=class s3{constructor(e){this.handler=e}async run(e,t,i){WE();const s={};let r={};if(typeof e!="object"||e===null||e instanceof $_||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if(typeof t=="object"){if(t===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof $_)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(t.length===0)throw new TypeError("'fetches' cannot be an empty array.");o=!1;for(const d of t){if(typeof d!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(d)===-1)throw new RangeError(`'fetches' contains invalid output name: ${d}.`);s[d]=null}if(typeof i=="object"&&i!==null)r=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let d=!1;const g=Object.getOwnPropertyNames(t);for(const p of this.outputNames)if(g.indexOf(p)!==-1){const h=t[p];(h===null||h instanceof $_)&&(d=!0,o=!1,s[p]=h)}if(d){if(typeof i=="object"&&i!==null)r=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else r=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const d of this.inputNames)if(typeof e[d]>"u")throw new Error(`input '${d}' is missing in 'feeds'.`);if(o)for(const d of this.outputNames)s[d]=null;const l=await this.handler.run(e,s,r),c={};for(const d in l)if(Object.hasOwnProperty.call(l,d)){const g=l[d];g instanceof $_?c[d]=g:c[d]=new $_(g.type,g.data,g.dims)}return KE(),c}async release(){return this.handler.dispose()}static async create(e,t,i,s){WE();let r,o={};if(typeof e=="string"){if(r=e,typeof t=="object"&&t!==null)o=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(r=e,typeof t=="object"&&t!==null)o=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){const g=e;let p=0,h=e.byteLength;if(typeof t=="object"&&t!==null)o=t;else if(typeof t=="number"){if(p=t,!Number.isSafeInteger(p))throw new RangeError("'byteOffset' must be an integer.");if(p<0||p>=g.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${g.byteLength}).`);if(h=e.byteLength-p,typeof i=="number"){if(h=i,!Number.isSafeInteger(h))throw new RangeError("'byteLength' must be an integer.");if(h<=0||p+h>g.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${g.byteLength-p}].`);if(typeof s=="object"&&s!==null)o=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(typeof i<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof t<"u")throw new TypeError("'options' must be an object.");r=new Uint8Array(g,p,h)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[l,c]=await G9(o),d=await l.createInferenceSessionHandler(r,c);return KE(),new s3(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const tW=eW,nW=Object.freeze(Object.defineProperty({__proto__:null,InferenceSession:tW,TRACE:n3,TRACE_FUNC_BEGIN:WE,TRACE_FUNC_END:KE,Tensor:$_,env:H9,registerBackend:U9},Symbol.toStringTag,{value:"Module"}));var oS=Object.defineProperty,iW=Object.getOwnPropertyDescriptor,sW=Object.getOwnPropertyNames,rW=Object.prototype.hasOwnProperty,aW=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')}),fn=(n,e)=>()=>(n&&(e=n(n=0)),e),E0=(n,e)=>{for(var t in e)oS(n,t,{get:e[t],enumerable:!0})},oW=(n,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of sW(e))!rW.call(n,s)&&s!==t&&oS(n,s,{get:()=>e[s],enumerable:!(i=iW(e,s))||i.enumerable});return n},Vv=n=>oW(oS({},"__esModule",{value:!0}),n),Z0,sm,Ig,V2,r3,a3=fn(()=>{Z0=new Map,sm=[],Ig=(n,e,t)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let i=Z0.get(n);if(i===void 0)Z0.set(n,{backend:e,priority:t});else{if(i.priority>t)return;if(i.priority===t&&i.backend!==e)throw new Error(`cannot register backend "${n}" using priority ${t}`)}if(t>=0){let s=sm.indexOf(n);s!==-1&&sm.splice(s,1);for(let r=0;r<sm.length;r++)if(Z0.get(sm[r]).priority<=t){sm.splice(r,0,n);return}sm.push(n)}return}throw new TypeError("not a valid backend")},V2=async n=>{let e=Z0.get(n);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let t=!!e.initPromise;try{return t||(e.initPromise=e.backend.init(n)),await e.initPromise,e.initialized=!0,e.backend}catch(i){return t||(e.error=`${i}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},r3=async n=>{let e=n.executionProviders||[],t=e.map(c=>typeof c=="string"?c:c.name),i=t.length===0?sm:t,s,r=[],o=new Set;for(let c of i){let d=await V2(c);typeof d=="string"?r.push({name:c,err:d}):(s||(s=d),s===d&&o.add(c))}if(!s)throw new Error(`no available backend found. ERR: ${r.map(c=>`[${c.name}] ${c.err}`).join(", ")}`);for(let{name:c,err:d}of r)t.includes(c)&&console.warn(`removing requested execution provider "${c}" from session options because it is not available: ${d}`);let l=e.filter(c=>o.has(typeof c=="string"?c:c.name));return[s,new Proxy(n,{get:(c,d)=>d==="executionProviders"?l:Reflect.get(c,d)})]}}),lW=fn(()=>{a3()}),o3,uW=fn(()=>{o3="1.22.0-dev.20250409-89f8206ba4"}),_1,Bc,l3=fn(()=>{uW(),_1="warning",Bc={wasm:{},webgl:{},webgpu:{},versions:{common:o3},set logLevel(n){if(n!==void 0){if(typeof n!="string"||["verbose","info","warning","error","fatal"].indexOf(n)===-1)throw new Error(`Unsupported logging level: ${n}`);_1=n}},get logLevel(){return _1}},Object.defineProperty(Bc,"logLevel",{enumerable:!0})}),ur,cW=fn(()=>{l3(),ur=Bc}),u3,c3,dW=fn(()=>{u3=(n,e)=>{let t=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);t.width=n.dims[3],t.height=n.dims[2];let i=t.getContext("2d");if(i!=null){let s,r;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(s=n.dims[2],r=n.dims[3]):(s=n.dims[3],r=n.dims[2]);let o=e?.format!==void 0?e.format:"RGB",l=e?.norm,c,d;l===void 0||l.mean===void 0?c=[255,255,255,255]:typeof l.mean=="number"?c=[l.mean,l.mean,l.mean,l.mean]:(c=[l.mean[0],l.mean[1],l.mean[2],0],l.mean[3]!==void 0&&(c[3]=l.mean[3])),l===void 0||l.bias===void 0?d=[0,0,0,0]:typeof l.bias=="number"?d=[l.bias,l.bias,l.bias,l.bias]:(d=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(d[3]=l.bias[3]));let g=r*s,p=0,h=g,v=g*2,y=-1;o==="RGBA"?(p=0,h=g,v=g*2,y=g*3):o==="RGB"?(p=0,h=g,v=g*2):o==="RBG"&&(p=0,v=g,h=g*2);for(let w=0;w<r;w++)for(let S=0;S<s;S++){let M=(n.data[p++]-d[0])*c[0],T=(n.data[h++]-d[1])*c[1],C=(n.data[v++]-d[2])*c[2],x=y===-1?255:(n.data[y++]-d[3])*c[3];i.fillStyle="rgba("+M+","+T+","+C+","+x+")",i.fillRect(S,w,1,1)}if("toDataURL"in t)return t.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},c3=(n,e)=>{let t=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),i;if(t!=null){let s,r,o;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(s=n.dims[2],r=n.dims[1],o=n.dims[3]):(s=n.dims[3],r=n.dims[2],o=n.dims[1]);let l=e!==void 0&&e.format!==void 0?e.format:"RGB",c=e?.norm,d,g;c===void 0||c.mean===void 0?d=[255,255,255,255]:typeof c.mean=="number"?d=[c.mean,c.mean,c.mean,c.mean]:(d=[c.mean[0],c.mean[1],c.mean[2],255],c.mean[3]!==void 0&&(d[3]=c.mean[3])),c===void 0||c.bias===void 0?g=[0,0,0,0]:typeof c.bias=="number"?g=[c.bias,c.bias,c.bias,c.bias]:(g=[c.bias[0],c.bias[1],c.bias[2],0],c.bias[3]!==void 0&&(g[3]=c.bias[3]));let p=r*s;if(e!==void 0&&(e.format!==void 0&&o===4&&e.format!=="RGBA"||o===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let h=4,v=0,y=1,w=2,S=3,M=0,T=p,C=p*2,x=-1;l==="RGBA"?(M=0,T=p,C=p*2,x=p*3):l==="RGB"?(M=0,T=p,C=p*2):l==="RBG"&&(M=0,C=p,T=p*2),i=t.createImageData(s,r);for(let R=0;R<r*s;v+=h,y+=h,w+=h,S+=h,R++)i.data[v]=(n.data[M++]-g[0])*d[0],i.data[y]=(n.data[T++]-g[1])*d[1],i.data[w]=(n.data[C++]-g[2])*d[2],i.data[S]=x===-1?255:(n.data[x++]-g[3])*d[3]}else throw new Error("Can not access image data");return i}}),EM,d3,f3,h3,p3,m3,fW=fn(()=>{lS(),EM=(n,e)=>{if(n===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:t,width:i}=e,s=e.norm??{mean:255,bias:0},r,o;typeof s.mean=="number"?r=[s.mean,s.mean,s.mean,s.mean]:r=[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],typeof s.bias=="number"?o=[s.bias,s.bias,s.bias,s.bias]:o=[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];let l=e.format!==void 0?e.format:"RGBA",c=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",d=t*i,g=c==="RGBA"?new Float32Array(d*4):new Float32Array(d*3),p=4,h=0,v=1,y=2,w=3,S=0,M=d,T=d*2,C=-1;l==="RGB"&&(p=3,h=0,v=1,y=2,w=-1),c==="RGBA"?C=d*3:c==="RBG"?(S=0,T=d,M=d*2):c==="BGR"&&(T=0,M=d,S=d*2);for(let x=0;x<d;x++,h+=p,y+=p,v+=p,w+=p)g[S++]=(n[h]+o[0])/r[0],g[M++]=(n[v]+o[1])/r[1],g[T++]=(n[y]+o[2])/r[2],C!==-1&&w!==-1&&(g[C++]=(n[w]+o[3])/r[3]);return c==="RGBA"?new $u("float32",g,[1,4,t,i]):new $u("float32",g,[1,3,t,i])},d3=async(n,e)=>{let t=typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement,i=typeof ImageData<"u"&&n instanceof ImageData,s=typeof ImageBitmap<"u"&&n instanceof ImageBitmap,r=typeof n=="string",o,l=e??{},c=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},d=g=>typeof HTMLCanvasElement<"u"&&g instanceof HTMLCanvasElement||g instanceof OffscreenCanvas?g.getContext("2d"):null;if(t){let g=c();g.width=n.width,g.height=n.height;let p=d(g);if(p!=null){let h=n.height,v=n.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(h=e.resizedHeight,v=e.resizedWidth),e!==void 0){if(l=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");l.tensorFormat="RGBA",l.height=h,l.width=v}else l.tensorFormat="RGBA",l.height=h,l.width=v;p.drawImage(n,0,0),o=p.getImageData(0,0,v,h).data}else throw new Error("Can not access image data")}else if(i){let g,p;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(g=e.resizedHeight,p=e.resizedWidth):(g=n.height,p=n.width),e!==void 0&&(l=e),l.format="RGBA",l.height=g,l.width=p,e!==void 0){let h=c();h.width=p,h.height=g;let v=d(h);if(v!=null)v.putImageData(n,0,0),o=v.getImageData(0,0,p,g).data;else throw new Error("Can not access image data")}else o=n.data}else if(s){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let g=c();g.width=n.width,g.height=n.height;let p=d(g);if(p!=null){let h=n.height,v=n.width;return p.drawImage(n,0,0,v,h),o=p.getImageData(0,0,v,h).data,l.height=h,l.width=v,EM(o,l)}else throw new Error("Can not access image data")}else{if(r)return new Promise((g,p)=>{let h=c(),v=d(h);if(!n||!v)return p();let y=new Image;y.crossOrigin="Anonymous",y.src=n,y.onload=()=>{h.width=y.width,h.height=y.height,v.drawImage(y,0,0,h.width,h.height);let w=v.getImageData(0,0,h.width,h.height);l.height=h.height,l.width=h.width,g(EM(w.data,l))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(o!==void 0)return EM(o,l);throw new Error("Input data provided is not supported - aborted tensor creation")},f3=(n,e)=>{let{width:t,height:i,download:s,dispose:r}=e,o=[1,i,t,4];return new $u({location:"texture",type:"float32",texture:n,dims:o,download:s,dispose:r})},h3=(n,e)=>{let{dataType:t,dims:i,download:s,dispose:r}=e;return new $u({location:"gpu-buffer",type:t??"float32",gpuBuffer:n,dims:i,download:s,dispose:r})},p3=(n,e)=>{let{dataType:t,dims:i,download:s,dispose:r}=e;return new $u({location:"ml-tensor",type:t??"float32",mlTensor:n,dims:i,download:s,dispose:r})},m3=(n,e,t)=>new $u({location:"cpu-pinned",type:n,data:e,dims:t??[e.length]})}),Tg,hv,v1,g3,hW=fn(()=>{Tg=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),hv=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),v1=!1,g3=()=>{if(!v1){v1=!0;let n=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,t=globalThis.Float16Array,i=typeof t<"u"&&t.from;n&&(Tg.set("int64",BigInt64Array),hv.set(BigInt64Array,"int64")),e&&(Tg.set("uint64",BigUint64Array),hv.set(BigUint64Array,"uint64")),i?(Tg.set("float16",t),hv.set(t,"float16")):Tg.set("float16",Uint16Array)}}}),_3,v3,pW=fn(()=>{lS(),_3=n=>{let e=1;for(let t=0;t<n.length;t++){let i=n[t];if(typeof i!="number"||!Number.isSafeInteger(i))throw new TypeError(`dims[${t}] must be an integer, got: ${i}`);if(i<0)throw new RangeError(`dims[${t}] must be a non-negative integer, got: ${i}`);e*=i}return e},v3=(n,e)=>{switch(n.location){case"cpu":return new $u(n.type,n.data,e);case"cpu-pinned":return new $u({location:"cpu-pinned",data:n.data,type:n.type,dims:e});case"texture":return new $u({location:"texture",texture:n.texture,type:n.type,dims:e});case"gpu-buffer":return new $u({location:"gpu-buffer",gpuBuffer:n.gpuBuffer,type:n.type,dims:e});case"ml-tensor":return new $u({location:"ml-tensor",mlTensor:n.mlTensor,type:n.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${n.location} is not supported`)}}}),$u,lS=fn(()=>{dW(),fW(),hW(),pW(),$u=class{constructor(n,e,t){g3();let i,s;if(typeof n=="object"&&"location"in n)switch(this.dataLocation=n.location,i=n.type,s=n.dims,n.location){case"cpu-pinned":{let o=Tg.get(i);if(!o)throw new TypeError(`unsupported type "${i}" to create tensor from pinned buffer`);if(!(n.data instanceof o))throw new TypeError(`buffer should be of type ${o.name}`);this.cpuData=n.data;break}case"texture":{if(i!=="float32")throw new TypeError(`unsupported type "${i}" to create tensor from texture`);this.gpuTextureData=n.texture,this.downloader=n.download,this.disposer=n.dispose;break}case"gpu-buffer":{if(i!=="float32"&&i!=="float16"&&i!=="int32"&&i!=="int64"&&i!=="uint32"&&i!=="uint8"&&i!=="bool"&&i!=="uint4"&&i!=="int4")throw new TypeError(`unsupported type "${i}" to create tensor from gpu buffer`);this.gpuBufferData=n.gpuBuffer,this.downloader=n.download,this.disposer=n.dispose;break}case"ml-tensor":{if(i!=="float32"&&i!=="float16"&&i!=="int32"&&i!=="int64"&&i!=="uint32"&&i!=="uint64"&&i!=="int8"&&i!=="uint8"&&i!=="bool"&&i!=="uint4"&&i!=="int4")throw new TypeError(`unsupported type "${i}" to create tensor from MLTensor`);this.mlTensorData=n.mlTensor,this.downloader=n.download,this.disposer=n.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,l;if(typeof n=="string")if(i=n,l=t,n==="string"){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");o=e}else{let c=Tg.get(n);if(c===void 0)throw new TypeError(`Unsupported tensor type: ${n}.`);if(Array.isArray(e)){if(n==="float16"&&c===Uint16Array||n==="uint4"||n==="int4")throw new TypeError(`Creating a ${n} tensor from number array is not supported. Please use ${c.name} as data.`);n==="uint64"||n==="int64"?o=c.from(e,BigInt):o=c.from(e)}else if(e instanceof c)o=e;else if(e instanceof Uint8ClampedArray)if(n==="uint8")o=Uint8Array.from(e);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(n==="float16"&&e instanceof Uint16Array&&c!==Uint16Array)o=new globalThis.Float16Array(e.buffer,e.byteOffset,e.length);else throw new TypeError(`A ${i} tensor's data must be type of ${c}`)}else if(l=e,Array.isArray(n)){if(n.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let c=typeof n[0];if(c==="string")i="string",o=n;else if(c==="boolean")i="bool",o=Uint8Array.from(n);else throw new TypeError(`Invalid element type of data array: ${c}.`)}else if(n instanceof Uint8ClampedArray)i="uint8",o=Uint8Array.from(n);else{let c=hv.get(n.constructor);if(c===void 0)throw new TypeError(`Unsupported type for tensor data: ${n.constructor}.`);i=c,o=n}if(l===void 0)l=[o.length];else if(!Array.isArray(l))throw new TypeError("A tensor's dims must be a number array");s=l,this.cpuData=o,this.dataLocation="cpu"}let r=_3(s);if(this.cpuData&&r!==this.cpuData.length&&!((i==="uint4"||i==="int4")&&Math.ceil(r/2)===this.cpuData.length))throw new Error(`Tensor's size(${r}) does not match data length(${this.cpuData.length}).`);this.type=i,this.dims=s,this.size=r}static async fromImage(n,e){return d3(n,e)}static fromTexture(n,e){return f3(n,e)}static fromGpuBuffer(n,e){return h3(n,e)}static fromMLTensor(n,e){return p3(n,e)}static fromPinnedBuffer(n,e,t){return m3(n,e,t)}toDataURL(n){return u3(this,n)}toImageData(n){return c3(this,n)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(n){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let e=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=e,n&&this.disposer&&(this.disposer(),this.disposer=void 0),e}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(n){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return v3(this,n)}}}),Id,y3=fn(()=>{lS(),Id=$u}),Hv,y1,zd,Fc,M3=fn(()=>{l3(),Hv=(n,e)=>{(typeof Bc.trace>"u"?!Bc.wasm.trace:!Bc.trace)||console.timeStamp(`${n}::ORT::${e}`)},y1=(n,e)=>{let t=new Error().stack?.split(/\r\n|\r|\n/g)||[],i=!1;for(let s=0;s<t.length;s++){if(i&&!t[s].includes("TRACE_FUNC")){let r=`FUNC_${n}::${t[s].trim().split(" ")[1]}`;e&&(r+=`::${e}`),Hv("CPU",r);return}t[s].includes("TRACE_FUNC")&&(i=!0)}},zd=n=>{(typeof Bc.trace>"u"?!Bc.wasm.trace:!Bc.trace)||y1("BEGIN",n)},Fc=n=>{(typeof Bc.trace>"u"?!Bc.wasm.trace:!Bc.trace)||y1("END",n)}}),b3,mW=fn(()=>{a3(),y3(),M3(),b3=class x3{constructor(e){this.handler=e}async run(e,t,i){zd();let s={},r={};if(typeof e!="object"||e===null||e instanceof Id||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if(typeof t=="object"){if(t===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Id)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(t.length===0)throw new TypeError("'fetches' cannot be an empty array.");o=!1;for(let d of t){if(typeof d!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(d)===-1)throw new RangeError(`'fetches' contains invalid output name: ${d}.`);s[d]=null}if(typeof i=="object"&&i!==null)r=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let d=!1,g=Object.getOwnPropertyNames(t);for(let p of this.outputNames)if(g.indexOf(p)!==-1){let h=t[p];(h===null||h instanceof Id)&&(d=!0,o=!1,s[p]=h)}if(d){if(typeof i=="object"&&i!==null)r=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else r=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let d of this.inputNames)if(typeof e[d]>"u")throw new Error(`input '${d}' is missing in 'feeds'.`);if(o)for(let d of this.outputNames)s[d]=null;let l=await this.handler.run(e,s,r),c={};for(let d in l)if(Object.hasOwnProperty.call(l,d)){let g=l[d];g instanceof Id?c[d]=g:c[d]=new Id(g.type,g.data,g.dims)}return Fc(),c}async release(){return this.handler.dispose()}static async create(e,t,i,s){zd();let r,o={};if(typeof e=="string"){if(r=e,typeof t=="object"&&t!==null)o=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(r=e,typeof t=="object"&&t!==null)o=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let g=e,p=0,h=e.byteLength;if(typeof t=="object"&&t!==null)o=t;else if(typeof t=="number"){if(p=t,!Number.isSafeInteger(p))throw new RangeError("'byteOffset' must be an integer.");if(p<0||p>=g.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${g.byteLength}).`);if(h=e.byteLength-p,typeof i=="number"){if(h=i,!Number.isSafeInteger(h))throw new RangeError("'byteLength' must be an integer.");if(h<=0||p+h>g.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${g.byteLength-p}].`);if(typeof s=="object"&&s!==null)o=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(typeof i<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof t<"u")throw new TypeError("'options' must be an object.");r=new Uint8Array(g,p,h)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[l,c]=await r3(o),d=await l.createInferenceSessionHandler(r,c);return Fc(),new x3(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),uS,gW=fn(()=>{mW(),uS=b3}),_W=fn(()=>{}),vW=fn(()=>{}),yW=fn(()=>{}),MW=fn(()=>{}),w3={};E0(w3,{InferenceSession:()=>uS,TRACE:()=>Hv,TRACE_FUNC_BEGIN:()=>zd,TRACE_FUNC_END:()=>Fc,Tensor:()=>Id,env:()=>ur,registerBackend:()=>Ig});var Gd=fn(()=>{lW(),cW(),gW(),y3(),_W(),vW(),M3(),yW(),MW()}),cS=fn(()=>{}),E3={};E0(E3,{default:()=>T3});var M1,b1,T3,bW=fn(()=>{RN(),n_(),dS(),M1="ort-wasm-proxy-worker",b1=globalThis.self?.name===M1,b1&&(self.onmessage=n=>{let{type:e,in:t}=n.data;try{switch(e){case"init-wasm":fS(t.wasm).then(()=>{RS(t).then(()=>{postMessage({type:e})},i=>{postMessage({type:e,err:i})})},i=>{postMessage({type:e,err:i})});break;case"init-ep":{let{epName:i,env:s}=t;DS(s,i).then(()=>{postMessage({type:e})},r=>{postMessage({type:e,err:r})});break}case"copy-from":{let{buffer:i}=t,s=$b(i);postMessage({type:e,out:s});break}case"create":{let{model:i,options:s}=t;BS(i,s).then(r=>{postMessage({type:e,out:r})},r=>{postMessage({type:e,err:r})});break}case"release":IS(t),postMessage({type:e});break;case"run":{let{sessionId:i,inputIndices:s,inputs:r,outputIndices:o,options:l}=t;OS(i,s,r,o,new Array(o.length).fill(null),l).then(c=>{c.some(d=>d[3]!=="cpu")?postMessage({type:e,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:e,out:c},FS([...r,...c]))},c=>{postMessage({type:e,err:c})});break}case"end-profiling":LS(t),postMessage({type:e});break;default:}}catch(i){postMessage({type:e,err:i})}}),T3=b1?null:n=>new Worker(n??Hu,{type:"module",name:M1})}),S3={};E0(S3,{default:()=>A3});var x1,w1,A3,H2,xW=fn(()=>{w1=(x1=import.meta.url,async function(n={}){var e,t,i=n,s=new Promise((G,Z)=>{e=G,t=Z}),r=typeof window=="object",o=typeof WorkerGlobalScope<"u",l=o&&self.name?.startsWith("em-pthread");i.mountExternalData=(G,Z)=>{G.startsWith("./")&&(G=G.substring(2)),(i.Eb||(i.Eb=new Map)).set(G,Z)},i.unmountExternalData=()=>{delete i.Eb};var c=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,pc:!0}).buffer.constructor;let d=G=>async(...Z)=>{try{if(i.Fb)throw Error("Session already started");let _e=i.Fb={dc:Z[0],errors:[]},Te=await G(...Z);if(i.Fb!==_e)throw Error("Session mismatch");i.Jb?.flush();let Re=_e.errors;if(0<Re.length){let ct=await Promise.all(Re);if(ct=ct.filter(Nt=>Nt),0<ct.length)throw Error(ct.join(`
`))}return Te}finally{i.Fb=null}};i.jsepInit=(G,Z)=>{if(G==="webgpu"){[i.Jb,i.Ub,i.Yb,i.Kb,i.Xb,i.jb,i.Zb,i.ac,i.Vb,i.Wb,i.$b]=Z;let _e=i.Jb;i.jsepRegisterBuffer=(Te,Re,ct,Nt)=>_e.registerBuffer(Te,Re,ct,Nt),i.jsepGetBuffer=Te=>_e.getBuffer(Te),i.jsepCreateDownloader=(Te,Re,ct)=>_e.createDownloader(Te,Re,ct),i.jsepOnCreateSession=Te=>{_e.onCreateSession(Te)},i.jsepOnReleaseSession=Te=>{_e.onReleaseSession(Te)},i.jsepOnRunStart=Te=>_e.onRunStart(Te),i.bc=(Te,Re)=>{_e.upload(Te,Re)}}else if(G==="webnn"){let _e=Z[0];[i.nc,i.Nb,i.webnnEnsureTensor,i.Ob,i.webnnDownloadTensor]=Z.slice(1),i.webnnReleaseTensorId=i.Nb,i.webnnUploadTensor=i.Ob,i.webnnOnRunStart=Te=>_e.onRunStart(Te),i.webnnOnRunEnd=_e.onRunEnd.bind(_e),i.webnnRegisterMLContext=(Te,Re)=>{_e.registerMLContext(Te,Re)},i.webnnOnReleaseSession=Te=>{_e.onReleaseSession(Te)},i.webnnCreateMLTensorDownloader=(Te,Re)=>_e.createMLTensorDownloader(Te,Re),i.webnnRegisterMLTensor=(Te,Re,ct,Nt)=>_e.registerMLTensor(Te,Re,ct,Nt),i.webnnCreateMLContext=Te=>_e.createMLContext(Te),i.webnnRegisterMLConstant=(Te,Re,ct,Nt,sn,pn)=>_e.registerMLConstant(Te,Re,ct,Nt,sn,i.Eb,pn),i.webnnRegisterGraphInput=_e.registerGraphInput.bind(_e),i.webnnIsGraphInput=_e.isGraphInput.bind(_e),i.webnnCreateTemporaryTensor=_e.createTemporaryTensor.bind(_e),i.webnnIsInt64Supported=_e.isInt64Supported.bind(_e)}};let g=()=>{let G=(Z,_e,Te)=>(...Re)=>{let ct=ps,Nt=_e?.();Re=Z(...Re);let sn=_e?.();return Nt!==sn&&(Z=sn,Te(Nt),_e=Te=null),ps!=ct?new Promise((pn,On)=>{es={resolve:pn,reject:On}}):Re};(()=>{for(let Z of["_OrtAppendExecutionProvider","_OrtCreateSession","_OrtRun","_OrtRunWithBinding","_OrtBindInput"])i[Z]=G(i[Z],()=>i[Z],_e=>i[Z]=_e)})(),d!==void 0&&(i._OrtRun=d(i._OrtRun),i._OrtRunWithBinding=d(i._OrtRunWithBinding)),g=void 0};i.asyncInit=()=>{g?.()};var p,h,v=Object.assign({},i),y=(G,Z)=>{throw Z},w="";(r||o)&&(o?w=self.location.href:typeof document<"u"&&document.currentScript&&(w=document.currentScript.src),x1&&(w=x1),w=w.startsWith("blob:")?"":w.slice(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1),o&&(h=G=>{var Z=new XMLHttpRequest;return Z.open("GET",G,!1),Z.responseType="arraybuffer",Z.send(null),new Uint8Array(Z.response)}),p=async G=>{if(pe(G))return new Promise((_e,Te)=>{var Re=new XMLHttpRequest;Re.open("GET",G,!0),Re.responseType="arraybuffer",Re.onload=()=>{Re.status==200||Re.status==0&&Re.response?_e(Re.response):Te(Re.status)},Re.onerror=Te,Re.send(null)});var Z=await fetch(G,{credentials:"same-origin"});if(Z.ok)return Z.arrayBuffer();throw Error(Z.status+" : "+Z.url)});var S=console.log.bind(console),M=console.error.bind(console),T=S,C=M;Object.assign(i,v),v=null;var x,R,P,D,z,U,N,j,J,W,oe,ne,q,le=i.wasmBinary,se=!1,pe=G=>G.startsWith("file://");function be(){return x.buffer!=D.buffer&&tt(),D}function ee(){return x.buffer!=D.buffer&&tt(),z}function te(){return x.buffer!=D.buffer&&tt(),U}function ue(){return x.buffer!=D.buffer&&tt(),N}function ae(){return x.buffer!=D.buffer&&tt(),j}function ce(){return x.buffer!=D.buffer&&tt(),J}function Be(){return x.buffer!=D.buffer&&tt(),W}function He(){return x.buffer!=D.buffer&&tt(),q}if(l){let G=function(Z){try{var _e=Z.data,Te=_e.Bb;if(Te==="load"){let Re=[];self.onmessage=ct=>Re.push(ct),self.startWorker=()=>{postMessage({Bb:"loaded"});for(let ct of Re)G(ct);self.onmessage=G};for(let ct of _e.Rb)i[ct]&&!i[ct].proxy||(i[ct]=(...Nt)=>{postMessage({Bb:"callHandler",Qb:ct,args:Nt})},ct=="print"&&(T=i[ct]),ct=="printErr"&&(C=i[ct]));x=_e.kc,tt(),Xe(_e.lc)}else if(Te==="run"){Yt(_e.Ab),Xc(_e.Ab,0,0,1,0,0),Tn(),Ie(_e.Ab),ot||(qc(),ot=!0);try{qe(_e.fc,_e.Hb)}catch(Re){if(Re!="unwind")throw Re}}else _e.target!=="setimmediate"&&(Te==="checkMailbox"?ot&&Ke():Te&&(C(`worker: received unknown command ${Te}`),C(_e)))}catch(Re){throw ol(),Re}};var Xe,ot=!1;C=function(...Z){Z=Z.join(" "),console.error(Z)},self.alert=function(...Z){postMessage({Bb:"alert",text:Z.join(" "),ic:al()})},self.onunhandledrejection=Z=>{throw Z.reason||Z},self.onmessage=G}function tt(){var G=x.buffer;i.HEAP8=D=new Int8Array(G),i.HEAP16=U=new Int16Array(G),i.HEAPU8=z=new Uint8Array(G),i.HEAPU16=N=new Uint16Array(G),i.HEAP32=j=new Int32Array(G),i.HEAPU32=J=new Uint32Array(G),i.HEAPF32=W=new Float32Array(G),i.HEAPF64=q=new Float64Array(G),i.HEAP64=oe=new BigInt64Array(G),i.HEAPU64=ne=new BigUint64Array(G)}function Ae(){l?startWorker(i):yn.Ca()}l||(x=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),tt());var ye,xe=0,ke=null;function ze(){if(--xe==0&&ke){var G=ke;ke=null,G()}}function je(G){throw C(G="Aborted("+G+")"),se=!0,G=new WebAssembly.RuntimeError(G+". Build with -sASSERTIONS for more info."),t(G),G}function Fe(){return{a:{L:Qe,Aa:Ve,b:rn,$:B,A:K,pa:Ee,X:Q,Z:ve,qa:ge,na:Le,ga:rt,ma:nt,J:ft,Y:yt,V:Ne,oa:Bt,W:on,va:bi,E:Je,Q:Ot,O:ti,D:Ln,u:Ct,r:gt,P:Qt,z:$s,R:Ds,ja:lt,T:Ze,aa:$t,M:vn,F:bn,ia:Ie,sa:En,t:ni,Ba:Ms,w:Fr,o:Ks,l:Pi,c:en,n:Ns,j:ec,v:uu,p:tc,f:Vf,s:qs,m:Hf,e:jf,k:Uc,i:$f,g:Wf,d:Do,da:Vd,ea:$d,fa:Gc,ba:Wd,ca:cu,N:Vc,xa:Hc,ua:tl,h:Yd,C:fo,G:Bo,ta:qd,x:Jd,ra:Qd,U:Bl,q:Kd,y:nl,K:Il,S:Ar,za:rl,ya:Io,ka:jc,la:$c,_:Et,B:Ol,I:fu,ha:Wc,H:Kc,a:x,wa:ht}}}var Ye={829644:(G,Z,_e,Te,Re)=>{if(i===void 0||!i.Eb)return 1;if((G=F(Number(G>>>0))).startsWith("./")&&(G=G.substring(2)),!(G=i.Eb.get(G)))return 2;if(Z=Number(Z>>>0),_e=Number(_e>>>0),Te=Number(Te>>>0),Z+_e>G.byteLength)return 3;try{let ct=G.subarray(Z,Z+_e);switch(Re){case 0:ee().set(ct,Te>>>0);break;case 1:i.mc?i.mc(Te,ct):i.bc(Te,ct);break;default:return 4}return 0}catch{return 4}},830468:(G,Z,_e)=>{i.Ob(G,ee().subarray(Z>>>0,Z+_e>>>0))},830532:()=>i.nc(),830574:G=>{i.Nb(G)},830611:()=>{i.Vb()},830642:()=>{i.Wb()},830671:()=>{i.$b()},830696:G=>i.Ub(G),830729:G=>i.Yb(G),830761:(G,Z,_e)=>{i.Kb(Number(G),Number(Z),Number(_e),!0)},830824:(G,Z,_e)=>{i.Kb(Number(G),Number(Z),Number(_e))},830881:()=>typeof wasmOffsetConverter<"u",830938:G=>{i.jb("Abs",G,void 0)},830989:G=>{i.jb("Neg",G,void 0)},831040:G=>{i.jb("Floor",G,void 0)},831093:G=>{i.jb("Ceil",G,void 0)},831145:G=>{i.jb("Reciprocal",G,void 0)},831203:G=>{i.jb("Sqrt",G,void 0)},831255:G=>{i.jb("Exp",G,void 0)},831306:G=>{i.jb("Erf",G,void 0)},831357:G=>{i.jb("Sigmoid",G,void 0)},831412:(G,Z,_e)=>{i.jb("HardSigmoid",G,{alpha:Z,beta:_e})},831491:G=>{i.jb("Log",G,void 0)},831542:G=>{i.jb("Sin",G,void 0)},831593:G=>{i.jb("Cos",G,void 0)},831644:G=>{i.jb("Tan",G,void 0)},831695:G=>{i.jb("Asin",G,void 0)},831747:G=>{i.jb("Acos",G,void 0)},831799:G=>{i.jb("Atan",G,void 0)},831851:G=>{i.jb("Sinh",G,void 0)},831903:G=>{i.jb("Cosh",G,void 0)},831955:G=>{i.jb("Asinh",G,void 0)},832008:G=>{i.jb("Acosh",G,void 0)},832061:G=>{i.jb("Atanh",G,void 0)},832114:G=>{i.jb("Tanh",G,void 0)},832166:G=>{i.jb("Not",G,void 0)},832217:(G,Z,_e)=>{i.jb("Clip",G,{min:Z,max:_e})},832286:G=>{i.jb("Clip",G,void 0)},832338:(G,Z)=>{i.jb("Elu",G,{alpha:Z})},832396:G=>{i.jb("Gelu",G,void 0)},832448:G=>{i.jb("Relu",G,void 0)},832500:(G,Z)=>{i.jb("LeakyRelu",G,{alpha:Z})},832564:(G,Z)=>{i.jb("ThresholdedRelu",G,{alpha:Z})},832634:(G,Z)=>{i.jb("Cast",G,{to:Z})},832692:G=>{i.jb("Add",G,void 0)},832743:G=>{i.jb("Sub",G,void 0)},832794:G=>{i.jb("Mul",G,void 0)},832845:G=>{i.jb("Div",G,void 0)},832896:G=>{i.jb("Pow",G,void 0)},832947:G=>{i.jb("Equal",G,void 0)},833e3:G=>{i.jb("Greater",G,void 0)},833055:G=>{i.jb("GreaterOrEqual",G,void 0)},833117:G=>{i.jb("Less",G,void 0)},833169:G=>{i.jb("LessOrEqual",G,void 0)},833228:(G,Z,_e,Te,Re)=>{i.jb("ReduceMean",G,{keepDims:!!Z,noopWithEmptyAxes:!!_e,axes:Te?Array.from(ae().subarray(Number(Te)>>>0,Number(Re)>>>0)):[]})},833403:(G,Z,_e,Te,Re)=>{i.jb("ReduceMax",G,{keepDims:!!Z,noopWithEmptyAxes:!!_e,axes:Te?Array.from(ae().subarray(Number(Te)>>>0,Number(Re)>>>0)):[]})},833577:(G,Z,_e,Te,Re)=>{i.jb("ReduceMin",G,{keepDims:!!Z,noopWithEmptyAxes:!!_e,axes:Te?Array.from(ae().subarray(Number(Te)>>>0,Number(Re)>>>0)):[]})},833751:(G,Z,_e,Te,Re)=>{i.jb("ReduceProd",G,{keepDims:!!Z,noopWithEmptyAxes:!!_e,axes:Te?Array.from(ae().subarray(Number(Te)>>>0,Number(Re)>>>0)):[]})},833926:(G,Z,_e,Te,Re)=>{i.jb("ReduceSum",G,{keepDims:!!Z,noopWithEmptyAxes:!!_e,axes:Te?Array.from(ae().subarray(Number(Te)>>>0,Number(Re)>>>0)):[]})},834100:(G,Z,_e,Te,Re)=>{i.jb("ReduceL1",G,{keepDims:!!Z,noopWithEmptyAxes:!!_e,axes:Te?Array.from(ae().subarray(Number(Te)>>>0,Number(Re)>>>0)):[]})},834273:(G,Z,_e,Te,Re)=>{i.jb("ReduceL2",G,{keepDims:!!Z,noopWithEmptyAxes:!!_e,axes:Te?Array.from(ae().subarray(Number(Te)>>>0,Number(Re)>>>0)):[]})},834446:(G,Z,_e,Te,Re)=>{i.jb("ReduceLogSum",G,{keepDims:!!Z,noopWithEmptyAxes:!!_e,axes:Te?Array.from(ae().subarray(Number(Te)>>>0,Number(Re)>>>0)):[]})},834623:(G,Z,_e,Te,Re)=>{i.jb("ReduceSumSquare",G,{keepDims:!!Z,noopWithEmptyAxes:!!_e,axes:Te?Array.from(ae().subarray(Number(Te)>>>0,Number(Re)>>>0)):[]})},834803:(G,Z,_e,Te,Re)=>{i.jb("ReduceLogSumExp",G,{keepDims:!!Z,noopWithEmptyAxes:!!_e,axes:Te?Array.from(ae().subarray(Number(Te)>>>0,Number(Re)>>>0)):[]})},834983:G=>{i.jb("Where",G,void 0)},835036:(G,Z,_e)=>{i.jb("Transpose",G,{perm:Z?Array.from(ae().subarray(Number(Z)>>>0,Number(_e)>>>0)):[]})},835160:(G,Z,_e,Te)=>{i.jb("DepthToSpace",G,{blocksize:Z,mode:F(_e),format:Te?"NHWC":"NCHW"})},835293:(G,Z,_e,Te)=>{i.jb("DepthToSpace",G,{blocksize:Z,mode:F(_e),format:Te?"NHWC":"NCHW"})},835426:(G,Z,_e,Te,Re,ct,Nt,sn,pn,On,Zn,hi,zi,ki,ga)=>{i.jb("ConvTranspose",G,{format:pn?"NHWC":"NCHW",autoPad:Z,dilations:[_e],group:Te,kernelShape:[Re],pads:[ct,Nt],strides:[sn],wIsConst:()=>!!be()[On>>>0],outputPadding:Zn?Array.from(ae().subarray(Number(Zn)>>>0,Number(hi)>>>0)):[],outputShape:zi?Array.from(ae().subarray(Number(zi)>>>0,Number(ki)>>>0)):[],activation:F(ga)})},835859:(G,Z,_e,Te,Re,ct,Nt,sn,pn,On,Zn,hi,zi,ki)=>{i.jb("ConvTranspose",G,{format:sn?"NHWC":"NCHW",autoPad:Z,dilations:Array.from(ae().subarray(Number(_e)>>>0,2+(Number(_e)>>>0)>>>0)),group:Te,kernelShape:Array.from(ae().subarray(Number(Re)>>>0,2+(Number(Re)>>>0)>>>0)),pads:Array.from(ae().subarray(Number(ct)>>>0,4+(Number(ct)>>>0)>>>0)),strides:Array.from(ae().subarray(Number(Nt)>>>0,2+(Number(Nt)>>>0)>>>0)),wIsConst:()=>!!be()[pn>>>0],outputPadding:On?Array.from(ae().subarray(Number(On)>>>0,Number(Zn)>>>0)):[],outputShape:hi?Array.from(ae().subarray(Number(hi)>>>0,Number(zi)>>>0)):[],activation:F(ki)})},836520:(G,Z,_e,Te,Re,ct,Nt,sn,pn,On,Zn,hi,zi,ki,ga)=>{i.jb("ConvTranspose",G,{format:pn?"NHWC":"NCHW",autoPad:Z,dilations:[_e],group:Te,kernelShape:[Re],pads:[ct,Nt],strides:[sn],wIsConst:()=>!!be()[On>>>0],outputPadding:Zn?Array.from(ae().subarray(Number(Zn)>>>0,Number(hi)>>>0)):[],outputShape:zi?Array.from(ae().subarray(Number(zi)>>>0,Number(ki)>>>0)):[],activation:F(ga)})},836953:(G,Z,_e,Te,Re,ct,Nt,sn,pn,On,Zn,hi,zi,ki)=>{i.jb("ConvTranspose",G,{format:sn?"NHWC":"NCHW",autoPad:Z,dilations:Array.from(ae().subarray(Number(_e)>>>0,2+(Number(_e)>>>0)>>>0)),group:Te,kernelShape:Array.from(ae().subarray(Number(Re)>>>0,2+(Number(Re)>>>0)>>>0)),pads:Array.from(ae().subarray(Number(ct)>>>0,4+(Number(ct)>>>0)>>>0)),strides:Array.from(ae().subarray(Number(Nt)>>>0,2+(Number(Nt)>>>0)>>>0)),wIsConst:()=>!!be()[pn>>>0],outputPadding:On?Array.from(ae().subarray(Number(On)>>>0,Number(Zn)>>>0)):[],outputShape:hi?Array.from(ae().subarray(Number(hi)>>>0,Number(zi)>>>0)):[],activation:F(ki)})},837614:(G,Z)=>{i.jb("GlobalAveragePool",G,{format:Z?"NHWC":"NCHW"})},837705:(G,Z,_e,Te,Re,ct,Nt,sn,pn,On,Zn,hi,zi,ki)=>{i.jb("AveragePool",G,{format:ki?"NHWC":"NCHW",auto_pad:Z,ceil_mode:_e,count_include_pad:Te,storage_order:Re,dilations:ct?Array.from(ae().subarray(Number(ct)>>>0,Number(Nt)>>>0)):[],kernel_shape:sn?Array.from(ae().subarray(Number(sn)>>>0,Number(pn)>>>0)):[],pads:On?Array.from(ae().subarray(Number(On)>>>0,Number(Zn)>>>0)):[],strides:hi?Array.from(ae().subarray(Number(hi)>>>0,Number(zi)>>>0)):[]})},838184:(G,Z)=>{i.jb("GlobalAveragePool",G,{format:Z?"NHWC":"NCHW"})},838275:(G,Z,_e,Te,Re,ct,Nt,sn,pn,On,Zn,hi,zi,ki)=>{i.jb("AveragePool",G,{format:ki?"NHWC":"NCHW",auto_pad:Z,ceil_mode:_e,count_include_pad:Te,storage_order:Re,dilations:ct?Array.from(ae().subarray(Number(ct)>>>0,Number(Nt)>>>0)):[],kernel_shape:sn?Array.from(ae().subarray(Number(sn)>>>0,Number(pn)>>>0)):[],pads:On?Array.from(ae().subarray(Number(On)>>>0,Number(Zn)>>>0)):[],strides:hi?Array.from(ae().subarray(Number(hi)>>>0,Number(zi)>>>0)):[]})},838754:(G,Z)=>{i.jb("GlobalMaxPool",G,{format:Z?"NHWC":"NCHW"})},838841:(G,Z,_e,Te,Re,ct,Nt,sn,pn,On,Zn,hi,zi,ki)=>{i.jb("MaxPool",G,{format:ki?"NHWC":"NCHW",auto_pad:Z,ceil_mode:_e,count_include_pad:Te,storage_order:Re,dilations:ct?Array.from(ae().subarray(Number(ct)>>>0,Number(Nt)>>>0)):[],kernel_shape:sn?Array.from(ae().subarray(Number(sn)>>>0,Number(pn)>>>0)):[],pads:On?Array.from(ae().subarray(Number(On)>>>0,Number(Zn)>>>0)):[],strides:hi?Array.from(ae().subarray(Number(hi)>>>0,Number(zi)>>>0)):[]})},839316:(G,Z)=>{i.jb("GlobalMaxPool",G,{format:Z?"NHWC":"NCHW"})},839403:(G,Z,_e,Te,Re,ct,Nt,sn,pn,On,Zn,hi,zi,ki)=>{i.jb("MaxPool",G,{format:ki?"NHWC":"NCHW",auto_pad:Z,ceil_mode:_e,count_include_pad:Te,storage_order:Re,dilations:ct?Array.from(ae().subarray(Number(ct)>>>0,Number(Nt)>>>0)):[],kernel_shape:sn?Array.from(ae().subarray(Number(sn)>>>0,Number(pn)>>>0)):[],pads:On?Array.from(ae().subarray(Number(On)>>>0,Number(Zn)>>>0)):[],strides:hi?Array.from(ae().subarray(Number(hi)>>>0,Number(zi)>>>0)):[]})},839878:(G,Z,_e,Te,Re)=>{i.jb("Gemm",G,{alpha:Z,beta:_e,transA:Te,transB:Re})},839982:G=>{i.jb("MatMul",G,void 0)},840036:(G,Z,_e,Te)=>{i.jb("ArgMax",G,{keepDims:!!Z,selectLastIndex:!!_e,axis:Te})},840144:(G,Z,_e,Te)=>{i.jb("ArgMin",G,{keepDims:!!Z,selectLastIndex:!!_e,axis:Te})},840252:(G,Z)=>{i.jb("Softmax",G,{axis:Z})},840315:(G,Z)=>{i.jb("Concat",G,{axis:Z})},840375:(G,Z,_e,Te,Re)=>{i.jb("Split",G,{axis:Z,numOutputs:_e,splitSizes:Te?Array.from(ae().subarray(Number(Te)>>>0,Number(Re)>>>0)):[]})},840531:G=>{i.jb("Expand",G,void 0)},840585:(G,Z)=>{i.jb("Gather",G,{axis:Number(Z)})},840656:(G,Z)=>{i.jb("GatherElements",G,{axis:Number(Z)})},840735:(G,Z)=>{i.jb("GatherND",G,{batch_dims:Number(Z)})},840814:(G,Z,_e,Te,Re,ct,Nt,sn,pn,On,Zn)=>{i.jb("Resize",G,{antialias:Z,axes:_e?Array.from(ae().subarray(Number(_e)>>>0,Number(Te)>>>0)):[],coordinateTransformMode:F(Re),cubicCoeffA:ct,excludeOutside:Nt,extrapolationValue:sn,keepAspectRatioPolicy:F(pn),mode:F(On),nearestMode:F(Zn)})},841176:(G,Z,_e,Te,Re,ct,Nt)=>{i.jb("Slice",G,{starts:Z?Array.from(ae().subarray(Number(Z)>>>0,Number(_e)>>>0)):[],ends:Te?Array.from(ae().subarray(Number(Te)>>>0,Number(Re)>>>0)):[],axes:ct?Array.from(ae().subarray(Number(ct)>>>0,Number(Nt)>>>0)):[]})},841440:G=>{i.jb("Tile",G,void 0)},841492:(G,Z,_e)=>{i.jb("InstanceNormalization",G,{epsilon:Z,format:_e?"NHWC":"NCHW"})},841606:(G,Z,_e)=>{i.jb("InstanceNormalization",G,{epsilon:Z,format:_e?"NHWC":"NCHW"})},841720:G=>{i.jb("Range",G,void 0)},841773:(G,Z)=>{i.jb("Einsum",G,{equation:F(Z)})},841854:(G,Z,_e,Te,Re)=>{i.jb("Pad",G,{mode:Z,value:_e,pads:Te?Array.from(ae().subarray(Number(Te)>>>0,Number(Re)>>>0)):[]})},841997:(G,Z,_e,Te,Re,ct)=>{i.jb("BatchNormalization",G,{epsilon:Z,momentum:_e,spatial:!!Re,trainingMode:!!Te,format:ct?"NHWC":"NCHW"})},842166:(G,Z,_e,Te,Re,ct)=>{i.jb("BatchNormalization",G,{epsilon:Z,momentum:_e,spatial:!!Re,trainingMode:!!Te,format:ct?"NHWC":"NCHW"})},842335:(G,Z,_e)=>{i.jb("CumSum",G,{exclusive:Number(Z),reverse:Number(_e)})},842432:(G,Z,_e)=>{i.jb("DequantizeLinear",G,{axis:Z,blockSize:_e})},842522:(G,Z,_e,Te,Re)=>{i.jb("GridSample",G,{align_corners:Z,mode:F(_e),padding_mode:F(Te),format:Re?"NHWC":"NCHW"})},842692:(G,Z,_e,Te,Re)=>{i.jb("GridSample",G,{align_corners:Z,mode:F(_e),padding_mode:F(Te),format:Re?"NHWC":"NCHW"})},842862:(G,Z)=>{i.jb("ScatterND",G,{reduction:F(Z)})},842947:(G,Z,_e,Te,Re,ct,Nt,sn,pn)=>{i.jb("Attention",G,{numHeads:Z,isUnidirectional:_e,maskFilterValue:Te,scale:Re,doRotary:ct,qkvHiddenSizes:Nt?Array.from(ae().subarray(Number(sn)>>>0,Number(sn)+Nt>>>0)):[],pastPresentShareBuffer:!!pn})},843219:G=>{i.jb("BiasAdd",G,void 0)},843274:G=>{i.jb("BiasSplitGelu",G,void 0)},843335:G=>{i.jb("FastGelu",G,void 0)},843391:(G,Z,_e,Te,Re,ct,Nt,sn,pn,On,Zn,hi,zi,ki,ga,dr)=>{i.jb("Conv",G,{format:hi?"NHWC":"NCHW",auto_pad:Z,dilations:_e?Array.from(ae().subarray(Number(_e)>>>0,Number(Te)>>>0)):[],group:Re,kernel_shape:ct?Array.from(ae().subarray(Number(ct)>>>0,Number(Nt)>>>0)):[],pads:sn?Array.from(ae().subarray(Number(sn)>>>0,Number(pn)>>>0)):[],strides:On?Array.from(ae().subarray(Number(On)>>>0,Number(Zn)>>>0)):[],w_is_const:()=>!!be()[Number(zi)>>>0],activation:F(ki),activation_params:ga?Array.from(Be().subarray(Number(ga)>>>0,Number(dr)>>>0)):[]})},843975:G=>{i.jb("Gelu",G,void 0)},844027:(G,Z,_e,Te,Re,ct,Nt,sn,pn)=>{i.jb("GroupQueryAttention",G,{numHeads:Z,kvNumHeads:_e,scale:Te,softcap:Re,doRotary:ct,rotaryInterleaved:Nt,smoothSoftmax:sn,localWindowSize:pn})},844244:(G,Z,_e,Te)=>{i.jb("LayerNormalization",G,{axis:Z,epsilon:_e,simplified:!!Te})},844355:(G,Z,_e,Te)=>{i.jb("LayerNormalization",G,{axis:Z,epsilon:_e,simplified:!!Te})},844466:(G,Z,_e,Te,Re,ct)=>{i.jb("MatMulNBits",G,{k:Z,n:_e,accuracyLevel:Te,bits:Re,blockSize:ct})},844593:(G,Z,_e,Te,Re,ct)=>{i.jb("MultiHeadAttention",G,{numHeads:Z,isUnidirectional:_e,maskFilterValue:Te,scale:Re,doRotary:ct})},844752:(G,Z)=>{i.jb("QuickGelu",G,{alpha:Z})},844816:(G,Z,_e,Te,Re)=>{i.jb("RotaryEmbedding",G,{interleaved:!!Z,numHeads:_e,rotaryEmbeddingDim:Te,scale:Re})},844955:(G,Z,_e)=>{i.jb("SkipLayerNormalization",G,{epsilon:Z,simplified:!!_e})},845057:(G,Z,_e)=>{i.jb("SkipLayerNormalization",G,{epsilon:Z,simplified:!!_e})},845159:(G,Z,_e,Te)=>{i.jb("GatherBlockQuantized",G,{gatherAxis:Z,quantizeAxis:_e,blockSize:Te})},845280:G=>{i.Zb(G)},845314:(G,Z)=>i.ac(Number(G),Number(Z),i.Fb.dc,i.Fb.errors)};function Ve(G,Z,_e){return Sr(async()=>{await i.Xb(Number(G),Number(Z),Number(_e))})}function Qe(){return typeof wasmOffsetConverter<"u"}class mt{name="ExitStatus";constructor(Z){this.message=`Program terminated with exit(${Z})`,this.status=Z}}var Tt=G=>{G.terminate(),G.onmessage=()=>{}},Me=[],me=G=>{Dt.length==0&&(vt(),We(Dt[0]));var Z=Dt.pop();if(!Z)return 6;Vt.push(Z),bt[G.Ab]=Z,Z.Ab=G.Ab;var _e={Bb:"run",fc:G.ec,Hb:G.Hb,Ab:G.Ab};return Z.postMessage(_e,G.Mb),0},$e=0,et=(G,Z,..._e)=>{for(var Te=2*_e.length,Re=ll(),ct=Yc(8*Te),Nt=ct>>>3,sn=0;sn<_e.length;sn++){var pn=_e[sn];typeof pn=="bigint"?(oe[Nt+2*sn]=1n,oe[Nt+2*sn+1]=pn):(oe[Nt+2*sn]=0n,He()[Nt+2*sn+1>>>0]=pn)}return G=gs(G,0,Te,ct,Z),po(Re),G};function ht(G){if(l)return et(0,1,G);if(P=G,!(0<$e)){for(var Z of Vt)Tt(Z);for(Z of Dt)Tt(Z);Dt=[],Vt=[],bt={},se=!0}y(0,new mt(G))}function at(G){if(l)return et(1,0,G);Et(G)}var Et=G=>{if(P=G,l)throw at(G),"unwind";ht(G)},Dt=[],Vt=[],an=[],bt={},Jt=G=>{var Z=G.Ab;delete bt[Z],Dt.push(G),Vt.splice(Vt.indexOf(G),1),G.Ab=0,Fl(Z)};function Tn(){an.forEach(G=>G())}var We=G=>new Promise(Z=>{G.onmessage=Re=>{var ct=(Re=Re.data).Bb;if(Re.Gb&&Re.Gb!=al()){var Nt=bt[Re.Gb];Nt?Nt.postMessage(Re,Re.Mb):C(`Internal error! Worker sent a message "${ct}" to target pthread ${Re.Gb}, but that thread no longer exists!`)}else ct==="checkMailbox"?Ke():ct==="spawnThread"?me(Re):ct==="cleanupThread"?Jt(bt[Re.hc]):ct==="loaded"?(G.loaded=!0,Z(G)):ct==="alert"?alert(`Thread ${Re.ic}: ${Re.text}`):Re.target==="setimmediate"?G.postMessage(Re):ct==="callHandler"?i[Re.Qb](...Re.args):ct&&C(`worker sent an unknown command ${ct}`)},G.onerror=Re=>{throw C(`worker sent an error! ${Re.filename}:${Re.lineno}: ${Re.message}`),Re};var _e,Te=[];for(_e of[])i.propertyIsEnumerable(_e)&&Te.push(_e);G.postMessage({Bb:"load",Rb:Te,kc:x,lc:R})});function vt(){var G=new Worker((()=>{let Z=URL;return import.meta.url>"file:"&&import.meta.url<"file;"?new Z("ort.bundle.min.mjs",import.meta.url):new URL(import.meta.url)})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});Dt.push(G)}var Yt=G=>{tt();var Z=ce()[G+52>>>2>>>0];G=ce()[G+56>>>2>>>0],uc(Z,Z-G),po(Z)},qe=(G,Z)=>{$e=0,G=mu(G,Z),0<$e?P=G:ac(G)};class Kt{constructor(Z){this.Ib=Z-24}}function rn(G,Z,_e){var Te=new Kt(G>>>=0);throw Z>>>=0,_e>>>=0,ce()[Te.Ib+16>>>2>>>0]=0,ce()[Te.Ib+4>>>2>>>0]=Z,ce()[Te.Ib+8>>>2>>>0]=_e,G}function fe(G,Z,_e,Te){return l?et(2,1,G,Z,_e,Te):B(G,Z,_e,Te)}function B(G,Z,_e,Te){if(G>>>=0,_e>>>=0,Te>>>=0,c===void 0)return 6;var Re=[];return l&&Re.length===0?fe(G,Z>>>=0,_e,Te):(G={ec:_e,Ab:G,Hb:Te,Mb:Re},l?(G.Bb="spawnThread",postMessage(G,Re),0):me(G))}var I=typeof TextDecoder<"u"?new TextDecoder:void 0,A=(G,Z=0,_e=NaN)=>{var Te=(Z>>>=0)+_e;for(_e=Z;G[_e]&&!(_e>=Te);)++_e;if(16<_e-Z&&G.buffer&&I)return I.decode(G.buffer instanceof ArrayBuffer?G.subarray(Z,_e):G.slice(Z,_e));for(Te="";Z<_e;){var Re=G[Z++];if(128&Re){var ct=63&G[Z++];if((224&Re)==192)Te+=String.fromCharCode((31&Re)<<6|ct);else{var Nt=63&G[Z++];65536>(Re=(240&Re)==224?(15&Re)<<12|ct<<6|Nt:(7&Re)<<18|ct<<12|Nt<<6|63&G[Z++])?Te+=String.fromCharCode(Re):(Re-=65536,Te+=String.fromCharCode(55296|Re>>10,56320|1023&Re))}}else Te+=String.fromCharCode(Re)}return Te},F=(G,Z)=>(G>>>=0)?A(ee(),G,Z):"";function K(G,Z,_e){return l?et(3,1,G,Z,_e):0}function Ee(G,Z){if(l)return et(4,1,G,Z)}var k=G=>{for(var Z=0,_e=0;_e<G.length;++_e){var Te=G.charCodeAt(_e);127>=Te?Z++:2047>=Te?Z+=2:55296<=Te&&57343>=Te?(Z+=4,++_e):Z+=3}return Z},re=(G,Z,_e)=>{var Te=ee();if(Z>>>=0,0<_e){var Re=Z;_e=Z+_e-1;for(var ct=0;ct<G.length;++ct){var Nt=G.charCodeAt(ct);if(55296<=Nt&&57343>=Nt&&(Nt=65536+((1023&Nt)<<10)|1023&G.charCodeAt(++ct)),127>=Nt){if(Z>=_e)break;Te[Z++>>>0]=Nt}else{if(2047>=Nt){if(Z+1>=_e)break;Te[Z++>>>0]=192|Nt>>6}else{if(65535>=Nt){if(Z+2>=_e)break;Te[Z++>>>0]=224|Nt>>12}else{if(Z+3>=_e)break;Te[Z++>>>0]=240|Nt>>18,Te[Z++>>>0]=128|Nt>>12&63}Te[Z++>>>0]=128|Nt>>6&63}Te[Z++>>>0]=128|63&Nt}}Te[Z>>>0]=0,G=Z-Re}else G=0;return G};function Q(G,Z){if(l)return et(5,1,G,Z)}function ve(G,Z,_e){if(l)return et(6,1,G,Z,_e)}function ge(G,Z,_e){return l?et(7,1,G,Z,_e):0}function Le(G,Z){if(l)return et(8,1,G,Z)}function rt(G,Z,_e){if(l)return et(9,1,G,Z,_e)}function nt(G,Z,_e,Te){if(l)return et(10,1,G,Z,_e,Te)}function ft(G,Z,_e,Te){if(l)return et(11,1,G,Z,_e,Te)}function yt(G,Z,_e,Te){if(l)return et(12,1,G,Z,_e,Te)}function Ne(G){if(l)return et(13,1,G)}function Bt(G,Z){if(l)return et(14,1,G,Z)}function on(G,Z,_e){if(l)return et(15,1,G,Z,_e)}var xn,Bn,bi=()=>je(""),gn=G=>{for(var Z="";ee()[G>>>0];)Z+=xn[ee()[G++>>>0]];return Z},Mn={},Se={};function we(G,Z,_e={}){return(function(Te,Re,ct={}){var Nt=Re.name;if(!Te)throw new Bn(`type "${Nt}" must have a positive integer typeid pointer`);if(Se.hasOwnProperty(Te)){if(ct.Sb)return;throw new Bn(`Cannot register type '${Nt}' twice`)}Se[Te]=Re,Mn.hasOwnProperty(Te)&&(Re=Mn[Te],delete Mn[Te],Re.forEach(sn=>sn()))})(G,Z,_e)}var Ge=(G,Z,_e)=>{switch(Z){case 1:return _e?Te=>be()[Te>>>0]:Te=>ee()[Te>>>0];case 2:return _e?Te=>te()[Te>>>1>>>0]:Te=>ue()[Te>>>1>>>0];case 4:return _e?Te=>ae()[Te>>>2>>>0]:Te=>ce()[Te>>>2>>>0];case 8:return _e?Te=>oe[Te>>>3]:Te=>ne[Te>>>3];default:throw new TypeError(`invalid integer width (${Z}): ${G}`)}};function Je(G,Z,_e){_e>>>=0,we(G>>>=0,{name:Z=gn(Z>>>0),fromWireType:Te=>Te,toWireType:function(Te,Re){if(typeof Re!="bigint"&&typeof Re!="number")throw Re=Re===null?"null":(Te=typeof Re)=="object"||Te==="array"||Te==="function"?Re.toString():""+Re,new TypeError(`Cannot convert "${Re}" to ${this.name}`);return typeof Re=="number"&&(Re=BigInt(Re)),Re},Cb:Ue,readValueFromPointer:Ge(Z,_e,Z.indexOf("u")==-1),Db:null})}var Ue=8;function Ot(G,Z,_e,Te){we(G>>>=0,{name:Z=gn(Z>>>0),fromWireType:function(Re){return!!Re},toWireType:function(Re,ct){return ct?_e:Te},Cb:Ue,readValueFromPointer:function(Re){return this.fromWireType(ee()[Re>>>0])},Db:null})}var jt=[],tn=[];function en(G){9<(G>>>=0)&&--tn[G+1]==0&&(tn[G]=void 0,jt.push(G))}var dn=G=>{if(!G)throw new Bn("Cannot use deleted val. handle = "+G);return tn[G]},wn=G=>{switch(G){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let Z=jt.pop()||tn.length;return tn[Z]=G,tn[Z+1]=1,Z}};function _n(G){return this.fromWireType(ce()[G>>>2>>>0])}var Fn={name:"emscripten::val",fromWireType:G=>{var Z=dn(G);return en(G),Z},toWireType:(G,Z)=>wn(Z),Cb:Ue,readValueFromPointer:_n,Db:null};function ti(G){return we(G>>>0,Fn)}var Pn=(G,Z)=>{switch(Z){case 4:return function(_e){return this.fromWireType(Be()[_e>>>2>>>0])};case 8:return function(_e){return this.fromWireType(He()[_e>>>3>>>0])};default:throw new TypeError(`invalid float width (${Z}): ${G}`)}};function Ln(G,Z,_e){_e>>>=0,we(G>>>=0,{name:Z=gn(Z>>>0),fromWireType:Te=>Te,toWireType:(Te,Re)=>Re,Cb:Ue,readValueFromPointer:Pn(Z,_e),Db:null})}function Ct(G,Z,_e,Te,Re){if(G>>>=0,_e>>>=0,Z=gn(Z>>>0),Re===-1&&(Re=4294967295),Re=sn=>sn,Te===0){var ct=32-8*_e;Re=sn=>sn<<ct>>>ct}var Nt=Z.includes("unsigned")?function(sn,pn){return pn>>>0}:function(sn,pn){return pn};we(G,{name:Z,fromWireType:Re,toWireType:Nt,Cb:Ue,readValueFromPointer:Ge(Z,_e,Te!==0),Db:null})}function gt(G,Z,_e){function Te(ct){var Nt=ce()[ct>>>2>>>0];return ct=ce()[ct+4>>>2>>>0],new Re(be().buffer,ct,Nt)}var Re=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][Z];we(G>>>=0,{name:_e=gn(_e>>>0),fromWireType:Te,Cb:Ue,readValueFromPointer:Te},{Sb:!0})}function Qt(G,Z){we(G>>>=0,{name:Z=gn(Z>>>0),fromWireType:function(_e){for(var Te,Re=ce()[_e>>>2>>>0],ct=_e+4,Nt=ct,sn=0;sn<=Re;++sn){var pn=ct+sn;sn!=Re&&ee()[pn>>>0]!=0||(Nt=F(Nt,pn-Nt),Te===void 0?Te=Nt:(Te+="\0",Te+=Nt),Nt=pn+1)}return Cr(_e),Te},toWireType:function(_e,Te){Te instanceof ArrayBuffer&&(Te=new Uint8Array(Te));var Re=typeof Te=="string";if(!(Re||Te instanceof Uint8Array||Te instanceof Uint8ClampedArray||Te instanceof Int8Array))throw new Bn("Cannot pass non-string to std::string");var ct=Re?k(Te):Te.length,Nt=pu(4+ct+1),sn=Nt+4;if(ce()[Nt>>>2>>>0]=ct,Re)re(Te,sn,ct+1);else if(Re)for(Re=0;Re<ct;++Re){var pn=Te.charCodeAt(Re);if(255<pn)throw Cr(Nt),new Bn("String has UTF-16 code units that do not fit in 8 bits");ee()[sn+Re>>>0]=pn}else for(Re=0;Re<ct;++Re)ee()[sn+Re>>>0]=Te[Re];return _e!==null&&_e.push(Cr,Nt),Nt},Cb:Ue,readValueFromPointer:_n,Db(_e){Cr(_e)}})}var Nn=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Ss=(G,Z)=>{for(var _e=G>>1,Te=_e+Z/2;!(_e>=Te)&&ue()[_e>>>0];)++_e;if(32<(_e<<=1)-G&&Nn)return Nn.decode(ee().slice(G,_e));for(_e="",Te=0;!(Te>=Z/2);++Te){var Re=te()[G+2*Te>>>1>>>0];if(Re==0)break;_e+=String.fromCharCode(Re)}return _e},yr=(G,Z,_e)=>{if(_e??=2147483647,2>_e)return 0;var Te=Z;_e=(_e-=2)<2*G.length?_e/2:G.length;for(var Re=0;Re<_e;++Re){var ct=G.charCodeAt(Re);te()[Z>>>1>>>0]=ct,Z+=2}return te()[Z>>>1>>>0]=0,Z-Te},$i=G=>2*G.length,ma=(G,Z)=>{for(var _e=0,Te="";!(_e>=Z/4);){var Re=ae()[G+4*_e>>>2>>>0];if(Re==0)break;++_e,65536<=Re?(Re-=65536,Te+=String.fromCharCode(55296|Re>>10,56320|1023&Re)):Te+=String.fromCharCode(Re)}return Te},fi=(G,Z,_e)=>{if(Z>>>=0,_e??=2147483647,4>_e)return 0;var Te=Z;_e=Te+_e-4;for(var Re=0;Re<G.length;++Re){var ct=G.charCodeAt(Re);if(55296<=ct&&57343>=ct&&(ct=65536+((1023&ct)<<10)|1023&G.charCodeAt(++Re)),ae()[Z>>>2>>>0]=ct,(Z+=4)+4>_e)break}return ae()[Z>>>2>>>0]=0,Z-Te},ks=G=>{for(var Z=0,_e=0;_e<G.length;++_e){var Te=G.charCodeAt(_e);55296<=Te&&57343>=Te&&++_e,Z+=4}return Z};function $s(G,Z,_e){if(G>>>=0,Z>>>=0,_e=gn(_e>>>=0),Z===2)var Te=Ss,Re=yr,ct=$i,Nt=sn=>ue()[sn>>>1>>>0];else Z===4&&(Te=ma,Re=fi,ct=ks,Nt=sn=>ce()[sn>>>2>>>0]);we(G,{name:_e,fromWireType:sn=>{for(var pn,On=ce()[sn>>>2>>>0],Zn=sn+4,hi=0;hi<=On;++hi){var zi=sn+4+hi*Z;hi!=On&&Nt(zi)!=0||(Zn=Te(Zn,zi-Zn),pn===void 0?pn=Zn:(pn+="\0",pn+=Zn),Zn=zi+Z)}return Cr(sn),pn},toWireType:(sn,pn)=>{if(typeof pn!="string")throw new Bn(`Cannot pass non-string to C++ string type ${_e}`);var On=ct(pn),Zn=pu(4+On+Z);return ce()[Zn>>>2>>>0]=On/Z,Re(pn,Zn+4,On+Z),sn!==null&&sn.push(Cr,Zn),Zn},Cb:Ue,readValueFromPointer:_n,Db(sn){Cr(sn)}})}function Ds(G,Z){we(G>>>=0,{Tb:!0,name:Z=gn(Z>>>0),Cb:0,fromWireType:()=>{},toWireType:()=>{}})}function lt(G){Xc(G>>>0,!o,1,!r,131072,!1),Tn()}var de=G=>{if(!se)try{if(G(),!(0<$e))try{l?ac(P):Et(P)}catch(Z){Z instanceof mt||Z=="unwind"||y(0,Z)}}catch(Z){Z instanceof mt||Z=="unwind"||y(0,Z)}};function Ie(G){G>>>=0,typeof Atomics.jc=="function"&&(Atomics.jc(ae(),G>>>2,G).value.then(Ke),G+=128,Atomics.store(ae(),G>>>2,1))}var Ke=()=>{var G=al();G&&(Ie(G),de(lc))};function Ze(G,Z){(G>>>=0)==Z>>>0?setTimeout(Ke):l?postMessage({Gb:G,Bb:"checkMailbox"}):(G=bt[G])&&G.postMessage({Bb:"checkMailbox"})}var wt=[];function $t(G,Z,_e,Te,Re){for(Z>>>=0,Te/=2,wt.length=Te,_e=Re>>>0>>>3,Re=0;Re<Te;Re++)wt[Re]=oe[_e+2*Re]?oe[_e+2*Re+1]:He()[_e+2*Re+1>>>0];return(Z?Ye[Z]:Kf[G])(...wt)}var vn=()=>{$e=0};function bn(G){G>>>=0,l?postMessage({Bb:"cleanupThread",hc:G}):Jt(bt[G])}function En(G){}var un=(G,Z)=>{var _e=Se[G];if(_e===void 0)throw G=rc(G),_e=gn(G),Cr(G),new Bn(`${Z} has unknown type ${_e}`);return _e},Qn=(G,Z,_e)=>{var Te=[];return G=G.toWireType(Te,_e),Te.length&&(ce()[Z>>>2>>>0]=wn(Te)),G};function ni(G,Z,_e){return Z>>>=0,_e>>>=0,G=dn(G>>>0),Z=un(Z,"emval::as"),Qn(Z,_e,G)}function Ms(G,Z){return Z>>>=0,G=dn(G>>>0),(Z=un(Z,"emval::as")).toWireType(null,G)}var bs=G=>{try{G()}catch(Z){je(Z)}},Ci=0,ps=null,Ws=0,Wr=[],Kr={},Bs={},co=0,es=null,ms=[];function Sr(G){return(function(Z){if(!se){if(Ci===0){var _e=!1,Te=!1;Z((Re=0)=>{if(!se&&(Ws=Re,_e=!0,Te)){Ci=2,bs(()=>gu(ps)),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.resume(),Re=!1;try{var ct=(function(){var pn=ae()[ps+8>>>2>>>0];return pn=yn[Bs[pn]],--$e,pn()})()}catch(pn){ct=pn,Re=!0}var Nt=!1;if(!ps){var sn=es;sn&&(es=null,(Re?sn.reject:sn.resolve)(ct),Nt=!0)}if(Re&&!Nt)throw ct}}),Te=!0,_e||(Ci=1,ps=(function(){var Re=pu(65548),ct=Re+12;ce()[Re>>>2>>>0]=ct,ce()[Re+4>>>2>>>0]=ct+65536,ct=Wr[0];var Nt=Kr[ct];return Nt===void 0&&(Nt=co++,Kr[ct]=Nt,Bs[Nt]=ct),ct=Nt,ae()[Re+8>>>2>>>0]=ct,Re})(),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.pause(),bs(()=>Nl(ps)))}else Ci===2?(Ci=0,bs(Oo),Cr(ps),ps=null,ms.forEach(de)):je(`invalid state: ${Ci}`);return Ws}})(Z=>{G().then(Z)})}function Fr(G){return G>>>=0,Sr(async()=>{var Z=await dn(G);return wn(Z)})}var na=[];function Ks(G,Z,_e,Te){return _e>>>=0,Te>>>=0,(G=na[G>>>0])(null,Z=dn(Z>>>0),_e,Te)}var ia={},Gs=G=>{var Z=ia[G];return Z===void 0?gn(G):Z};function Pi(G,Z,_e,Te,Re){return _e>>>=0,Te>>>=0,Re>>>=0,(G=na[G>>>0])(Z=dn(Z>>>0),Z[_e=Gs(_e)],Te,Re)}var ns=()=>typeof globalThis=="object"?globalThis:Function("return this")();function Ns(G){return(G>>>=0)==0?wn(ns()):(G=Gs(G),wn(ns()[G]))}var Vs=G=>{var Z=na.length;return na.push(G),Z},Ba=(G,Z)=>{for(var _e=Array(G),Te=0;Te<G;++Te)_e[Te]=un(ce()[Z+4*Te>>>2>>>0],"parameter "+Te);return _e},Dl=(G,Z)=>Object.defineProperty(Z,"name",{value:G});function ec(G,Z,_e){var Te=(Z=Ba(G,Z>>>0)).shift();G--;var Re=`return function (obj, func, destructorsRef, args) {
`,ct=0,Nt=[];_e===0&&Nt.push("obj");for(var sn=["retType"],pn=[Te],On=0;On<G;++On)Nt.push("arg"+On),sn.push("argType"+On),pn.push(Z[On]),Re+=`  var arg${On} = argType${On}.readValueFromPointer(args${ct?"+"+ct:""});
`,ct+=Z[On].Cb;return Re+=`  var rv = ${_e===1?"new func":"func.call"}(${Nt.join(", ")});
`,Te.Tb||(sn.push("emval_returnValue"),pn.push(Qn),Re+=`  return emval_returnValue(retType, destructorsRef, rv);
`),sn.push(Re+`};
`),G=(function(Zn){var hi=Function;if(!(hi instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof hi} which is not a function`);var zi=Dl(hi.name||"unknownFunctionName",function(){});return zi.prototype=hi.prototype,zi=new zi,(Zn=hi.apply(zi,Zn))instanceof Object?Zn:zi})(sn)(...pn),_e=`methodCaller<(${Z.map(Zn=>Zn.name).join(", ")}) => ${Te.name}>`,Vs(Dl(_e,G))}function uu(G){return G=Gs(G>>>0),wn(i[G])}function tc(G,Z){return Z>>>=0,G=dn(G>>>0),Z=dn(Z),wn(G[Z])}function Vf(G){9<(G>>>=0)&&(tn[G+1]+=1)}function qs(){return wn([])}function Hf(G){G=dn(G>>>0);for(var Z=Array(G.length),_e=0;_e<G.length;_e++)Z[_e]=G[_e];return wn(Z)}function jf(G){return wn(Gs(G>>>0))}function Uc(){return wn({})}function $f(G){for(var Z=dn(G>>>=0);Z.length;){var _e=Z.pop();Z.pop()(_e)}en(G)}function Wf(G,Z,_e){Z>>>=0,_e>>>=0,G=dn(G>>>0),Z=dn(Z),_e=dn(_e),G[Z]=_e}function Do(G,Z){return Z>>>=0,G=(G=un(G>>>0,"_emval_take_value")).readValueFromPointer(Z),wn(G)}function Vd(G,Z){G=-9007199254740992>G||9007199254740992<G?NaN:Number(G),Z>>>=0,G=new Date(1e3*G),ae()[Z>>>2>>>0]=G.getUTCSeconds(),ae()[Z+4>>>2>>>0]=G.getUTCMinutes(),ae()[Z+8>>>2>>>0]=G.getUTCHours(),ae()[Z+12>>>2>>>0]=G.getUTCDate(),ae()[Z+16>>>2>>>0]=G.getUTCMonth(),ae()[Z+20>>>2>>>0]=G.getUTCFullYear()-1900,ae()[Z+24>>>2>>>0]=G.getUTCDay(),G=(G.getTime()-Date.UTC(G.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,ae()[Z+28>>>2>>>0]=G}var Hd=G=>G%4==0&&(G%100!=0||G%400==0),kc=[0,31,60,91,121,152,182,213,244,274,305,335],jd=[0,31,59,90,120,151,181,212,243,273,304,334];function $d(G,Z){G=-9007199254740992>G||9007199254740992<G?NaN:Number(G),Z>>>=0,G=new Date(1e3*G),ae()[Z>>>2>>>0]=G.getSeconds(),ae()[Z+4>>>2>>>0]=G.getMinutes(),ae()[Z+8>>>2>>>0]=G.getHours(),ae()[Z+12>>>2>>>0]=G.getDate(),ae()[Z+16>>>2>>>0]=G.getMonth(),ae()[Z+20>>>2>>>0]=G.getFullYear()-1900,ae()[Z+24>>>2>>>0]=G.getDay();var _e=(Hd(G.getFullYear())?kc:jd)[G.getMonth()]+G.getDate()-1|0;ae()[Z+28>>>2>>>0]=_e,ae()[Z+36>>>2>>>0]=-60*G.getTimezoneOffset(),_e=new Date(G.getFullYear(),6,1).getTimezoneOffset();var Te=new Date(G.getFullYear(),0,1).getTimezoneOffset();G=0|(_e!=Te&&G.getTimezoneOffset()==Math.min(Te,_e)),ae()[Z+32>>>2>>>0]=G}function Gc(G){G>>>=0;var Z=new Date(ae()[G+20>>>2>>>0]+1900,ae()[G+16>>>2>>>0],ae()[G+12>>>2>>>0],ae()[G+8>>>2>>>0],ae()[G+4>>>2>>>0],ae()[G>>>2>>>0],0),_e=ae()[G+32>>>2>>>0],Te=Z.getTimezoneOffset(),Re=new Date(Z.getFullYear(),6,1).getTimezoneOffset(),ct=new Date(Z.getFullYear(),0,1).getTimezoneOffset(),Nt=Math.min(ct,Re);return 0>_e?ae()[G+32>>>2>>>0]=+(Re!=ct&&Nt==Te):0<_e!=(Nt==Te)&&(Re=Math.max(ct,Re),Z.setTime(Z.getTime()+6e4*((0<_e?Nt:Re)-Te))),ae()[G+24>>>2>>>0]=Z.getDay(),_e=(Hd(Z.getFullYear())?kc:jd)[Z.getMonth()]+Z.getDate()-1|0,ae()[G+28>>>2>>>0]=_e,ae()[G>>>2>>>0]=Z.getSeconds(),ae()[G+4>>>2>>>0]=Z.getMinutes(),ae()[G+8>>>2>>>0]=Z.getHours(),ae()[G+12>>>2>>>0]=Z.getDate(),ae()[G+16>>>2>>>0]=Z.getMonth(),ae()[G+20>>>2>>>0]=Z.getYear(),G=Z.getTime(),BigInt(isNaN(G)?-1:G/1e3)}function Wd(G,Z,_e,Te,Re,ct,Nt){return l?et(16,1,G,Z,_e,Te,Re,ct,Nt):-52}function cu(G,Z,_e,Te,Re,ct){if(l)return et(17,1,G,Z,_e,Te,Re,ct)}var el={},Kd=()=>performance.timeOrigin+performance.now();function Vc(G,Z){if(l)return et(18,1,G,Z);if(el[G]&&(clearTimeout(el[G].id),delete el[G]),!Z)return 0;var _e=setTimeout(()=>{delete el[G],de(()=>oc(G,performance.timeOrigin+performance.now()))},Z);return el[G]={id:_e,qc:Z},0}function Hc(G,Z,_e,Te){G>>>=0,Z>>>=0,_e>>>=0,Te>>>=0;var Re=new Date().getFullYear(),ct=new Date(Re,0,1).getTimezoneOffset();Re=new Date(Re,6,1).getTimezoneOffset();var Nt=Math.max(ct,Re);ce()[G>>>2>>>0]=60*Nt,ae()[Z>>>2>>>0]=+(ct!=Re),G=(Z=sn=>{var pn=Math.abs(sn);return`UTC${0<=sn?"-":"+"}${String(Math.floor(pn/60)).padStart(2,"0")}${String(pn%60).padStart(2,"0")}`})(ct),Z=Z(Re),Re<ct?(re(G,_e,17),re(Z,Te,17)):(re(G,Te,17),re(Z,_e,17))}var qd=()=>Date.now();function tl(G,Z,_e){return 0<=G&&3>=G?(G===0?G=Date.now():G=performance.timeOrigin+performance.now(),oe[_e>>>0>>>3]=BigInt(Math.round(1e6*G)),0):28}var nc=[],Xd=(G,Z)=>{nc.length=0;for(var _e;_e=ee()[G++>>>0];){var Te=_e!=105;Z+=(Te&=_e!=112)&&Z%8?4:0,nc.push(_e==112?ce()[Z>>>2>>>0]:_e==106?oe[Z>>>3]:_e==105?ae()[Z>>>2>>>0]:He()[Z>>>3>>>0]),Z+=Te?8:4}return nc};function Yd(G,Z,_e){return G>>>=0,Z=Xd(Z>>>0,_e>>>0),Ye[G](...Z)}function fo(G,Z,_e){return G>>>=0,Z=Xd(Z>>>0,_e>>>0),Ye[G](...Z)}var Bo=()=>{};function Jd(G,Z){return C(F(G>>>0,Z>>>0))}var Qd=()=>{throw $e+=1,"unwind"};function Bl(){return 4294901760}var nl=()=>navigator.hardwareConcurrency;function Il(){return je("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function Ar(G){G>>>=0;var Z=ee().length;if(G<=Z||4294901760<G)return!1;for(var _e=1;4>=_e;_e*=2){var Te=Z*(1+.2/_e);Te=Math.min(Te,G+100663296);e:{Te=(Math.min(4294901760,65536*Math.ceil(Math.max(G,Te)/65536))-x.buffer.byteLength+65535)/65536|0;try{x.grow(Te),tt();var Re=1;break e}catch{}Re=void 0}if(Re)return!0}return!1}var il=()=>(je("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),sl={},ic=G=>{G.forEach(Z=>{il()})};function rl(){var G=Error().stack.toString().split(`
`);return G[0]=="Error"&&G.shift(),ic(G),sl.Lb=il(),sl.cc=G,sl.Lb}function Io(G,Z,_e){if(G>>>=0,Z>>>=0,sl.Lb==G)var Te=sl.cc;else(Te=Error().stack.toString().split(`
`))[0]=="Error"&&Te.shift(),ic(Te);for(var Re=3;Te[Re]&&il()!=G;)++Re;for(G=0;G<_e&&Te[G+Re];++G)ae()[Z+4*G>>>2>>>0]=il();return G}var du,sc={},cr=()=>{if(!du){var G,Z={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(G in sc)sc[G]===void 0?delete Z[G]:Z[G]=sc[G];var _e=[];for(G in Z)_e.push(`${G}=${Z[G]}`);du=_e}return du};function jc(G,Z){if(l)return et(19,1,G,Z);G>>>=0,Z>>>=0;var _e=0;return cr().forEach((Te,Re)=>{var ct=Z+_e;for(Re=ce()[G+4*Re>>>2>>>0]=ct,ct=0;ct<Te.length;++ct)be()[Re++>>>0]=Te.charCodeAt(ct);be()[Re>>>0]=0,_e+=Te.length+1}),0}function $c(G,Z){if(l)return et(20,1,G,Z);G>>>=0,Z>>>=0;var _e=cr();ce()[G>>>2>>>0]=_e.length;var Te=0;return _e.forEach(Re=>Te+=Re.length+1),ce()[Z>>>2>>>0]=Te,0}function Ol(G){return l?et(21,1,G):52}function fu(G,Z,_e,Te){return l?et(22,1,G,Z,_e,Te):52}function Wc(G,Z,_e,Te){return l?et(23,1,G,Z,_e,Te):70}var Ll=[null,[],[]];function Kc(G,Z,_e,Te){if(l)return et(24,1,G,Z,_e,Te);Z>>>=0,_e>>>=0,Te>>>=0;for(var Re=0,ct=0;ct<_e;ct++){var Nt=ce()[Z>>>2>>>0],sn=ce()[Z+4>>>2>>>0];Z+=8;for(var pn=0;pn<sn;pn++){var On=ee()[Nt+pn>>>0],Zn=Ll[G];On===0||On===10?((G===1?T:C)(A(Zn)),Zn.length=0):Zn.push(On)}Re+=sn}return ce()[Te>>>2>>>0]=Re,0}l||(function(){for(var G=i.numThreads-1;G--;)vt();Me.unshift(()=>{xe++,(function(Z){l?Z():Promise.all(Dt.map(We)).then(Z)})(()=>ze())})})();for(var hu=Array(256),ho=0;256>ho;++ho)hu[ho]=String.fromCharCode(ho);xn=hu,Bn=i.BindingError=class extends Error{constructor(G){super(G),this.name="BindingError"}},i.InternalError=class extends Error{constructor(G){super(G),this.name="InternalError"}},tn.push(0,1,void 0,1,null,1,!0,1,!1,1),i.count_emval_handles=()=>tn.length/2-5-jt.length;var yn,Kf=[ht,at,fe,K,Ee,Q,ve,ge,Le,rt,nt,ft,yt,Ne,Bt,on,Wd,cu,Vc,jc,$c,Ol,fu,Wc,Kc];(async function(){function G(Te,Re){return yn=Te.exports,yn=(function(){var ct=yn,Nt={};for(let[sn,pn]of Object.entries(ct))Nt[sn]=typeof pn=="function"?(...On)=>{Wr.push(sn);try{return pn(...On)}finally{se||(Wr.pop(),ps&&Ci===1&&Wr.length===0&&(Ci=0,$e+=1,bs(sa),typeof Fibers<"u"&&Fibers.rc()))}}:pn;return Nt})(),yn=(function(){var ct=yn,Nt=pn=>On=>pn(On)>>>0,sn=pn=>()=>pn()>>>0;return(ct=Object.assign({},ct)).Da=Nt(ct.Da),ct.fb=sn(ct.fb),ct.hb=Nt(ct.hb),ct.tb=Nt(ct.tb),ct.ub=sn(ct.ub),ct.__cxa_get_exception_ptr=Nt(ct.__cxa_get_exception_ptr),ct})(),an.push(yn.ib),R=Re,ze(),yn}xe++;var Z=Fe();if(i.instantiateWasm)return new Promise(Te=>{i.instantiateWasm(Z,(Re,ct)=>{G(Re,ct),Te(Re.exports)})});if(l)return new Promise(Te=>{Xe=Re=>{var ct=new WebAssembly.Instance(Re,Fe());Te(G(ct,Re))}});ye??=i.locateFile?i.locateFile?i.locateFile("ort-wasm-simd-threaded.jsep.wasm",w):w+"ort-wasm-simd-threaded.jsep.wasm":new URL("/assets/ort-wasm-simd-threaded.jsep-B0T3yYHD.wasm",import.meta.url).href;try{var _e=await(async function(Te){var Re=ye;if(!le&&typeof WebAssembly.instantiateStreaming=="function"&&!pe(Re))try{var ct=fetch(Re,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(ct,Te)}catch(Nt){C(`wasm streaming compile failed: ${Nt}`),C("falling back to ArrayBuffer instantiation")}return(async function(Nt,sn){try{var pn=await(async function(On){if(!le)try{var Zn=await p(On);return new Uint8Array(Zn)}catch{}if(On==ye&&le)On=new Uint8Array(le);else{if(!h)throw"both async and sync fetching of the wasm failed";On=h(On)}return On})(Nt);return await WebAssembly.instantiate(pn,sn)}catch(On){C(`failed to asynchronously prepare wasm: ${On}`),je(On)}})(Re,Te)})(Z);return G(_e.instance,_e.module)}catch(Te){return t(Te),Promise.reject(Te)}})();var rc=G=>(rc=yn.Da)(G),qc=()=>(qc=yn.Ea)();i._OrtInit=(G,Z)=>(i._OrtInit=yn.Fa)(G,Z),i._OrtGetLastError=(G,Z)=>(i._OrtGetLastError=yn.Ga)(G,Z),i._OrtCreateSessionOptions=(G,Z,_e,Te,Re,ct,Nt,sn,pn,On)=>(i._OrtCreateSessionOptions=yn.Ha)(G,Z,_e,Te,Re,ct,Nt,sn,pn,On),i._OrtAppendExecutionProvider=(G,Z,_e,Te,Re)=>(i._OrtAppendExecutionProvider=yn.Ia)(G,Z,_e,Te,Re),i._OrtAddFreeDimensionOverride=(G,Z,_e)=>(i._OrtAddFreeDimensionOverride=yn.Ja)(G,Z,_e),i._OrtAddSessionConfigEntry=(G,Z,_e)=>(i._OrtAddSessionConfigEntry=yn.Ka)(G,Z,_e),i._OrtReleaseSessionOptions=G=>(i._OrtReleaseSessionOptions=yn.La)(G),i._OrtCreateSession=(G,Z,_e)=>(i._OrtCreateSession=yn.Ma)(G,Z,_e),i._OrtReleaseSession=G=>(i._OrtReleaseSession=yn.Na)(G),i._OrtGetInputOutputCount=(G,Z,_e)=>(i._OrtGetInputOutputCount=yn.Oa)(G,Z,_e),i._OrtGetInputOutputMetadata=(G,Z,_e,Te)=>(i._OrtGetInputOutputMetadata=yn.Pa)(G,Z,_e,Te),i._OrtFree=G=>(i._OrtFree=yn.Qa)(G),i._OrtCreateTensor=(G,Z,_e,Te,Re,ct)=>(i._OrtCreateTensor=yn.Ra)(G,Z,_e,Te,Re,ct),i._OrtGetTensorData=(G,Z,_e,Te,Re)=>(i._OrtGetTensorData=yn.Sa)(G,Z,_e,Te,Re),i._OrtReleaseTensor=G=>(i._OrtReleaseTensor=yn.Ta)(G),i._OrtCreateRunOptions=(G,Z,_e,Te)=>(i._OrtCreateRunOptions=yn.Ua)(G,Z,_e,Te),i._OrtAddRunConfigEntry=(G,Z,_e)=>(i._OrtAddRunConfigEntry=yn.Va)(G,Z,_e),i._OrtReleaseRunOptions=G=>(i._OrtReleaseRunOptions=yn.Wa)(G),i._OrtCreateBinding=G=>(i._OrtCreateBinding=yn.Xa)(G),i._OrtBindInput=(G,Z,_e)=>(i._OrtBindInput=yn.Ya)(G,Z,_e),i._OrtBindOutput=(G,Z,_e,Te)=>(i._OrtBindOutput=yn.Za)(G,Z,_e,Te),i._OrtClearBoundOutputs=G=>(i._OrtClearBoundOutputs=yn._a)(G),i._OrtReleaseBinding=G=>(i._OrtReleaseBinding=yn.$a)(G),i._OrtRunWithBinding=(G,Z,_e,Te,Re)=>(i._OrtRunWithBinding=yn.ab)(G,Z,_e,Te,Re),i._OrtRun=(G,Z,_e,Te,Re,ct,Nt,sn)=>(i._OrtRun=yn.bb)(G,Z,_e,Te,Re,ct,Nt,sn),i._OrtEndProfiling=G=>(i._OrtEndProfiling=yn.cb)(G),i._JsepOutput=(G,Z,_e)=>(i._JsepOutput=yn.db)(G,Z,_e),i._JsepGetNodeName=G=>(i._JsepGetNodeName=yn.eb)(G);var al=()=>(al=yn.fb)(),Cr=i._free=G=>(Cr=i._free=yn.gb)(G),pu=i._malloc=G=>(pu=i._malloc=yn.hb)(G),Xc=(G,Z,_e,Te,Re,ct)=>(Xc=yn.kb)(G,Z,_e,Te,Re,ct),ol=()=>(ol=yn.lb)(),gs=(G,Z,_e,Te,Re)=>(gs=yn.mb)(G,Z,_e,Te,Re),Fl=G=>(Fl=yn.nb)(G),ac=G=>(ac=yn.ob)(G),oc=(G,Z)=>(oc=yn.pb)(G,Z),lc=()=>(lc=yn.qb)(),uc=(G,Z)=>(uc=yn.rb)(G,Z),po=G=>(po=yn.sb)(G),Yc=G=>(Yc=yn.tb)(G),ll=()=>(ll=yn.ub)(),mu=i.dynCall_ii=(G,Z)=>(mu=i.dynCall_ii=yn.vb)(G,Z),Nl=G=>(Nl=yn.wb)(G),sa=()=>(sa=yn.xb)(),gu=G=>(gu=yn.yb)(G),Oo=()=>(Oo=yn.zb)();return i.stackSave=()=>ll(),i.stackRestore=G=>po(G),i.stackAlloc=G=>Yc(G),i.setValue=function(G,Z,_e="i8"){switch(_e.endsWith("*")&&(_e="*"),_e){case"i1":case"i8":be()[G>>>0]=Z;break;case"i16":te()[G>>>1>>>0]=Z;break;case"i32":ae()[G>>>2>>>0]=Z;break;case"i64":oe[G>>>3]=BigInt(Z);break;case"float":Be()[G>>>2>>>0]=Z;break;case"double":He()[G>>>3>>>0]=Z;break;case"*":ce()[G>>>2>>>0]=Z;break;default:je(`invalid type for setValue: ${_e}`)}},i.getValue=function(G,Z="i8"){switch(Z.endsWith("*")&&(Z="*"),Z){case"i1":case"i8":return be()[G>>>0];case"i16":return te()[G>>>1>>>0];case"i32":return ae()[G>>>2>>>0];case"i64":return oe[G>>>3];case"float":return Be()[G>>>2>>>0];case"double":return He()[G>>>3>>>0];case"*":return ce()[G>>>2>>>0];default:je(`invalid type for getValue: ${Z}`)}},i.UTF8ToString=F,i.stringToUTF8=re,i.lengthBytesUTF8=k,(function G(){if(0<xe)ke=G;else if(l)e(i),Ae();else{for(;0<Me.length;)Me.shift()(i);0<xe?ke=G:(i.calledRun=!0,se||(Ae(),e(i)))}})(),i.PTR_SIZE=4,s}),A3=w1,H2=globalThis.self?.name?.startsWith("em-pthread"),H2&&w1()}),E1,qE,j2,Hu,C3,TM,$2,W2,T1,K2,S1,P3,A1,R3,dS=fn(()=>{cS(),E1=typeof location>"u"?void 0:location.origin,qE=import.meta.url>"file:"&&import.meta.url<"file;",j2=()=>{{if(qE){let n=URL;return new URL(new n("ort.bundle.min.mjs",import.meta.url).href,E1).href}return import.meta.url}},Hu=j2(),C3=()=>{if(Hu&&!Hu.startsWith("blob:"))return Hu.substring(0,Hu.lastIndexOf("/")+1)},TM=(n,e)=>{try{let t=e??Hu;return(t?new URL(n,t):new URL(n)).origin===E1}catch{return!1}},$2=(n,e)=>{let t=e??Hu;try{return(t?new URL(n,t):new URL(n)).href}catch{return}},W2=(n,e)=>`${e??"./"}${n}`,T1=async n=>{let e=await(await fetch(n,{credentials:"same-origin"})).blob();return URL.createObjectURL(e)},K2=async n=>(await import(n)).default,S1=(bW(),Vv(E3)).default,P3=async()=>{if(!Hu)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(TM(Hu))return[void 0,S1()];let n=await T1(Hu);return[n,S1(n)]},A1=(xW(),Vv(S3)).default,R3=async(n,e,t)=>{if(!n&&!e&&A1&&Hu&&TM(Hu))return[void 0,A1];{let i="ort-wasm-simd-threaded.jsep.mjs",s=n??$2(i,e),r=t&&s&&!TM(s,e),o=r?await T1(s):s??W2(i,e);return[r?o:void 0,await K2(o)]}}}),C1,SM,ev,P1,q2,X2,Y2,fS,er,n_=fn(()=>{dS(),SM=!1,ev=!1,P1=!1,q2=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},X2=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Y2=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},fS=async n=>{if(SM)return Promise.resolve();if(ev)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(P1)throw new Error("previous call to 'initializeWebAssembly()' failed.");ev=!0;let e=n.initTimeout,t=n.numThreads;if(n.simd!==!1){if(n.simd==="relaxed"){if(!Y2())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!X2())throw new Error("WebAssembly SIMD is not supported in the current environment.")}let i=q2();t>1&&!i&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+t+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),n.numThreads=t=1);let s=n.wasmPaths,r=typeof s=="string"?s:void 0,o=s?.mjs,l=o?.href??o,c=s?.wasm,d=c?.href??c,g=n.wasmBinary,[p,h]=await R3(l,r,t>1),v=!1,y=[];if(e>0&&y.push(new Promise(w=>{setTimeout(()=>{v=!0,w()},e)})),y.push(new Promise((w,S)=>{let M={numThreads:t};if(g)M.wasmBinary=g;else if(d||r)M.locateFile=T=>d??r+T;else if(l&&l.indexOf("blob:")!==0)M.locateFile=T=>new URL(T,l).href;else if(p){let T=C3();T&&(M.locateFile=C=>T+C)}h(M).then(T=>{ev=!1,SM=!0,C1=T,w(),p&&URL.revokeObjectURL(p)},T=>{ev=!1,P1=!0,S(T)})})),await Promise.race(y),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},er=()=>{if(SM&&C1)return C1;throw new Error("WebAssembly is not initialized yet.")}}),Dd,Ub,Fs,hS=fn(()=>{n_(),Dd=(n,e)=>{let t=er(),i=t.lengthBytesUTF8(n)+1,s=t._malloc(i);return t.stringToUTF8(n,s,i),e.push(s),s},Ub=(n,e,t,i)=>{if(typeof n=="object"&&n!==null){if(t.has(n))throw new Error("Circular reference in options");t.add(n)}Object.entries(n).forEach(([s,r])=>{let o=e?e+s:s;if(typeof r=="object")Ub(r,o+".",t,i);else if(typeof r=="string"||typeof r=="number")i(o,r.toString());else if(typeof r=="boolean")i(o,r?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof r}`)})},Fs=n=>{let e=er(),t=e.stackSave();try{let i=e.PTR_SIZE,s=e.stackAlloc(2*i);e._OrtGetLastError(s,s+i);let r=Number(e.getValue(s,i===4?"i32":"i64")),o=e.getValue(s+i,"*"),l=o?e.UTF8ToString(o):"";throw new Error(`${n} ERROR_CODE: ${r}, ERROR_MESSAGE: ${l}`)}finally{e.stackRestore(t)}}}),D3,wW=fn(()=>{n_(),hS(),D3=n=>{let e=er(),t=0,i=[],s=n||{};try{if(n?.logSeverityLevel===void 0)s.logSeverityLevel=2;else if(typeof n.logSeverityLevel!="number"||!Number.isInteger(n.logSeverityLevel)||n.logSeverityLevel<0||n.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${n.logSeverityLevel}`);if(n?.logVerbosityLevel===void 0)s.logVerbosityLevel=0;else if(typeof n.logVerbosityLevel!="number"||!Number.isInteger(n.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${n.logVerbosityLevel}`);n?.terminate===void 0&&(s.terminate=!1);let r=0;return n?.tag!==void 0&&(r=Dd(n.tag,i)),t=e._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,r),t===0&&Fs("Can't create run options."),n?.extra!==void 0&&Ub(n.extra,"",new WeakSet,(o,l)=>{let c=Dd(o,i),d=Dd(l,i);e._OrtAddRunConfigEntry(t,c,d)!==0&&Fs(`Can't set a run config entry: ${o} - ${l}.`)}),[t,i]}catch(r){throw t!==0&&e._OrtReleaseRunOptions(t),i.forEach(o=>e._free(o)),r}}}),J2,Q2,Z2,tv,eP,B3,EW=fn(()=>{n_(),hS(),J2=n=>{switch(n){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${n}`)}},Q2=n=>{switch(n){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${n}`)}},Z2=n=>{n.extra||(n.extra={}),n.extra.session||(n.extra.session={});let e=n.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),n.executionProviders&&n.executionProviders.some(t=>(typeof t=="string"?t:t.name)==="webgpu")&&(n.enableMemPattern=!1)},tv=(n,e,t,i)=>{let s=Dd(e,i),r=Dd(t,i);er()._OrtAddSessionConfigEntry(n,s,r)!==0&&Fs(`Can't set a session config entry: ${e} - ${t}.`)},eP=async(n,e,t)=>{for(let i of e){let s=typeof i=="string"?i:i.name,r=[];switch(s){case"webnn":if(s="WEBNN",typeof i!="string"){let g=i?.deviceType;g&&tv(n,"deviceType",g,t)}break;case"webgpu":if(s="JS",typeof i!="string"){let g=i;if(g?.preferredLayout){if(g.preferredLayout!=="NCHW"&&g.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${g.preferredLayout}`);tv(n,"preferredLayout",g.preferredLayout,t)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${s}`)}let o=Dd(s,t),l=r.length,c=0,d=0;if(l>0){c=er()._malloc(l*er().PTR_SIZE),t.push(c),d=er()._malloc(l*er().PTR_SIZE),t.push(d);for(let g=0;g<l;g++)er().setValue(c+g*er().PTR_SIZE,r[g][0],"*"),er().setValue(d+g*er().PTR_SIZE,r[g][1],"*")}await er()._OrtAppendExecutionProvider(n,o,c,d,l)!==0&&Fs(`Can't append execution provider: ${s}.`)}},B3=async n=>{let e=er(),t=0,i=[],s=n||{};Z2(s);try{let r=J2(s.graphOptimizationLevel??"all"),o=Q2(s.executionMode??"sequential"),l=typeof s.logId=="string"?Dd(s.logId,i):0,c=s.logSeverityLevel??2;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log serverity level is not valid: ${c}`);let d=s.logVerbosityLevel??0;if(!Number.isInteger(d)||d<0||d>4)throw new Error(`log verbosity level is not valid: ${d}`);let g=typeof s.optimizedModelFilePath=="string"?Dd(s.optimizedModelFilePath,i):0;if(t=e._OrtCreateSessionOptions(r,!!s.enableCpuMemArena,!!s.enableMemPattern,o,!!s.enableProfiling,0,l,c,d,g),t===0&&Fs("Can't create session options."),s.executionProviders&&await eP(t,s.executionProviders,i),s.enableGraphCapture!==void 0){if(typeof s.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${s.enableGraphCapture}`);tv(t,"enableGraphCapture",s.enableGraphCapture.toString(),i)}if(s.freeDimensionOverrides)for(let[p,h]of Object.entries(s.freeDimensionOverrides)){if(typeof p!="string")throw new Error(`free dimension override name must be a string: ${p}`);if(typeof h!="number"||!Number.isInteger(h)||h<0)throw new Error(`free dimension override value must be a non-negative integer: ${h}`);let v=Dd(p,i);e._OrtAddFreeDimensionOverride(t,v,h)!==0&&Fs(`Can't set a free dimension override: ${p} - ${h}.`)}return s.extra!==void 0&&Ub(s.extra,"",new WeakSet,(p,h)=>{tv(t,p,h,i)}),[t,i]}catch(r){throw t!==0&&e._OrtReleaseSessionOptions(t)!==0&&Fs("Can't release session options."),i.forEach(o=>e._free(o)),r}}}),W_,Gh,Sg,pS,kb,mS,gS,XE,ai=fn(()=>{W_=n=>{switch(n){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${n}`)}},Gh=n=>{switch(n){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${n}`)}},Sg=(n,e)=>{let t=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][n],i=typeof e=="number"?e:e.reduce((s,r)=>s*r,1);return t>0?Math.ceil(i*t):void 0},pS=n=>{switch(n){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${n}`)}},kb=n=>{switch(n){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${n}`)}},mS=n=>n==="float32"||n==="float16"||n==="int32"||n==="int64"||n==="uint32"||n==="uint8"||n==="bool"||n==="uint4"||n==="int4",gS=n=>n==="float32"||n==="float16"||n==="int32"||n==="int64"||n==="uint32"||n==="uint64"||n==="int8"||n==="uint8"||n==="bool"||n==="uint4"||n==="int4",XE=n=>{switch(n){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${n}`)}}}),_S,I3=fn(()=>{cS(),_S=async n=>{if(typeof n=="string"){let e=await fetch(n);if(!e.ok)throw new Error(`failed to load external data file: ${n}`);let t=e.headers.get("Content-Length"),i=t?parseInt(t,10):0;if(i<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${n}, no response body.`);let s=e.body.getReader(),r;try{r=new ArrayBuffer(i)}catch(l){if(l instanceof RangeError){let c=Math.ceil(i/65536);r=new WebAssembly.Memory({initial:c,maximum:c}).buffer}else throw l}let o=0;for(;;){let{done:l,value:c}=await s.read();if(l)break;let d=c.byteLength;new Uint8Array(r,o,d).set(c),o+=d}return new Uint8Array(r,0,i)}}else return n instanceof Blob?new Uint8Array(await n.arrayBuffer()):n instanceof Uint8Array?n:new Uint8Array(n)}}),tP,nP,iP,sP,vS,rP,Zi,qh=fn(()=>{ai(),tP=["V","I","W","E","F"],nP=(n,e)=>{console.log(`[${tP[n]},${new Date().toISOString()}]${e}`)},vS=(n,e)=>{iP=n,sP=e},rP=(n,e)=>{let t=kb(n),i=kb(iP);t>=i&&nP(t,typeof e=="function"?e():e)},Zi=(...n)=>{sP&&rP(...n)}}),aP,h0,Ut,Gb,O3,L3,F3,vi=fn(()=>{aP=class{static calcMatMulShape(n,e){return n[1]!==e[0]?void 0:[n[0],e[1]]}},h0=class{static calcShape(n,e,t=!1){let i=n.length,s=e.length;if(i===0)return e;if(s===0)return n;let r=Math.max(n.length,e.length),o=new Array(r);if(t){if(i<2||s<2)return;let l=aP.calcMatMulShape([n[i-2],n[i-1]],[e[s-2],e[s-1]]);if(l===void 0)return;[o[r-2],o[r-1]]=l}for(let l=t?3:1;l<=r;l++){let c=i-l<0?1:n[i-l],d=s-l<0?1:e[s-l];if(c!==d&&c>1&&d>1)return;let g=Math.max(c,d);if(c&&d)o[r-l]=Math.max(c,d);else{if(g>1)return;o[r-l]=0}}return o}static isValidBroadcast(n,e){let t=n.length,i=e.length;if(t>i)return!1;for(let s=1;s<=t;s++)if(n[t-s]!==1&&n[t-s]!==e[i-s])return!1;return!0}},Ut=class $M{static size(e){return $M.getSizeFromDimensionRange(e,0,e.length)}static convertShape(e,t=4){let i=e.length;if(i===0)return[];let s=new Array(i),r=i-1;for(;r>=0;){if(e[r]%t===0){s[r]=e[r]/t;break}if(t%e[r]!==0)throw new Error("cannot convert shape");s[r]=1,t/=e[r],r--}for(r--;r>=0;r--)s[r]=e[r];return s}static sizeFromDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return $M.getSizeFromDimensionRange(e,t,e.length)}static sizeToDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);return $M.getSizeFromDimensionRange(e,0,t)}static getSizeFromDimensionRange(e,t,i){let s=1;for(let r=t;r<i;r++){if(e[r]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");s*=Number(e[r])}return s}static computeStrides(e){let t=e.length;if(t===0)return[];if(t===1)return[1];let i=new Array(t);i[t-1]=1,i[t-2]=e[t-1];for(let s=t-3;s>=0;--s)i[s]=i[s+1]*e[s+1];return i}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map(i=>this.normalizeAxis(i,t??e.length))}static sortBasedOnPerm(e,t){return t?t.map(i=>e[i]):e.slice().reverse()}static padShape(e,t){let i=e.length;return e.map((s,r)=>s+t[r]+t[r+i])}static areEqual(e,t){return e.length!==t.length?!1:e.every((i,s)=>i===t[s])}},Gb=class pv{static adjustPoolAttributes(e,t,i,s,r,o){if(!e&&i.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let l=0;l<t.length-2;l++)l>=i.length?i.push(t[l+2]):i[l]=t[l+2];for(let l=0;l<i.length;l++)if(l<s.length){if(s[l]<0)throw new Error("strides should be greater than or equal to 1")}else s.push(1);for(let l=0;l<i.length;l++)if(l<r.length){if(r[l]<0)throw new Error("dilations should be greater than or equal to 1")}else r.push(1);for(let l=0;l<i.length*2;l++)if(l<o.length){if(o[l]<0)throw new Error("pad should be greater than or equal to 1")}else o.push(0);for(let l=0;l<i.length;l++){if(i[l]<=0)throw new Error("kernel shapes need to be greater than 0");if(o[l]>=i[l]||o[l+i.length]>=i[l])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,t,i,s,r,o,l){if(l){if(r.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(s.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let c=0;c<e.length-2;c++)pv.adjustPadAndReturnShape(e[c+(o?1:2)],t[c],i[c],s[c],r,c,c+e.length-2,l)}}static computePoolOutputShape(e,t,i,s,r,o,l){if(t.length<=0)throw new Error("input shape must be of size greater than 0");let c=[t[0],t[1]];return pv.computeShapeHelper(e,t,c,i,s,r,o,l),c}static computeConvOutputShape(e,t,i,s,r,o,l){if(e.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let c=[e[0],t[0]];return pv.computeShapeHelper(!1,e,c,i,s,r,o,l),c}static computeShapeHelper(e,t,i,s,r,o,l,c){if(e)for(let d=0;d<t.length-2;d++)i.push(1);else for(let d=0;d<t.length-2;d++)i.push(pv.adjustPadAndReturnShape(t[d+2],s[d],r[d],o[d],l,d,d+t.length-2,c))}static adjustPadAndReturnShape(e,t,i,s,r,o,l,c){let d=i*(s-1)+1;if(c&&c!=="NOTSET")switch(c){case"VALID":return r[o]=0,r[l]=0,Math.floor((e-d)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(i!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let g=((e+t-1)/t-1)*t+s-e;return r[o]=Math.floor(c==="SAME_LOWER"?(g+1)/2:g/2),r[l]=g-r[o],Math.floor((e+g-s)/t+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+r[o]+r[l]-d)/t+1)}},O3=class{static getShapeOfGemmResult(n,e,t,i,s){if(n.length!==2||t.length!==2)throw new Error("shape need to be of size 2");let r,o,l;e?(r=n[1],o=n[0]):(r=n[0],o=n[1]);let c=-1;if(i?(l=t[0],c=1):(l=t[1],c=0),t[c]!==o)throw new Error("dimension mismatch");if(r<=0||l<=0||o<=0)throw new Error("invalid shape specified");if(s&&!h0.isValidBroadcast(s,[r,l]))throw new Error("gemm: invalid bias shape for broadcast");return[r,l,o]}},L3=-34028234663852886e22,F3=34028234663852886e22}),yS,N3=fn(()=>{ai(),yS=(n,e)=>new(pS(e))(n)}),YE,R1,oP,D1,lP,B1,I1,O1,uP,z3,TW=fn(()=>{qh(),YE=(n,e=!0)=>{if(n.byteLength%8!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 8 (BigInt).");let t=n.byteLength/8,i=new BigInt64Array(n.buffer,n.byteOffset,t),s=new Int32Array(t);for(let r=0;r<t;r++){let o=i[r];if(o>2147483647n||o<-2147483648n)throw new Error(`Overflow occurred when converting BigInt to Int32 at index ${r}: ${o}`);s[r]=Number(o)}return e?new Uint8Array(s.buffer):s},R1=(n,e=!0)=>{if(n.byteLength%4!==0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (Int32).");let t=n.byteLength/4,i=new Int32Array(n.buffer,n.byteOffset,t),s=BigInt64Array.from(i,BigInt);return e?new Uint8Array(s.buffer):s},oP=1,D1=()=>oP++,lP=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),B1=(n,e)=>{let t=lP.get(n);if(!t)throw new Error("Unsupported data type.");return e.length>0?Math.ceil(e.reduce((i,s)=>i*s)*t/8):0},I1=class{constructor(n){this.shouldConvertInt64toInt32=!1,this.isInt64ToInt32Converted=!1;let{sessionId:e,context:t,tensor:i,dataType:s,shape:r,shouldConvertInt64toInt32:o=!1}=n;this.sessionId=e,this.mlContext=t,this.mlTensor=i,this.dataType=s,this.tensorShape=r,this.shouldConvertInt64toInt32=o}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return B1(this.dataType,this.tensorShape)}destroy(){Zi("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(n){this.mlContext.writeTensor(this.mlTensor,n)}async read(n,e){if(n){let t=await this.mlContext.readTensor(this.mlTensor),i=R1(new Uint8Array(t));if(e){(e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength)).set(i);return}else return i.buffer}else return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(n,e,t){return this.mlContext===n&&this.dataType===e&&this.tensorShape.length===t.length&&this.tensorShape.every((i,s)=>i===t[s])}setIsInt64ToInt32Converted(n){this.isInt64ToInt32Converted=n}},O1=class{constructor(n,e){this.tensorManager=n,this.wrapper=e}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(n,e,t,i){let s=e,r=this.tensorManager.getMLContext(n),o=s==="int64"&&!r.opSupportLimits().input.dataTypes.includes("int64");if(o&&(s="int32",Zi("verbose",()=>"[WebNN] TensorIdTracker.ensureTensor: convert dataType from int64 to int32")),this.wrapper){if(this.wrapper.canReuseTensor(r,s,t))return this.wrapper.tensor;if(i){if(this.wrapper.byteLength!==B1(s,t))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let l=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(n,s,t,l,!0,!0,o),i&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(n){let e=n;if(this.wrapper)if(this.wrapper.shouldConvertInt64toInt32&&(e=YE(n,!0),this.wrapper.setIsInt64ToInt32Converted(!0)),e.byteLength===this.wrapper.byteLength){this.wrapper.write(e);return}else Zi("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor();this.activeUpload?this.activeUpload.set(e):this.activeUpload=new Uint8Array(e)}async download(n){if(this.activeUpload){let e=this.wrapper?.isInt64ToInt32Converted?R1(this.activeUpload):this.activeUpload;if(n){n instanceof ArrayBuffer?new Uint8Array(n).set(e):new Uint8Array(n.buffer,n.byteOffset,n.byteLength).set(e);return}else return e.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return n?this.wrapper.read(this.wrapper?.shouldConvertInt64toInt32,n):this.wrapper.read(this.wrapper?.shouldConvertInt64toInt32)}},uP=class{constructor(n){this.backend=n,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(n){let e=this.backend.getMLContext(n);if(!e)throw new Error("MLContext not found for session.");return e}reserveTensorId(){let n=D1();return this.tensorTrackersById.set(n,new O1(this)),n}releaseTensorId(n){let e=this.tensorTrackersById.get(n);e&&(this.tensorTrackersById.delete(n),e.tensorWrapper&&this.releaseTensor(e.tensorWrapper))}async ensureTensor(n,e,t,i,s){Zi("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${e}, dataType: ${t}, shape: ${i}, copyOld: ${s}}`);let r=this.tensorTrackersById.get(e);if(!r)throw new Error("Tensor not found.");return r.ensureTensor(n,t,i,s)}upload(n,e){let t=this.tensorTrackersById.get(n);if(!t)throw new Error("Tensor not found.");t.upload(e)}async download(n,e){Zi("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${n}, dstBuffer: ${e?.byteLength}}`);let t=this.tensorTrackersById.get(n);if(!t)throw new Error("Tensor not found.");return t.download(e)}releaseTensorsForSession(n){for(let e of this.freeTensors)e.sessionId===n&&e.destroy();this.freeTensors=this.freeTensors.filter(e=>e.sessionId!==n)}registerTensor(n,e,t,i){let s=this.getMLContext(n),r=D1(),o=new I1({sessionId:n,context:s,tensor:e,dataType:t,shape:i});return this.tensorTrackersById.set(r,new O1(this,o)),this.externalTensors.add(o),r}async getCachedTensor(n,e,t,i,s,r,o=!1){let l=this.getMLContext(n);for(let[d,g]of this.freeTensors.entries())if(g.canReuseTensor(l,e,t)){Zi("verbose",()=>`[WebNN] Reusing tensor {dataType: ${e}, shape: ${t}}`);let p=this.freeTensors.splice(d,1)[0];return p.sessionId=n,p}Zi("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${e}, shape: ${t}}`);let c=await l.createTensor({dataType:e,shape:t,dimensions:t,usage:i,writable:s,readable:r});return new I1({sessionId:n,context:l,tensor:c,dataType:e,shape:t,shouldConvertInt64toInt32:o})}releaseTensor(n){this.externalTensors.has(n)&&this.externalTensors.delete(n),this.freeTensors.push(n)}},z3=(...n)=>new uP(...n)}),AM,cP,U3,SW=fn(()=>{ai(),n_(),N3(),TW(),qh(),AM=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),cP=(n,e)=>{if(n===e)return!0;if(n===void 0||e===void 0)return!1;let t=Object.keys(n).sort(),i=Object.keys(e).sort();return t.length===i.length&&t.every((s,r)=>s===i[r]&&n[s]===e[s])},U3=class{constructor(n){this.tensorManager=z3(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,vS(n.logLevel,!!n.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(n){Zi("verbose",()=>`[WebNN] onRunStart {sessionId: ${n}}`),this.activeSessionId=n}onRunEnd(n){Zi("verbose",()=>`[WebNN] onRunEnd {sessionId: ${n}}`);let e=this.temporarySessionTensorIds.get(n);if(e){for(let t of e)Zi("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t);this.temporarySessionTensorIds.delete(n),this.activeSessionId=void 0}}async createMLContext(n){if(n instanceof GPUDevice){let t=this.mlContextCache.findIndex(i=>i.gpuDevice===n);if(t!==-1)return this.mlContextCache[t].mlContext;{let i=await navigator.ml.createContext(n);return this.mlContextCache.push({gpuDevice:n,mlContext:i}),i}}else if(n===void 0){let t=this.mlContextCache.findIndex(i=>i.options===void 0&&i.gpuDevice===void 0);if(t!==-1)return this.mlContextCache[t].mlContext;{let i=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:i}),i}}let e=this.mlContextCache.findIndex(t=>cP(t.options,n));if(e!==-1)return this.mlContextCache[e].mlContext;{let t=await navigator.ml.createContext(n);return this.mlContextCache.push({options:n,mlContext:t}),t}}registerMLContext(n,e){this.mlContextBySessionId.set(n,e);let t=this.sessionIdsByMLContext.get(e);t||(t=new Set,this.sessionIdsByMLContext.set(e,t)),t.add(n),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(n,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(n){this.sessionGraphInputs.delete(n);let e=this.mlContextBySessionId.get(n);if(!e)return;this.tensorManager.releaseTensorsForSession(n),this.mlContextBySessionId.delete(n);let t=this.sessionIdsByMLContext.get(e);if(t.delete(n),t.size===0){this.sessionIdsByMLContext.delete(e);let i=this.mlContextCache.findIndex(s=>s.mlContext===e);i!==-1&&this.mlContextCache.splice(i,1)}}getMLContext(n){return this.mlContextBySessionId.get(n)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(n){Zi("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${n}}`),this.tensorManager.releaseTensorId(n)}async ensureTensor(n,e,t,i,s){let r=AM.get(t);if(!r)throw new Error(`Unsupported ONNX data type: ${t}`);return this.tensorManager.ensureTensor(n??this.currentSessionId,e,r,i,s)}async createTemporaryTensor(n,e,t){Zi("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${e}, shape: ${t}}`);let i=AM.get(e);if(!i)throw new Error(`Unsupported ONNX data type: ${e}`);let s=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(n,s,i,t,!1);let r=this.temporarySessionTensorIds.get(n);return r?r.push(s):this.temporarySessionTensorIds.set(n,[s]),s}uploadTensor(n,e){if(!er().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");Zi("verbose",()=>`[WebNN] uploadTensor {tensorId: ${n}, data: ${e.byteLength}}`),this.tensorManager.upload(n,e)}async downloadTensor(n,e){return this.tensorManager.download(n,e)}createMLTensorDownloader(n,e){return async()=>{let t=await this.tensorManager.download(n);return yS(t,e)}}registerMLTensor(n,e,t,i){let s=AM.get(t);if(!s)throw new Error(`Unsupported ONNX data type: ${t}`);let r=this.tensorManager.registerTensor(n,e,s,i);return Zi("verbose",()=>`[WebNN] registerMLTensor {tensor: ${e}, dataType: ${s}, dimensions: ${i}} -> {tensorId: ${r}}`),r}registerMLConstant(n,e,t,i,s,r,o=!1){if(!r)throw new Error("External mounted files are not available.");let l=n;n.startsWith("./")&&(l=n.substring(2));let c=r.get(l);if(!c)throw new Error(`File with name ${l} not found in preloaded files.`);if(e+t>c.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let d=c.slice(e,e+t).buffer,g;switch(s.dataType){case"float32":g=new Float32Array(d);break;case"float16":g=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(d):new Uint16Array(d);break;case"int32":g=new Int32Array(d);break;case"uint32":g=new Uint32Array(d);break;case"int64":o?(g=YE(new Uint8Array(d),!1),s.dataType="int32"):g=new BigInt64Array(d);break;case"uint64":g=new BigUint64Array(d);break;case"int8":g=new Int8Array(d);break;case"int4":case"uint4":case"uint8":g=new Uint8Array(d);break;default:throw new Error(`Unsupported data type: ${s.dataType} in creating WebNN Constant from external data.`)}return Zi("verbose",()=>`[WebNN] registerMLConstant {dataType: ${s.dataType}, shape: ${s.shape}}} ${o?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),i.constant(s,g)}registerGraphInput(n){this.temporaryGraphInputs.push(n)}isGraphInput(n,e){let t=this.sessionGraphInputs.get(n);return t?t.includes(e):!1}isInt64Supported(n){return!!this.mlContextBySessionId.get(n)?.opSupportLimits().input.dataTypes.includes("int64")}flush(){}}}),MS=fn(()=>{}),L1,CM,PM,dP,fP,F1,JE,hP,k3,AW=fn(()=>{qh(),MS(),L1=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),CM=[],PM=n=>Math.ceil(Number(n)/16)*16,dP=n=>{for(let e=0;e<CM.length;e++){let t=CM[e];if(n<=t)return t}return Math.ceil(n/16)*16},fP=1,F1=()=>fP++,JE=async(n,e,t,i)=>{let s=PM(t),r=n.device.createBuffer({size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let o=n.getCommandEncoder();n.endComputePass(),o.copyBufferToBuffer(e,0,r,0,s),n.flush(),await r.mapAsync(GPUMapMode.READ);let l=r.getMappedRange();if(i){let c=i();return c.set(new Uint8Array(l,0,t)),c}else return new Uint8Array(l.slice(0,t))}finally{r.destroy()}},hP=class{constructor(n){this.backend=n,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of L1)CM.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(n,e){let t=e.buffer,i=e.byteOffset,s=e.byteLength,r=PM(s),o=this.storageCache.get(n);if(!o)throw new Error("gpu data for uploading does not exist");if(Number(o.originalSize)!==s)throw new Error(`inconsistent data size. gpu data size=${o.originalSize}, data size=${s}`);let l=this.backend.device.createBuffer({mappedAtCreation:!0,size:r,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),c=l.getMappedRange();new Uint8Array(c).set(new Uint8Array(t,i,s)),l.unmap();let d=this.backend.device.createCommandEncoder();d.copyBufferToBuffer(l,0,o.gpuData.buffer,0,r),this.backend.device.queue.submit([d.finish()]),l.destroy(),Zi("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${n})`)}memcpy(n,e){let t=this.storageCache.get(n);if(!t)throw new Error("source gpu data for memcpy does not exist");let i=this.storageCache.get(e);if(!i)throw new Error("destination gpu data for memcpy does not exist");if(t.originalSize!==i.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=PM(t.originalSize),r=this.backend.getCommandEncoder();this.backend.endComputePass(),r.copyBufferToBuffer(t.gpuData.buffer,0,i.gpuData.buffer,0,s)}registerExternalBuffer(n,e,t){let i;if(t){if(i=t[0],n===t[1])return Zi("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${i}, buffer is the same, skip.`),i;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else i=F1();return this.storageCache.set(i,{gpuData:{id:i,type:0,buffer:n},originalSize:e}),Zi("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${e}) => id=${i}, registered.`),i}unregisterExternalBuffer(n){n!==void 0&&(this.storageCache.delete(n),Zi("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${n}`))}create(n,e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let t=dP(n),i,s=(e&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,r=(e&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||r){let l=(s?this.freeBuffers:this.freeUniformBuffers).get(t);l?l.length>0?i=l.pop():i=this.backend.device.createBuffer({size:t,usage:e}):i=this.backend.device.createBuffer({size:t,usage:e})}else i=this.backend.device.createBuffer({size:t,usage:e});let o={id:F1(),type:0,buffer:i};return this.storageCache.set(o.id,{gpuData:o,originalSize:Number(n)}),Zi("verbose",()=>`[WebGPU] GpuDataManager.create(size=${n}) => id=${o.id}`),o}get(n){return this.storageCache.get(n)?.gpuData}release(n){let e=typeof n=="bigint"?Number(n):n,t=this.storageCache.get(e);if(!t){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return Zi("verbose",()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${t.gpuData.id}`),this.storageCache.delete(e),this.buffersPending.push(t.gpuData.buffer),t.originalSize}async download(n,e){let t=this.storageCache.get(Number(n));if(!t)throw new Error("data does not exist");await JE(this.backend,t.gpuData.buffer,t.originalSize,e)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let n of this.buffersPending){let e=L1.get(n.size);if((n.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let t=this.freeBuffers.get(n.size)||[];e===void 0||t.length>=e?n.destroy():t.push(n)}else if((n.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let t=this.freeUniformBuffers.get(n.size)||[];e===void 0||t.length>=e?n.destroy():t.push(n)}else n.destroy()}this.buffersPending=[]}else{let n=this.capturedPendingBuffers.get(this.backend.currentSessionId);n||(n=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,n));for(let e of this.buffersPending)n.push(e);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(n=>{n.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(n=>{n.forEach(e=>{e.destroy()})}),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(n=>{n.forEach(e=>{e.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(n){let e=this.capturedPendingBuffers.get(n);e&&(e.forEach(t=>{t.destroy()}),this.capturedPendingBuffers.delete(n)),this.sessionCount-=1,this.sessionCount===0&&(Zi("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map)}},k3=(...n)=>new hP(...n)}),pP,Ts,$r=fn(()=>{pP=class{constructor(n){Object.assign(this,n)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(n=>`${this[n]}`).join(";")),this.key}},Ts=n=>new pP(n)}),p0,RM,Va,qo,Wn,Lr,QE,Y_,pm,Vn,nv,Wt,zn,G3,bS,mP,V3,Mi=fn(()=>{ai(),vi(),p0=64,RM=(n,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(n)){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${n}`)}},Va=(n,e=1)=>{let t=RM(n,e);return typeof t=="string"?t:t[0]},qo=(n,e=1)=>{let t=RM(n,e);return typeof t=="string"?t:t[1]},Wn=(...n)=>{let e=[];return n.forEach(t=>{t.length!==0&&e.push({type:12,data:t},{type:12,data:Ut.computeStrides(t)})}),e},Lr=n=>n%4===0?4:n%2===0?2:1,QE=(n="f32",e,t="0")=>!e||e===1?`${n}(${t})`:`vec${e}<${n}>(${t})`,Y_=(n,e,t)=>n==="f32"?t:e===1?`f32(${t})`:`vec${e}<f32>(${t})`,pm=(n,e)=>e===4?`(${n}.x + ${n}.y + ${n}.z + ${n}.w)`:e===2?`(${n}.x + ${n}.y)`:e===3?`(${n}.x + ${n}.y + ${n}.z)`:n,Vn=(n,e,t,i)=>n.startsWith("uniforms.")&&t>4?typeof e=="string"?i==="f16"?`${n}[(${e}) / 8][(${e}) % 8 / 4][(${e}) % 8 % 4]`:`${n}[(${e}) / 4][(${e}) % 4]`:i==="f16"?`${n}[${Math.floor(e/8)}][${Math.floor(e%8/4)}][${e%8%4}]`:`${n}[${Math.floor(e/4)}][${e%4}]`:t>1?`${n}[${e}]`:n,nv=(n,e,t,i,s)=>{let r=typeof t=="number",o=r?t:t.length,l=[...new Array(o).keys()],c=o<2?"u32":o<=4?`vec${o}<u32>`:`array<u32, ${o}>`,d=RM(e,s),g=typeof d=="string"?d:d[1],p=typeof d=="string"?d:d[0],h={indices:c,value:g,storage:p,tensor:e},v=ee=>typeof ee=="string"?ee:`${ee}u`,y={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},w=r?"uniforms.":"",S=`${w}${n}_shape`,M=`${w}${n}_strides`,T="";for(let ee=0;ee<o-1;ee++)T+=`
    let dim${ee} = current / ${Vn(M,ee,o)};
    let rest${ee} = current % ${Vn(M,ee,o)};
    indices[${ee}] = dim${ee};
    current = rest${ee};
    `;T+=`indices[${o-1}] = current;`;let C=o<2?"":`
  fn o2i_${n}(offset: u32) -> ${h.indices} {
    var indices: ${h.indices};
    var current = offset;
    ${T}
    return indices;
  }`,x=ee=>(y.offsetToIndices=!0,o<2?ee:`o2i_${n}(${ee})`),R=[];if(o>=2)for(let ee=o-1;ee>=0;ee--)R.push(`${Vn(M,ee,o)} * (indices[${ee}])`);let P=o<2?"":`
  fn i2o_${n}(indices: ${h.indices}) -> u32 {
    return ${R.join("+")};
  }`,D=ee=>(y.indicesToOffset=!0,o<2?ee:`i2o_${n}(${ee})`),z=(...ee)=>o===0?"0u":`${h.indices}(${ee.map(v).join(",")})`,U=(ee,te)=>o<2?`${ee}`:`${Vn(ee,te,o)}`,N=(ee,te,ue)=>o<2?`${ee}=${ue};`:`${Vn(ee,te,o)}=${ue};`,j={},J=(ee,te)=>{y.broadcastedIndicesToOffset=!0;let ue=`${te.name}broadcastedIndicesTo${n}Offset`;if(ue in j)return`${ue}(${ee})`;let ae=[];for(let ce=o-1;ce>=0;ce--){let Be=te.indicesGet("outputIndices",ce+te.rank-o);ae.push(`${U(M,ce)} * (${Be} % ${U(S,ce)})`)}return j[ue]=`fn ${ue}(outputIndices: ${te.type.indices}) -> u32 {
             return ${ae.length>0?ae.join("+"):"0u"};
           }`,`${ue}(${ee})`},W=(ee,te)=>(()=>{if(h.storage===h.value)return`${n}[${ee}]=${te};`;if(h.storage==="vec2<u32>"&&h.value==="i32")return`${n}[${ee}]=vec2<u32>(u32(${te}), select(0u, 0xFFFFFFFFu, ${te} < 0));`;if(h.storage==="vec2<u32>"&&h.value==="u32")return`${n}[${ee}]=vec2<u32>(u32(${te}), 0u);`;if(h.storage==="u32"&&h.value==="vec4<bool>")return`${n}[${ee}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${te}));`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),oe=ee=>(()=>{if(h.storage===h.value)return`${n}[${ee}]`;if(h.storage==="vec2<u32>"&&h.value==="i32")return`i32(${n}[${ee}].x)`;if(h.storage==="vec2<u32>"&&h.value==="u32")return`u32(${n}[${ee}].x)`;if(h.storage==="u32"&&h.value==="vec4<bool>")return`vec4<bool>(bool(${n}[${ee}] & 0xFFu), bool(${n}[${ee}] & 0xFF00u), bool(${n}[${ee}] & 0xFF0000u), bool(${n}[${ee}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),ne=o<2?"":`
  fn get_${n}ByIndices(indices: ${h.indices}) -> ${g} {
    return ${oe(`i2o_${n}(indices)`)};
  }`,q=o<2?"":(()=>{let ee=l.map(ue=>`d${ue}: u32`).join(", "),te=l.map(ue=>`d${ue}`).join(", ");return`
  fn get_${n}(${ee}) -> ${g} {
    return get_${n}ByIndices(${z(te)});
  }`})(),le=(...ee)=>{if(ee.length!==o)throw new Error(`indices length must be ${o}`);let te=ee.map(v).join(",");return o===0?oe("0u"):o===1?oe(te[0]):(y.get=!0,y.getByIndices=!0,y.indicesToOffset=!0,`get_${n}(${te})`)},se=ee=>o<2?oe(ee):(y.getByIndices=!0,y.indicesToOffset=!0,`get_${n}ByIndices(${ee})`),pe=o<2?"":`
  fn set_${n}ByIndices(indices: ${h.indices}, value: ${g}) {
    ${W(`i2o_${n}(indices)`,"value")}
  }`,be=o<2?"":(()=>{let ee=l.map(ue=>`d${ue}: u32`).join(", "),te=l.map(ue=>`d${ue}`).join(", ");return`
  fn set_${n}(${ee}, value: ${g}) {
    set_${n}ByIndices(${z(te)}, value);
  }`})();return{impl:()=>{let ee=[],te=!1;return y.offsetToIndices&&(ee.push(C),te=!0),y.indicesToOffset&&(ee.push(P),te=!0),y.broadcastedIndicesToOffset&&(Object.values(j).forEach(ue=>ee.push(ue)),te=!0),y.set&&(ee.push(be),te=!0),y.setByIndices&&(ee.push(pe),te=!0),y.get&&(ee.push(q),te=!0),y.getByIndices&&(ee.push(ne),te=!0),!r&&te&&ee.unshift(`const ${S} = ${h.indices}(${t.join(",")});`,`const ${M} = ${h.indices}(${Ut.computeStrides(t).join(",")});`),ee.join(`
`)},type:h,offsetToIndices:x,indicesToOffset:D,broadcastedIndicesToOffset:J,indices:z,indicesGet:U,indicesSet:N,set:(...ee)=>{if(ee.length!==o+1)throw new Error(`indices length must be ${o}`);let te=ee[o];if(typeof te!="string")throw new Error("value must be string");let ue=ee.slice(0,o).map(v).join(",");return o===0?W("0u",te):o===1?W(ue[0],te):(y.set=!0,y.setByIndices=!0,y.indicesToOffset=!0,`set_${n}(${ue}, ${te})`)},setByOffset:W,setByIndices:(ee,te)=>o<2?W(ee,te):(y.setByIndices=!0,y.indicesToOffset=!0,`set_${n}ByIndices(${ee}, ${te});`),get:le,getByOffset:oe,getByIndices:se,usage:i,name:n,strides:M,shape:S,rank:o}},Wt=(n,e,t,i=1)=>nv(n,e,t,"input",i),zn=(n,e,t,i=1)=>nv(n,e,t,"output",i),G3=(n,e,t)=>nv(n,e,t,"atomicOutput",1),bS=(n,e,t,i=1)=>nv(n,e,t,"internal",i),mP=class{constructor(n,e){this.normalizedDispatchGroup=n,this.limits=e,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(n){return`if (global_idx >= ${typeof n=="number"?`${n}u`:n}) { return; }`}mainStart(n=p0){let e=typeof n=="number"?n:n[0],t=typeof n=="number"?1:n[1],i=typeof n=="number"?1:n[2];if(e>this.limits.maxComputeWorkgroupSizeX||t>this.limits.maxComputeWorkgroupSizeY||i>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${e}, ${t}, ${i}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(e*t*i>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${e}, ${t}, ${i}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,r=s?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,o=s?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${e*t*i}u + local_idx;`;return`@compute @workgroup_size(${e}, ${t}, ${i})
  fn main(${r}) {
    ${o}
  `}appendVariableUniforms(n){n.rank!==0&&(n.shape.startsWith("uniforms.")&&this.uniforms.push({name:n.shape.replace("uniforms.",""),type:"u32",length:n.rank}),n.strides.startsWith("uniforms.")&&this.uniforms.push({name:n.strides.replace("uniforms.",""),type:"u32",length:n.rank}))}declareVariable(n,e){if(n.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(n),this.appendVariableUniforms(n);let t=n.usage==="input"?"read":"read_write",i=n.usage==="atomicOutput"?"atomic<i32>":n.type.storage;return`@group(0) @binding(${e}) var<storage, ${t}> ${n.name}: array<${i}>;`}declareVariables(...n){return n.map(e=>this.declareVariable(e,this.variableIndex++)).join(`
`)}registerInternalVariable(n){if(n.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(n),this.appendVariableUniforms(n)}registerInternalVariables(...n){return n.forEach(e=>this.registerInternalVariable(e)),this}registerUniform(n,e,t=1){return this.uniforms.push({name:n,type:e,length:t}),this}registerUniforms(n){return this.uniforms=this.uniforms.concat(n),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let n=[];for(let{name:e,type:t,length:i}of this.uniforms)if(i&&i>4)t==="f16"?n.push(`@align(16) ${e}:array<mat2x4<${t}>, ${Math.ceil(i/8)}>`):n.push(`${e}:array<vec4<${t}>, ${Math.ceil(i/4)}>`);else{let s=i==null||i===1?t:`vec${i}<${t}>`;n.push(`${e}:${s}`)}return`
      struct Uniforms { ${n.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(n=>n.impl()).join(`
`)+this.internalVariables.map(n=>n.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let n=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map(e=>[n(e.type),e.length??1])}},V3=(n,e)=>new mP(n,e)}),gP,N1,_P,vP,yP,MP,Yu,H3,j3,ym=fn(()=>{ai(),vi(),$r(),Mi(),gP=(n,e)=>{if(!n||n.length!==1)throw new Error("Transpose requires 1 input.");if(e.length!==0&&e.length!==n[0].dims.length)throw new Error(`perm size ${e.length} does not match input rank ${n[0].dims.length}`)},N1=(n,e)=>e.length!==0?e:[...new Array(n).keys()].reverse(),_P=(n,e)=>Ut.sortBasedOnPerm(n,N1(n.length,e)),vP=(n,e,t,i)=>{let s=`fn perm(i: ${i.type.indices}) -> ${t.type.indices} {
    var a: ${t.type.indices};`;for(let r=0;r<e;++r)s+=`a[${n[r]}]=i[${r}];`;return s+="return a;}"},yP=(n,e)=>{let t=[],i=[];for(let s=0;s<n.length;++s)n[s]!==1&&t.push(n[s]),n[e[s]]!==1&&i.push(e[s]);return{newShape:t,newPerm:i}},MP=(n,e)=>{let t=0;for(let i=0;i<n.length;++i)if(e[n[i]]!==1){if(n[i]<t)return!1;t=n[i]}return!0},Yu=(n,e)=>{let t=n.dataType,i=n.dims.length,s=N1(i,e),r=_P(n.dims,s),o=n.dims,l=r,c=i<2||MP(s,n.dims),d;if(c)return d=y=>{let w=Wt("input",t,o,4),S=zn("output",t,l,4);return`
  ${y.registerUniform("output_size","u32").declareVariables(w,S)}
  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let y=Ut.size(r);return{outputs:[{dims:r,dataType:n.dataType}],dispatchGroup:{x:Math.ceil(y/64/4)},programUniforms:[{type:12,data:Math.ceil(y/4)}]}},getShaderSource:d};let{newShape:g,newPerm:p}=yP(n.dims,s),h=Ut.areEqual(p,[2,3,1]),v=Ut.areEqual(p,[3,1,2]);if(g.length===2||h||v){o=h?[g[0],g[1]*g[2]]:v?[g[0]*g[1],g[2]]:g,l=[o[1],o[0]];let y=16;return d=w=>{let S=Wt("a",t,o.length),M=zn("output",t,l.length);return`
  ${w.registerUniform("output_size","u32").declareVariables(S,M)}
  var<workgroup> tile : array<array<${M.type.value}, ${y+1}>, ${y}>;
  ${w.mainStart([y,y,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${y} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${y}u + local_id.x;
    let input_row = workgroup_id_x * ${y}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${S.getByIndices(`${S.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${y}u + local_id.x;
    let output_row = workgroup_id_y * ${y}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${M.setByIndices(`${M.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let w=Ut.size(r);return{outputs:[{dims:r,dataType:n.dataType}],dispatchGroup:{x:Math.ceil(l[1]/y),y:Math.ceil(l[0]/y)},programUniforms:[{type:12,data:w},...Wn(o,l)]}},getShaderSource:d}}return d=y=>{let w=Wt("a",t,o.length),S=zn("output",t,l.length);return`
  ${y.registerUniform("output_size","u32").declareVariables(w,S)}

  ${vP(s,i,w,S)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${S.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${S.setByOffset("global_idx",w.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:["rank"]},getRunData:()=>{let y=Ut.size(r);return{outputs:[{dims:r,dataType:n.dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},...Wn(o,l)]}},getShaderSource:d}},H3=(n,e)=>{gP(n.inputs,e.perm),n.compute(Yu(n.inputs[0],e.perm))},j3=n=>Ts({perm:n.perm})}),bP,xP,wP,EP,TP,SP,AP,CP,PP,RP,Ed,$3,W3,K3,q3,X3,Y3,J3,Q3,Z3,eL,CW=fn(()=>{ai(),vi(),Mi(),xS(),ym(),bP={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},xP={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},wP={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},EP={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},TP=(n,e)=>{let t=[];for(let i=e-n;i<e;++i)t.push(i);return t},SP=(n,e)=>{let t=[],i=n.length;for(let r=0;r<i;r++)e.indexOf(r)===-1&&t.push(n[r]);let s=e.map(r=>n[r]);return[t,s]},AP=(n,e)=>{let t=n.length+e.length,i=[],s=0;for(let r=0;r<t;r++)e.indexOf(r)===-1?i.push(n[s++]):i.push(1);return i},CP=(n,e)=>{for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0},PP=(n,e)=>{let t=[];if(!CP(n,e)){for(let i=0;i<e;++i)n.indexOf(i)===-1&&t.push(i);n.forEach(i=>t.push(i))}return t},RP=(n,e,t,i,s,r,o)=>{let l=t[0].dims,c=Ut.size(r),d=Ut.size(o),g=Wt("_A",t[0].dataType,l),p=zn("output",s,r),h=64;c===1&&(h=256);let v=`
          var<workgroup> aBestValues : array<f32, ${h}>;
       `,y=w=>`
        ${w.registerUniform("reduceSize","u32").declareVariables(g,p)}
        ${v}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${w.mainStart(h)}

          let outputIndex = global_idx / ${h};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${wP[i]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${h}) {
           let candidate = f32(${g.getByOffset("offset + k")});
           bestValue = ${bP[i]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${h}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${xP[i]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${p.setByOffset("outputIndex",`${i==="mean"?`${p.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${p.type.storage}(${EP[i]})`}`)};
         }
        }`;return{name:n,shaderCache:{hint:`${e};${h}`,inputDependencies:["type"]},getShaderSource:y,getRunData:()=>({outputs:[{dims:r,dataType:s}],dispatchGroup:{x:c},programUniforms:[{type:12,data:d}]})}},Ed=(n,e,t,i)=>{let s=n.inputs.length===1?t:ZE(n.inputs,t),r=s.axes;r.length===0&&!s.noopWithEmptyAxes&&(r=n.inputs[0].dims.map((v,y)=>y));let o=Ut.normalizeAxes(r,n.inputs[0].dims.length),l=o,c=n.inputs[0],d=PP(l,n.inputs[0].dims.length);d.length>0&&(c=n.compute(Yu(n.inputs[0],d),{inputs:[0],outputs:[-1]})[0],l=TP(l.length,c.dims.length));let[g,p]=SP(c.dims,l),h=g;s.keepDims&&(h=AP(g,o)),n.compute(RP(e,s.cacheKey,[c],i,n.inputs[0].dataType,h,p),{inputs:[c]})},$3=(n,e)=>{Ed(n,"ReduceMeanShared",e,"mean")},W3=(n,e)=>{Ed(n,"ReduceL1Shared",e,"l1")},K3=(n,e)=>{Ed(n,"ReduceL2Shared",e,"l2")},q3=(n,e)=>{Ed(n,"ReduceLogSumExpShared",e,"logSumExp")},X3=(n,e)=>{Ed(n,"ReduceMaxShared",e,"max")},Y3=(n,e)=>{Ed(n,"ReduceMinShared",e,"min")},J3=(n,e)=>{Ed(n,"ReduceProdShared",e,"prod")},Q3=(n,e)=>{Ed(n,"ReduceSumShared",e,"sum")},Z3=(n,e)=>{Ed(n,"ReduceSumSquareShared",e,"sumSquare")},eL=(n,e)=>{Ed(n,"ReduceLogSumShared",e,"logSum")}}),Td,DP,Vb,ZE,Sd,BP,IP,OP,LP,FP,NP,zP,UP,kP,GP,Ad,tL,nL,iL,sL,rL,aL,oL,lL,uL,cL,xS=fn(()=>{ai(),vi(),$r(),Mi(),CW(),Td=n=>{if(!n||n.length===0||n.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(n.length===2&&n[1].dims.length!==1)throw new Error("Invalid axes input dims.")},DP=n=>["","",`var value = ${n.getByIndices("input_indices")};`,""],Vb=(n,e,t,i,s,r,o=!1,l=!1)=>{let c=[],d=t[0].dims,g=d.length,p=Ut.normalizeAxes(s,g),h=!l&&p.length===0;d.forEach((w,S)=>{h||p.indexOf(S)>=0?o&&c.push(1):c.push(w)});let v=c.length,y=Ut.size(c);return{name:n,shaderCache:e,getShaderSource:w=>{let S=[],M=Wt("_A",t[0].dataType,g),T=zn("output",r,v),C=i(M,T,p),x=C[2];for(let R=0,P=0;R<g;R++)h||p.indexOf(R)>=0?(o&&P++,x=`for(var j${R}: u32 = 0; j${R} < ${d[R]}; j${R}++) {
                  ${C[2].includes("last_index")?`let last_index = j${R};`:""}
                  ${M.indicesSet("input_indices",R,`j${R}`)}
                  ${x}
                }`):(S.push(`${M.indicesSet("input_indices",R,T.indicesGet("output_indices",P))};`),P++);return`

        ${w.registerUniform("output_size","u32").declareVariables(M,T)}

        ${w.mainStart()}
          ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${M.type.indices};
          let output_indices = ${T.offsetToIndices("global_idx")};

          ${S.join(`
`)}
          ${C[0]}       // init ops for reduce max/min
          ${C[1]}
          ${x}
          ${C[3]}
          ${C.length===4?T.setByOffset("global_idx","value"):C.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:c,dataType:r}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},...Wn(d,c)]})}},ZE=(n,e)=>{let t=[];return n[1].dims[0]>0&&n[1].getBigInt64Array().forEach(i=>t.push(Number(i))),Ts({axes:t,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},Sd=(n,e,t,i)=>{let s=n.inputs,r=s.length===1?t:ZE(s,t);n.compute(Vb(e,{hint:r.cacheKey,inputDependencies:["rank"]},[s[0]],r.noopWithEmptyAxes&&r.axes.length===0?DP:i,r.axes,s[0].dataType,r.keepDims,r.noopWithEmptyAxes),{inputs:[0]})},BP=(n,e)=>{Td(n.inputs),Sd(n,"ReduceLogSum",e,(t,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${t.getByIndices("input_indices")};`,"value = log(value);"])},IP=(n,e)=>{Td(n.inputs),Sd(n,"ReduceL1",e,(t,i)=>[`var value = ${i.type.storage}(0);`,"",`value += abs(${t.getByIndices("input_indices")});`,""])},OP=(n,e)=>{Td(n.inputs),Sd(n,"ReduceL2",e,(t,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${t.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},LP=(n,e)=>{Td(n.inputs),Sd(n,"ReduceLogSumExp",e,(t,i)=>[`var value = ${i.type.storage}(0);`,"",`value += exp(${t.getByIndices("input_indices")});`,"value = log(value);"])},FP=(n,e)=>{Td(n.inputs),Sd(n,"ReduceMax",e,(t,i,s)=>{let r=[];for(let o=0;o<t.rank;o++)(s.indexOf(o)>=0||s.length===0)&&r.push(t.indicesSet("input_indices",o,0));return[`${r.join(`
`)}`,`var value = ${t.getByIndices("input_indices")};`,`value = max(value, ${t.getByIndices("input_indices")});`,""]})},NP=(n,e)=>{Td(n.inputs),Sd(n,"ReduceMean",e,(t,i,s)=>{let r=1;for(let o=0;o<t.rank;o++)(s.indexOf(o)>=0||s.length===0)&&(r*=n.inputs[0].dims[o]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${i.type.value}(sum / ${r});`]})},zP=(n,e)=>{Td(n.inputs),Sd(n,"ReduceMin",e,(t,i,s)=>{let r=[];for(let o=0;o<t.rank;o++)(s.indexOf(o)>=0||s.length===0)&&r.push(`input_indices[${o}] = 0;`);return[`${r.join(`
`)}`,`var value = ${t.getByIndices("input_indices")};`,`value = min(value, ${t.getByIndices("input_indices")});`,""]})},UP=(n,e)=>{Td(n.inputs),Sd(n,"ReduceProd",e,(t,i)=>[`var value = ${i.type.storage}(1);`,"",`value *= ${t.getByIndices("input_indices")};`,""])},kP=(n,e)=>{Td(n.inputs),Sd(n,"ReduceSum",e,(t,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${t.getByIndices("input_indices")};`,""])},GP=(n,e)=>{Td(n.inputs),Sd(n,"ReduceSumSquare",e,(t,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${t.getByIndices("input_indices")}; value += t * t;`,""])},Ad=(n,e,t)=>{if(e.length===0)return t;let i=1,s=1;for(let r=0;r<e.length;r++)e.indexOf(r)===-1?i*=n[r]:s*=n[r];return s<32&&i>1024},tL=(n,e)=>{Ad(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?NP(n,e):$3(n,e)},nL=(n,e)=>{Ad(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?IP(n,e):W3(n,e)},iL=(n,e)=>{Ad(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?OP(n,e):K3(n,e)},sL=(n,e)=>{Ad(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?LP(n,e):q3(n,e)},rL=(n,e)=>{Ad(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?FP(n,e):X3(n,e)},aL=(n,e)=>{Ad(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?zP(n,e):Y3(n,e)},oL=(n,e)=>{Ad(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?UP(n,e):J3(n,e)},lL=(n,e)=>{Ad(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?kP(n,e):Q3(n,e)},uL=(n,e)=>{Ad(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?GP(n,e):Z3(n,e)},cL=(n,e)=>{Ad(n.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?BP(n,e):eL(n,e)}}),z1,dL,fL,eT,PW=fn(()=>{ai(),$r(),xS(),z1=n=>{if(!n||n.length===0||n.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(n[0].dataType!==1)throw new Error("Invalid input type.")},dL=(n,e)=>{z1(n.inputs);let t=(i,s,r)=>{let o=[];for(let l=0;l<i.rank;l++)(r.indexOf(l)>=0||r.length===0)&&o.push(`input_indices[${l}] = 0;`);return[`${o.join(`
`)}`,`var value = ${i.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${i.getByIndices("input_indices")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${i.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",s.setByOffset("global_idx","best_index")]};n.compute(Vb("ArgMin",{hint:e.cacheKey,inputDependencies:["rank"]},[n.inputs[0]],t,[e.axis],7,e.keepDims),{inputs:[0]})},fL=(n,e)=>{z1(n.inputs);let t=(i,s,r)=>{let o=[];for(let l=0;l<i.rank;l++)(r.indexOf(l)>=0||r.length===0)&&o.push(`input_indices[${l}] = 0;`);return[`${o.join(`
`)}`,`var value = ${i.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${i.getByIndices("input_indices")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${i.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",s.setByOffset("global_idx","best_index")]};n.compute(Vb("argMax",{hint:e.cacheKey,inputDependencies:["rank"]},[n.inputs[0]],t,[e.axis],7,e.keepDims),{inputs:[0]})},eT=n=>Ts(n)}),VP,DM,HP,jP,$P,jv,WP,hL,wS=fn(()=>{ai(),vi(),MS(),Mi(),VP=(n,e)=>{let t=n[0],i=n[1],s=n[2],r=n[3],o=n[4],l=n[5];if(o&&l)throw new Error("Attention cannot have both past and attention_bias");if(t.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let c=t.dims[0],d=t.dims[1],g=t.dims[2];if(s.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(i.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(i.dims[0]!==g)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(s.dims[0]!==i.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let p=s.dims[0]/3,h=p,v=h;if(e.qkvHiddenSizes.length>0){if(e.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let C of e.qkvHiddenSizes)if(C%e.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");p=e.qkvHiddenSizes[0],h=e.qkvHiddenSizes[1],v=e.qkvHiddenSizes[2]}let y=d;if(p!==h)throw new Error("qkv_hidden_sizes first element should be same as the second");if(s.dims[0]!==p+h+v)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let w=0;if(o){if(h!==v)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(o.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(o.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(o.dims[1]!==c)throw new Error('Input "past" second dimension must be batch_size');if(o.dims[2]!==e.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(o.dims[4]!==h/e.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');e.pastPresentShareBuffer||(w=o.dims[3])}let S=y+w,M=-1,T=0;if(r)throw new Error("Mask not supported");if(o)throw new Error("past is not supported");if(l){if(l.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(l.dims[0]!==c||l.dims[1]!==e.numHeads||l.dims[2]!==d||l.dims[3]!==S)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:c,sequenceLength:d,pastSequenceLength:w,kvSequenceLength:y,totalSequenceLength:S,maxSequenceLength:M,inputHiddenSize:g,hiddenSize:p,vHiddenSize:v,headSize:Math.floor(p/e.numHeads),vHeadSize:Math.floor(v/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:T,scale:e.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},DM=(n,e,t)=>e&&n?`
      let total_sequence_length_input = u32(${e.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${n?.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${t?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,HP=(n,e,t,i,s,r,o,l)=>{let c=Lr(o?1:r),d=64,g=r/c;g<d&&(d=32);let p=Math.ceil(r/c/d),h=[{type:12,data:e},{type:12,data:t},{type:12,data:i},{type:12,data:s},{type:12,data:g},{type:12,data:p}],v=Va(n.dataType,c),y=qo(1,c),w=["type"];o&&w.push("type"),l&&w.push("type");let S=M=>{let T=zn("x",n.dataType,n.dims,c),C=[T],x=o?Wt("seq_lens",o.dataType,o.dims):void 0;x&&C.push(x);let R=l?Wt("total_sequence_length_input",l.dataType,l.dims):void 0;R&&C.push(R);let P=qo(n.dataType),D=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${d}>;
  var<workgroup> thread_sum: array<f32, ${d}>;
  ${M.registerUniforms(D).declareVariables(...C)}
  ${M.mainStart([d,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${DM(x,R,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${d}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${o?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${y}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${y}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(c){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${c}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${d}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${y}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${y}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(c){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${c}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${d}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${T.type.value}(${P}(1.0) / ${P}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${y}(x[offset + i]);
        x[offset + i] = ${T.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${o?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${T.type.value}(${P}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${d};${v};${c}`,inputDependencies:w},getShaderSource:S,getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:s,z:e*t},programUniforms:h})}},jP=(n,e,t,i,s,r,o,l,c)=>{let d=o+r.kvSequenceLength,g=[r.batchSize,r.numHeads,r.sequenceLength,d],p=n>1&&i,h=r.kvNumHeads?r.kvNumHeads:r.numHeads,v=p?[r.batchSize,h,d,r.headSize]:void 0,y=r.nReps?r.nReps:1,w=r.scale===0?1/Math.sqrt(r.headSize):r.scale,S=Lr(r.headSize),M=r.headSize/S,T=12,C={x:Math.ceil(d/T),y:Math.ceil(r.sequenceLength/T),z:r.batchSize*r.numHeads},x=[{type:12,data:r.sequenceLength},{type:12,data:M},{type:12,data:d},{type:12,data:r.numHeads},{type:12,data:r.headSize},{type:1,data:w},{type:12,data:o},{type:12,data:r.kvSequenceLength},{type:12,data:y}],R=p&&i&&Ut.size(i.dims)>0,P=["type","type"];R&&P.push("type"),s&&P.push("type"),l&&P.push("type"),c&&P.push("type");let D=[{dims:g,dataType:e.dataType,gpuDataType:0}];p&&D.push({dims:v,dataType:e.dataType,gpuDataType:0});let z=U=>{let N=Wt("q",e.dataType,e.dims,S),j=Wt("key",t.dataType,t.dims,S),J=[N,j];if(R){let pe=Wt("past_key",i.dataType,i.dims,S);J.push(pe)}s&&J.push(Wt("attention_bias",s.dataType,s.dims));let W=l?Wt("seq_lens",l.dataType,l.dims):void 0;W&&J.push(W);let oe=c?Wt("total_sequence_length_input",c.dataType,c.dims):void 0;oe&&J.push(oe);let ne=zn("output",e.dataType,g),q=[ne];p&&q.push(zn("present_key",e.dataType,v,S));let le=qo(1,S),se=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${T}u;

  var<workgroup> tileQ: array<${N.type.storage}, ${T*T}>;
  var<workgroup> tileK: array<${N.type.storage}, ${T*T}>;
  ${U.registerUniforms(se).declareVariables(...J,...q)}
  ${U.mainStart([T,T,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${y===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${y===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${DM(W,oe,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${R&&p?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${p?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${le}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${R&&p?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${p?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${le}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(S){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${S}`)}})()};
        output[outputIdx] = ${ne.type.value} (sum * uniforms.alpha) + ${s?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${S};${s!==void 0};${i!==void 0};${n}`,inputDependencies:P},getRunData:()=>({outputs:D,dispatchGroup:C,programUniforms:x}),getShaderSource:z}},$P=(n,e,t,i,s,r,o=void 0,l=void 0)=>{let c=r+s.kvSequenceLength,d=s.nReps?s.nReps:1,g=s.vHiddenSize*d,p=n>1&&i,h=s.kvNumHeads?s.kvNumHeads:s.numHeads,v=p?[s.batchSize,h,c,s.headSize]:void 0,y=[s.batchSize,s.sequenceLength,g],w=12,S={x:Math.ceil(s.vHeadSize/w),y:Math.ceil(s.sequenceLength/w),z:s.batchSize*s.numHeads},M=[{type:12,data:s.sequenceLength},{type:12,data:c},{type:12,data:s.vHeadSize},{type:12,data:s.numHeads},{type:12,data:s.headSize},{type:12,data:g},{type:12,data:r},{type:12,data:s.kvSequenceLength},{type:12,data:d}],T=p&&i&&Ut.size(i.dims)>0,C=["type","type"];T&&C.push("type"),o&&C.push("type"),l&&C.push("type");let x=[{dims:y,dataType:e.dataType,gpuDataType:0}];p&&x.push({dims:v,dataType:e.dataType,gpuDataType:0});let R=P=>{let D=Wt("probs",e.dataType,e.dims),z=Wt("v",t.dataType,t.dims),U=[D,z];T&&U.push(Wt("past_value",i.dataType,i.dims));let N=o?Wt("seq_lens",o.dataType,o.dims):void 0;o&&U.push(N);let j=l?Wt("total_sequence_length_input",l.dataType,l.dims):void 0;l&&U.push(j);let J=[zn("output",e.dataType,y)];p&&J.push(zn("present_value",e.dataType,v));let W=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${w}u;
  var<workgroup> tileQ: array<${D.type.value}, ${w*w}>;
  var<workgroup> tileV: array<${D.type.value}, ${w*w}>;
  ${P.registerUniforms(W).declareVariables(...U,...J)}
  ${P.mainStart([w,w,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${d===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${d===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${DM(N,j,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${T&&p?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${p?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${D.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${T&&p?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${p?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${i!==void 0};${n}`,inputDependencies:C},getRunData:()=>({outputs:x,dispatchGroup:S,programUniforms:M}),getShaderSource:R}},jv=(n,e,t,i,s,r,o,l,c,d,g=void 0,p=void 0)=>{let h=Math.min(n.outputCount,1+(o?1:0)+(l?1:0)),v=h>1?d.pastSequenceLength:0,y=v+d.kvSequenceLength,w=c&&Ut.size(c.dims)>0?c:void 0,S=[e,t];h>1&&o&&Ut.size(o.dims)>0&&S.push(o),w&&S.push(w),g&&S.push(g),p&&S.push(p);let M=n.compute(jP(h,e,t,o,w,d,v,g,p),{inputs:S,outputs:h>1?[-1,1]:[-1]})[0];n.compute(HP(M,d.batchSize,d.numHeads,v,d.sequenceLength,y,g,p),{inputs:g&&p?[M,g,p]:[M],outputs:[]});let T=[M,i];h>1&&l&&Ut.size(l.dims)>0&&T.push(l),g&&T.push(g),p&&T.push(p),n.compute($P(h,M,i,l,d,v,g,p),{inputs:T,outputs:h>1?[0,2]:[0]})},WP=(n,e)=>{let t=[e.batchSize,e.numHeads,e.sequenceLength,e.headSize],i=e.sequenceLength,s=e.inputHiddenSize,r=e.headSize,o=12,l={x:Math.ceil(e.headSize/o),y:Math.ceil(e.sequenceLength/o),z:e.batchSize*e.numHeads},c=[n.inputs[0],n.inputs[1],n.inputs[2]],d=[{type:12,data:i},{type:12,data:s},{type:12,data:r},{type:12,data:e.numHeads},{type:12,data:e.headSize},{type:12,data:e.hiddenSize},{type:12,data:e.hiddenSize+e.hiddenSize+e.vHiddenSize}],g=p=>{let h=zn("output_q",c[0].dataType,t),v=zn("output_k",c[0].dataType,t),y=zn("output_v",c[0].dataType,t),w=Wt("input",c[0].dataType,c[0].dims),S=Wt("weight",c[1].dataType,c[1].dims),M=Wt("bias",c[2].dataType,c[2].dims),T=w.type.storage,C=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${o}u;
  var<workgroup> tileInput: array<${T}, ${o*o}>;
  var<workgroup> tileWeightQ: array<${T}, ${o*o}>;
  var<workgroup> tileWeightK: array<${T}, ${o*o}>;
  var<workgroup> tileWeightV: array<${T}, ${o*o}>;
  ${p.registerUniforms(C).declareVariables(w,S,M,h,v,y)}
  ${p.mainStart([o,o,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${T}(0);
    var valueK = ${T}(0);
    var valueV = ${T}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return n.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:t,dataType:n.inputs[0].dataType,gpuDataType:0},{dims:t,dataType:n.inputs[0].dataType,gpuDataType:0},{dims:t,dataType:n.inputs[0].dataType,gpuDataType:0}],dispatchGroup:l,programUniforms:d}),getShaderSource:g},{inputs:c,outputs:[-1,-1,-1]})},hL=(n,e)=>{let t=VP(n.inputs,e),[i,s,r]=WP(n,t);return jv(n,i,s,r,n.inputs[4],void 0,void 0,void 0,n.inputs[5],t)}}),KP,qP,XP,pL,RW=fn(()=>{Gd(),ai(),vi(),$r(),Mi(),KP=(n,e)=>{if(!n||n.length!==5)throw new Error("BatchNormalization requires 5 inputs");let t=(i,s,r)=>{let o=s.length;if(o!==i.length)throw new Error(`${r}: num dimensions != ${o}`);s.forEach((l,c)=>{if(l!==i[c])throw new Error(`${r}: dim[${c}] do not match`)})};if(n[0].dims.length>1){let i=e.format==="NHWC"?e.spatial?n[0].dims.slice(-1):n[0].dims.slice(-1).concat(n[0].dims.slice(1,n[0].dims.length-1)):n[0].dims.slice(1,e.spatial?2:void 0);t(n[1].dims,i,"Invalid input scale"),t(n[2].dims,i,"Invalid input B"),t(n[3].dims,i,"Invalid input mean"),t(n[4].dims,i,"Invalid input var")}else t(n[1].dims,[1],"Invalid input scale"),t(n[2].dims,[1],"Invalid input B"),t(n[3].dims,[1],"Invalid input mean"),t(n[4].dims,[1],"Invalid input var")},qP=(n,e)=>{let{epsilon:t,spatial:i,format:s}=e,r=n[0].dims,o=i?Lr(r[r.length-1]):1,l=s==="NHWC"&&r.length>1?o:1,c=Ut.size(r)/o,d=i,g=d?r.length:r,p=Wt("x",n[0].dataType,n[0].dims,o),h=Wt("scale",n[1].dataType,n[1].dims,l),v=Wt("bias",n[2].dataType,n[2].dims,l),y=Wt("inputMean",n[3].dataType,n[3].dims,l),w=Wt("inputVar",n[4].dataType,n[4].dims,l),S=zn("y",n[0].dataType,g,o),M=()=>{let C="";if(i)C=`let cOffset = ${r.length===1?"0u":s==="NHWC"?`outputIndices[${r.length-1}] / ${o}`:"outputIndices[1]"};`;else if(s==="NCHW")C=`
            ${S.indicesSet("outputIndices","0","0")}
            let cOffset = ${S.indicesToOffset("outputIndices")};`;else{C=`var cIndices = ${h.type.indices}(0);
                       cIndices[0] = outputIndices[${r.length-1}];`;for(let x=1;x<h.rank;x++)C+=`cIndices[${x}] = outputIndices[${x}];`;C+=`let cOffset = ${h.indicesToOffset("cIndices")};`}return C},T=C=>`
  const epsilon = ${t};
  ${C.registerUniform("outputSize","u32").declareVariables(p,h,v,y,w,S)}
  ${C.mainStart()}
  ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${S.offsetToIndices(`global_idx * ${o}`)};
    ${M()}
    let scale = ${h.getByOffset("cOffset")};
    let bias = ${v.getByOffset("cOffset")};
    let inputMean = ${y.getByOffset("cOffset")};
    let inputVar = ${w.getByOffset("cOffset")};
    let x = ${p.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${S.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${e.epsilon}_${e.format}_${i}_${o}`,inputDependencies:d?["rank","type","type","type","type"]:void 0},getShaderSource:T,getRunData:()=>({outputs:[{dims:n[0].dims,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:d?[{type:12,data:c},...Wn(r)]:[{type:12,data:c}]})}},XP=n=>Ts(n),pL=(n,e)=>{let{inputs:t,outputCount:i}=n,s=XP({...e,outputCount:i});if(ur.webgpu.validateInputContent&&KP(t,s),e.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");n.compute(qP(t,s))}}),YP,JP,mL,DW=fn(()=>{vi(),Mi(),YP=n=>{if(n[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(n[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(n[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(n[0].dims[2]!==n[1].dims[0])throw new Error("last dimension of input and bias are not the same")},JP=n=>{let e=n[0].dims,t=n[0].dims[2],i=Ut.size(e)/4,s=n[0].dataType,r=Wt("input",s,e,4),o=Wt("bias",s,[t],4),l=Wt("residual",s,e,4),c=zn("output",s,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:d=>`
  const channels = ${t}u / 4;
  ${d.declareVariables(r,o,l,c)}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let value = ${r.getByOffset("global_idx")}
      + ${o.getByOffset("global_idx % channels")} + ${l.getByOffset("global_idx")};
    ${c.setByOffset("global_idx","value")}
  }`}},mL=n=>{YP(n.inputs),n.compute(JP(n.inputs))}}),QP,vs,gL,_L,vL,yL,ML,bL,xL,wL,EL,ZP,TL,SL,AL,CL,mv,PL,WM,RL,DL,BL,IL,OL,LL,FL,NL,zL,UL,kL,GL,VL,HL,jL,$L,U1,WL,tT,nT,KL,qL,XL,eR,tR,YL,ES=fn(()=>{ai(),vi(),$r(),Mi(),QP=(n,e,t,i,s,r,o)=>{let l=Math.ceil(e/4),c="";typeof s=="string"?c=`${s}(a)`:c=s("a");let d=Wt("inputData",t,[l],4),g=zn("outputData",i,[l],4),p=[{name:"vec_size",type:"u32"}];return o&&p.push(...o),`
      ${n.registerUniforms(p).declareVariables(d,g)}

  ${r??""}

  ${n.mainStart()}
    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${d.getByOffset("global_idx")};
    ${g.setByOffset("global_idx",c)}
  }`},vs=(n,e,t,i,s,r=n.dataType,o,l)=>{let c=[{type:12,data:Math.ceil(Ut.size(n.dims)/4)}];return o&&c.push(...o),{name:e,shaderCache:{hint:s,inputDependencies:["type"]},getShaderSource:d=>QP(d,Ut.size(n.dims),n.dataType,r,t,i,l),getRunData:d=>({outputs:[{dims:n.dims,dataType:r}],dispatchGroup:{x:Math.ceil(Ut.size(d[0].dims)/64/4)},programUniforms:c})}},gL=n=>{n.compute(vs(n.inputs[0],"Abs","abs"))},_L=n=>{n.compute(vs(n.inputs[0],"Acos","acos"))},vL=n=>{n.compute(vs(n.inputs[0],"Acosh","acosh"))},yL=n=>{n.compute(vs(n.inputs[0],"Asin","asin"))},ML=n=>{n.compute(vs(n.inputs[0],"Asinh","asinh"))},bL=n=>{n.compute(vs(n.inputs[0],"Atan","atan"))},xL=n=>{n.compute(vs(n.inputs[0],"Atanh","atanh"))},wL=n=>Ts(n),EL=(n,e)=>{let t;switch(e.to){case 10:t="vec4<f16>";break;case 1:t="vec4<f32>";break;case 12:t="vec4<u32>";break;case 6:t="vec4<i32>";break;case 9:t="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}n.compute(vs(n.inputs[0],"Cast",t,void 0,e.cacheKey,e.to))},ZP=n=>{let e,t,i=n.length>=2&&n[1].data!==0,s=n.length>=3&&n[2].data!==0;switch(n[0].dataType){case 1:e=i?n[1].getFloat32Array()[0]:-34028234663852886e22,t=s?n[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:e=i?n[1].getUint16Array()[0]:64511,t=s?n[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return Ts({min:e,max:t})},TL=(n,e)=>{let t=e||ZP(n.inputs),i=qo(n.inputs[0].dataType);n.compute(vs(n.inputs[0],"Clip",s=>`clamp(${s}, vec4<${i}>(uniforms.min), vec4<${i}>(uniforms.max))`,void 0,t.cacheKey,void 0,[{type:n.inputs[0].dataType,data:t.min},{type:n.inputs[0].dataType,data:t.max}],[{name:"min",type:i},{name:"max",type:i}]),{inputs:[0]})},SL=n=>{n.compute(vs(n.inputs[0],"Ceil","ceil"))},AL=n=>{n.compute(vs(n.inputs[0],"Cos","cos"))},CL=n=>{n.compute(vs(n.inputs[0],"Cosh","cosh"))},mv=n=>Ts(n),PL=(n,e)=>{let t=qo(n.inputs[0].dataType);n.compute(vs(n.inputs[0],"Elu",i=>`elu_vf32(${i})`,`
  const elu_alpha_ = ${t}(${e.alpha});

  fn elu_f32(a: ${t}) -> ${t} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${t}>) -> vec4<${t}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},WM=(n="f32")=>`
const r0: ${n} = 0.3275911;
const r1: ${n} = 0.254829592;
const r2: ${n} = -0.284496736;
const r3: ${n} = 1.421413741;
const r4: ${n} = -1.453152027;
const r5: ${n} = 1.061405429;

fn erf_vf32(v: vec4<${n}>) -> vec4<${n}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,RL=n=>{let e=qo(n.inputs[0].dataType);n.compute(vs(n.inputs[0],"Erf",t=>`erf_vf32(${t})`,WM(e)))},DL=n=>{n.compute(vs(n.inputs[0],"Exp","exp"))},BL=n=>{n.compute(vs(n.inputs[0],"Floor","floor"))},IL=n=>{let e=qo(n.inputs[0].dataType);n.compute(vs(n.inputs[0],"Gelu",t=>`0.5 * ${t} * (1.0 + erf_vf32(${t} * 0.7071067811865475))`,WM(e)))},OL=(n,e)=>{let t=qo(n.inputs[0].dataType);n.compute(vs(n.inputs[0],"LeakyRelu",i=>`select(leaky_relu_alpha_ * ${i}, ${i}, ${i} >= vec4<${t}>(0.0))`,`const leaky_relu_alpha_ = ${t}(${e.alpha});`,e.cacheKey))},LL=n=>{n.compute(vs(n.inputs[0],"Not",e=>`!${e}`))},FL=n=>{n.compute(vs(n.inputs[0],"Neg",e=>`-${e}`))},NL=n=>{n.compute(vs(n.inputs[0],"Reciprocal",e=>`1.0/${e}`))},zL=n=>{let e=qo(n.inputs[0].dataType);n.compute(vs(n.inputs[0],"Relu",t=>`select(vec4<${e}>(0.0), ${t}, ${t} > vec4<${e}>(0.0))`))},UL=n=>{n.compute(vs(n.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},kL=n=>Ts(n),GL=(n,e)=>{let t=qo(n.inputs[0].dataType);n.compute(vs(n.inputs[0],"HardSigmoid",i=>`max(vec4<${t}>(0.0), min(vec4<${t}>(1.0), ${e.alpha} * ${i} + vec4<${t}>(${e.beta})))`,void 0,e.cacheKey))},VL=n=>{n.compute(vs(n.inputs[0],"Sin","sin"))},HL=n=>{n.compute(vs(n.inputs[0],"Sinh","sinh"))},jL=n=>{n.compute(vs(n.inputs[0],"Sqrt","sqrt"))},$L=n=>{n.compute(vs(n.inputs[0],"Tan","tan"))},U1=n=>`sign(${n}) * (1 - exp(-2 * abs(${n}))) / (1 + exp(-2 * abs(${n})))`,WL=n=>{n.compute(vs(n.inputs[0],"Tanh",U1))},tT=(n="f32")=>`
const fast_gelu_a: ${n} = 0.5;
const fast_gelu_b: ${n} = 0.7978845608028654;
const fast_gelu_c: ${n} = 0.035677408136300125;

fn tanh_v(v: vec4<${n}>) -> vec4<${n}> {
  return ${U1("v")};
}
`,nT=n=>`(fast_gelu_a + fast_gelu_a * tanh_v(${n} * (fast_gelu_c * ${n} * ${n} + fast_gelu_b))) * ${n}`,KL=n=>{let e=qo(n.inputs[0].dataType);n.compute(vs(n.inputs[0],"FastGelu",nT,tT(e),void 0,n.inputs[0].dataType))},qL=(n,e)=>{let t=qo(n.inputs[0].dataType);return n.compute(vs(n.inputs[0],"ThresholdedRelu",i=>`select(vec4<${t}>(0.0), ${i}, ${i} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${t}>(${e.alpha});`,e.cacheKey)),0},XL=n=>{n.compute(vs(n.inputs[0],"Log","log"))},eR=(n,e)=>`
const alpha = vec4<${n}>(${e});
const one = ${n}(1.0);
const zero = ${n}(0.0);

fn quick_gelu_impl(x: vec4<${n}>) -> vec4<${n}> {
  let v = x *alpha;
  var x1 : vec4<${n}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,tR=n=>`quick_gelu_impl(${n})`,YL=(n,e)=>{let t=qo(n.inputs[0].dataType);n.compute(vs(n.inputs[0],"QuickGelu",tR,eR(t,e.alpha),e.cacheKey,n.inputs[0].dataType))}}),nR,iR,JL,BW=fn(()=>{vi(),Mi(),ES(),nR=n=>{if(n[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(n[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(n[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(n[0].dims[2]!==n[1].dims[0])throw new Error("last dimension of input and bias are not the same")},iR=n=>{let e=n[0].dims.slice();e[2]=e[2]/2;let t=Wt("input",n[0].dataType,n[0].dims,4),i=Wt("bias",n[0].dataType,[n[0].dims[2]],4),s=zn("output",n[0].dataType,e,4),r=Ut.size(e)/4,o=Va(n[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:l=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${n[0].dims[2]/4/2}u;

  ${l.declareVariables(t,i,s)}

  ${WM(o)}

  ${l.mainStart()}
    ${l.guardAgainstOutOfBoundsWorkgroupSizes(r)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${s.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},JL=n=>{nR(n.inputs),n.compute(iR(n.inputs))}}),sR,rR,Cd,QL,ZL,eF,tF,nF,iF,sF,rF,aF,oF,IW=fn(()=>{ai(),vi(),Mi(),sR=(n,e,t,i,s,r,o,l,c,d,g,p)=>{let h,v;typeof l=="string"?h=v=(T,C)=>`${l}((${T}),(${C}))`:typeof l=="function"?h=v=l:(h=l.scalar,v=l.vector);let y=zn("outputData",g,i.length,4),w=Wt("aData",c,e.length,4),S=Wt("bData",d,t.length,4),M;if(s)if(r){let T=Ut.size(e)===1,C=Ut.size(t)===1,x=e.length>0&&e[e.length-1]%4===0,R=t.length>0&&t[t.length-1]%4===0;T||C?M=y.setByOffset("global_idx",v(T?`${w.type.value}(${w.getByOffset("0")}.x)`:w.getByOffset("global_idx"),C?`${S.type.value}(${S.getByOffset("0")}.x)`:S.getByOffset("global_idx"))):M=`
            let outputIndices = ${y.offsetToIndices("global_idx * 4u")};
            let offsetA = ${w.broadcastedIndicesToOffset("outputIndices",y)};
            let offsetB = ${S.broadcastedIndicesToOffset("outputIndices",y)};
            ${y.setByOffset("global_idx",v(o||x?w.getByOffset("offsetA / 4u"):`${w.type.value}(${w.getByOffset("offsetA / 4u")}[offsetA % 4u])`,o||R?S.getByOffset("offsetB / 4u"):`${S.type.value}(${S.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else M=y.setByOffset("global_idx",v(w.getByOffset("global_idx"),S.getByOffset("global_idx")));else{if(!r)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let T=(C,x,R="")=>{let P=`aData[indexA${x}][componentA${x}]`,D=`bData[indexB${x}][componentB${x}]`;return`
            let outputIndices${x} = ${y.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offsetA${x} = ${w.broadcastedIndicesToOffset(`outputIndices${x}`,y)};
            let offsetB${x} = ${S.broadcastedIndicesToOffset(`outputIndices${x}`,y)};
            let indexA${x} = offsetA${x} / 4u;
            let indexB${x} = offsetB${x} / 4u;
            let componentA${x} = offsetA${x} % 4u;
            let componentB${x} = offsetB${x} % 4u;
            ${C}[${x}] = ${R}(${h(P,D)});
          `};g===9?M=`
            var data = vec4<u32>(0);
            ${T("data",0,"u32")}
            ${T("data",1,"u32")}
            ${T("data",2,"u32")}
            ${T("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:M=`
            ${T("outputData[global_idx]",0)}
            ${T("outputData[global_idx]",1)}
            ${T("outputData[global_idx]",2)}
            ${T("outputData[global_idx]",3)}
          `}return`
        ${n.registerUniform("vec_size","u32").declareVariables(w,S,y)}

        ${p??""}

        ${n.mainStart()}
        ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${M}
      }`},rR=(n,e,t,i,s,r,o=t.dataType)=>{let l=t.dims.map(w=>Number(w)??1),c=i.dims.map(w=>Number(w)??1),d=!Ut.areEqual(l,c),g=l,p=Ut.size(l),h=!1,v=!1,y=[d];if(d){let w=h0.calcShape(l,c,!1);if(!w)throw new Error("Can't perform binary op on the given tensors");g=w.slice(),p=Ut.size(g);let S=Ut.size(l)===1,M=Ut.size(c)===1,T=l.length>0&&l[l.length-1]%4===0,C=c.length>0&&c[c.length-1]%4===0;y.push(S),y.push(M),y.push(T),y.push(C);let x=1;for(let R=1;R<g.length;R++){let P=l[l.length-R],D=c[c.length-R];if(P===D)x*=P;else break}x%4===0?(v=!0,h=!0):(S||M||T||C)&&(h=!0)}else h=!0;return y.push(h),{name:n,shaderCache:{hint:e+y.map(w=>w.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:w=>sR(w,l,c,g,h,d,v,s,t.dataType,i.dataType,o,r),getRunData:()=>({outputs:[{dims:g,dataType:o}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:[{type:12,data:Math.ceil(Ut.size(g)/4)},...Wn(l,c,g)]})}},Cd=(n,e,t,i,s,r)=>{n.compute(rR(e,s??"",n.inputs[0],n.inputs[1],t,i,r))},QL=n=>{Cd(n,"Add",(e,t)=>`${e}+${t}`)},ZL=n=>{Cd(n,"Div",(e,t)=>`${e}/${t}`)},eF=n=>{Cd(n,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},tF=n=>{Cd(n,"Mul",(e,t)=>`${e}*${t}`)},nF=n=>{let e=Wt("input",n.inputs[0].dataType,n.inputs[0].dims).type.value;Cd(n,"Pow",{scalar:(t,i)=>`pow_custom(${t},${i})`,vector:(t,i)=>`pow_vector_custom(${t},${i})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},iF=n=>{Cd(n,"Sub",(e,t)=>`${e}-${t}`)},sF=n=>{Cd(n,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},rF=n=>{Cd(n,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},aF=n=>{Cd(n,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},oF=n=>{Cd(n,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}}),aR,oR,lR,uR,lF,uF,OW=fn(()=>{ai(),vi(),$r(),Mi(),aR=(n,e)=>{if(!n||n.length<1)throw new Error("too few inputs");let t=0,i=n[t],s=i.dataType,r=i.dims.length;n.forEach((o,l)=>{if(l!==t){if(o.dataType!==s)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape");o.dims.forEach((c,d)=>{if(d!==e&&c!==i.dims[d])throw new Error("non concat dimensions must match")})}})},oR=(n,e)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${n}u>(${e});
    for (var i: u32 = 0u; i < ${n}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${n}u;
  }`,lR=(n,e)=>{let t=n.length,i=[];for(let s=0;s<t;++s){let r=e.setByOffset("global_idx",n[s].getByIndices("indices"));t===1?i.push(r):s===0?i.push(`if (inputIndex == ${s}u) { ${r} }`):s===t-1?i.push(`else { ${r} }`):i.push(`else if (inputIndex == ${s}) { ${r} }`)}return i.join(`
`)},uR=(n,e,t,i)=>{let s=Ut.size(t),r=new Array(n.length),o=new Array(n.length),l=0,c=[],d=[],g=[{type:12,data:s}];for(let w=0;w<n.length;++w)l+=n[w].dims[e],r[w]=l,d.push(n[w].dims.length),o[w]=Wt(`input${w}`,i,d[w]),c.push("rank"),g.push({type:12,data:r[w]});for(let w=0;w<n.length;++w)g.push(...Wn(n[w].dims));g.push(...Wn(t));let p=zn("output",i,t.length),h=p.indicesGet("indices",e),v=Array.from(Array(r.length).keys()).map(w=>`uniforms.sizeInConcatAxis${w}`).join(","),y=w=>`

  ${(()=>{w.registerUniform("outputSize","u32");for(let S=0;S<n.length;S++)w.registerUniform(`sizeInConcatAxis${S}`,"u32");return w.declareVariables(...o,p)})()}

  ${oR(r.length,v)}

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${p.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${h});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${r.length}u>(${v});
      ${h} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${lR(o,p)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`,inputDependencies:c},getRunData:()=>({outputs:[{dims:t,dataType:i}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:g}),getShaderSource:y}},lF=(n,e)=>{let t=n.inputs,i=t[0].dims,s=Ut.normalizeAxis(e.axis,i.length);aR(t,s);let r=i.slice();r[s]=t.reduce((l,c)=>l+(c.dims.length>s?c.dims[s]:0),0);let o=t.filter(l=>Ut.size(l.dims)>0);n.compute(uR(o,s,r,t[0].dataType),{inputs:o})},uF=n=>Ts({axis:n.axis})}),Kg,qg,Xg,TS,i_=fn(()=>{ai(),vi(),Kg=(n,e,t="f32")=>{switch(n.activation){case"Relu":return`value = max(value, ${e}(0.0));`;case"Sigmoid":return`value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${e}(${t}(uniforms.clip_min)), ${e}(${t}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${e}(0.0), min(${e}(1.0), ${t}(uniforms.alpha) * value + ${t}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${t}(uniforms.alpha) * value, value, value >= ${e}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${n.activation}`)}},qg=(n,e)=>{n.activation==="Clip"?e.push({type:1,data:n.clipMax},{type:1,data:n.clipMin}):n.activation==="HardSigmoid"?e.push({type:1,data:n.alpha},{type:1,data:n.beta}):n.activation==="LeakyRelu"&&e.push({type:1,data:n.alpha})},Xg=(n,e)=>{n.activation==="Clip"?e.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):n.activation==="HardSigmoid"?e.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):n.activation==="LeakyRelu"&&e.push({name:"alpha",type:"f32"})},TS=n=>{let e=n?.activation||"";if(e==="HardSigmoid"){let[t,i]=n?.activation_params||[.2,.5];return{activation:e,alpha:t,beta:i}}else if(e==="Clip"){let[t,i]=n?.activation_params||[L3,F3];return{activation:e,clipMax:i,clipMin:t}}else if(e==="LeakyRelu"){let[t]=n?.activation_params||[.01];return{activation:e,alpha:t}}return{activation:e}}}),oo,cF,SS=fn(()=>{oo=(n,e)=>{switch(n){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component is not supported.`)}},cF=n=>`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      `}),dF,LW=fn(()=>{dF=n=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${n}.x), i32(${n}.y), i32(${n}.z), 1));
}
`}),Cv,AS,CS=fn(()=>{ai(),vi(),Mi(),i_(),Cv=(n,e,t,i,s)=>{let r=i-t;return`
      ${Array.from({length:t}).map((o,l)=>`
      if (${Vn(e.shape,l,e.rank)} != 1) {
        ${e.indicesSet(n,l,Vn(s,l+r,i))}
      } else {
        ${e.indicesSet(n,l,0)}
      }`).join("")}
`},AS=(n,e,t,i,s=!1,r)=>{let o=n[0].dims,l=n[1].dims,c=o[o.length-2],d=l[l.length-1],g=o[o.length-1],p=Lr(d),h=Lr(g),v=Lr(c),y=Ut.size(t)/p/v,w=n.length>2,S=i?i.slice(0,-2):t.slice(0,-2),M=[Ut.size(S),c,d],T=[{type:12,data:y},{type:12,data:c},{type:12,data:d},{type:12,data:g}];qg(e,T),T.push(...Wn(S,o,l)),w&&T.push(...Wn(n[2].dims)),T.push(...Wn(M));let C=x=>{let R=bS("batch_dims",n[0].dataType,S.length),P=Wt("a",n[0].dataType,o.length,h),D=Wt("b",n[1].dataType,l.length,p),z=zn("output",n[0].dataType,M.length,p),U=Va(z.type.tensor),N=Kg(e,z.type.value,U),j=[P,D],J="";if(w){let ne=s?p:1;j.push(Wt("bias",n[2].dataType,n[2].dims.length,ne)),J=`${s?`value += bias[col / ${ne}];`:`value += ${z.type.value}(bias[row + i]);`}`}let W=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Xg(e,W);let oe=()=>{let ne=`var a_data: ${P.type.value};`;for(let q=0;q<h;q++)ne+=`
              let b_data${q} = b[(b_offset + (k + ${q}) * uniforms.N + col) / ${p}];`;for(let q=0;q<v;q++){ne+=`a_data = a[(a_offset + (row + ${q}) * uniforms.K + k) / ${h}];`;for(let le=0;le<h;le++)ne+=`
            values[${q}] = fma(${D.type.value}(a_data${h===1?"":`[${le}]`}), b_data${le}, values[${q}]);
`}return ne};return`
  ${x.registerUniforms(W).registerInternalVariables(R).declareVariables(...j,z)}
  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${p})) * ${p};
    var index1 = global_idx / (uniforms.N / ${p});
    let stride1 = uniforms.M / ${v};
    let row = (index1 % stride1) * ${v};
    let batch = index1 / stride1;

    ${t.length===2?"":`let batch_indices = ${R.offsetToIndices("batch")};`}

    var a_indices: ${P.type.indices};
    ${Cv("a_indices",P,P.rank-2,R.rank,"batch_indices")}
    ${P.indicesSet("a_indices",P.rank-2,0)}
    ${P.indicesSet("a_indices",P.rank-1,0)}
    let a_offset = ${P.indicesToOffset("a_indices")};

    var b_indices: ${D.type.indices};
    ${Cv("b_indices",D,D.rank-2,R.rank,"batch_indices")}
    ${D.indicesSet("b_indices",D.rank-2,0)}
    ${D.indicesSet("b_indices",D.rank-1,0)}
    let b_offset = ${D.indicesToOffset("b_indices")};
    var values: array<${z.type.value}, ${v}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${h}) {
      ${oe()}
    }
    for (var i = 0u; i < ${v}u; i++) {
      var value = values[i];
      ${J}
      ${N}
      let cur_indices = ${z.type.indices}(batch, row + i, col);
      let offset = ${z.indicesToOffset("cur_indices")};
      ${z.setByOffset(`offset / ${p}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${e.activation};${p};${h};${v};${s}`,inputDependencies:w?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r?r(t):t,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:T}),getShaderSource:C}}}),cR,dR,iT,k1,fR,sT,hR,Hb,PS=fn(()=>{ai(),vi(),Mi(),i_(),CS(),SS(),cR=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,dR=(n,e)=>n?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,iT=(n,e,t="f32",i,s=!1,r=32,o=!1,l=32)=>{let c=e[1]*n[1],d=e[0]*n[0],g=s?c:r,p=s?r:c,h=g/e[0],v=r/e[1];if(!((s&&h===4&&n[1]===4||!s&&(h===3||h===4))&&g%e[0]===0&&r%e[1]===0&&n[0]===4))throw new Error(`If transposeA ${s} is true, innerElementSize ${h} and workPerThread[1] ${n[1]} must be 4.
      Otherwise, innerElementSize ${h} must be 3 or 4.
  tileAWidth ${g} must be divisible by workgroupSize[0]${e[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${h}<${t}>, ${g/h}>, ${p}>;
var<workgroup> mm_Bsub: array<array<vec4<${t}>, ${d/n[0]}>, ${r}>;

const rowPerThread = ${n[1]};
const colPerThread = ${n[0]};
const innerElementSize = ${h};
const tileInner = ${r};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${o?"0":"i32(globalId.z)"};
  ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${c};

  let num_tiles = ${o?`${Math.ceil(l/r)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${o?`i32(globalId.z) * ${l}`:"0"};

  var acc: array<vec4<${t}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${v};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${cR(s,i)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${v}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${i?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${h===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${dR(s,h)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},k1=(n,e)=>n?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,fR=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",sT=(n,e,t="f32",i,s=!1,r=32,o=!1,l=32,c=!1)=>{let d=n[1]*e[1],g=n[0]*e[0],p=s?d:r,h=s?r:d;if(!(h%e[1]===0&&p%e[0]===0&&r%e[1]===0))throw new Error(`tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${p} must be divisible by workgroupSize[0]${e[0]}, tileInner ${r} must be divisible by workgroupSize[1]${e[1]}`);let v=h/e[1],y=p/e[0],w=r/e[1],S=c?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${d};
    let globalColStart = i32(workgroupId.x) * ${g};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${p}; inputCol = inputCol + ${e[0]}) {
          ${k1(s,i)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${i?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${t}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${s?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${d};

let tileRowA = i32(localId.y) * ${v};
let tileColA = i32(localId.x) * ${y};
let tileRowB = i32(localId.y) * ${w};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${v}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${y}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${k1(s,i)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${i?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${t}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${fR(s)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${t}, ${p}>, ${h}>;
  var<workgroup> mm_Bsub : array<array<${t}, ${g}>, ${r}>;
  const rowPerThread = ${n[1]};
  const colPerThread = ${n[0]};
  const tileInner = ${r};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${o?"0":"i32(globalId.z)"};
    ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${o?`${Math.ceil(l/r)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${o?`i32(globalId.z) * ${l}`:"0"};

    var acc : array<array<${t}, colPerThread>, rowPerThread>;
    ${S}
  }
`},hR=(n,e,t,i,s=!1)=>{let[r,o,l,c]=i,d=Va(i[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${r.type.indices}) -> ${oo(n,d)} {
      var value = ${oo(n,d)}(0.0);
      let col = colIn * ${n};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${o.type.indices};
        ${Cv("aIndices",o,o.rank-2,r.rank,"batchIndices")}
        ${o.indicesSet("aIndices",o.rank-2,"u32(row)")}
        ${o.indicesSet("aIndices",o.rank-1,"u32(colIn)")}
        value = ${o.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${r.type.indices}) -> ${oo(n,d)} {
      var value = ${oo(n,d)}(0.0);
      let col = colIn * ${n};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${l.type.indices};
        ${Cv("bIndices",l,l.rank-2,r.rank,"batchIndices")}
        ${l.indicesSet("bIndices",l.rank-2,"u32(row)")}
        ${l.indicesSet("bIndices",l.rank-1,"u32(colIn)")}
        value = ${l.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${oo(n,d)}) {
      let col = colIn * ${n};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${s?"bias[colIn]":`${oo(n,d)}(bias[row])`};`:""}
        ${t}
        ${c.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},Hb=(n,e,t,i,s=!1,r)=>{let o=n[0].dims,l=n[1].dims,c=o.slice(0,-2),d=l.slice(0,-2),g=i?i.slice(0,-2):t.slice(0,-2),p=Ut.size(g),h=o[o.length-2],v=o[o.length-1],y=l[l.length-1],w=v%4===0&&y%4===0,S=h<=8?[4,1,1]:[4,4,1],M=[8,8,1],T=[Math.ceil(y/M[0]/S[0]),Math.ceil(h/M[1]/S[1]),Math.ceil(p/M[2]/S[2])],C=w?4:1,x=[...c,h,v/C],R=x.length,P=[...d,v,y/C],D=P.length,z=[p,h,y/C],U=[{type:6,data:h},{type:6,data:y},{type:6,data:v}];qg(e,U),U.push(...Wn(g,x,P));let N=["rank","rank"],j=n.length>2;j&&(U.push(...Wn(n[2].dims)),N.push("rank")),U.push(...Wn(z));let J=W=>{let oe=g.length,ne=bS("batchDims",n[0].dataType,oe,1),q=Va(n[0].dataType),le=Wt("a",n[0].dataType,R,C),se=Wt("b",n[1].dataType,D,C),pe=zn("result",n[0].dataType,z.length,C),be=[le,se];if(j){let ce=s?C:1;be.push(Wt("bias",n[2].dataType,n[2].dims.length,ce))}let ee=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Xg(e,ee);let te=Va(pe.type.tensor),ue=Kg(e,pe.type.value,te),ae=hR(C,j,ue,[ne,le,se,pe],s);return`
  ${W.registerUniforms(ee).registerInternalVariables(ne).declareVariables(...be,pe)}
  ${ae}
  ${w?iT(S,M,q,ne):sT(S,M,q,ne)}
                   `};return{name:"MatMul",shaderCache:{hint:`${S};${e.activation};${w};${s}`,inputDependencies:N},getRunData:()=>({outputs:[{dims:r?r(t):t,dataType:n[0].dataType}],dispatchGroup:{x:T[0],y:T[1],z:T[2]},programUniforms:U}),getShaderSource:J}}}),pR,fF,FW=fn(()=>{ai(),qh(),Mi(),i_(),SS(),LW(),PS(),pR=(n,e,t,i,s=!1,r,o=4,l=4,c=4,d="f32")=>{let g=U=>{switch(U){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${d}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${U} is not supported.`)}},p=U=>{switch(U){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${U} is not supported.`)}},h=n?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,v=n?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,y=n?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",w=n?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",S=n?"row":"col",M=n?"col":"row",T=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${n?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${S} / outWidth;
    let outCol = ${S} % outWidth;

    let WRow = ${M} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${M} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${M} % inChannels;
    var resData = ${oo(o,d)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${w}) {
      ${h}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${g(o)}
    }
    return resData;`,C=n?e&&i?`
    let col = colIn * ${o};
    ${T}`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${T}
    }
    return ${oo(o,d)}(0.0);`:i&&t?`
    let col = colIn * ${o};
    ${T}`:`
    let col = colIn * ${o};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${T}
    }
    return ${oo(o,d)}(0.0);`,x=n?i&&t?p(l):`
    let col = colIn * ${l};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${p(l)}
    }
    return ${oo(l,d)}(0.0);`:`
    let col = colIn * ${l};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${p(l)}
    }
    return ${oo(l,d)}(0.0);`,R=oo(c,d),P=oo(n?o:l,d),D=oo(n?l:o,d),z=Kg(r,R,d);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${P} {
      ${n?C:x}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${D} {
      ${n?x:C}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${R}) {
      let col = colIn * ${c};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${n?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${v}
      ${cF(s)}
      ${z}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},fF=(n,e,t,i,s,r,o,l,c)=>{let d=e.format==="NHWC",g=d?n[0].dims[3]:n[0].dims[1],p=t[0],h=d?t[2]:t[3],v=d?t[1]:t[2],y=d?t[3]:t[1],w=d&&(g%4===0||g%3===0)&&y%4===0,S=d?y:h*v,M=d?h*v:y,T=[8,8,1],C=i<=8?[4,1,1]:[4,4,1],x=[Math.ceil(S/T[0]/C[0]),Math.ceil(M/T[1]/C[1]),Math.ceil(p/T[2]/C[2])];Zi("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${x}`);let R=w?d&&g%4!==0?3:4:1,P=T[1]*C[1],D=T[0]*C[0],z=Math.max(T[0]*R,T[1]),U=i%P===0,N=s%D===0,j=r%z===0,J=w?[R,4,4]:[1,1,1],W=[{type:6,data:i},{type:6,data:s},{type:6,data:r},{type:6,data:[e.pads[0],e.pads[1]]},{type:6,data:e.strides},{type:6,data:e.dilations}];qg(e,W),W.push(...Wn(n[0].dims,n[1].dims));let oe=["rank","rank"];o&&(W.push(...Wn(n[2].dims)),oe.push("rank")),W.push(...Wn(t));let ne=q=>{let le=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Xg(e,le);let se=w?4:1,pe=Va(n[0].dataType),be=`
      fn setOutputAtIndex(flatIndex : i32, value : ${w?`vec4<${pe}>`:pe}) {
        result[flatIndex] = ${w?`vec4<${pe}>`:pe}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${w?`vec4<${pe}>`:pe}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${w?"/ 4":""}, value);
      }`,ee=Wt("x",n[0].dataType,n[0].dims.length,R===3?1:R),te=Wt("w",n[1].dataType,n[1].dims.length,se),ue=[ee,te],ae=zn("result",n[0].dataType,t.length,se);if(o){let ce=Wt("bias",n[2].dataType,n[2].dims.length,se);ue.push(ce),be+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${w?`vec4<${pe}>`:pe} {
          return bias[coords.${d?"w":"y"}${w?"/ 4":""}];
        }`}return`
        ${dF("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${q.registerUniforms(le).declareVariables(...ue,ae)}
        ${be}
        ${pR(d,U,N,j,o,e,J[0],J[1],J[2],pe)}
        ${w?iT(C,T,pe,void 0,!d,z):sT(C,T,pe,void 0,!d,z,!1,void 0,l)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${e.cacheKey};${R};${w};${U};${N};${j};${P};${D};${z}`,inputDependencies:oe},getRunData:()=>({outputs:[{dims:c?c(t):t,dataType:n[0].dataType}],dispatchGroup:{x:x[0],y:x[1],z:x[2]},programUniforms:W}),getShaderSource:ne}}}),mR,G1,iv,gR,V1,_R,hF,pF,NW=fn(()=>{ai(),qh(),vi(),Mi(),i_(),SS(),mR=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e},G1=n=>typeof n=="number"?[n,n,n]:n,iv=(n,e)=>e<=1?n:n+(n-1)*(e-1),gR=(n,e,t,i=1)=>{let s=iv(e,i);return Math.floor((n[0]*(t-1)-t+s)/2)},V1=(n,e,t,i,s)=>{s==null&&(s=gR(n,e[0],i[0]));let r=[0,0,0,t];for(let o=0;o<3;o++)n[o]+2*s>=e[o]&&(r[o]=Math.trunc((n[o]-e[o]+2*s)/i[o]+1));return r},_R=(n,e,t,i,s,r,o,l,c,d)=>{let g,p,h,v;if(n==="VALID"&&(n=0),typeof n=="number"){g={top:n,bottom:n,left:n,right:n,front:n,back:n};let y=V1([e,t,i,1],[l,c,d],1,[s,r,o],n);p=y[0],h=y[1],v=y[2]}else if(Array.isArray(n)){if(!n.every((w,S,M)=>w===M[0]))throw Error(`Unsupported padding parameter: ${n}`);g={top:n[0],bottom:n[1],left:n[2],right:n[3],front:n[4],back:n[5]};let y=V1([e,t,i,1],[l,c,d],1,[s,r,o],n[0]);p=y[0],h=y[1],v=y[2]}else if(n==="SAME_UPPER"){p=Math.ceil(e/s),h=Math.ceil(t/r),v=Math.ceil(i/o);let y=(p-1)*s+l-e,w=(h-1)*r+c-t,S=(v-1)*o+d-i,M=Math.floor(y/2),T=y-M,C=Math.floor(w/2),x=w-C,R=Math.floor(S/2),P=S-R;g={top:C,bottom:x,left:R,right:P,front:M,back:T}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:g,outDepth:p,outHeight:h,outWidth:v}},hF=(n,e,t,i,s,r=!1,o="channelsLast")=>{let l,c,d,g,p;if(o==="channelsLast")[l,c,d,g,p]=n;else if(o==="channelsFirst")[l,p,c,d,g]=n;else throw new Error(`Unknown dataFormat ${o}`);let[h,,v,y,w]=e,[S,M,T]=G1(t),[C,x,R]=G1(i),P=iv(v,C),D=iv(y,x),z=iv(w,R),{padInfo:U,outDepth:N,outHeight:j,outWidth:J}=_R(s,c,d,g,S,M,T,P,D,z),W=r?h*p:h,oe=[0,0,0,0,0];return o==="channelsFirst"?oe=[l,W,N,j,J]:o==="channelsLast"&&(oe=[l,N,j,J,W]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:d,inWidth:g,inChannels:p,outDepth:N,outHeight:j,outWidth:J,outChannels:W,padInfo:U,strideDepth:S,strideHeight:M,strideWidth:T,filterDepth:v,filterHeight:y,filterWidth:w,effectiveFilterDepth:P,effectiveFilterHeight:D,effectiveFilterWidth:z,dilationDepth:C,dilationHeight:x,dilationWidth:R,inShape:n,outShape:oe,filterShape:e}},pF=(n,e,t,i,s,r)=>{let o=r==="channelsLast";o?n[0].dims[3]:n[0].dims[1];let l=[64,1,1],c={x:t.map((S,M)=>M)},d=[Math.ceil(mR(c.x.map(S=>t[S]))/l[0]),1,1];Zi("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${d}`);let g=1,p=Ut.size(t),h=[{type:12,data:p},{type:12,data:i},{type:12,data:s},{type:12,data:e.strides},{type:12,data:e.dilations}];qg(e,h),h.push(...Wn(n[0].dims,n[1].dims));let v=["rank","rank"],y=n.length===3;y&&(h.push(...Wn(n[2].dims)),v.push("rank")),h.push(...Wn(t));let w=S=>{let M=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:i.length},{name:"pads",type:"u32",length:s.length},{name:"strides",type:"u32",length:e.strides.length},{name:"dilations",type:"u32",length:e.dilations.length}];Xg(e,M);let T=1,C=Va(n[0].dataType),x=Wt("x",n[0].dataType,n[0].dims.length,g),R=Wt("W",n[1].dataType,n[1].dims.length,T),P=[x,R],D=zn("result",n[0].dataType,t.length,T),z="";if(y){let j=Wt("bias",n[2].dataType,n[2].dims.length,T);P.push(j),z+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${C} {
          return bias[${o?Vn("coords",4,5):Vn("coords",1,5)}];
        }`}let U=oo(g,C),N=Kg(e,U,C);return`
            ${z}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${x.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${R.getByIndices("aIndices")};
            }
          ${S.registerUniforms(M).declareVariables(...P,D)}
          ${S.mainStart()}
          ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${D.offsetToIndices("global_idx")};
              let batch = ${Vn("coords",0,x.rank)};
              let d2 = ${o?Vn("coords",x.rank-1,x.rank):Vn("coords",1,x.rank)};
              let xFRCCorner = vec3<u32>(${o?Vn("coords",1,x.rank):Vn("coords",2,x.rank)},
              ${o?Vn("coords",2,x.rank):Vn("coords",3,x.rank)},
              ${o?Vn("coords",3,x.rank):Vn("coords",4,x.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${o?Vn("uniforms.x_shape",1,x.rank):Vn("uniforms.x_shape",2,x.rank)};
              let xShapeZ = ${o?Vn("uniforms.x_shape",2,x.rank):Vn("uniforms.x_shape",3,x.rank)};
              let xShapeW = ${o?Vn("uniforms.x_shape",3,x.rank):Vn("uniforms.x_shape",4,x.rank)};
              let xShapeU = ${o?Vn("uniforms.x_shape",4,x.rank):Vn("uniforms.x_shape",1,x.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${o?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${o?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${o?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${o?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${y?"value = value + getBiasByOutputCoords(coords)":""};
              ${N}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${e.cacheKey};${o};${g};${y}`,inputDependencies:v},getRunData:()=>({outputs:[{dims:t,dataType:n[0].dataType}],dispatchGroup:{x:d[0],y:d[1],z:d[2]},programUniforms:h}),getShaderSource:w}}}),mF,gF,zW=fn(()=>{ai(),vi(),Mi(),i_(),mF=(n,e,t,i)=>{let s=n.length>2,r=s?"value += b[output_channel];":"",o=n[0].dims,l=n[1].dims,c=e.format==="NHWC",d=c?t[3]:t[1],g=d/e.group,p=c&&g>=4?Lr(d):1,h=Ut.size(t)/p,v=[{type:12,data:h},{type:12,data:e.dilations},{type:12,data:[e.strides[0],e.strides[1]]},{type:12,data:[e.pads[0],e.pads[1]]},{type:12,data:g}];qg(e,v),v.push(...Wn(o,[l[0],l[1],l[2],l[3]/p]));let y=s?["rank","rank","rank"]:["rank","rank"];v.push(...Wn([t[0],t[1],t[2],t[3]/p]));let w=S=>{let M=zn("output",n[0].dataType,t.length,p),T=Va(M.type.tensor),C=Kg(e,M.type.value,T),x=Wt("x",n[0].dataType,o.length),R=Wt("w",n[1].dataType,l.length,p),P=[x,R];s&&P.push(Wt("b",n[2].dataType,n[2].dims,p));let D=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:e.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];Xg(e,D);let z=c?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${x.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${R.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${x.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${R.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${S.registerUniforms(D).declareVariables(...P,M)}

  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${M.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${c?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${c?1:2}], outputIndices[${c?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${p} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${c?2:1}];

    var value: ${M.type.value} = ${M.type.value}(0);
    ${z}
    ${r}
    ${C}
    ${M.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${e.cacheKey}_${p}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:i?i(t):t,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:v}),getShaderSource:w}},gF=(n,e,t,i)=>{let s=n.length>2,r=Lr(t[3]),o=Lr(t[2]),l=Ut.size(t)/r/o,c=[n[0].dims[0],n[0].dims[1],n[0].dims[2],n[0].dims[3]/r],d=[n[1].dims[0],n[1].dims[1],n[1].dims[2],n[1].dims[3]/r],g=[t[0],t[1],t[2],t[3]/r],p=[{type:12,data:l},{type:6,data:[e.strides[0],e.strides[1]]},{type:6,data:[e.pads[0],e.pads[1]]}];qg(e,p),p.push(...Wn(c,d,g));let h=(o-1)*e.strides[1]+d[1],v=y=>{let w=zn("output",n[0].dataType,g.length,r),S=Va(w.type.tensor),M=Kg(e,w.type.value,S),T=Wt("x",n[0].dataType,c.length,r),C=Wt("w",n[1].dataType,d.length,r),x=[T,C];s&&x.push(Wt("b",n[2].dataType,n[2].dims,r));let R=s?"value += b[output_channel];":"",P=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Xg(e,P),`
  ${y.registerUniforms(P).declareVariables(...x,w)}
  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${o}u;
    let col = (index1 % width1) * ${o}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${T.type.value}, ${h}>;
    var values: array<${w.type.value}, ${o}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${d[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${h}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${T.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${T.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${d[1]}; w_width++) {
          let w_val = ${C.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${o}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${o}u; i++) {
      var value = values[i];
      ${R}
      ${M}
      ${w.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${e.cacheKey};${r};${o};${h};${d[0]};${d[1]}`,inputDependencies:s?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:i?i(t):t,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p}),getShaderSource:v}}}),vR,BM,yR,IM,rT,H1,MR,bR,aT,UW=fn(()=>{vi(),FW(),NW(),PS(),zW(),i_(),CS(),ym(),vR=(n,e,t,i,s,r)=>{let o=n[0],l=n.slice(r?1:2,r?3:4),c=l.length,d=e[0],g=e.slice(2).map((h,v)=>h+(h-1)*(t[v]-1)),p=l.map((h,v)=>h+i[v]+i[v+c]).map((h,v)=>Math.floor((h-g[v]+s[v])/s[v]));return p.splice(0,0,o),p.splice(r?3:1,0,d),p},BM=[2,3,1,0],yR=(n,e)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length>5)throw new Error("greater than 5D is not supported");if(n[0].dims.length!==n[1].dims.length)throw new Error("filter does not have same dimension as input");let t=n[0].dims[e.format==="NHWC"?n[0].dims.length-1:1],i=n[1].dims[1]*e.group;if(t!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(n.length===3&&(n[2].dims.length!==1||n[1].dims[0]!==n[2].dims[0]))throw new Error("invalid bias");let s=n[0].dims.length-2;if(e.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(e.strides.length!==s)throw new Error(`strides should be ${s}D`);if(e.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape")},IM=(n,e)=>{let t=n.kernelShape.slice();t.length<e[1].dims.length-2&&t.push(...Array(e[1].dims.length-2-t.length).fill(0));for(let r=2;r<e[1].dims.length;++r)t[r-2]===0&&(t[r-2]=e[1].dims[r]);let i=n.pads.slice();Gb.adjustPadsBasedOnAutoPad(e[0].dims,n.strides,n.dilations,t,i,n.format==="NHWC",n.autoPad);let s=Object.assign({},n);return Object.assign(s,{kernelShape:t,pads:i}),s},rT=n=>{let e=TS(n),t=n.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][n.auto_pad],s=n.dilations,r=n.group,o=n.kernel_shape,l=n.pads,c=n.strides,d=n.w_is_const();return{autoPad:i,format:t,dilations:s,group:r,kernelShape:o,pads:l,strides:c,wIsConst:d,...e,cacheKey:`${n.format};${e.activation};`}},H1=(n,e,t,i)=>{let s=t.format==="NHWC",r=vR(e[0].dims,e[1].dims,t.dilations,t.pads,t.strides,s);if(t.group!==1){let P=[e[0]];if(s){let D=n.kernelCustomData.wT??n.compute(Yu(e[1],BM),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=D),P.push(D)}else P.push(e[1]);e.length===3&&P.push(e[2]),!n.adapterInfo.isArchitecture("ampere")&&s&&e[1].dims[0]===t.group&&e[1].dims[1]===1&&t.dilations[0]===1&&t.dilations[1]===1?n.compute(gF(P,t,r,i),{inputs:P}):n.compute(mF(P,t,r,i),{inputs:P});return}let o=e.length===3,l=e[0].dims[s?1:2],c=e[0].dims[s?2:3],d=e[0].dims[s?3:1],g=e[1].dims[2],p=e[1].dims[3],h=r[s?1:2],v=r[s?2:3],y=r[s?3:1],w=s&&g===l&&p===c&&t.pads[0]===0&&t.pads[1]===0;if(w||g===1&&p===1&&t.dilations[0]===1&&t.dilations[1]===1&&t.strides[0]===1&&t.strides[1]===1&&t.pads[0]===0&&t.pads[1]===0){let P=r[0],D,z,U,N=[];if(s){let W=n.kernelCustomData.wT??n.compute(Yu(e[1],BM),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];if(t.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=W),w){let oe=l*c*d;D=e[0].reshape([1,P,oe]),z=W.reshape([1,oe,y]),U=[1,P,y]}else D=e[0].reshape([P,l*c,d]),z=W.reshape([1,d,y]),U=[P,h*v,y];N.push(D),N.push(z)}else D=e[0].reshape([P,d,l*c]),z=e[1].reshape([1,y,d]),U=[P,y,h*v],N.push(z),N.push(D);o&&N.push(e[2]);let j=U[2],J=N[0].dims[N[0].dims.length-1];j<8&&J<8?n.compute(AS(N,t,r,U,s,i),{inputs:N}):n.compute(Hb(N,t,r,U,s,i),{inputs:N});return}let S=!0,M=n.kernelCustomData.wT??n.compute(Yu(e[1],BM),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=M);let T=[e[0],M];o&&T.push(e[2]);let C=s?h*v:y,x=s?y:h*v,R=g*p*d;n.compute(fF(T,t,r,C,x,R,o,S,i),{inputs:T})},MR=(n,e)=>{let t=e.format==="NHWC",i=[n.inputs[0].reshape(t?[n.inputs[0].dims[0],1,n.inputs[0].dims[1],n.inputs[0].dims[2]]:[n.inputs[0].dims[0],n.inputs[0].dims[1],1,n.inputs[0].dims[2]]),n.inputs[1].reshape([n.inputs[1].dims[0],n.inputs[1].dims[1],1,n.inputs[1].dims[2]])];n.inputs.length===3&&i.push(n.inputs[2]);let s=[0,e.pads[0],0,e.pads[1]],r=[1].concat(e.strides),o=[1].concat(e.dilations),l=[1].concat(e.kernelShape),c=IM({...e,pads:s,strides:r,dilations:o,kernelShape:l},i);H1(n,i,c,d=>t?[d[0],d[2],d[3]]:[d[0],d[1],d[3]])},bR=(n,e,t)=>{let i=t.format==="NHWC"?"channelsLast":"channelsFirst",s=IM(t,e),r=t.autoPad==="NOTSET"?t.pads:t.autoPad,o=hF(e[0].dims,e[1].dims,t.strides,t.dilations,r,!1,i);n.compute(pF(e,s,o.outShape,[o.filterDepth,o.filterHeight,o.filterWidth],[o.padInfo.front,o.padInfo.top,o.padInfo.left],i))},aT=(n,e)=>{if(yR(n.inputs,e),n.inputs[0].dims.length===3)MR(n,e);else if(n.inputs[0].dims.length===5)bR(n,n.inputs,e);else{let t=IM(e,n.inputs);H1(n,n.inputs,t)}}}),_F,kW=fn(()=>{ai(),qh(),vi(),Mi(),_F=(n,e,t)=>{let i=n.length>2,s=e.outputShape,r=e.format==="NHWC",o=e.group,l=n[1].dims,c=l[2]/o,d=l[3],g=r?Lr(c):1,p=r&&d===1&&c>=4,h=p?Math.floor(c/4)*4:Math.floor(c/g)*g,v=c-h,y=r?Lr(d):1,w=r?d===1?g:y:1,S=Ut.size(s)/y,M=[Math.ceil(S/64),1,1];Zi("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${M}`);let T=["rank","rank"],C=[e.strides[0],e.strides[1]],x=[e.kernelShape[r?1:2],e.kernelShape[r?2:3]],R=[e.dilations[0],e.dilations[1]],P=[x[0]+(e.dilations[0]<=1?0:(e.kernelShape[r?1:2]-1)*(e.dilations[0]-1)),x[1]+(e.dilations[1]<=1?0:(e.kernelShape[r?2:3]-1)*(e.dilations[1]-1))],D=[P[0]-1-Math.floor((e.pads[0]+e.pads[2])/2),P[1]-1-Math.floor((e.pads[1]+e.pads[3])/2)],z=[{type:12,data:S},{type:12,data:C},{type:12,data:x},{type:12,data:R},{type:12,data:P},{type:6,data:D},{type:12,data:h},{type:12,data:c},{type:12,data:d},...Wn(n[0].dims,n[1].dims)];i&&(z.push(...Wn(n[2].dims)),T.push("rank")),z.push(...Wn(s));let U=N=>{let j=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:C.length},{name:"filter_dims",type:"u32",length:x.length},{name:"dilations",type:"u32",length:x.length},{name:"effective_filter_dims",type:"u32",length:P.length},{name:"pads",type:"i32",length:D.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],J=Va(n[0].dataType),W=r?1:2,oe=r?2:3,ne=r?3:1,q=Wt("W",n[1].dataType,n[1].dims.length,w),le=Wt("Dy",n[0].dataType,n[0].dims.length,g),se=[le,q];i&&se.push(Wt("bias",n[2].dataType,[s[ne]].length,y));let pe=zn("result",n[0].dataType,s.length,y),be=()=>{let ue="";if(p)g===4?ue+=`
        let xValue = ${le.getByOffset("x_offset")};
        let wValue = ${q.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`:g===2?ue+=`
          dotProd = dotProd + dot(vec4<${J}>(${le.getByOffset("x_offset")}, ${le.getByOffset("x_offset + 1u")}), vec4<${J}>(${q.getByOffset("w_offset")}, ${q.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`:g===1&&(ue+=`
          dotProd = dotProd + dot(vec4<${J}>(${le.getByOffset("x_offset")}, ${le.getByOffset("x_offset + 1u")}, ${le.getByOffset("x_offset + 2u")}, ${le.getByOffset("x_offset + 3u")}), vec4<${J}>(${q.getByOffset("w_offset")}, ${q.getByOffset("w_offset + 1u")}, ${q.getByOffset("w_offset + 2u")}, ${q.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`);else if(ue+=`
                  let xValue = ${r?le.getByOffset(`${le.indicesToOffset(`${le.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${g}`):le.get("batch","inputChannel","idyR","idyC")};
        `,g===1)ue+=`
          let w_offset = ${q.indicesToOffset(`${q.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${q.getByOffset(`w_offset / ${w}`)};
          dotProd = dotProd + xValue * wValue;`;else for(let ae=0;ae<g;ae++)ue+=`
            let wValue${ae} = ${q.getByOffset(`${q.indicesToOffset(`${q.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${ae}, wOutChannel)`)} / ${w}`)};
            dotProd = dotProd + xValue[${ae}] * wValue${ae};`;return ue},ee=()=>{if(v===0)return"";if(!p)throw new Error(`packInputAs4 ${p} is not true.`);let ue="";if(g===1){ue+="dotProd = dotProd";for(let ae=0;ae<v;ae++)ue+=`
            + ${le.getByOffset(`x_offset + ${ae}`)} * ${q.getByOffset(`w_offset + ${ae}`)}`;ue+=";"}else if(g===2){if(v!==2)throw new Error(`Invalid inputChannelsRemainder ${v}.`);ue+=`
          let xValue = ${le.getByOffset("x_offset")};
          let wValue = ${q.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`}return ue},te=`
            let outputIndices = ${pe.offsetToIndices(`global_idx * ${y}`)};
            let batch = ${pe.indicesGet("outputIndices",0)};
            let d1 = ${pe.indicesGet("outputIndices",ne)};
            let r = ${pe.indicesGet("outputIndices",W)};
            let c = ${pe.indicesGet("outputIndices",oe)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${pe.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${J}(dyRCorner) + ${J}(wR)) / ${J}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${J}(uniforms.Dy_shape[${W}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${J}(dyCCorner) + ${J}(wC)) / ${J}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${J}(uniforms.Dy_shape[${oe}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${p?`
                var x_offset = ${le.indicesToOffset(`${le.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${g};
                var w_offset = ${q.indicesToOffset(`${q.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${w};
                  `:""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${p?4:g}) {
                  ${be()}
                  inputChannel = inputChannel + ${p?4:g};
                }
                ${ee()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${i?` + bias[d1 / ${y}]`:""};
            ${pe.setByOffset("global_idx","value")};
          `;return`
    ${N.registerUniforms(j).declareVariables(...se,pe)}
      ${N.mainStart()}
      ${N.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${te}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${e.cacheKey};${g}${w}${y}${p}${v}`,inputDependencies:T},getRunData:()=>({dispatchGroup:{x:M[0],y:M[1],z:M[2]},outputs:[{dims:t?t(s):s,dataType:n[0].dataType}],programUniforms:z}),getShaderSource:U}}}),xR,wR,ER,j1,vF,TR,$1,SR,yF,GW=fn(()=>{kW(),i_(),ym(),xR=(n,e,t,i,s,r)=>(n-1)*e+t+(i-1)*s+1-r,wR=(n,e,t,i,s)=>{let r=Math.floor(n/2);e==="SAME_UPPER"?(t[i]=r,t[s]=n-r):e==="SAME_LOWER"&&(t[i]=n-r,t[s]=r)},ER=(n,e,t,i,s,r,o,l,c,d)=>{let g=n.length-2,p=d.length===0;c.length<g&&c.push(...Array(g-c.length).fill(0));let h=n[0],v=e[l?3:1]*s;for(let y=0,w=n.length-g-(l?1:0);y<g;++y,++w){let S=n[w],M=p?S*o[y]:d[y],T=xR(S,o[y],r[y],e[w],t[y],M);wR(T,i,r,y,y+g),p&&d.push(o[y]*(S-1)+c[y]+(e[w]-1)*t[y]+1-r[y]-r[y+g])}d.splice(0,0,h),d.splice(l?3:1,0,v)},j1=(n,e)=>{let t=n.kernelShape.slice();if(n.kernelShape.length===0||n.kernelShape.reduce((p,h)=>p*h,1)===0){t.length=0;for(let p=2;p<e[1].dims.length;++p)t.push(e[1].dims[p])}let i=n.format==="NHWC";t.splice(0,0,e[1].dims[0]),t.splice(i?3:1,0,e[1].dims[1]);let s=n.pads.slice(),r=n.outputShape.slice(),o=n.outputPadding.slice(),l=e[0].dims,c=n.dilations.slice();if(c.reduce((p,h)=>p+h,0)===0){let p=e[0].dims.length-2;c=new Array(p).fill(1)}let d=n.strides.slice();if(d.reduce((p,h)=>p+h,0)===0){let p=e[0].dims.length-2;d=new Array(p).fill(1)}ER(l,t,c,n.autoPad,n.group,s,d,i,o,r);let g=Object.assign({},n);return Object.assign(g,{kernelShape:t,pads:s,outputPadding:o,outputShape:r,dilations:c,strides:d}),g},vF=n=>{let e=TS(n),t=n.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof n.autoPad>"u"?0:n.autoPad],s=n.dilations,r=n.group,o=n.kernelShape,l=n.pads,c=n.strides,d=n.wIsConst(),g=n.outputPadding,p=n.outputShape;return{autoPad:i,format:t,dilations:s,group:r,kernelShape:o,outputPadding:g,outputShape:p,pads:l,strides:c,wIsConst:d,...e,cacheKey:`${n.format};${e.activation};`}},TR=(n,e)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4&&n[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(n[0].dims.length!==n[1].dims.length)throw new Error("filter does not have same dimension as input");let t=n[0].dims[e.format==="NHWC"?n[0].dims.length-1:1],i=n[1].dims[0];if(t!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let s=n[1].dims[1]*e.group;if(n.length===3&&(n[2].dims.length!==1||n[2].dims[0]!==s))throw new Error("invalid bias");let r=n[0].dims.length-2;if(e.dilations.reduce((o,l)=>o+l,0)>0&&e.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(e.strides.reduce((o,l)=>o+l,0)>0&&e.strides.length!==r)throw new Error(`strides should be ${r}D`);if(e.pads.reduce((o,l)=>o+l,0)>0&&e.pads.length!==r*2)throw new Error(`pads should be ${r*2}D`);if(e.outputPadding.length!==r&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${r}D`);if(e.kernelShape.reduce((o,l)=>o+l,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==n[0].dims.length-2)throw new Error("invalid output shape")},$1=(n,e,t,i)=>{let s=n.kernelCustomData.wT??n.compute(Yu(e[1],[2,3,0,1]),{inputs:[1],outputs:[t.wIsConst?-2:-1]})[0];t.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=s);let r=[e[0],s];e.length===3&&r.push(e[2]),n.compute(_F(r,t,i),{inputs:r})},SR=(n,e)=>{let t=e.format==="NHWC",i=[n.inputs[0].reshape(t?[n.inputs[0].dims[0],1,n.inputs[0].dims[1],n.inputs[0].dims[2]]:[n.inputs[0].dims[0],n.inputs[0].dims[1],1,n.inputs[0].dims[2]]),n.inputs[1].reshape([n.inputs[1].dims[0],n.inputs[1].dims[1],1,n.inputs[1].dims[2]])];n.inputs.length===3&&i.push(n.inputs[2]);let s=e.kernelShape;(s.length===0||s[0]===0)&&(s=[n.inputs[1].dims[2]]);let r=e.dilations;(r.length===0||r[0]===0)&&(r=[1]);let o=e.strides;(o.length===0||o[0]===0)&&(o=[1]);let l=e.pads;l.length===0&&(l=[0,0]),l=[0,l[0],0,l[1]],o=[1].concat(o),r=[1].concat(r),s=[1].concat(s);let c=e.outputPadding;c=[0].concat(c);let d=j1({...e,pads:l,strides:o,dilations:r,kernelShape:s,outputPadding:c},i);$1(n,i,d,g=>t?[g[0],g[2],g[3]]:[g[0],g[1],g[3]])},yF=(n,e)=>{if(TR(n.inputs,e),n.inputs[0].dims.length===3)SR(n,e);else{let t=j1(e,n.inputs);$1(n,n.inputs,t)}}}),AR,MF,bF,VW=fn(()=>{ai(),vi(),$r(),Mi(),AR=(n,e,t,i)=>{let s=Ut.size(e),r=e.length,o=Wt("input",n,r),l=zn("output",n,r),c=t.dataType===6?t.getInt32Array()[0]:Number(t.getBigInt64Array()[0]),d=Ut.normalizeAxis(c,r),g=p=>{let h=` i32(${o.indicesGet("inputIndices","uniforms.axis")}) `,v=Vn("uniforms.input_shape","uniforms.axis",r),y=i.reverse?h+(i.exclusive?" + 1":""):"0",w=i.reverse?v:h+(i.exclusive?"":" + 1");return`
                ${p.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(o,l)}
                ${p.mainStart()}
                  ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${l.offsetToIndices("global_idx")};
                  var sum = ${l.type.value}(0);
                  let first : i32 = ${y};
                  let last : i32 = ${w};
                  for (var i : i32 = first; i < last; i++) {
                    ${o.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${o.getByIndices("inputIndices")};
                  }
                  ${l.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:i.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:e,dataType:n}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},{type:12,data:d},...Wn(e,e)]}),getShaderSource:g}},MF=(n,e)=>{let t=n.inputs[0].dims,i=n.inputs[0].dataType,s=n.inputs[1];n.compute(AR(i,t,s,e),{inputs:[0]})},bF=n=>{let e=n.exclusive===1,t=n.reverse===1;return Ts({exclusive:e,reverse:t})}}),CR,PR,RR,xF,wF,HW=fn(()=>{ai(),vi(),$r(),Mi(),CR=n=>{if(!n||n.length!==1)throw new Error("DepthToSpace requires 1 input.");if(n[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},PR=(n,e,t,i)=>{let s=[];s.push(`fn perm(i: ${i.type.indices}) -> ${t.type.indices} {
    var a: ${t.type.indices};`);for(let r=0;r<e;++r)s.push(t.indicesSet("a",n[r],`i[${r}]`));return s.push("return a;}"),s.join(`
`)},RR=(n,e)=>{let t,i,s,r,o,l,c=e.format==="NHWC",d=e.blocksize,g=e.mode==="DCR";c?([t,i,s,r]=n.dims,o=g?[t,i,s,d,d,r/d**2]:[t,i,s,r/d**2,d,d],l=g?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([t,i,s,r]=[n.dims[0],n.dims[2],n.dims[3],n.dims[1]],o=g?[t,d,d,r/d**2,i,s]:[t,r/d**2,d,d,i,s],l=g?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let p=n.reshape(o),h=p.dims.length,v=n.dataType,y=Wt("a",v,h),w=zn("output",v,h),S=M=>`
  ${M.registerUniform("output_size","u32").declareVariables(y,w)}

  ${PR(l,h,y,w)}

  ${M.mainStart()}
    ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${w.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${w.setByOffset("global_idx",y.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${n.dims};${e.blocksize};${e.mode}`,inputDependencies:["rank"]},getRunData:M=>{let T=c?[t,i*d,s*d,r/d**2]:[t,r/d**2,i*d,s*d],C=Ut.size(T),x=p.dims,R=Ut.sortBasedOnPerm(x,l);return{outputs:[{dims:T,dataType:M[0].dataType}],dispatchGroup:{x:Math.ceil(C/64)},programUniforms:[{type:12,data:C},...Wn(x,R)]}},getShaderSource:S}},xF=(n,e)=>{CR(n.inputs),n.compute(RR(n.inputs[0],e))},wF=n=>Ts({blocksize:n.blocksize,mode:n.mode,format:n.format})}),OM,sv,W1,DR,BR,IR,OR,K1,LR,EF,TF,jW=fn(()=>{ai(),vi(),$r(),Mi(),OM="[a-zA-Z]|\\.\\.\\.",sv="("+OM+")+",W1="^"+sv+"$",DR="("+sv+",)*"+sv,BR="^"+DR+"$",IR=class{constructor(n=-1){this.symbolToIndices=new Map,this.inputIndex=n}addSymbol(n,e){let t=this.symbolToIndices.get(n);t===void 0?t=[e]:t.push(e),this.symbolToIndices.set(n,t)}},OR=class{constructor(n,e){this.equation=e,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[t,i]=e.includes("->")?e.split("->",2):[e,""];if(!t.match(RegExp(BR)))throw new Error("Invalid LHS term");if(t.split(",").forEach((s,r)=>{let o=n[r].dims.slice();if(!s.match(RegExp(W1)))throw new Error("Invalid LHS term");let l=this.processTerm(s,!0,o,r);this.lhs.push(l)}),i==="")i+=[...this.symbolToInfo.entries()].filter(([s,r])=>r.count===1||s==="...").map(([s])=>s).join("");else if(!i.match(RegExp(sv)))throw new Error("Invalid RHS");i.match(RegExp(OM,"g"))?.forEach(s=>{if(s==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let r=this.symbolToInfo.get(s);if(r===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(r.dimValue)}}),this.rhs=this.processTerm(i,!1,this.outputDims)}addSymbol(n,e,t){let i=this.symbolToInfo.get(n);if(i!==void 0){if(i.dimValue!==e&&i.count!==1)throw new Error("Dimension mismatch");i.count++,i.inputIndices.push(t)}else i={count:1,dimValue:e,inputIndices:[t]};this.symbolToInfo.set(n,i)}processTerm(n,e,t,i=-1){let s=t.length,r=!1,o=[],l=0;if(!n.match(RegExp(W1))&&!e&&n!=="")throw new Error("Invalid LHS term");let c=n.match(RegExp(OM,"g")),d=new IR(i);return c?.forEach((g,p)=>{if(g==="..."){if(r)throw new Error("Only one ellipsis is allowed per input term");r=!0;let h=s-c.length+1;if(h<0)throw new Error("Ellipsis out of bounds");if(o=t.slice(l,l+h),this.hasEllipsis){if(this.ellipsisDims.length!==o.length||this.ellipsisDims.toString()!==o.toString())throw new Error("Ellipsis dimensions mismatch")}else if(e)this.hasEllipsis=!0,this.ellipsisDims=o;else throw new Error("Ellipsis must be specified in the LHS");for(let v=0;v<o.length;v++){let y=String.fromCharCode(48+v);d.addSymbol(y,p+v),this.addSymbol(y,t[l++],i)}}else d.addSymbol(g,p+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(g,t[l++],i)}),d}},K1=n=>n+"_max",LR=(n,e,t,i)=>{let s=n.map(d=>d.length).map((d,g)=>Wt(`input${g}`,e,d)),r=Ut.size(i),o=zn("output",e,i.length),l=[...t.symbolToInfo.keys()].filter(d=>!t.rhs.symbolToIndices.has(d)),c=d=>{let g=[],p="var prod = 1.0;",h="var sum = 0.0;",v="sum += prod;",y=[],w=[],S=[],M=[],T=t.symbolToInfo.size===t.rhs.symbolToIndices.size;t.symbolToInfo.forEach((x,R)=>{if(t.rhs.symbolToIndices.has(R)){let P=t.rhs.symbolToIndices.get(R)?.[0];P!==void 0&&t.lhs.forEach((D,z)=>{if(x.inputIndices.includes(z)){let U=D.symbolToIndices.get(R);if(U===void 0)throw new Error("Invalid symbol error");U.forEach(N=>{g.push(`${s[z].indicesSet(`input${z}Indices`,N,o.indicesGet("outputIndices",P))}`)})}})}else t.lhs.forEach((P,D)=>{if(x.inputIndices.includes(D)){let z=P.symbolToIndices.get(R);if(z===void 0)throw new Error("Invalid symbol error");z.forEach(U=>{y.push(`${s[D].indicesSet(`input${D}Indices`,U,`${R}`)}`)}),M.push(`prod *= ${s[D].getByIndices(`input${D}Indices`)};`)}}),w.push(`for(var ${R}: u32 = 0; ${R} < uniforms.${K1(R)}; ${R}++) {`),S.push("}")});let C=T?[...g,`let sum = ${s.map((x,R)=>x.getByIndices(`input${R}Indices`)).join(" * ")};`]:[...g,h,...w,...y,p,...M,v,...S];return`
            ${d.registerUniforms(l.map(x=>({name:`${K1(x)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...s,o)}

            ${d.mainStart()}
            ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${o.offsetToIndices("global_idx")};
            ${s.map((x,R)=>`var input${R}Indices: ${s[R].type.indices};`).join(`
`)}
            ${C.join(`
`)};
            ${o.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:t.equation,inputDependencies:n.map(()=>"rank")},getRunData:()=>{let d=l.filter(p=>t.symbolToInfo.has(p)).map(p=>({type:12,data:t.symbolToInfo.get(p)?.dimValue||0}));d.push({type:12,data:r});let g=n.map((p,h)=>[...Wn(p)]).reduce((p,h)=>p.concat(h),d);return g.push(...Wn(i)),{outputs:[{dims:i,dataType:e}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:g}},getShaderSource:c}},EF=(n,e)=>{let t=new OR(n.inputs,e.equation),i=t.outputDims,s=n.inputs.map((r,o)=>r.dims);n.compute(LR(s,n.inputs[0].dataType,t,i))},TF=n=>{let e=n.equation.replace(/\s+/g,"");return Ts({equation:e})}}),FR,q1,NR,zR,SF,$W=fn(()=>{ai(),vi(),Mi(),FR=n=>{if(!n||n.length!==2)throw new Error("Expand requires 2 input.");let e=n[0].dims,t=Array.from(n[1].getBigInt64Array(),Number),i=t.length<e.length?0:t.length-e.length,s=e.length<t.length?0:e.length-t.length;for(;i<t.length&&s<e.length;++i,++s)if(t[i]!==e[s]&&t[i]!==1&&e[s]!==1)throw new Error("Expand requires shape to be broadcastable to input")},q1=(n,e)=>{let t=n.length-e.length,i=[];for(let s=0;s<t;++s)i.push(n[s]);for(let s=0;s<e.length;++s)i.push(e[s]===1?n[s+t]:e[s]);return i},NR=(n,e)=>n.length>e.length?q1(n,e):q1(e,n),zR=n=>{let e=n[0].dims,t=Array.from(n[1].getBigInt64Array(),Number),i=NR(e,t),s=n[0].dataType,r=s===9||Ut.size(e)===1,o=s===9||e.length>0&&e[e.length-1]%4===0?4:1,l=r||i.length>0&&i[i.length-1]%4===0?4:1,c=Math.ceil(Ut.size(i)/l),d=p=>{let h=Wt("input",s,e.length,o),v=zn("output",s,i.length,l),y;if(s===9){let w=(S,M,T="")=>`
          let outputIndices${M} = ${v.offsetToIndices(`outputOffset + ${M}u`)};
          let offset${M} = ${h.broadcastedIndicesToOffset(`outputIndices${M}`,v)};
          let index${M} = offset${M} / 4u;
          let component${M} = offset${M} % 4u;
          ${S}[${M}] = ${T}(${h.getByOffset(`index${M}`)}[component${M}]);
        `;y=`
        let outputOffset = global_idx * ${l};
        var data = vec4<u32>(0);
        ${w("data",0,"u32")}
        ${w("data",1,"u32")}
        ${w("data",2,"u32")}
        ${w("data",3,"u32")}
        ${v.setByOffset("global_idx","data")}
      }`}else y=`
        let outputIndices = ${v.offsetToIndices(`global_idx * ${l}`)};
        let inputOffset = ${h.broadcastedIndicesToOffset("outputIndices",v)};
        let data = ${v.type.value}(${h.getByOffset(`inputOffset / ${o}`)});
        ${v.setByOffset("global_idx","data")}
      }`;return`
    ${p.registerUniform("vec_size","u32").declareVariables(h,v)}
    ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${y}`},g=[{type:12,data:c},...Wn(e,i)];return{name:"Expand",shaderCache:{hint:`${i.length};${o}${l}`,inputDependencies:["rank"]},getShaderSource:d,getRunData:()=>({outputs:[{dims:i,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:g})}},SF=n=>{FR(n.inputs),n.compute(zR(n.inputs),{inputs:[0]})}}),UR,AF,WW=fn(()=>{ai(),vi(),Mi(),ES(),UR=n=>{let e=n[0].dataType,t=Ut.size(n[0].dims),i=Ut.size(n[1].dims),s=i%4===0,r=o=>{let l=Wt("x",e,[1],4),c=Wt("bias",e,[1],4),d=zn("y",e,[1],4),g=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],p=v=>`
      let bias${v}_offset: u32 = (global_idx * 4 + ${v}) % uniforms.bias_size;
      let bias${v} = ${c.getByOffset(`bias${v}_offset / 4`)}[bias${v}_offset % 4];`,h=s?`
      let bias = ${c.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${p(0)}${p(1)}${p(2)}${p(3)}
      let bias = ${l.type.value}(bias0, bias1, bias2, bias3);`;return`${o.registerUniforms(g).declareVariables(l,c,d)}

    ${tT(qo(e))}

    ${o.mainStart(p0)}
      ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${l.getByOffset("global_idx")};
      ${h}
      let x_in = x + bias;
      ${d.setByOffset("global_idx",nT("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${s}`,inputDependencies:["type","type"]},getShaderSource:r,getRunData:o=>({outputs:[{dims:o[0].dims,dataType:o[0].dataType}],programUniforms:[{type:12,data:Math.ceil(t/4)},{type:12,data:i}],dispatchGroup:{x:Math.ceil(t/p0/4)}})}},AF=n=>{n.inputs.length<2||Ut.size(n.inputs[1].dims)===0?KL(n):n.compute(UR(n.inputs))}}),kR,GR,CF,PF,KW=fn(()=>{ai(),vi(),$r(),Mi(),kR=n=>{if(!n||n.length!==2)throw new Error("Gather requires 2 inputs.")},GR=(n,e)=>{let t=n[0].dims,i=n[1].dims,s=t.length,r=Ut.normalizeAxis(e.axis,s),o=t.slice(0);o.splice(r,1,...i);let l=t[r],c=n[0].dataType===9?4:1,d=Math.ceil(Ut.size(o)/c),g=[{type:12,data:d},{type:6,data:l},{type:12,data:r},...Wn(n[0].dims,n[1].dims,o)],p=h=>{let v=Wt("data",n[0].dataType,n[0].dims.length,c),y=Wt("inputIndices",n[1].dataType,n[1].dims.length),w=zn("output",n[0].dataType,o.length,c),S=T=>{let C=i.length,x=`var indicesIndices${T}  = ${y.type.indices}(0);`;for(let R=0;R<C;R++)x+=`${C>1?`indicesIndices${T}[${R}]`:`indicesIndices${T}`} = ${o.length>1?`outputIndices${T}[uniforms.axis + ${R}]`:`outputIndices${T}`};`;x+=`
          var idx${T} = ${y.getByIndices(`indicesIndices${T}`)};
          if (idx${T} < 0) {
            idx${T} = idx${T} + uniforms.axisDimLimit;
          }
          var dataIndices${T} : ${v.type.indices};
        `;for(let R=0,P=0;R<s;R++)R===r?(x+=`${s>1?`dataIndices${T}[${R}]`:`dataIndices${T}`} = u32(idx${T});`,P+=C):(x+=`${s>1?`dataIndices${T}[${R}]`:`dataIndices${T}`} = ${o.length>1?`outputIndices${T}[${P}]`:`outputIndices${T}`};`,P++);return x},M;if(n[0].dataType===9){let T=(C,x,R="")=>`
          let outputIndices${x} = ${w.offsetToIndices(`outputOffset + ${x}u`)};
          ${S(x)};
          let offset${x} = ${v.indicesToOffset(`dataIndices${x}`)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${C}[${x}] = ${R}(${v.getByOffset(`index${x}`)}[component${x}]);
        `;M=`
        let outputOffset = global_idx * ${c};
        var value = vec4<u32>(0);
        ${T("value",0,"u32")}
        ${T("value",1,"u32")}
        ${T("value",2,"u32")}
        ${T("value",3,"u32")}
        ${w.setByOffset("global_idx","value")}
      `}else M=`
      let outputIndices = ${w.offsetToIndices("global_idx")};
      ${S("")};
      let value = ${v.getByIndices("dataIndices")};
      ${w.setByOffset("global_idx","value")};
      `;return`
      ${h.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(v,y,w)}
      ${h.mainStart()}
        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${M}
      }`};return{name:"Gather",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:o,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:g}),getShaderSource:p}},CF=n=>Ts({axis:n.axis}),PF=(n,e)=>{let t=n.inputs;kR(t),n.compute(GR(n.inputs,e))}}),VR,RF,DF,qW=fn(()=>{ai(),vi(),Mi(),VR=(n,e,t,i,s,r,o,l,c)=>{let d=[{type:12,data:r},{type:12,data:i},{type:12,data:s},{type:12,data:t},{type:12,data:o},{type:12,data:l},{type:12,data:c}],g=[r];d.push(...Wn(e.dims,g));let p=h=>{let v=Wt("indices_data",e.dataType,e.dims.length),y=zn("input_slice_offsets_data",12,1,1),w=[v,y],S=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:s.length},{name:"sizes_from_slice_dims_data",type:"u32",length:t.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${h.registerUniforms(S).declareVariables(...w)}
  ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${s.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${t.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return n.compute({name:"computeSliceOffsets",shaderCache:{hint:`${s.length}_${t.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:g,dataType:n.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:d}),getShaderSource:p},{inputs:[e],outputs:[-1]})[0]},RF=(n,e)=>{let t=n.inputs,i=t[0].dims,s=t[0].dataType,r=t[1].dims,o=r[r.length-1],l=Ut.sizeToDimension(r,r.length-1),c=Ut.sizeFromDimension(i,e.batchDims+o),d=Ut.sizeToDimension(i,e.batchDims),g=Ut.sizeFromDimension(i,e.batchDims),p=l/d,h=new Array(o),v=c;for(let x=0;x<o;++x)h[o-1-x]=v,v*=i[e.batchDims+o-1-x];let y=VR(n,t[1],h,e.batchDims,i,l,p,g,o),w=e.batchDims+o;if(w>i.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let S=r.slice(0,-1).concat(i.slice(w)),M=Ut.size(S),T=[{type:12,data:M},{type:12,data:c},...Wn(t[0].dims,y.dims,S)],C=x=>{let R=Wt("data",t[0].dataType,t[0].dims.length),P=Wt("slice_offsets",12,y.dims.length),D=zn("output",t[0].dataType,S.length);return`
          ${x.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(R,P,D)}
            ${x.mainStart()}
            ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};n.compute({name:"GatherND",shaderCache:{hint:e.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:S,dataType:s}],dispatchGroup:{x:Math.ceil(M/64)},programUniforms:T}),getShaderSource:C},{inputs:[t[0],y]})},DF=n=>({batchDims:n.batch_dims,cacheKey:""})}),HR,jR,BF,IF,XW=fn(()=>{ai(),vi(),$r(),Mi(),HR=(n,e)=>{if(n.length<3||n.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let t=Ut.normalizeAxis(e.quantizeAxis,n[0].dims.length),i=e.blockSize,s=n[0],r=n[2],o=n.length===4?n[3]:void 0;if(r.dims.length!==s.dims.length||!s.dims.map((l,c)=>c===t?Math.ceil(l/i)===r.dims[c]:l===r.dims[c]).reduce((l,c)=>l&&c,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(o){if(o.dataType!==s.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(o.dims.length!==r.dims.length||!o.dims.map((l,c)=>l===r.dims[c]).reduce((l,c)=>l&&c,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},jR=(n,e)=>{let t=n[0].dims,i=n[1].dims,s=t.length,r=Ut.normalizeAxis(e.gatherAxis,s),o=Ut.normalizeAxis(e.quantizeAxis,s),l=t.slice(0);l.splice(r,1,...i);let c=Ut.size(l),d=n[2].dataType,g=n[0].dataType===22,p=[{type:12,data:c},{type:12,data:o},{type:12,data:r},{type:12,data:e.blockSize},...Wn(...n.map((v,y)=>v.dims),l)],h=v=>{let y=Wt("data",n[0].dataType,n[0].dims.length),w=Wt("inputIndices",n[1].dataType,n[1].dims.length),S=Wt("scales",n[2].dataType,n[2].dims.length),M=n.length>3?Wt("zeroPoint",n[3].dataType,n[3].dims.length):void 0,T=zn("output",d,l.length),C=[y,w,S];M&&C.push(M);let x=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${v.registerUniforms(x).declareVariables(...C,T)}
        ${v.mainStart()}
        let output_indices = ${T.offsetToIndices("global_idx")};
        var indices_indices = ${w.type.indices}(0);
        ${i.length>1?`
          for (var i: u32 = 0; i < ${i.length}; i++) {
            let index = ${T.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${w.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${T.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${y.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${T.indicesGet("output_indices","i")};
          ${y.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${w.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${t[r]};
        }
        ${y.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${l.length}; i++) {
          let index = ${T.indicesGet("output_indices",`i + ${i.length} - 1`)};
          ${y.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${y.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${y.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${g?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${S.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${S.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${S.getByIndices("scale_indices")};
        ${M?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${M.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${M.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${g?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${qo(d)}(quantized_data - zero_point) * scale;
        ${T.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${e.cacheKey};${n.filter((v,y)=>y!==1).map(v=>v.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:n.length},(v,y)=>"rank")},getRunData:()=>({outputs:[{dims:l,dataType:d}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:p}),getShaderSource:h}},BF=(n,e)=>{let t=n.inputs;HR(t,e),n.compute(jR(n.inputs,e))},IF=n=>Ts({blockSize:n.blockSize,gatherAxis:n.gatherAxis,quantizeAxis:n.quantizeAxis})}),$R,WR,OF,LF,YW=fn(()=>{ai(),vi(),$r(),Mi(),$R=n=>{if(!n||n.length!==2)throw new Error("GatherElements requires 2 inputs.");if(n[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(n[0].dims.length!==n[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},WR=(n,e)=>{let t=n[0].dims,i=n[0].dataType,s=t.length,r=n[1].dims,o=n[1].dataType,l=Ut.normalizeAxis(e.axis,s),c=t[l],d=r.slice(0),g=Ut.size(d),p=Wt("input",i,s),h=Wt("indicesInput",o,r.length),v=zn("output",i,d.length),y=[{type:12,data:g},{type:6,data:c},{type:12,data:l}];return y.push(...Wn(t,r,d)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:d,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:y}),getShaderSource:w=>`
      ${w.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(p,h,v)}
      ${w.mainStart()}
      ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${v.offsetToIndices("global_idx")};

      var idx = ${h.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${p.type.indices}(outputIndices);
      ${p.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${p.getByIndices("inputIndices")};

      ${v.setByOffset("global_idx","value")};
  }`}},OF=n=>Ts({axis:n.axis}),LF=(n,e)=>{let t=n.inputs;$R(t),n.compute(WR(n.inputs,e))}}),KR,qR,FF,NF,JW=fn(()=>{ai(),vi(),Mi(),KR=n=>{if(!n)throw new Error("Input is missing");if(n.length<2||n.length>3)throw new Error("Invaid input number.");if(n.length===3&&n[2].dims.length>2)throw new Error("Invalid input shape of C");if(n[0].dataType!==n[1].dataType||n.length===3&&n[0].dataType!==n[2].dataType)throw new Error("Input types are mismatched")},qR=(n,e)=>{let t=n[0].dims.slice(),i=n[1].dims.slice(),[s,r,o]=O3.getShapeOfGemmResult(t,e.transA,i,e.transB,n.length===3?n[2].dims:void 0),l=[s,r];if(!l)throw new Error("Can't use gemm on the given tensors");let c=16,d=Math.ceil(r/c),g=Math.ceil(s/c),p=!0,h=Ut.size(l),v=[{type:12,data:p?d:h},{type:12,data:s},{type:12,data:r},{type:12,data:o},{type:1,data:e.alpha},{type:1,data:e.beta}],y=["type","type"];n.length===3&&(v.push(...Wn(n[2].dims)),y.push("rank")),v.push(...Wn(l));let w=M=>{let T="";e.transA&&e.transB?T="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":e.transA&&!e.transB?T="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!e.transA&&e.transB?T="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!e.transA&&!e.transB&&(T="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let C=e.alpha===1?"":"value *= uniforms.alpha;",x=Wt("a",n[0].dataType,n[0].dims),R=Wt("b",n[1].dataType,n[1].dims),P=x.type.value,D=null,z=[x,R];n.length===3&&(D=Wt("c",n[2].dataType,n[2].dims.length),z.push(D));let U=zn("output",n[0].dataType,l.length);z.push(U);let N=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${M.registerUniforms(N).declareVariables(...z)}

  ${M.mainStart()}
    ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${P}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${T}
    }

    ${C}
    ${D!=null?`let cOffset = ${D.broadcastedIndicesToOffset("vec2(m, n)",U)}; value += ${P}(uniforms.beta) * ${D.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},S=M=>{let T=Wt("a",n[0].dataType,n[0].dims),C=Wt("b",n[1].dataType,n[1].dims),x=null,R=[T,C];n.length===3&&(x=Wt("c",n[2].dataType,n[2].dims.length),R.push(x));let P=zn("output",n[0].dataType,l.length);R.push(P);let D=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],z="",U="";e.transA&&e.transB?(U=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${T.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${C.type.value}(0);
      }
      `,z="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):e.transA&&!e.transB?(U=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${T.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${C.type.value}(0);
      }
      `,z="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!e.transA&&e.transB?(U=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${T.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${C.type.value}(0);
      }
      `,z="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!e.transA&&!e.transB&&(U=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${T.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${C.type.value}(0);
      }
      `,z="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let N=e.alpha===1?"":"value *= uniforms.alpha;";return`
  ${M.registerUniforms(D).declareVariables(...R)}
  var<workgroup> tile_a: array<array<${T.type.storage}, ${c}>, ${c}>;
  var<workgroup> tile_b: array<array<${C.type.storage}, ${c}>, ${c}>;
  ${M.mainStart([c,c,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${c};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${c};
    let num_tiles = (uniforms.K - 1) / ${c} + 1;
    var k_start = 0u;
    var value = ${P.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${U}
      k_start = k_start + ${c};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${c}; k++) {
        ${z}
      }
      workgroupBarrier();
    }

    ${N}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${x!=null?`let cOffset = ${x.broadcastedIndicesToOffset("vec2(m, n)",P)}; value += ${P.type.value}(uniforms.beta) * ${x.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return p?{name:"GemmShared",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:l,dataType:n[0].dataType}],dispatchGroup:{x:d*g},programUniforms:v}),getShaderSource:S}:{name:"Gemm",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:l,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:v}),getShaderSource:w}},FF=n=>{let e=n.transA,t=n.transB,i=n.alpha,s=n.beta;return{transA:e,transB:t,alpha:i,beta:s,cacheKey:`${n.transA};${n.transB};${n.alpha===1}`}},NF=(n,e)=>{KR(n.inputs),n.compute(qR(n.inputs,e))}}),Nf,Nh,mg,gg,XR,YR,JR,QR,ZR,eD,tD,nD,zF,UF,QW=fn(()=>{ai(),vi(),$r(),Mi(),[Nf,Nh,mg,gg]=[0,1,2,3],XR=n=>{if(n[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(n[0].dims.length!==n[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(n[0].dims.length-2!==n[1].dims[n[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${n[0].dims.length-2}`);if(n[0].dims[0]!==n[1].dims[0])throw new Error("grid batch size must match input batch size")},YR=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,JR=n=>`
  fn gs_bicubic_interpolate(p: mat4x4<${n}>, x: f32, y: f32) -> ${n} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${n}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,QR=n=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${n.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,ZR=n=>`
  ${n.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,eD=(n,e,t)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${e} {
     var pixel = ${e}(0);
     var indices = vec4<u32>(0);
     indices[${Nf}] = batch;
     indices[${Nh}] = channel;`+(()=>{switch(t.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${mg}] = u32(r);
            indices[${gg}] = u32(c);
          } else {
            return ${e}(0);
          }
        `;case"border":return`
          indices[${mg}] = u32(clamp(r, 0, H - 1));
          indices[${gg}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${mg}] = gs_reflect(r, border[1], border[3]);
          indices[${gg}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${t.paddingMode} is not supported`)}})()+`
    return ${n.getByIndices("indices")};
  }
`,tD=(n,e,t)=>(()=>{switch(t.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${Nf}], indices[${Nh}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${Nf}], indices[${Nh}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${Nf}], indices[${Nh}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${Nf}], indices[${Nh}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${Nf}], indices[${Nh}], border);

          let dx2 = ${e}(f32(x2) - x);
          let dx1 = ${e}(x - f32(x1));
          let dy2 = ${e}(f32(y2) - y);
          let dy1 = ${e}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${e}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${Nf}], indices[${Nh}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${t.mode} is not supported`)}})()+`${n.setByOffset("global_idx","result")}`,nD=(n,e)=>{let t=Wt("x",n[0].dataType,n[0].dims.length),i=[n[1].dims[0],n[1].dims[1],n[1].dims[2]],s=Wt("grid",n[1].dataType,i.length,2),r=[n[0].dims[0],n[0].dims[1],n[1].dims[1],n[1].dims[2]];e.format==="NHWC"&&(r=[n[0].dims[0],n[1].dims[1],n[1].dims[2],n[0].dims[3]],[Nf,Nh,mg,gg]=[0,3,1,2]);let o=zn("output",n[0].dataType,r.length),l=t.type.value,c=Ut.size(r),d=[{type:12,data:c},...Wn(n[0].dims,i,r)],g=p=>`
  ${p.registerUniform("output_size","u32").declareVariables(t,s,o)}
  ${YR}
  ${JR(l)}
  ${QR(e)}
  ${ZR(e)}
  ${eD(t,l,e)}

  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${mg}]);
      let W_in = i32(uniforms.x_shape[${gg}]);

      ${e.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${o.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${Nf}], indices[${mg}], indices[${gg}]);
      let nxy = ${s.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${tD(o,l,e)}
  }`;return{name:"GridSample",shaderCache:{hint:`${e.cacheKey}`,inputDependencies:["type","type"]},getRunData:p=>{let h=Ut.size(r);return{outputs:[{dims:r,dataType:p[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:d}},getShaderSource:g}},zF=(n,e)=>{XR(n.inputs),n.compute(nD(n.inputs,e))},UF=n=>Ts({alignCorners:n.align_corners,mode:n.mode,paddingMode:n.padding_mode,format:n.format})}),Sl,iD,kF,X1,sD,gv,GF,VF=fn(()=>{ai(),vi(),$r(),MS(),wS(),Mi(),ym(),Sl=(n,e)=>n.length>e&&n[e].dims.length>0?n[e]:void 0,iD=(n,e)=>{let t=n[0],i=Sl(n,1),s=Sl(n,2),r=Sl(n,3),o=Sl(n,4),l=Sl(n,5),c=Sl(n,6),d=Sl(n,7);if(t.dims.length!==3&&t.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let g=t.dims[0],p=t.dims[1],h=t.dims.length===3?t.dims[2]:e.numHeads*t.dims[4],v=p,y=0,w=0,S=Math.floor(h/e.numHeads);if(c&&d&&Ut.size(c.dims)&&Ut.size(d.dims)){if(c.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(c.dims[0]!==g||c.dims[1]!==e.numHeads||c.dims[3]!==S)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(d.dims[0]!==g||d.dims[1]!==e.numHeads||d.dims[3]!==S)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(c.dims[2]!==d.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(d.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');y=c.dims[2],w=c.dims[2]}else if(c&&Ut.size(c.dims)||d&&Ut.size(d.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let M;if(i&&Ut.size(i.dims)>0){if(t.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(t.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(i.dims.length===3){if(i.dims[2]!==t.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');M=2,v=i.dims[1]}else if(i.dims.length===5){if(i.dims[2]!==e.numHeads||i.dims[3]!==2||i.dims[4]!==S)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(s)throw new Error('Expect "value" be none when "key" has packed kv format.');M=5,v=i.dims[1]}else{if(i.dims[1]!==e.numHeads||i.dims[3]!==S)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');M=0,v=i.dims[2]}}else{if(t.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(t.dims[2]!==e.numHeads||t.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');M=3}if(r&&Ut.size(r.dims)>0){if(r.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(i&&i.dims.length===5&&i.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let T=y+v,C=0;if(o&&Ut.size(o.dims)>0){C=8;let D=o.dims;throw D.length===1?D[0]===g?C=1:D[0]===3*g+2&&(C=3):D.length===2&&D[0]===g&&D[1]===T&&(C=5),C===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let x=!1,R=h;if(s&&Ut.size(s.dims)>0){if(s.dims.length!==3&&s.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(t.dims[0]!==s.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(s.dims.length===3){if(v!==s.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');R=s.dims[2]}else{if(v!==s.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');R=s.dims[1]*s.dims[3],x=!0}}let P=!1;if(o&&Ut.size(o.dims)>0)throw new Error("Key padding mask is not supported");if(l&&Ut.size(l.dims)>0){if(l.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(l.dims[0]!==g||l.dims[1]!==e.numHeads||l.dims[2]!==p||l.dims[3]!==T)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:g,sequenceLength:p,pastSequenceLength:y,kvSequenceLength:v,totalSequenceLength:T,maxSequenceLength:w,inputHiddenSize:0,hiddenSize:h,vHiddenSize:R,headSize:S,vHeadSize:Math.floor(R/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:C,scale:e.scale,broadcastResPosBias:P,passPastInKv:x,qkvFormat:M}},kF=n=>Ts({...n}),X1=Ts({perm:[0,2,1,3]}),sD=(n,e,t,i,s,r,o)=>{let l=[i,s,r],c=Ut.size(l),d=[{type:12,data:c},{type:12,data:o},{type:12,data:r}],g=p=>{let h=zn("qkv_with_bias",e.dataType,l),v=Wt("qkv",e.dataType,l),y=Wt("bias",t.dataType,l),w=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${p.registerUniforms(w).declareVariables(v,y,h)}
  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return n.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:l,dataType:e.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:d}),getShaderSource:g},{inputs:[e,t],outputs:[-1]})[0]},gv=(n,e,t,i,s,r,o,l)=>{let c=r;if(o&&Ut.size(o.dims)>0){if(i===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return c=sD(n,r,o,e,i,t*s,l),c=c.reshape([e,i,t,s]),t===1||i===1?c:n.compute(Yu(c,X1.perm),{inputs:[c],outputs:[-1]})[0]}else return r.dims.length===3&&(c=r.reshape([e,i,t,s])),t===1||i===1?c:n.compute(Yu(c,X1.perm),{inputs:[c],outputs:[-1]})[0]},GF=(n,e)=>{let t=iD(n.inputs,e),i=n.inputs[0],s=Sl(n.inputs,1),r=Sl(n.inputs,2),o=Sl(n.inputs,3),l=Sl(n.inputs,4),c=Sl(n.inputs,5),d=Sl(n.inputs,6),g=Sl(n.inputs,7);if(i.dims.length===5)throw new Error("Packed QKV is not implemented");if(s?.dims.length===5)throw new Error("Packed KV is not implemented");let p=s&&r&&s.dims.length===4&&r.dims.length===4,h=gv(n,t.batchSize,t.numHeads,t.sequenceLength,t.headSize,i,o,0);if(p)return jv(n,h,s,r,l,void 0,d,g,c,t);if(!s||!r)throw new Error("key and value must be provided");let v=gv(n,t.batchSize,t.numHeads,t.kvSequenceLength,t.headSize,s,o,t.hiddenSize),y=gv(n,t.batchSize,t.numHeads,t.kvSequenceLength,t.vHeadSize,r,o,2*t.hiddenSize);jv(n,h,v,y,l,void 0,d,g,c,t)}}),rD,aD,oD,lD,oT,HF,jF,$F=fn(()=>{ai(),vi(),$r(),Mi(),rD=n=>{if(!n||n.length<1)throw new Error("too few inputs")},aD=(n,e)=>{let t=[],i=e.numOutputs;return n[1].dims[0]>0&&(n[1].getBigInt64Array().forEach(s=>t.push(Number(s))),i=t.length),Ts({numOutputs:i,axis:e.axis,splitSizes:t})},oD=n=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${n}u; i += 1u ) {
    if (index < ${Vn("uniforms.size_in_split_axis","i",n)}) {
        return i;
    }
    }
    return ${n}u;
}`,lD=n=>{let e=n.length,t=[];for(let i=0;i<e;++i){let s=n[i].setByIndices("indices","input[global_idx]");e===1?t.push(s):i===0?t.push(`if (output_number == ${i}u) { ${s} }`):i===e-1?t.push(`else { ${s} }`):t.push(`else if (output_number == ${i}) { ${s} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${n[0].type.indices}, global_idx: u32) {
        ${t.join(`
`)}
      }`},oT=(n,e)=>{let t=n[0].dims,i=Ut.size(t),s=n[0].dataType,r=Ut.normalizeAxis(e.axis,t.length),o=new Array(e.numOutputs),l=Wt("input",s,t.length),c=new Array(e.numOutputs),d=[],g=[],p=0,h=[{type:12,data:i}];for(let y=0;y<e.numOutputs;y++){p+=e.splitSizes[y],c[y]=p;let w=t.slice();w[r]=e.splitSizes[y],g.push(w),o[y]=zn(`output${y}`,s,w.length),d.push({dims:g[y],dataType:n[0].dataType})}h.push({type:12,data:c},...Wn(t,...g));let v=y=>`
  ${y.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",c.length).declareVariables(l,...o)}
  ${oD(c.length)}
  ${lD(o)}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${l.offsetToIndices("global_idx")};
    var index = ${l.indicesGet("indices",r)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${Vn("uniforms.size_in_split_axis","output_number - 1u",c.length)};
      ${l.indicesSet("indices",r,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey,inputDependencies:["rank"]},getShaderSource:v,getRunData:()=>({outputs:d,dispatchGroup:{x:Math.ceil(i/64)},programUniforms:h})}},HF=(n,e)=>{rD(n.inputs);let t=n.inputs.length===1?e:aD(n.inputs,e);n.compute(oT(n.inputs,t),{inputs:[0]})},jF=n=>{let e=n.axis,t=n.splitSizes,i=n.numOutputs<0?t.length:n.numOutputs;if(i!==t.length)throw new Error("numOutputs and splitSizes lengh must be equal");return Ts({axis:e,numOutputs:i,splitSizes:t})}}),uD,jb,WF,KF=fn(()=>{ai(),vi(),$r(),Mi(),uD=(n,e)=>{let[t,i,s,r]=n,{numHeads:o,rotaryEmbeddingDim:l}=e;if(t.dims.length!==3&&t.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${t.dims.length}`);if(!Ut.areEqual(i.dims,[])&&!Ut.areEqual(i.dims,[1])&&i.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${i.dims.length}`);if(s.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${s.dims.length}`);if(r.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${r.dims.length}`);if(!Ut.areEqual(s.dims,r.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(l>0&&o===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let c=t.dims[0],d=t.dims[t.dims.length-2],g=s.dims[0],p=Ut.sizeFromDimension(t.dims,1)/d,h=l===0?s.dims[1]*2:p/o;if(l>h)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(i.dims.length===2){if(c!==i.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${i.dims[0]}`);if(d!==i.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${i.dims[1]}`)}if(h/2!==s.dims[1]&&l/2!==s.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${s.dims[1]}`);if(d>g)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},jb=(n,e)=>{let{interleaved:t,numHeads:i,rotaryEmbeddingDim:s,scale:r}=e,o=n[0].dims[0],l=Ut.sizeFromDimension(n[0].dims,1),c=n[0].dims[n[0].dims.length-2],d=l/c,g=n[2].dims[1],p=s===0?g*2:d/i,h=new Array(o,c,d/p,p-g),v=Ut.computeStrides(h),y=[{type:1,data:r},{type:12,data:h},{type:12,data:v},...n[0].dims.length===3?new Array({type:12,data:[l,d,p,1]}):[],...n[0].dims.length===4?new Array({type:12,data:[l,p,c*p,1]}):[],...Wn(n[0].dims,n[1].dims,n[2].dims,n[3].dims,n[0].dims)],w=S=>{let M=Wt("input",n[0].dataType,n[0].dims.length),T=Wt("position_ids",n[1].dataType,n[1].dims.length),C=Wt("cos_cache",n[2].dataType,n[2].dims.length),x=Wt("sin_cache",n[3].dataType,n[3].dims.length),R=zn("output",n[0].dataType,n[0].dims.length);return S.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:h.length},{name:"global_strides",type:"u32",length:v.length},{name:"input_output_strides",type:"u32",length:v.length}]),`
        ${S.declareVariables(M,T,C,x,R)}

        ${S.mainStart(p0)}
          let half_rotary_emb_dim = uniforms.${C.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${S.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${T.broadcastedIndicesToOffset("bsnh.xy",zn("",T.type.tensor,2))};
            let position_id =
                u32(${T.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${t});
            let j = i + select(half_rotary_emb_dim, 1, ${t});
            let re = ${M.getByOffset("i")} * ${C.get("position_id","bsnh[3]")} -
                ${M.getByOffset("j")} * ${x.get("position_id","bsnh[3]")};
            ${R.setByOffset("i","re")}
            let im = ${M.getByOffset("i")} * ${x.get("position_id","bsnh[3]")} +
                ${M.getByOffset("j")} * ${C.get("position_id","bsnh[3]")};
            ${R.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${R.setByOffset("k",M.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:Ts({interleaved:t}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:w,getRunData:()=>({outputs:[{dims:n[0].dims,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(Ut.size(h)/p0)},programUniforms:y})}},WF=(n,e)=>{uD(n.inputs,e),n.compute(jb(n.inputs,e))}}),cD,dD,Y1,fD,qF,ZW=fn(()=>{$r(),ai(),wS(),VF(),$F(),ym(),KF(),Mi(),cD=(n,e)=>{if(e.doRotary&&n.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let t=n[0],i=n[1],s=n[2],r=n[3],o=n[4];if(e.doRotary!==0&&n.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(e.localWindowSize!==-1)throw new Error("Local attention is not supported");if(e.softcap!==0)throw new Error("Softcap is not supported");if(e.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(e.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(t.dims.length!==3&&t.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let l=!1,c=t.dims[0],d=t.dims[1],g=t.dims.length===3?l?t.dims[2]/3:t.dims[2]:e.numHeads*t.dims[4],p=d,h=0,v=!i||i.dims.length===0,y=Math.floor(v?g/(e.numHeads+2*e.kvNumHeads):g/e.numHeads);v&&(g=y*e.numHeads);let w=r&&r.dims.length!==0,S=o&&o.dims.length!==0;if(w&&r.dims.length===4&&r.dims[0]===c&&r.dims[1]!==e.kvNumHeads&&r.dims[2]===e.kvNumHeads&&r.dims[3]===y)throw new Error("BSNH pastKey/pastValue is not supported");if(w&&S){if(r.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(o.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');h=r.dims[2]}else if(w||S)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let M=1;if(i&&i.dims.length>0){if(t.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(t.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(i.dims.length===3){if(t.dims[2]%i.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');p=i.dims[1]}else if(i.dims.length===5){if(i.dims[2]!==e.numHeads||i.dims[3]!==2||i.dims[4]!==y)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(s)throw new Error('Expect "value" be none when "key" has packed kv format.');p=i.dims[1]}else{if(i.dims[1]!==e.numHeads||i.dims[3]!==y)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');p=i.dims[2]}}else{if(t.dims.length!==3&&t.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(t.dims.length===5&&(t.dims[2]!==e.numHeads||t.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');M=3}let T=0,C=!1,x=e.kvNumHeads?y*e.kvNumHeads:g;if(s&&s.dims.length>0){if(s.dims.length!==3&&s.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(t.dims[0]!==s.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(s.dims.length===3){if(p!==s.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');x=s.dims[2]}else{if(p!==s.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');x=s.dims[1]*s.dims[3],C=!0}}let R=n.length>4?n[5]:void 0;if(R&&R.dims.length!==1&&R.dims[0]!==c)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:c,sequenceLength:d,pastSequenceLength:h,kvSequenceLength:p,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:g,vHiddenSize:x,headSize:y,vHeadSize:Math.floor(x/e.kvNumHeads),numHeads:e.numHeads,kvNumHeads:e.kvNumHeads,nReps:e.numHeads/e.kvNumHeads,pastPresentShareBuffer:!1,maskType:T,scale:e.scale,broadcastResPosBias:!1,passPastInKv:C,qkvFormat:M}},dD=Ts({perm:[0,2,1,3]}),Y1=(n,e,t)=>{let i=e,s=t.kvNumHeads;return e.dims.length===3&&t.kvSequenceLength!==0&&(i=e.reshape([t.batchSize,t.kvSequenceLength,s,t.headSize]),i=n.compute(Yu(i,dD.perm),{inputs:[i],outputs:[-1]})[0]),i},fD=(n,e,t,i)=>{let s=7,r=["type","type"],o=[n*e],l=n*e,c=[{type:12,data:l},{type:12,data:e},{type:12,data:n}],d=g=>{let p=Wt("seq_lens",t.dataType,t.dims),h=Wt("total_seq_lens",i.dataType,i.dims),v=zn("pos_ids",s,o),y=[{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}];return`
  ${g.registerUniforms(y).declareVariables(p,h,v)}
  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let total_sequence_length = u32(${h.getByOffset("0")});
    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;
    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;
    let batch_idx = global_idx / uniforms.sequence_length;
    let sequence_idx = i32(global_idx % uniforms.sequence_length);
    var pos_id: i32 = 0;
    let seqlen = ${p.getByOffset("batch_idx")};
    let total_seqlen = seqlen + 1;
    if (is_first_prompt) {
      if (sequence_idx < total_seqlen) {
        pos_id = sequence_idx;
      } else {
        pos_id = 1;
      }
      ${v.setByOffset("global_idx","pos_id")}
    } else if (is_subsequent_prompt) {
      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);
      if (past_seqlen + sequence_idx < total_seqlen) {
        pos_id = past_seqlen + sequence_idx;
      } else {
        pos_id = 1;
      }
      ${v.setByOffset("global_idx","pos_id")}
    } else if (global_idx < uniforms.batch_size) {
      ${v.setByOffset("global_idx","seqlen")}
    };
  }
  `};return{name:"GeneratePositionIds",shaderCache:{hint:`${n};${e}`,inputDependencies:r},getRunData:()=>({outputs:[{dims:o,dataType:s}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c}),getShaderSource:d}},qF=(n,e)=>{let t=cD(n.inputs,e);if(n.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(n.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let i=n.inputs[0],s=n.inputs[1]&&n.inputs[1].dims.length>0?n.inputs[1]:void 0,r=n.inputs[2]&&n.inputs[2].dims.length>0?n.inputs[2]:void 0,o=n.inputs[3]&&n.inputs[3].dims.length!==0?n.inputs[3]:void 0,l=n.inputs[4]&&n.inputs[4].dims.length!==0?n.inputs[4]:void 0,c=n.inputs.length>4?n.inputs[5]:void 0,d=n.inputs.length>5?n.inputs[6]:void 0,g=t.kvNumHeads?t.kvNumHeads:t.numHeads,p=Ts({axis:2,numOutputs:3,splitSizes:[t.numHeads*t.headSize,g*t.headSize,g*t.headSize]}),[h,v,y]=!s&&!r?n.compute(oT([i],p),{inputs:[i],outputs:[-1,-1,-1]}):[i,s,r],w,S;if(e.doRotary){let x=n.compute(fD(t.batchSize,t.sequenceLength,c,d),{inputs:[c,d],outputs:[-1]})[0],R=n.inputs[7],P=n.inputs[8],D=Ts({interleaved:e.rotaryInterleaved!==0,numHeads:t.numHeads,rotaryEmbeddingDim:0,scale:e.scale}),z=[h,x,R,P],U=[-1];w=n.compute(jb(z,D),{inputs:z,outputs:U})[0],z.splice(0,1,v);let N=Ts({interleaved:e.rotaryInterleaved!==0,numHeads:t.kvNumHeads,rotaryEmbeddingDim:0,scale:e.scale});S=n.compute(jb(z,N),{inputs:z,outputs:U})[0]}let M=gv(n,t.batchSize,t.numHeads,t.sequenceLength,t.headSize,e.doRotary?w:h,void 0,0),T=Y1(n,e.doRotary?S:v,t),C=Y1(n,y,t);jv(n,M,T,C,void 0,void 0,o,l,void 0,t,c,d)}}),J1,hD,pD,XF,eK=fn(()=>{ai(),vi(),ym(),Mi(),J1=(n,e,t,i,s,r,o,l)=>{let c=Lr(r),d=c===1?"f32":`vec${c}f`,g=c===1?"vec2f":`mat2x${c}f`,p=s*o,h=64;p===1&&(h=256);let v=[s,o,r/c],y=[s,o,2],w=["rank","type","type"],S=[];S.push(...Wn(v,y));let M=T=>{let C=Wt("x",e.dataType,3,c),x=Wt("scale",t.dataType,t.dims),R=Wt("bias",i.dataType,i.dims),P=zn("output",1,3,2),D=[C,x,R,P];return`
  var<workgroup> workgroup_shared : array<${g}, ${h}>;
  const workgroup_size = ${h}u;
  ${T.declareVariables(...D)}
  ${T.mainStart(h)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${d}(0);
    var squared_sum = ${d}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${d}(${C.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${g}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${pm("workgroup_shared[0][0]",c)} / f32(hight * ${c});
      let squared_sum_final = ${pm("workgroup_shared[0][1]",c)} / f32(hight * ${c});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${l}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return n.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${c};${l};${h}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:y,dataType:1}],dispatchGroup:{x:p},programUniforms:S}),getShaderSource:M},{inputs:[e,t,i],outputs:[-1]})[0]},hD=(n,e,t)=>{let i=e[0].dims,s=i,r=2,o=i[0],l=i[1],c=Ut.sizeFromDimension(i,r),d=Lr(c),g=Ut.size(s)/d,p=J1(n,e[0],e[1],e[2],o,c,l,t.epsilon),h=[o,l,c/d],v=[o,l],y=["type","none"],w=S=>{let M=Wt("x",e[0].dataType,h.length,d),T=Wt("scale_shift",1,v.length,2),C=zn("output",e[0].dataType,h.length,d),x=[M,T,C];return`
  ${S.registerUniform("output_size","u32").declareVariables(...x)}
  ${S.mainStart()}
  ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${C.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${T.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${M.getByOffset("global_idx")} * ${C.type.value}(scale_shift.x) + ${C.type.value}(scale_shift.y);
      ${C.setByOffset("global_idx","value")};
  }`};n.compute({name:"InstanceNormalization",shaderCache:{hint:`${d}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:[{type:12,data:g},...Wn(h,v,h)]}),getShaderSource:w},{inputs:[e[0],p]})},pD=(n,e,t)=>{let i=e[0].dims,s=i,r=i[0],o=i[i.length-1],l=Ut.sizeFromDimension(i,1)/o,c=Lr(o),d=Ut.size(s)/c,g=[{type:12,data:l},{type:12,data:Math.floor(o/c)}],p=["type","type"],h=!1,v=[0,i.length-1];for(let M=0;M<i.length-2;M++)h=h||i[M+1]!==1,v.push(M+1);h=h&&i[i.length-1]!==1;let y=h?n.compute(Yu(n.inputs[0],v),{inputs:[n.inputs[0]],outputs:[-1]})[0]:n.inputs[0].reshape(Array.from({length:i.length},(M,T)=>i[v[T]])),w=J1(n,y,e[1],e[2],r,l,o,t.epsilon),S=M=>{let T=Va(e[0].dataType),C=c===1?"vec2f":`mat${c}x2f`,x=D=>{let z=D===0?"x":"y",U=c===1?"f32":`vec${c}f`;switch(c){case 1:return`${T}(${U}(scale.${z}))`;case 2:return`vec2<${T}>(${U}(scale[0].${z}, scale[1].${z}))`;case 4:return`vec4<${T}>(${U}(scale[0].${z}, scale[1].${z}, scale[2].${z}, scale[3].${z}))`;default:throw new Error(`Not supported compoents ${c}`)}},R=Wt("input",e[0].dataType,e[0].dims,c),P=zn("output",e[0].dataType,s,c);return`
  @group(0) @binding(0) var<storage, read> input : array<${R.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${C}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${P.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${M.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${x(0)}, ${x(1)});
  }`};n.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${c}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:g}),getShaderSource:S},{inputs:[e[0],w]})},XF=(n,e)=>{e.format==="NHWC"?pD(n,n.inputs,e):hD(n,n.inputs,e)}}),mD,gD,YF,tK=fn(()=>{ai(),vi(),Mi(),mD=n=>{if(!n||n.length<2)throw new Error("layerNorm requires at least 2 inputs.")},gD=(n,e,t)=>{let i=e.simplified,s=n[0].dims,r=n[1],o=!i&&n[2],l=s,c=Ut.normalizeAxis(e.axis,s.length),d=Ut.sizeToDimension(s,c),g=Ut.sizeFromDimension(s,c),p=Ut.size(r.dims),h=o?Ut.size(o.dims):0;if(p!==g||o&&h!==g)throw new Error(`Size of X.shape()[axis:] == ${g}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${p} and bias size of ${h}`);let v=[];for(let R=0;R<s.length;++R)R<c?v.push(s[R]):v.push(1);let y=Lr(g),w=["type","type"],S=[{type:12,data:d},{type:1,data:g},{type:12,data:Math.floor(g/y)},{type:1,data:e.epsilon}];o&&w.push("type");let M=t>1,T=t>2,C=R=>{let P=Va(n[0].dataType),D=[Wt("x",n[0].dataType,n[0].dims,y),Wt("scale",r.dataType,r.dims,y)];o&&D.push(Wt("bias",o.dataType,o.dims,y)),D.push(zn("output",n[0].dataType,l,y)),M&&D.push(zn("mean_data_output",1,v)),T&&D.push(zn("inv_std_output",1,v));let z=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${R.registerUniforms(z).declareVariables(...D)}
  ${R.mainStart()}
    ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${QE("f32",y)};
    var mean_square_vector = ${QE("f32",y)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${Y_(P,y,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${pm("mean_vector",y)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${pm("mean_square_vector",y)} / uniforms.norm_size ${i?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${Y_(P,y,"x[j + offset]")};
      let f32scale = ${Y_(P,y,"scale[j]")};
      output[j + offset] = ${D[0].type.value}((f32input ${i?"":"- mean"}) * inv_std_dev * f32scale
        ${o?`+ ${Y_(P,y,"bias[j]")}`:""}
      );
    }

    ${M?"mean_data_output[global_idx] = mean":""};
    ${T?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},x=[{dims:l,dataType:n[0].dataType}];return M&&x.push({dims:v,dataType:1}),T&&x.push({dims:v,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${y};${t};${i}`,inputDependencies:w},getRunData:()=>({outputs:x,dispatchGroup:{x:Math.ceil(d/64)},programUniforms:S}),getShaderSource:C}},YF=(n,e)=>{mD(n.inputs),n.compute(gD(n.inputs,e,n.outputCount))}}),_D,JF,nK=fn(()=>{vi(),CS(),PS(),_D=n=>{if(!n||n.length!==2)throw new Error("MatMul requires 2 inputs.");if(n[0].dims[n[0].dims.length-1]!==n[1].dims[n[1].dims.length-2])throw new Error("shared dimension does not match.")},JF=n=>{_D(n.inputs);let e=h0.calcShape(n.inputs[0].dims,n.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");let t=e[e.length-1],i=n.inputs[0].dims[n.inputs[0].dims.length-1];if(t<8&&i<8)n.compute(AS(n.inputs,{activation:""},e));else{let s=e[e.length-2],r=Ut.size(n.inputs[0].dims.slice(0,-2)),o=Ut.size(n.inputs[1].dims.slice(0,-2));if(r!==1&&s===1&&o===1){let l=n.inputs[0].reshape([1,r,i]),c=n.inputs[1].reshape([1,i,t]),d=[1,r,t],g=[l,c];n.compute(Hb(g,{activation:""},e,d),{inputs:g})}else n.compute(Hb(n.inputs,{activation:""},e))}}}),vD,yD,MD,QF,ZF,iK=fn(()=>{ai(),vi(),$r(),Mi(),vD=(n,e)=>{if(n.length<3||n.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let t=n[0],i=t.dims.length;if(t.dims[i-1]!==e.k)throw new Error("The last dim of input shape does not match the k value");let s=Math.floor((e.k+e.blockSize-1)/e.blockSize),r=e.blockSize/8*e.bits,o=n[1];if(!Ut.areEqual(o.dims,[e.n,s,r]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let l=n[2].dims;if(Ut.size(l)!==e.n*s)throw new Error("scales input size error.");if(n.length===4){let c=n[3].dims,d=e.bits>4?e.n*s:e.n*Math.floor((s+1)/2);if(Ut.size(c)!==d)throw new Error("zeroPoints input size error.")}},yD=(n,e)=>{let t=n[0].dims,i=t.length,s=t[i-2],r=e.k,o=e.n,l=t.slice(0,i-2),c=Ut.size(l),d=n[1].dims[2]/4,g=n[0].dataType,p=Lr(e.k),h=Lr(d),v=Lr(o),y=l.concat([s,o]),w=s>1&&o/v%2===0?2:1,S=Ut.size(y)/v/w,M=64,T=[],C=[c,s,r/p],x=Ut.convertShape(n[1].dims).slice();x.splice(-1,1,d/h),T.push(...Wn(C)),T.push(...Wn(x)),T.push(...Wn(n[2].dims)),n.length===4&&T.push(...Wn(Ut.convertShape(n[3].dims)));let R=[c,s,o/v];T.push(...Wn(R));let P=D=>{let z=C.length,U=Wt("a",n[0].dataType,z,p),N=Wt("b",12,x.length,h),j=Wt("scales",n[2].dataType,n[2].dims.length),J=[U,N,j],W=n.length===4?Wt("zero_points",12,n[3].dims.length):void 0;W&&J.push(W);let oe=R.length,ne=zn("output",n[0].dataType,oe,v),q=Va(n[0].dataType),le=(()=>{switch(p){case 1:return`array<${q}, 8>`;case 2:return`mat4x2<${q}>`;case 4:return`mat2x4<${q}>`;default:throw new Error(`${p}-component is not supported.`)}})(),se=()=>{let ee=`
          // reuse a data
            var input_offset = ${U.indicesToOffset(`${U.type.indices}(batch, row, word_offset)`)};
            var a_data: ${le};
            for (var j: u32 = 0; j < ${8/p}; j++) {
              a_data[j] = ${U.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let te=0;te<v*w;te++)ee+=`
            b_value = ${h===1?`b${te}_data`:`b${te}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${le}(${Array.from({length:4},(ue,ae)=>`${q}(b_value_lower[${ae}]), ${q}(b_value_upper[${ae}])`).join(", ")});
            b_dequantized_values = ${p===1?`${le}(${Array.from({length:8},(ue,ae)=>`(b_quantized_values[${ae}] - ${W?`zero_point${te}`:"zero_point"}) * scale${te}`).join(", ")});`:`(b_quantized_values - ${le}(${Array(8).fill(`${W?`zero_point${te}`:"zero_point"}`).join(",")})) * scale${te};`};
            workgroup_shared[local_id.x * ${w} + ${Math.floor(te/v)}]${v>1?`[${te%v}]`:""} += ${Array.from({length:8/p},(ue,ae)=>`${p===1?`a_data[${ae}] * b_dequantized_values[${ae}]`:`dot(a_data[${ae}], b_dequantized_values[${ae}])`}`).join(" + ")};
          `;return ee},pe=()=>{let ee=`
            var col_index = col * ${v};
            ${W?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${q}(8);`}
            `;for(let te=0;te<v*w;te++)ee+=`
            let scale${te} = ${j.getByOffset("col_index * nBlocksPerCol + block")};
            ${W?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${W.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${te} = ${q}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return ee},be=()=>{let ee=`col_index = col * ${v};`;for(let te=0;te<v*w;te++)ee+=`
            let b${te}_data = ${N.getByIndices(`${N.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return ee+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${le};
            var b_dequantized_values: ${le};`,ee};return`
        var<workgroup> workgroup_shared: array<${ne.type.value}, ${w*M}>;
        ${D.declareVariables(...J,ne)}
        ${D.mainStart([M,1,1])}
          let output_indices = ${ne.offsetToIndices(`(global_idx / ${M}) * ${w}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${M}) {
            //process one block
            var word_offset: u32 = block * ${e.blockSize/p};
            ${pe()}
            for (var word: u32 = 0; word < ${d}; word += ${h}) {
              ${be()}
              for (var i: u32 = 0; i < ${h}; i++) {
                ${se()}
                word_offset += ${8/p};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${w}) {
            var output_value: ${ne.type.value} = ${ne.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${M}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${w};
            }
            ${ne.setByIndices(`${ne.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${e.blockSize};${e.bits};${p};${h};${v};${w};${M}`,inputDependencies:Array(n.length).fill("rank")},getRunData:()=>({outputs:[{dims:y,dataType:g}],dispatchGroup:{x:S},programUniforms:T}),getShaderSource:P}},MD=(n,e)=>{let t=n[0].dims,i=t.length,s=t[i-2],r=e.k,o=e.n,l=t.slice(0,i-2),c=Ut.size(l),d=n[1].dims[2]/4,g=n[0].dataType,p=Lr(e.k),h=Lr(d),v=l.concat([s,o]),y=128,w=o%8===0?8:o%4===0?4:1,S=y/w,M=S*h*8,T=M/p,C=M/e.blockSize,x=Ut.size(v)/w,R=[],P=[c,s,r/p],D=Ut.convertShape(n[1].dims).slice();D.splice(-1,1,d/h),R.push(...Wn(P)),R.push(...Wn(D)),R.push(...Wn(n[2].dims)),n.length===4&&R.push(...Wn(Ut.convertShape(n[3].dims)));let z=[c,s,o];R.push(...Wn(z));let U=N=>{let j=P.length,J=Wt("a",n[0].dataType,j,p),W=Wt("b",12,D.length,h),oe=Wt("scales",n[2].dataType,n[2].dims.length),ne=[J,W,oe],q=n.length===4?Wt("zero_points",12,n[3].dims.length):void 0;q&&ne.push(q);let le=z.length,se=zn("output",n[0].dataType,le),pe=Va(n[0].dataType),be=()=>{switch(p){case 1:return`
          let a_data0 = vec4<${pe}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${pe}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${pe}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${pe}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${p}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${J.type.value}, ${T}>;
        var<workgroup> inter_results: array<array<${se.type.value}, ${S}>, ${w}>;
        ${N.declareVariables(...ne,se)}
        ${N.mainStart([S,w,1])}
          let output_indices = ${se.offsetToIndices(`workgroup_index * ${w}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${C} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${T};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${T}; a_offset += ${y})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${J.getByIndices(`${J.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${J.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${C} + local_id.x;
            ${q?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${q.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${pe}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${pe}(8);`}
            let scale = ${oe.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${W.getByIndices(`${W.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${e.blockSize/p};
            for (var i: u32 = 0; i < ${h}; i++) {
              ${be()}
              let b_value = ${h===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${pe}>(${Array.from({length:4},(ee,te)=>`${pe}(b_value_lower[${te}]), ${pe}(b_value_upper[${te}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${pe}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(ee,te)=>`${`dot(a_data${te}, b_dequantized_values[${te}])`}`).join(" + ")};
              word_offset += ${8/p};
            }
            workgroupBarrier();
          }

          if (local_idx < ${w}) {
            var output_value: ${se.type.value} = ${se.type.value}(0);
            for (var b = 0u; b < ${S}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${se.setByIndices(`${se.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${e.blockSize};${p};${h};${S};${w}`,inputDependencies:Array(n.length).fill("rank")},getRunData:()=>({outputs:[{dims:v,dataType:g}],dispatchGroup:{x},programUniforms:R}),getShaderSource:U}},QF=(n,e)=>{vD(n.inputs,e),e.blockSize===32&&n.adapterInfo.isVendor("intel")&&n.adapterInfo.isArchitecture("gen-12lp")?n.compute(MD(n.inputs,e)):n.compute(yD(n.inputs,e))},ZF=n=>Ts(n)}),bD,xD,wD,ED,TD,SD,AD,CD,eN,sK=fn(()=>{ai(),vi(),Mi(),bD=n=>{if(!n||n.length<1)throw new Error("Too few inputs");if(n[0].dataType!==1&&n[0].dataType!==10)throw new Error("Input type must be float or float16.");if(n.length>=2){let e=n[0].dims.length*2===n[1].dims[0];if(n.length===4&&(e=n[3].dims[0]*2===n[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},xD=(n,e,t)=>{let i="";for(let s=e-1;s>=0;--s)i+=`
            k = i32(${n.indicesGet("indices",s)}) - ${Vn("uniforms.pads",s,t)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${Vn("uniforms.x_shape",s,e)})) {
              break;
            }
            offset += k * i32(${Vn("uniforms.x_strides",s,e)});
        `;return`
          value = ${n.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${i}
            value = x[offset];
          }
      `},wD=(n,e,t)=>{let i="";for(let s=e-1;s>=0;--s)i+=`
                k = i32(${n.indicesGet("indices",s)}) - ${Vn("uniforms.pads",s,t)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${Vn("uniforms.x_shape",s,e)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${Vn("uniforms.x_shape",s,e)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${Vn("uniforms.x_strides",s,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},ED=(n,e,t)=>{let i="";for(let s=e-1;s>=0;--s)i+=`
                k = i32(${n.indicesGet("indices",s)}) - ${Vn("uniforms.pads",s,t)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${Vn("uniforms.x_shape",s,e)})) {
                  k = i32(${Vn("uniforms.x_shape",s,e)}) - 1;
                }
                offset += k * i32(${Vn("uniforms.x_strides",s,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},TD=(n,e,t)=>{let i="";for(let s=e-1;s>=0;--s)i+=`
                k = i32(${n.indicesGet("indices",s)}) - ${Vn("uniforms.pads",s,t)};
                if (k < 0)  {
                  k += i32(${Vn("uniforms.x_shape",s,e)}]);
                }
                if (k >= i32(${Vn("uniforms.x_shape",s,e)})) {
                  k -= i32(${Vn("uniforms.x_shape",s,e)});
                }
                offset += k * i32(${Vn("uniforms.x_strides",s,e)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},SD=(n,e,t)=>{switch(t.mode){case 0:return xD(n,e,t.pads.length);case 1:return wD(n,e,t.pads.length);case 2:return ED(n,e,t.pads.length);case 3:return TD(n,e,t.pads.length);default:throw new Error("Invalid mode")}},AD=(n,e)=>{let t=Ut.padShape(n[0].dims.slice(),e.pads),i=n[0].dims,s=Ut.size(t),r=[{type:12,data:s},{type:6,data:e.pads}],o=n.length>=3&&n[2].data;e.mode===0&&r.push({type:o?n[2].dataType:1,data:e.value}),r.push(...Wn(n[0].dims,t));let l=["rank"],c=d=>{let g=zn("output",n[0].dataType,t.length),p=Wt("x",n[0].dataType,i.length),h=p.type.value,v=SD(g,i.length,e),y=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:e.pads.length}];return e.mode===0&&y.push({name:"constant_value",type:o?h:"f32"}),`
            ${d.registerUniforms(y).declareVariables(p,g)}
            ${d.mainStart()}
            ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${g.offsetToIndices("global_idx")};

            var value = ${h}(0);
            ${v}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${e.mode}${o}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:t,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(Ut.size(t)/64)},programUniforms:r}),getShaderSource:c}},CD=(n,e)=>{if(n.length>1){let t=n[1].getBigInt64Array(),i=n.length>=3&&n[2].data?n[2].dataType===10?n[2].getUint16Array()[0]:n[2].getFloat32Array()[0]:0,s=n[0].dims.length,r=new Int32Array(2*s).fill(0);if(n.length>=4){let l=n[3].getBigInt64Array();for(let c=0;c<l.length;c++)r[Number(l[c])]=Number(t[c]),r[Number(l[c])+s]=Number(t[c+l.length])}else t.forEach((l,c)=>r[Number(c)]=Number(l));let o=[];return r.forEach(l=>o.push(l)),{mode:e.mode,value:i,pads:o}}else return e},eN=(n,e)=>{bD(n.inputs);let t=CD(n.inputs,e);n.compute(AD(n.inputs,t),{inputs:[0]})}}),rv,Q1,Z1,eE,tE,PD,RD,nE,iE,tN,nN,sE,iN,sN,rE,rN,aN,oN,lN,rK=fn(()=>{Gd(),ai(),vi(),Mi(),rv=n=>{if(ur.webgpu.validateInputContent&&(!n||n.length!==1))throw new Error("Pool ops requires 1 input.")},Q1=(n,e,t)=>{let i=e.format==="NHWC",s=n.dims.slice();i&&s.splice(1,0,s.pop());let r=Object.hasOwnProperty.call(e,"dilations"),o=e.kernelShape.slice(),l=e.strides.slice(),c=r?e.dilations.slice():[],d=e.pads.slice();Gb.adjustPoolAttributes(t,s,o,l,c,d);let g=Gb.computePoolOutputShape(t,s,l,c,o,d,e.autoPad),p=Object.assign({},e);r?Object.assign(p,{kernelShape:o,strides:l,pads:d,dilations:c,cacheKey:e.cacheKey}):Object.assign(p,{kernelShape:o,strides:l,pads:d,cacheKey:e.cacheKey});let h=g.slice();return h.push(h.splice(1,1)[0]),[p,i?h:g]},Z1=(n,e)=>{let t=e.format==="NHWC",i=Ut.size(n),s=Ut.size(e.kernelShape),r=[{type:12,data:i},{type:12,data:s}],o=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(e.kernelShape.length<=2){let l=e.kernelShape[e.kernelShape.length-1],c=e.strides[e.strides.length-1],d=e.pads[e.pads.length/2-1],g=e.pads[e.pads.length-1],p=!!(d+g);r.push({type:12,data:l},{type:12,data:c},{type:12,data:d},{type:12,data:g}),o.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let h=!1;if(e.kernelShape.length===2){let v=e.kernelShape[e.kernelShape.length-2],y=e.strides[e.strides.length-2],w=e.pads[e.pads.length/2-2],S=e.pads[e.pads.length-2];h=!!(w+S),r.push({type:12,data:v},{type:12,data:y},{type:12,data:w},{type:12,data:S}),o.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[r,o,!0,p,h]}else{if(t)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let l=Ut.computeStrides(e.kernelShape);r.push({type:12,data:l},{type:12,data:e.pads},{type:12,data:e.strides}),o.push({name:"kernelStrides",type:"u32",length:l.length},{name:"pads",type:"u32",length:e.pads.length},{name:"strides",type:"u32",length:e.strides.length});let c=e.pads.reduce((d,g)=>d+g);return[r,o,!!c,!1,!1]}},eE=(n,e,t,i,s,r,o,l,c,d,g,p)=>{let h=s.format==="NHWC",v=e.type.value,y=zn("output",e.type.tensor,i);if(s.kernelShape.length<=2){let w="",S="",M="",T=t-(h?2:1);if(g?w=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${T}] < 0 || xIndices[${T}]
                      >= uniforms.x_shape[${T}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${r}
                }`:w=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${T}] = indices[${T}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${r}
                }`,s.kernelShape.length===2){let C=t-(h?3:2);p?S=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${C}] = indices[${C}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${C}] < 0 || xIndices[${C}] >= uniforms.x_shape[${C}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:S=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${C}] = indices[${C}] * uniforms.sh - uniforms.phStart + j;
                `,M=`
              }
            `}return`
            ${n.registerUniforms(c).declareVariables(e,y)}

            ${n.mainStart()}
              ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${y.offsetToIndices("global_idx")};
              var xIndices = ${y.offsetToIndices("global_idx")};

              var value = ${v}(${l});
              var pad = 0;
              ${S}
              ${w}
              ${M}
              ${o}

              output[global_idx] = value;
            }`}else{if(h)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let w=s.kernelShape.length,S=s.pads.length,M="";return d?M=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${r}
              }`:M=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${r}
            `,`
            ${n.registerUniforms(c).declareVariables(e,y)}

            ${n.mainStart()}
              ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${y.offsetToIndices("global_idx")};
              var xIndices = ${y.offsetToIndices("global_idx")};

              var offsets: array<u32, ${w}>;

              var value = ${v}(${l});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${w-1}u; j++) {
                  offsets[j] = offset / ${Vn("uniforms.kernelStrides","j",w)};
                  offset -= offsets[j] * ${Vn("uniforms.kernelStrides","j",w)};
                }
                offsets[${w-1}] = offset;

                isPad = false;
                for (var j = ${t-w}u; j < ${t}u; j++) {
                  xIndices[j] = indices[j] * ${Vn("uniforms.strides",`j - ${t-w}u`,w)}
                    + offsets[j - ${t-w}u] - ${Vn("uniforms.pads","j - 2u",S)};
                  ${M}
              }
              ${o}

              output[global_idx] = value;
            }`}},tE=n=>`${n.format};${n.ceilMode};${n.autoPad};${n.kernelShape.length}`,PD=n=>`${tE(n)};${n.countIncludePad}`,RD=n=>`${tE(n)};${n.storageOrder};${n.dilations}`,nE=n=>({format:n.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][n.auto_pad],ceilMode:n.ceil_mode,kernelShape:n.kernel_shape,strides:n.strides,pads:n.pads}),iE=(n,e,t,i)=>{let[s,r]=Q1(e,i,t),o=Wt("x",e.dataType,e.dims.length),l=o.type.value,c="value += x_val;",d="";s.countIncludePad?d+=`value /= ${l}(uniforms.kernelSize);`:d+=`value /= ${l}(i32(uniforms.kernelSize) - pad);`;let[g,p,h,v,y]=Z1(r,s);g.push(...Wn(e.dims,r));let w=["rank"];return{name:n,shaderCache:{hint:`${i.cacheKey};${h};${v};${y}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(Ut.size(r)/64)},programUniforms:g}),getShaderSource:S=>eE(S,o,e.dims.length,r.length,s,c,d,0,p,h,v,y)}},tN=n=>{let e=n.count_include_pad!==0,t=nE(n);if(t.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let i={countIncludePad:e,...t,cacheKey:""};return{...i,cacheKey:PD(i)}},nN=(n,e)=>{rv(n.inputs),n.compute(iE("AveragePool",n.inputs[0],!1,e))},sE={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},iN=n=>{let e=n.format;return{format:e,...sE,cacheKey:e}},sN=(n,e)=>{rv(n.inputs),n.compute(iE("GlobalAveragePool",n.inputs[0],!0,e))},rE=(n,e,t,i)=>{let[s,r]=Q1(e,i,t),o=`
      value = max(x_val, value);
    `,l="",c=Wt("x",e.dataType,e.dims.length),d=["rank"],[g,p,h,v,y]=Z1(r,s);return g.push(...Wn(e.dims,r)),{name:n,shaderCache:{hint:`${i.cacheKey};${h};${v};${y}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(Ut.size(r)/64)},programUniforms:g}),getShaderSource:w=>eE(w,c,e.dims.length,r.length,s,o,l,e.dataType===10?-65504:-1e5,p,h,v,y)}},rN=(n,e)=>{rv(n.inputs),n.compute(rE("MaxPool",n.inputs[0],!1,e))},aN=n=>{let e=n.storage_order,t=n.dilations,i=nE(n);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(i.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let s={storageOrder:e,dilations:t,...i,cacheKey:""};return{...s,cacheKey:RD(s)}},oN=n=>{let e=n.format;return{format:e,...sE,cacheKey:e}},lN=(n,e)=>{rv(n.inputs),n.compute(rE("GlobalMaxPool",n.inputs[0],!0,e))}}),DD,BD,uN,cN,aK=fn(()=>{ai(),vi(),$r(),Mi(),DD=(n,e)=>{if(n.length<2||n.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(n.length===3&&n[1].dims===n[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(n.length===3&&n[0].dataType!==n[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(n[0].dataType===6&&n.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(n[1].dims.length!==0&&n[1].dims.length!==1&&n[1].dims.length!==n[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(n.length>2){if(n[0].dataType!==n[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(n[1].dims.length!==n[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!n[1].dims.map((t,i)=>t===n[2].dims[i]).reduce((t,i)=>t&&i,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(e.blockSize>0){if(n[1].dims.length===0||n[1].dims.length===1&&n[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!n[1].dims.map((s,r)=>r===e.axis||s===n[0].dims[r]).reduce((s,r)=>s&&r,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(n[1].dims.length!==n[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let t=n[0].dims[e.axis],i=n[1].dims[e.axis];if(e.blockSize<Math.ceil(t/i)||e.blockSize>Math.ceil(t/(i-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},BD=(n,e)=>{let t=Ut.normalizeAxis(e.axis,n[0].dims.length),i=n[0].dataType,s=i===3,r=n[0].dims,o=n[1].dataType,l=Ut.size(r),c=i===3||i===2,d=c?[Math.ceil(Ut.size(n[0].dims)/4)]:n[0].dims,g=n[1].dims,p=n.length>2?n[2]:void 0,h=p?c?[Math.ceil(Ut.size(p.dims)/4)]:p.dims:void 0,v=g.length===0||g.length===1&&g[0]===1,y=v===!1&&g.length===1,w=Lr(l),S=v&&(!c||w===4),M=S?w:1,T=S&&!c?w:1,C=Wt("input",c?12:i,d.length,T),x=Wt("scale",o,g.length),R=p?Wt("zero_point",c?12:i,h.length):void 0,P=zn("output",o,r.length,M),D=[C,x];R&&D.push(R);let z=[d,g];p&&z.push(h);let U=[{type:12,data:l/M},{type:12,data:t},{type:12,data:e.blockSize},...Wn(...z,r)],N=j=>{let J=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${j.registerUniforms(J).declareVariables(...D,P)}
      ${j.mainStart()}
          ${j.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${P.offsetToIndices("global_idx")};

          // Set input x
          ${c?`
            let input = ${C.getByOffset("global_idx / 4")};
            let x_vec = ${s?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${M===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${C.getByOffset("global_idx")};`};

          // Set scale input
          ${v?`let scale_value= ${x.getByOffset("0")}`:y?`
            let scale_index = ${P.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${x.getByOffset("scale_index")};`:`
            var scale_indices: ${x.type.indices} = output_indices;
            let index = ${x.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${x.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${x.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${R?v?c?`
                let zero_point_input = ${R.getByOffset("0")};
                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${R.getByOffset("0")}`:y?c?`
                let zero_point_index = ${P.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${R.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${P.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${R.getByOffset("zero_point_index")};`:c?`
                let zero_point_offset = ${x.indicesToOffset("scale_indices")};
                let zero_point_input = ${R.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${R.getByIndices("scale_indices")};`:`let zero_point_value = ${c?s?"i32":"u32":C.type.value}(0);`};
      // Compute and write output
      ${P.setByOffset("global_idx",`${P.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:e.cacheKey,inputDependencies:R?["rank","rank","rank"]:["rank","rank"]},getShaderSource:N,getRunData:()=>({outputs:[{dims:r,dataType:o}],dispatchGroup:{x:Math.ceil(l/M/64),y:1,z:1},programUniforms:U})}},uN=(n,e)=>{DD(n.inputs,e),n.compute(BD(n.inputs,e))},cN=n=>Ts({axis:n.axis,blockSize:n.blockSize})}),ID,OD,dN,oK=fn(()=>{Gd(),ai(),Mi(),ID=(n,e,t)=>{let i=n===e,s=n<e&&t<0,r=n>e&&t>0;if(i||s||r)throw new Error("Range these inputs' contents are invalid.")},OD=(n,e,t,i)=>{let s=Math.abs(Math.ceil((e-n)/t)),r=[s],o=s,l=[{type:12,data:o},{type:i,data:n},{type:i,data:t},...Wn(r)],c=d=>{let g=zn("output",i,r.length),p=g.type.value,h=[{name:"outputSize",type:"u32"},{name:"start",type:p},{name:"delta",type:p}];return`
        ${d.registerUniforms(h).declareVariables(g)}
        ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${p}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${i}`},getShaderSource:c,getRunData:()=>({outputs:[{dims:r,dataType:i}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:l})}},dN=n=>{let e=0,t=0,i=0;n.inputs[0].dataType===6?(e=n.inputs[0].getInt32Array()[0],t=n.inputs[1].getInt32Array()[0],i=n.inputs[2].getInt32Array()[0]):n.inputs[0].dataType===1&&(e=n.inputs[0].getFloat32Array()[0],t=n.inputs[1].getFloat32Array()[0],i=n.inputs[2].getFloat32Array()[0]),ur.webgpu.validateInputContent&&ID(e,t,i),n.compute(OD(e,t,i,n.inputs[0].dataType),{inputs:[]})}}),LD,aE,oE,FD,fN,hN,lK=fn(()=>{ai(),vi(),$r(),Mi(),LD=(n,e,t,i)=>{if(n!=="none"&&i!=="i32"&&i!=="u32"&&i!=="f32")throw new Error(`Input ${i} is not supported with reduction ${n}.`);let s=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,r=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${e}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(n){case"none":return`${e}=${t};`;case"add":return i==="i32"||i==="u32"?`atomicAdd(&${e}, bitcast<${i}>(${t}));`:`
              ${s}bitcast<${i}>(oldValue) + (${t})${r}`;case"max":return i==="i32"||i==="u32"?`atomicMax(&${e}, bitcast<${i}>(${t}));`:`
                ${s}max(bitcast<f32>(oldValue), (${t}))${r}`;case"min":return i==="i32"||i==="u32"?`atomicMin(&${e}, bitcast<${i}>(${t}));`:`${s}min(bitcast<${i}>(oldValue), (${t}))${r}`;case"mul":return`${s}(bitcast<${i}>(oldValue) * (${t}))${r}`;default:throw new Error(`Reduction ${n} is not supported.`)}},aE=(n,e)=>`${n===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[${e?"i - indices_start":"i"}];
    let dim_value = uniforms.output_shape[${e?"i - indices_start":"i"} + uniforms.last_index_dimension];`}
    
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));`,oE=(n,e,t)=>`for (var i = 0u; i < uniforms.num_updates_elements; i++) {
        let value = updates[uniforms.num_updates_elements * ${t?"global_idx":"idx"} + i];
        ${LD(n.reduction,"output[data_offset + i]","value",e)}
      }`,FD=(n,e)=>{let t=n[0].dims,i=n[1].dims,s=t,r=1,o=Math.ceil(Ut.size(i)/r),l=i[i.length-1],c=Ut.sizeFromDimension(t,l),d=Ut.sizeFromDimension(i,0)/l,g=[{type:12,data:o},{type:12,data:l},{type:12,data:c},...Wn(n[1].dims,n[2].dims,s)],p=h=>{let v=Wt("indices",n[1].dataType,n[1].dims.length),y=Wt("updates",n[2].dataType,n[2].dims.length,r),w=e.reduction!=="none"&&e.reduction!==""?G3("output",n[0].dataType,s.length):zn("output",n[0].dataType,s.length,r);return`
      ${h.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(v,y,w)}
      ${h.mainStart()}
        ${h.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var hasDuplicates = false;
  if (${e.reduction==="none"}) {
    for (var i = 0; i < ${d}; i = i + 1) {
      for (var j = i + 1; j < ${d}; j = j + 1) {
        var index_i = i32(indices[i].x);
        var index_j = i32(indices[j].x);
        if (index_i == index_j) {
          hasDuplicates = true;
          break;
        }
      }
      if (hasDuplicates) {
        break;
      }
    }
  }

  if (${e.reduction==="none"} && hasDuplicates) {
    if (global_idx != 0u) {
      return;
    }
    // Process each index-update pair individually when duplicates exist
    for (var idx = 0u; idx < ${d}u; idx++) {
      var data_offset = 0u;
      for (var i = 0u; i < uniforms.last_index_dimension; i++) {
        var index = i32(indices[idx * uniforms.last_index_dimension + i].x);
        ${aE(t.length,!1)}
      }
      ${oE(e,w.type.value,!1)}
    }
    return;
  }

  var data_offset = 0u;
  var indices_start = uniforms.last_index_dimension * global_idx;
  var indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${aE(t.length,!0)}
  }
  ${oE(e,w.type.value,!0)}
  }`};return{name:"ScatterND",shaderCache:{hint:`${e.cacheKey}_${e.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:s,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:g}),getShaderSource:p}},fN=n=>Ts({reduction:n.reduction}),hN=(n,e)=>{n.compute(FD(n.inputs,e),{inputs:[n.inputs[1],n.inputs[2]],outputs:[]})}}),ND,zD,UD,lE,kD,GD,VD,HD,jD,$D,WD,KD,uE,qD,XD,YD,JD,QD,pN,mN,uK=fn(()=>{ai(),vi(),$r(),Mi(),ND=(n,e)=>{if(n.every(t=>t>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),n.length>0){if(e.mode==="linear"){if(!(n.length===2||n.length===3||n.length===4&&n[0]===1&&n[1]===1||n.length===4&&n[0]===1&&n[3]===1||n.length===5&&n[0]===1&&n[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(e.mode==="cubic"&&!(n.length===2||n.length===4&&n[0]===1&&n[1]===1||n.length===4&&n[0]===1&&n[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},zD=(n,e,t)=>{e.every(s=>s>=0&&s<t||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let i=new Array(t).fill(1);return e.forEach((s,r)=>i[s]=n[r]),i},UD=(n,e,t,i,s,r)=>{let[o,l,c]=t>10?[1,2,3]:[-1,n.length>1?1:-1,-1],d=n[0].dims.length;if(o>0&&n.length>o&&n[o].dims.length>0)n[o].getFloat32Array().forEach(g=>r.push(g));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(l>0&&n.length>l&&n[l].dims.length===1&&n[l].dims[0]>0){if(n[l].getFloat32Array().forEach(g=>i.push(g)),i.length!==0&&i.length!==d&&t>=18&&i.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");ND(i,e),e.axes.length>0&&zD(i,e.axes,d).forEach((g,p)=>i[p]=g)}if(c>0&&n.length>c&&n[c].dims.length===1&&n[c].dims[0]>0&&(n[c].getBigInt64Array().forEach(g=>s.push(Number(g))),s.length!==0&&s.length!==d&&t>=18&&s.length!==e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(i.length!==0&&i.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(s.length!==0&&s.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof i<"u"&&typeof s<"u"&&i.length>0&&s.length>d)throw new Error("Resize requires only of scales or sizes to be specified")},lE=(n,e,t,i)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${n}) * (${e});
  let whole = ${i}(big / (${t}));
  let fract = ${i}(big % (${t})) / ${i}(${t});
  return whole + fract;
`,kD=(n,e)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${e} { `+(()=>{switch(n){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${e}(xResized) / ${e}(xScale);
          } else {
            ${lE("xResized","lengthOriginal","lengthResized",e)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${e}(xResized) + 0.5) / ${e}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${e}(xResized) + 0.5) / ${e}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${lE("xResized","lengthOriginal - 1","lengthResized - 1",e)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${e}(roiStart) * ${e}(lengthOriginal - 1) +
                        (${e}(xResized) * ${e}(roiEnd - roiStart) * ${e}(lengthOriginal - 1)) /
                        ${e}(lengthResized - 1);
                  } else {
                    return 0.5 * ${e}(roiStart + roiEnd) * ${e}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${e}xScale * ${e}(lengthResized);
                  const adjustment = ${e}(lengthResized) / outputWidth;
                  const center = ${e}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;case"half_pixel":return`return ((${e}(xResized) + 0.5) / ${e}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${n} is not supported`)}})()+"}",GD=(n,e,t)=>`fn getNearestPixelFromOriginal(xOriginal: ${t}, isDownSample: bool) -> ${t} {`+(()=>{switch(n){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${n} is not supported`)}})()+"}",VD=(n,e,t)=>{let i=new Array(t).fill(0).concat(new Array(t).fill(1)),s=n.length===0?i:n.slice();return e.length>0?(e.forEach((r,o)=>{i[r]=s[o],i[o+t]=s[e.length+o]}),i):s},HD=(n,e,t,i)=>{let s=[];if(t.length>0)if(i.length>0){if(n.forEach(r=>s.push(r)),Math.max(...i)>n.length)throw new Error("axes is out of bound");i.forEach((r,o)=>s[r]=t[o])}else t.forEach(r=>s.push(r));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");s=n.map((r,o)=>Math.round(r*e[o]))}return s},jD=(n,e,t)=>{let i=(()=>{switch(t.keepAspectRatioPolicy){case"not_larger":return t.axes.length>0?Math.min(...t.axes.map(r=>e[r]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return t.axes.length>0?Math.max(...t.axes.map(r=>e[r]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${t.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let s=n.slice();return t.axes.length>0?(t.axes.forEach(r=>e[r]=i),t.axes.forEach(r=>s[r]=Math.round(n[r]*e[r]))):(e.fill(i,0,e.length),s.forEach((r,o)=>s[o]=Math.round(r*e[o]))),s},$D=(n,e,t,i,s)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${n.type.indices}) -> array<${n.type.value}, ${t.length}> {
      var original_indices: array<${n.type.value}, ${t.length}>;
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var output_index = ${n.indicesGet("output_indices","i")};
        var scale = ${Vn("uniforms.scales","i",i)};
        var roi_low = ${Vn("uniforms.roi","i",s)};
        var roi_hi = ${Vn("uniforms.roi",`i + ${e.length}`,s)};
        if (scale == 1.0) {
          original_indices[i] = ${n.type.value}(output_index);
        } else {
          var input_shape_i = ${Vn("uniforms.input_shape","i",e.length)};
          var output_shape_i = ${Vn("uniforms.output_shape","i",t.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,WD=(n,e,t,i,s,r,o)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${n.type.indices} {
      var input_indices: ${n.type.indices};
      for (var i:u32 = 0; i < ${i.length}; i++) {
        var output_index = ${e.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${Vn("uniforms.scales","i",s)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${Vn("uniforms.roi","i",r)};
          var roi_hi = ${Vn("uniforms.roi",`i + ${t.length}`,r)};
          var input_shape_i = ${Vn("uniforms.input_shape","i",t.length)};
          var output_shape_i = ${Vn("uniforms.output_shape","i",i.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${o} || (original_idx >= 0 && original_idx < ${e.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${e.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${n.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,KD=(n,e)=>`
    fn checkInputIndices(input_indices: ${n.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var input_index = ${n.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${Vn("uniforms.input_shape","i",e.length)}) {
          return false;
        }
      }
      return true;
    }`,uE=(n,e,t,i)=>n.rank>i?`
    ${n.indicesSet("input_indices",e,"channel")};
    ${n.indicesSet("input_indices",t,"batch")};
`:"",qD=(n,e,t,i,s)=>{let[r,o,l,c]=t.length===2?[-1,0,1,-1]:[0,2,3,1],d=n.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${d} {
      var input_indices: ${n.type.indices};
      ${n.indicesSet("input_indices",o,`max(0, min(row, ${t[o]} - 1))`)};
      ${n.indicesSet("input_indices",l,`max(0, min(col, ${t[l]} - 1))`)};
      ${uE(n,c,r,2)}
      return ${n.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${d} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${d} = originalIndices[${o}];
      var col:${d} = originalIndices[${l}];
      ${i?`if (row < 0 || row > (${t[o]} - 1) || col < 0 || col > (${t[l]} - 1)) {
        return ${s};
      }`:""};
      row = max(0, min(row, ${t[o]} - 1));
      col = max(0, min(col, ${t[l]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${t.length>2?`u32(originalIndices[${c}])`:"0"};
      var batch: u32 =  ${t.length>2?`u32(originalIndices[${r}])`:"0"};
      var x11: ${d} = getInputValue(batch, channel, row1, col1);
      var x12: ${d} = getInputValue(batch, channel, row1, col2);
      var x21: ${d} = getInputValue(batch, channel, row2, col1);
      var x22: ${d} = getInputValue(batch, channel, row2, col2);
      var dx1: ${d} = abs(row - ${d}(row1));
      var dx2: ${d} = abs(${d}(row2) - row);
      var dy1: ${d} = abs(col - ${d}(col1));
      var dy2: ${d} = abs(${d}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},XD=(n,e,t,i,s,r,o,l,c,d)=>{let g=t.length===2,[p,h]=g?[0,1]:[2,3],v=n.type.value,y=w=>{let S=w===p?"row":"col";return`
      fn ${S}CubicInterpolation(input_indices: ${n.type.indices}, output_indices: ${e.type.indices}) -> ${v} {
        var output_index = ${e.indicesGet("output_indices",w)};
        var originalIdx: ${v} = getOriginalCoordinateFromResizedCoordinate(output_index, ${s[w]},
        ${i[w]}, ${t[w]}, ${r[w]}, ${r[w]} + ${t.length});
        var fractOriginalIdx: ${v} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${l} && (originalIdx < 0 || originalIdx > (${t[w]} - 1))) {
          return ${c};
        }
        var data: array<${v}, 4> = array<${v}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${S}: ${v} = originalIdx + ${v}(i);
          if (${S} < 0 || ${S} >= ${t[w]}) {
            ${d?`coefs[i + 1] = 0.0;
                        continue;`:l?`return ${c};`:`${S} = max(0, min(${S}, ${t[w]} - 1));`};
          }
        var input_indices_copy: ${n.type.indices} = input_indices;
          ${n.indicesSet("input_indices_copy",w,`u32(${S})`)};
          data[i + 1] = ${w===p?n.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${y(p)};
    ${y(h)};
  fn getCubicInterpolationCoefs(s: ${v}) -> array<${v}, 4> {
    var absS = abs(s);
    var coeffs: array<${v}, 4> = array<${v}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${v} = 1.0 - absS;
    var twoMinusAbsS: ${v} = 2.0 - absS;
    var onePlusAbsS: ${v} = 1.0 + absS;
    coeffs[0] = ((${o} * onePlusAbsS - 5 * ${o}) * onePlusAbsS + 8 * ${o}) * onePlusAbsS - 4 * ${o};
    coeffs[1] = ((${o} + 2) * absS - (${o} + 3)) * absS * absS + 1;
    coeffs[2] = ((${o} + 2) * oneMinusAbsS - (${o} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${o} * twoMinusAbsS - 5 * ${o}) * twoMinusAbsS + 8 * ${o}) * twoMinusAbsS - 4 * ${o};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${v}, 4>, coefs: array<${v}, 4>) -> ${v} {
    var coefsSum: ${v} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${v} {
    var input_indices: ${n.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},YD=(n,e,t,i,s)=>{let[r,o,l,c,d]=t.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],g=n.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${g} {
      var input_indices: ${n.type.indices};
      ${n.indicesSet("input_indices",o,`max(0, min(depth, ${t[o]} - 1))`)};
      ${n.indicesSet("input_indices",l,`max(0, min(height, ${t[l]} - 1))`)};
      ${n.indicesSet("input_indices",c,`max(0, min(width, ${t[c]} - 1))`)};
      ${uE(n,d,r,3)}
      return ${n.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${e.type.indices}) -> ${g} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${g} = originalIndices[${o}];
      var height:${g} = originalIndices[${l}];
      var width:${g} = originalIndices[${c}];
      ${i?`if (depth < 0 || depth > (${t[o]} - 1) || height < 0 || height > (${t[l]} - 1) || width < 0 || (width > ${t[c]} - 1)) {
      return ${s};
        }`:""};

    depth = max(0, min(depth, ${t[o]} - 1));
      height = max(0, min(height, ${t[l]} - 1));
      width = max(0, min(width, ${t[c]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${t.length>3?`u32(originalIndices[${d}])`:"0"};
      var batch: u32 =  ${t.length>3?`u32(originalIndices[${r}])`:"0"};

      var x111: ${g} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${g} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${g} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${g} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${g} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${g} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${g} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${g} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${g} = abs(depth - ${g}(depth1));
      var dx2: ${g} = abs(${g}(depth2) - depth);
      var dy1: ${g} = abs(height - ${g}(height1));
      var dy2: ${g} = abs(${g}(height2) - height);
      var dz1: ${g} = abs(width - ${g}(width1));
      var dz2: ${g} = abs(${g}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},JD=(n,e,t,i,s,r)=>{let o=n.dims,l=VD(r,e.axes,o.length),c=HD(o,i,s,e.axes),d=i.slice();i.length===0&&(d=o.map((T,C)=>T===0?1:c[C]/T),e.keepAspectRatioPolicy!=="stretch"&&(c=jD(o,d,e)));let g=zn("output",n.dataType,c.length),p=Wt("input",n.dataType,o.length),h=Ut.size(c),v=o.length===c.length&&o.every((T,C)=>T===c[C]),y=e.coordinateTransformMode==="tf_crop_and_resize",w=e.extrapolationValue,S=p.type.value,M=T=>`
      ${v?"":`
      ${kD(e.coordinateTransformMode,S)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${KD(p,o)};
              ${GD(e.nearestMode,t,S)};
              ${WD(p,g,o,c,d.length,l.length,y)};
              `;case"linear":return`
              ${$D(g,o,c,d.length,l.length)};
              ${(()=>{if(o.length===2||o.length===4)return`${qD(p,g,o,y,w)}`;if(o.length===3||o.length===5)return`${YD(p,g,o,y,w)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(o.length===2||o.length===4)return`${XD(p,g,o,c,d,l,e.cubicCoeffA,y,e.extrapolationValue,e.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${T.registerUniform("output_size","u32").registerUniform("scales","f32",d.length).registerUniform("roi","f32",l.length).declareVariables(p,g)}
      ${T.mainStart()}
        ${T.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${v?"output[global_idx] = input[global_idx];":`
        let output_indices = ${g.offsetToIndices("global_idx")};
        var input_indices: ${p.type.indices};
        ${(()=>{switch(e.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${p.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${o.length===2||o.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${t}|${d.length>0?e.mode==="cubic"?d:d.length:""}|${s.length>0?s:""}|${l.length>0?l:""}|${v}|${e.mode==="nearest"?o.length:o}`,inputDependencies:["rank"]},getShaderSource:M,getRunData:()=>({outputs:[{dims:c,dataType:n.dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:[{type:12,data:h},{type:1,data:d},{type:1,data:l},...Wn(o,c)]})}},QD=n=>{let e=n.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},pN=(n,e)=>{let t=[],i=[],s=[],r=QD(n);if(e.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");UD(n.inputs,e,r,t,i,s),n.compute(JD(n.inputs[0],e,r,t,i,s),{inputs:[0]})},mN=n=>{let e=n.antialias,t=n.axes,i=n.coordinateTransformMode,s=n.cubicCoeffA,r=n.excludeOutside!==0,o=n.extrapolationValue,l=n.keepAspectRatioPolicy,c=n.mode,d=n.nearestMode===""?"simple":n.nearestMode;return Ts({antialias:e,axes:t,coordinateTransformMode:i,cubicCoeffA:s,excludeOutside:r,extrapolationValue:o,keepAspectRatioPolicy:l,mode:c,nearestMode:d})}}),ZD,eB,gN,cK=fn(()=>{ai(),vi(),Mi(),ZD=n=>{if(!n||n.length<3)throw new Error("layerNorm requires at least 3 inputs.");let e=n[0],t=n[1],i=n[2];if(e.dataType!==t.dataType||e.dataType!==i.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Skip must be 2D or 3D");let s=e.dims[e.dims.length-1],r=e.dims[e.dims.length-2];if(t.dims[t.dims.length-1]!==s)throw new Error("Skip must have the same hidden size as input");if(t.dims[t.dims.length-2]!==r)throw new Error("Skip must have the same sequence length as input");if(i.dims.length!==1)throw new Error("Gamma must be 1D");if(i.dims[i.dims.length-1]!==s)throw new Error("Gamma must have the same hidden size as input");if(n.length>3){let o=n[3];if(o.dims.length!==1)throw new Error("Beta must be 1D");if(o.dims[o.dims.length-1]!==s)throw new Error("Beta must have the same hidden size as input")}if(n.length>4){let o=n[4];if(o.dims.length!==1)throw new Error("Bias must be 1D");if(o.dims[o.dims.length-1]!==s)throw new Error("Bias must have the same hidden size as input")}},eB=(n,e,t,i)=>{let s=e.simplified,r=n[0].dims,o=Ut.size(r),l=r,c=o,d=r.slice(-1)[0],g=i?r.slice(0,-1).concat(1):[],p=!s&&n.length>3,h=n.length>4,v=i&&t>1,y=i&&t>2,w=t>3,S=64,M=Lr(d),T=[{type:12,data:c},{type:12,data:M},{type:12,data:d},{type:1,data:e.epsilon}],C=R=>{let P=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],D=[Wt("x",n[0].dataType,n[0].dims,M),Wt("skip",n[1].dataType,n[1].dims,M),Wt("gamma",n[2].dataType,n[2].dims,M)];p&&D.push(Wt("beta",n[3].dataType,n[3].dims,M)),h&&D.push(Wt("bias",n[4].dataType,n[4].dims,M)),D.push(zn("output",n[0].dataType,l,M)),v&&D.push(zn("mean_output",1,g)),y&&D.push(zn("inv_std_output",1,g)),w&&D.push(zn("input_skip_bias_sum",n[0].dataType,l,M));let z=Va(n[0].dataType),U=Va(1,M);return`

      ${R.registerUniforms(P).declareVariables(...D)}
      var<workgroup> sum_shared : array<${U}, ${S}>;
      var<workgroup> sum_squared_shared : array<${U}, ${S}>;

      ${R.mainStart([S,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${S};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${S};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${S-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${h?"bias[offset1d + i]":z+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${w?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${Y_(z,M,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${S};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${pm("sum",M)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${pm("square_sum",M)} / f32(uniforms.hidden_size) ${s?"":"- mean * mean"} + uniforms.epsilon);
        ${v?"mean_output[global_idx] = mean;":""}
        ${y?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${s?"":`- ${z}(mean)`}) *
            ${z}(inv_std_dev) * gamma[offset1d + i]
            ${p?"+ beta[offset1d + i]":""};
        }
      }`},x=[{dims:l,dataType:n[0].dataType}];return t>1&&x.push({dims:g,dataType:1}),t>2&&x.push({dims:g,dataType:1}),t>3&&x.push({dims:r,dataType:n[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${M};${v};${y};${w}`,inputDependencies:n.map((R,P)=>"type")},getShaderSource:C,getRunData:()=>({outputs:x,dispatchGroup:{x:Math.ceil(c/d)},programUniforms:T})}},gN=(n,e)=>{ZD(n.inputs);let t=[0];n.outputCount>1&&t.push(-3),n.outputCount>2&&t.push(-3),n.outputCount>3&&t.push(3),n.compute(eB(n.inputs,e,n.outputCount,!1),{outputs:t})}}),tB,av,nB,cE,iB,sB,_N,vN,dK=fn(()=>{ai(),vi(),$r(),Mi(),tB=(n,e)=>{if(!n||n.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");n.slice(1).forEach((t,i)=>{if(n[i+1].dataType!==6&&n[i+1].dataType!==7)throw new Error(`Input ${i} must be an array of int32 or int64`)})},av=(n,e)=>{let t=[];if(n.length>e)if(n[e].dataType===7)n[e].getBigInt64Array().forEach(i=>t.push(Number(i)));else if(n[e].dataType===6)n[e].getInt32Array().forEach(i=>t.push(Number(i)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return t},nB=(n,e)=>{if(n.length>1){let t=av(n,1),i=av(n,2),s=av(n,3);return s.length===0&&(s=[...Array(n[0].dims.length).keys()]),Ts({starts:t,ends:i,axes:s})}else return e},cE=(n,e,t,i,s)=>{let r=n;return n<0&&(r+=t[i[e]]),s[e]<0?Math.max(0,Math.min(r,t[i[e]]-1)):Math.max(0,Math.min(r,t[i[e]]))},iB=(n,e,t)=>`fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${n.type.indices} {
          var input_indices: ${n.type.indices};
          var carry = 0u;
          for (var i = ${t.length}; i >= 0; i--) {
            let input_shape_i = ${Vn("uniforms.input_shape","i",t.length)};
            let steps_i = ${Vn("uniforms.steps","i",t.length)};
            let signs_i = ${Vn("uniforms.signs","i",t.length)};
            let starts_i = ${Vn("uniforms.starts","i",t.length)};
            var output_index = ${e.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${n.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,sB=(n,e)=>{let t=n[0].dims,i=Ut.size(t),s=e.axes.length>0?Ut.normalizeAxes(e.axes,t.length):[...Array(t.length).keys()],r=av(n,4);r.forEach(M=>M!==0||(()=>{throw new Error("step cannot be 0")})),r.length===0&&(r=Array(s.length).fill(1));let o=e.starts.map((M,T)=>cE(M,T,t,s,r)),l=e.ends.map((M,T)=>cE(M,T,t,s,r));if(s.length!==o.length||s.length!==l.length)throw new Error("start, ends and axes should have the same number of elements");if(s.length!==t.length)for(let M=0;M<t.length;++M)s.includes(M)||(o.splice(M,0,0),l.splice(M,0,t[M]),r.splice(M,0,1));let c=r.map(M=>Math.sign(M));r.forEach((M,T,C)=>{if(M<0){let x=(l[T]-o[T])/M,R=o[T],P=R+x*r[T];o[T]=P,l[T]=R,C[T]=-M}});let d=t.slice(0);s.forEach((M,T)=>{d[M]=Math.ceil((l[M]-o[M])/r[M])});let g={dims:d,dataType:n[0].dataType},p=zn("output",n[0].dataType,d.length),h=Wt("input",n[0].dataType,n[0].dims.length),v=Ut.size(d),y=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:o.length},{name:"signs",type:"i32",length:c.length},{name:"steps",type:"u32",length:r.length}],w=[{type:12,data:v},{type:12,data:o},{type:6,data:c},{type:12,data:r},...Wn(n[0].dims,d)],S=M=>`
      ${M.registerUniforms(y).declareVariables(h,p)}
        ${iB(h,p,t)}
        ${M.mainStart()}
          ${M.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${p.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${p.setByOffset("global_idx",h.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${c.length}_${o.length}_${r.length}`,inputDependencies:["rank"]},getShaderSource:S,getRunData:()=>({outputs:[g],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:w})}},_N=(n,e)=>{tB(n.inputs,e);let t=nB(n.inputs,e);n.compute(sB(n.inputs,t),{inputs:[0]})},vN=n=>{let e=n.starts,t=n.ends,i=n.axes;return Ts({starts:e,ends:t,axes:i})}}),rB,aB,yN,MN,fK=fn(()=>{ai(),vi(),$r(),ym(),Mi(),rB=n=>{if(!n||n.length!==1)throw new Error("Softmax op requires 1 input.")},aB=(n,e)=>{let t=n.inputs[0],i=t.dims,s=Ut.size(i),r=i.length,o=Ut.normalizeAxis(e.axis,r),l=o<i.length-1,c,d=[];l?(d=Array.from({length:r},(D,z)=>z),d[o]=r-1,d[r-1]=o,c=n.compute(Yu(t,d),{inputs:[t],outputs:[-1]})[0]):c=t;let g=c.dims,p=g[r-1],h=s/p,v=Lr(p),y=p/v,w=64;h===1&&(w=256);let S=(D,z)=>z===4?`max(max(${D}.x, ${D}.y), max(${D}.z, ${D}.w))`:z===2?`max(${D}.x, ${D}.y)`:z===3?`max(max(${D}.x, ${D}.y), ${D}.z)`:D,M=Wt("x",c.dataType,c.dims,v),T=zn("result",c.dataType,c.dims,v),C=M.type.value,x=Va(c.dataType)==="f32"?`var threadMax = ${C}(-3.402823e+38f);`:`var threadMax = ${C}(-65504.0h);`,R=D=>`
      var<workgroup> rowMaxShared : ${C};
      var<workgroup> rowSumShared : ${C};
      var<workgroup> threadShared : array<${C}, ${w}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${C} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${C}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${D.registerUniform("packedCols","i32").declareVariables(M,T)}
      ${D.mainStart(w)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${w};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${x}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${C}(${S("threadShared[0]",v)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${C}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${C}(${pm("threadShared[0]",v)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,P=n.compute({name:"Softmax",shaderCache:{hint:`${v};${w}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:g,dataType:c.dataType}],dispatchGroup:{x:h},programUniforms:[{type:6,data:y}]}),getShaderSource:R},{inputs:[c],outputs:[l?-1:0]})[0];l&&n.compute(Yu(P,d),{inputs:[P]})},yN=(n,e)=>{rB(n.inputs),aB(n,e)},MN=n=>Ts({axis:n.axis})}),dE,oB,lB,uB,bN,hK=fn(()=>{ai(),vi(),Mi(),dE=n=>Array.from(n.getBigInt64Array(),Number),oB=n=>{if(!n||n.length!==2)throw new Error("Tile requires 2 inputs.");if(n[0].dataType!==1&&n[0].dataType!==10&&n[0].dataType!==6&&n[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(n[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(n[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(dE(n[1]).length!==n[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},lB=(n,e)=>{let t=[];for(let i=0;i<n.length;++i)t.push(n[i]*e[i]);return t},uB=(n,e)=>{let t=n[0].dims,i=e??dE(n[1]),s=lB(t,i),r=Ut.size(s),o=n[0].dataType,l=Wt("input",o,t.length),c=zn("output",o,s.length),d=g=>`
      const inputShape = ${l.indices(...t)};
      ${g.registerUniform("output_size","u32").declareVariables(l,c)}
      ${g.mainStart()}
      ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${c.offsetToIndices("global_idx")};
      var input_indices: ${l.type.indices};
      for (var i = 0; i < ${t.length}; i++) {
        let input_dim_i = ${l.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${c.indicesGet("output_indices","i")}  % input_dim_i;

        ${l.indicesSet("input_indices","i","input_dim_value")}
      }
      ${c.setByOffset("global_idx",l.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${i}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:s,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:[{type:12,data:r},...Wn(n[0].dims,s)]}),getShaderSource:d}},bN=n=>{oB(n.inputs),n.compute(uB(n.inputs),{inputs:[0]})}}),cB,dB,xN,pK=fn(()=>{ai(),vi(),Mi(),cB=(n,e,t,i,s)=>{let r=zn("output_data",s,t.length,4),o=Wt("a_data",e[1].dataType,e[1].dims.length,4),l=Wt("b_data",e[2].dataType,e[2].dims.length,4),c=Wt("c_data",e[0].dataType,e[0].dims.length,4),d,g=(p,h,v)=>`select(${h}, ${p}, ${v})`;if(!i)d=r.setByOffset("global_idx",g(o.getByOffset("global_idx"),l.getByOffset("global_idx"),c.getByOffset("global_idx")));else{let p=(h,v,y="")=>{let w=`a_data[index_a${v}][component_a${v}]`,S=`b_data[index_b${v}][component_b${v}]`,M=`bool(c_data[index_c${v}] & (0xffu << (component_c${v} * 8)))`;return`
            let output_indices${v} = ${r.offsetToIndices(`global_idx * 4u + ${v}u`)};
            let offset_a${v} = ${o.broadcastedIndicesToOffset(`output_indices${v}`,r)};
            let offset_b${v} = ${l.broadcastedIndicesToOffset(`output_indices${v}`,r)};
            let offset_c${v} = ${c.broadcastedIndicesToOffset(`output_indices${v}`,r)};
            let index_a${v} = offset_a${v} / 4u;
            let index_b${v} = offset_b${v} / 4u;
            let index_c${v} = offset_c${v} / 4u;
            let component_a${v} = offset_a${v} % 4u;
            let component_b${v} = offset_b${v} % 4u;
            let component_c${v} = offset_c${v} % 4u;
            ${h}[${v}] = ${y}(${g(w,S,M)});
          `};s===9?d=`
            var data = vec4<u32>(0);
            ${p("data",0,"u32")}
            ${p("data",1,"u32")}
            ${p("data",2,"u32")}
            ${p("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:d=`
            ${p("output_data[global_idx]",0)}
            ${p("output_data[global_idx]",1)}
            ${p("output_data[global_idx]",2)}
            ${p("output_data[global_idx]",3)}
          `}return`
        ${n.registerUniform("vec_size","u32").declareVariables(c,o,l,r)}
        ${n.mainStart()}
        ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${d}
      }`},dB=n=>{let e=n[1].dims,t=n[2].dims,i=n[0].dims,s=n[1].dataType,r=!(Ut.areEqual(e,t)&&Ut.areEqual(t,i)),o=e,l=Ut.size(e);if(r){let d=h0.calcShape(h0.calcShape(e,t,!1),i,!1);if(!d)throw new Error("Can't perform where op on the given tensors");o=d,l=Ut.size(o)}let c=Math.ceil(l/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:d=>cB(d,n,o,r,s),getRunData:()=>({outputs:[{dims:o,dataType:s}],dispatchGroup:{x:Math.ceil(l/64/4)},programUniforms:[{type:12,data:c},...Wn(i,e,t,o)]})}},xN=n=>{n.compute(dB(n.inputs))}}),wN,mK=fn(()=>{PW(),wS(),RW(),DW(),BW(),IW(),OW(),UW(),GW(),VW(),HW(),jW(),$W(),WW(),KW(),qW(),XW(),YW(),JW(),QW(),ZW(),eK(),tK(),nK(),iK(),VF(),sK(),rK(),aK(),oK(),lK(),xS(),uK(),KF(),cK(),dK(),fK(),$F(),hK(),ym(),ES(),pK(),wN=new Map([["Abs",[gL]],["Acos",[_L]],["Acosh",[vL]],["Add",[QL]],["ArgMax",[fL,eT]],["ArgMin",[dL,eT]],["Asin",[yL]],["Asinh",[ML]],["Atan",[bL]],["Atanh",[xL]],["Attention",[hL]],["AveragePool",[nN,tN]],["BatchNormalization",[pL]],["BiasAdd",[mL]],["BiasSplitGelu",[JL]],["Cast",[EL,wL]],["Ceil",[SL]],["Clip",[TL]],["Concat",[lF,uF]],["Conv",[aT,rT]],["ConvTranspose",[yF,vF]],["Cos",[AL]],["Cosh",[CL]],["CumSum",[MF,bF]],["DepthToSpace",[xF,wF]],["DequantizeLinear",[uN,cN]],["Div",[ZL]],["Einsum",[EF,TF]],["Elu",[PL,mv]],["Equal",[eF]],["Erf",[RL]],["Exp",[DL]],["Expand",[SF]],["FastGelu",[AF]],["Floor",[BL]],["FusedConv",[aT,rT]],["Gather",[PF,CF]],["GatherElements",[LF,OF]],["GatherBlockQuantized",[BF,IF]],["GatherND",[RF,DF]],["Gelu",[IL]],["Gemm",[NF,FF]],["GlobalAveragePool",[sN,iN]],["GlobalMaxPool",[lN,oN]],["Greater",[sF]],["GreaterOrEqual",[aF]],["GridSample",[zF,UF]],["GroupQueryAttention",[qF]],["HardSigmoid",[GL,kL]],["InstanceNormalization",[XF]],["LayerNormalization",[YF]],["LeakyRelu",[OL,mv]],["Less",[rF]],["LessOrEqual",[oF]],["Log",[XL]],["MatMul",[JF]],["MatMulNBits",[QF,ZF]],["MaxPool",[rN,aN]],["Mul",[tF]],["MultiHeadAttention",[GF,kF]],["Neg",[FL]],["Not",[LL]],["Pad",[eN]],["Pow",[nF]],["QuickGelu",[YL,mv]],["Range",[dN]],["Reciprocal",[NL]],["ReduceMin",[aL]],["ReduceMean",[tL]],["ReduceMax",[rL]],["ReduceSum",[lL]],["ReduceProd",[oL]],["ReduceL1",[nL]],["ReduceL2",[iL]],["ReduceLogSum",[cL]],["ReduceLogSumExp",[sL]],["ReduceSumSquare",[uL]],["Relu",[zL]],["Resize",[pN,mN]],["RotaryEmbedding",[WF]],["ScatterND",[hN,fN]],["Sigmoid",[UL]],["Sin",[VL]],["Sinh",[HL]],["Slice",[_N,vN]],["SkipLayerNormalization",[gN]],["Split",[HF,jF]],["Sqrt",[jL]],["Softmax",[yN,MN]],["Sub",[iF]],["Tan",[$L]],["Tanh",[WL]],["ThresholdedRelu",[qL,mv]],["Tile",[bN]],["Transpose",[H3,j3]],["Where",[xN]]])}),EN,gK=fn(()=>{Gd(),qh(),Mi(),EN=class{constructor(n){this.backend=n,this.repo=new Map,this.attributesBound=!1}getArtifact(n){return this.repo.get(n)}setArtifact(n,e){this.repo.set(n,e)}run(n,e,t,i,s){zd(n.programInfo.name);let r=this.backend.device,o=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let l=[];for(let d of e)l.push({binding:l.length,resource:{buffer:d.buffer}});for(let d of t)l.push({binding:l.length,resource:{buffer:d.buffer}});s&&l.push({binding:l.length,resource:s});let c=r.createBindGroup({layout:n.computePipeline.getBindGroupLayout(0),entries:l,label:n.programInfo.name});if(this.backend.sessionStatus==="capturing"){let d={kernelId:this.backend.currentKernelId,computePipeline:n.computePipeline,bindGroup:c,dispatchGroup:i};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(d)}o.setPipeline(n.computePipeline),o.setBindGroup(0,c),o.dispatchWorkgroups(...i),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Fc(n.programInfo.name)}dispose(){}build(n,e){zd(n.name);let t=this.backend.device,i=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(d=>{t.features.has(d.feature)&&i.push(`enable ${d.extension};`)});let s=V3(e,this.backend.device.limits),r=n.getShaderSource(s),o=`${i.join(`
`)}
${s.additionalImplementations}
${r}`,l=t.createShaderModule({code:o,label:n.name});Zi("verbose",()=>`[WebGPU] ${n.name} shader code: ${o}`);let c=t.createComputePipeline({compute:{module:l,entryPoint:"main"},layout:"auto",label:n.name});return Fc(n.name),{programInfo:n,computePipeline:c,uniformVariablesInfo:s.variablesInfo}}normalizeDispatchGroupSize(n){let e=typeof n=="number"?n:n.x,t=typeof n=="number"?1:n.y||1,i=typeof n=="number"?1:n.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(e<=s&&t<=s&&i<=s)return[e,t,i];let r=e*t*i,o=Math.ceil(Math.sqrt(r));if(o>s){if(o=Math.ceil(Math.cbrt(r)),o>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[o,o,o]}else return[o,o,1]}}}),TN={};E0(TN,{WebGpuBackend:()=>SN});var fB,hB,pB,SN,_K=fn(()=>{Gd(),ai(),qh(),N3(),AW(),mK(),gK(),fB=(n,e)=>{if(e.length!==n.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${n.length}.`);let t=[];for(let i=0;i<n.length;++i){let s=n[i].dataType;switch(e[i]){case"none":{t.push("");break}case"type":{t.push(`${s}`);break}case"rank":{let r=n[i].dims.length;t.push(`${s};${r}`);break}case"dims":{let r=n[i].dims.join(",");t.push(`${s};${r}`);break}default:throw new Error(`unsupported input dependency: ${e[i]}`)}}return t.join("|")},hB=(n,e,t)=>{let i=n.name;return n.shaderCache?.hint&&(i+="["+n.shaderCache.hint+"]"),i+=":"+t+`:${fB(e,n.shaderCache?.inputDependencies??new Array(e.length).fill("dims"))}`,i},pB=class{constructor(n){n&&(this.architecture=n.architecture,this.vendor=n.vendor)}isArchitecture(n){return this.architecture===n}isVendor(n){return this.vendor===n}},SN=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let n=this.kernelCustomData.get(this.currentKernelId);return n||(n={},this.kernelCustomData.set(this.currentKernelId,n)),n}async initialize(n,e){this.env=n;let t=[],i={requiredLimits:{maxComputeWorkgroupStorageSize:e.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.limits.maxStorageBufferBindingSize,maxBufferSize:e.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:e.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:e.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:e.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:e.limits.maxComputeWorkgroupSizeZ},requiredFeatures:t},s=r=>e.features.has(r)&&t.push(r)&&!0;s("chromium-experimental-timestamp-query-inside-passes")||s("timestamp-query"),s("shader-f16"),s("subgroups"),this.device=await e.requestDevice(i),this.adapterInfo=new pB(e.info||await e.requestAdapterInfo()),this.gpuDataManager=k3(this),this.programManager=new EN(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,vS(n.logLevel,!!n.debug),this.device.onuncapturederror=r=>{r.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${r.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:e,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let n=this.getCommandEncoder(),e={};this.queryType==="at-passes"&&(e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=n.beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;zd(),this.endComputePass();let n;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),n=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(n,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,n,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&n.mapAsync(GPUMapMode.READ).then(()=>{let e=new BigUint64Array(n.getMappedRange()),t=this.pendingQueries.get(n);for(let i=0;i<e.length/2;i++){let s=t[i],r=s.kernelId,o=this.kernels.get(r),l=o.kernelType,c=o.kernelName,d=s.programName,g=s.inputTensorViews,p=s.outputTensorViews,h=e[i*2],v=e[i*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=h);let y=Number(h-this.queryTimeBase),w=Number(v-this.queryTimeBase);if(!Number.isSafeInteger(y)||!Number.isSafeInteger(w))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:g.map(S=>({dims:S.dims,dataType:Gh(S.dataType)})),outputsMetadata:p.map(S=>({dims:S.dims,dataType:Gh(S.dataType)})),kernelId:r,kernelType:l,kernelName:c,programName:d,startTime:y,endTime:w});else{let S="";g.forEach((T,C)=>{S+=`input[${C}]: [${T.dims}] | ${Gh(T.dataType)}, `});let M="";p.forEach((T,C)=>{M+=`output[${C}]: [${T.dims}] | ${Gh(T.dataType)}, `}),console.log(`[profiling] kernel "${r}|${l}|${c}|${d}" ${S}${M}execution time: ${w-y} ns`)}Hv("GPU",`${d}::${h}::${v}`)}n.unmap(),this.pendingQueries.delete(n)}),Fc()}run(n,e,t,i,s,r){zd(n.name);let o=[];for(let T=0;T<e.length;++T){let C=e[T].data;if(C===0)continue;let x=this.gpuDataManager.get(C);if(!x)throw new Error(`no GPU data for input: ${C}`);o.push(x)}let{outputs:l,dispatchGroup:c,programUniforms:d}=n.getRunData(e),g=t.length===0?l.map((T,C)=>C):t;if(g.length!==l.length)throw new Error(`Output size ${g.length} must be equal to ${l.length}.`);let p=[],h=[];for(let T=0;T<l.length;++T){if(!Number.isInteger(g[T])||g[T]<-3||g[T]>=r)throw new Error(`Invalid output index: ${g[T]}`);if(g[T]===-3)continue;let C=g[T]===-1,x=g[T]===-2,R=C||x?s(l[T].dataType,l[T].dims):i(g[T],l[T].dataType,l[T].dims);if(p.push(R),R.data===0)continue;let P=this.gpuDataManager.get(R.data);if(!P)throw new Error(`no GPU data for output: ${R.data}`);if(C&&this.temporaryData.push(P),x){let D=this.kernelPersistentData.get(this.currentKernelId);D||(D=[],this.kernelPersistentData.set(this.currentKernelId,D)),D.push(P)}h.push(P)}if(o.length!==e.length||h.length!==p.length){if(h.length===0)return Fc(n.name),p;throw new Error(`Program ${n.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let v;if(d){let T=0,C=[];d.forEach(D=>{let z=typeof D.data=="number"?[D.data]:D.data;if(z.length===0)return;let U=D.type===10?2:4,N,j;D.type===10?(j=z.length>4?16:z.length>2?8:z.length*U,N=z.length>4?16:U*z.length):(j=z.length<=2?z.length*U:16,N=16),T=Math.ceil(T/j)*j,C.push(T);let J=D.type===10?8:4;T+=z.length>4?Math.ceil(z.length/J)*N:z.length*U});let x=16;T=Math.ceil(T/x)*x;let R=new ArrayBuffer(T);d.forEach((D,z)=>{let U=C[z],N=typeof D.data=="number"?[D.data]:D.data;if(D.type===6)new Int32Array(R,U,N.length).set(N);else if(D.type===12)new Uint32Array(R,U,N.length).set(N);else if(D.type===10)new Uint16Array(R,U,N.length).set(N);else if(D.type===1)new Float32Array(R,U,N.length).set(N);else throw new Error(`Unsupported uniform type: ${Gh(D.type)}`)});let P=this.gpuDataManager.create(T,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(P.buffer,0,R,0,T),this.gpuDataManager.release(P.id),v={offset:0,size:T,buffer:P.buffer}}let y=this.programManager.normalizeDispatchGroupSize(c),w=y[1]===1&&y[2]===1,S=hB(n,e,w),M=this.programManager.getArtifact(S);if(M||(M=this.programManager.build(n,y),this.programManager.setArtifact(S,M),Zi("info",()=>`[artifact] key: ${S}, programName: ${n.name}`)),d&&M.uniformVariablesInfo){if(d.length!==M.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${M.uniformVariablesInfo.length}, got ${d.length} in program "${M.programInfo.name}".`);for(let T=0;T<d.length;T++){let C=d[T],x=C.type,R=typeof C.data=="number"?1:C.data.length,[P,D]=M.uniformVariablesInfo[T];if(x!==P||R!==D)throw new Error(`Uniform variable ${T} mismatch: expect type ${P} with size ${D}, got type ${x} with size ${R} in program "${M.programInfo.name}".`)}}if(Zi("info",()=>`[ProgramManager] run "${n.name}" (key=${S}) with ${y[0]}x${y[1]}x${y[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let T={kernelId:this.currentKernelId,programName:M.programInfo.name,inputTensorViews:e,outputTensorViews:p};this.pendingKernels.push(T),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(T)}return this.programManager.run(M,o,h,y,v),Fc(n.name),p}upload(n,e){this.gpuDataManager.upload(n,e)}memcpy(n,e){this.gpuDataManager.memcpy(n,e)}async download(n,e){await this.gpuDataManager.download(n,e)}alloc(n){return this.gpuDataManager.create(n).id}free(n){return this.gpuDataManager.release(n)}createKernel(n,e,t,i){let s=wN.get(n);if(!s)throw new Error(`kernel not implemented: ${n}`);let r={kernelType:n,kernelName:i,kernelEntry:s[0],attributes:[s[1],t]};this.kernels.set(e,r)}releaseKernel(n){let e=this.kernelPersistentData.get(n);if(e){for(let t of e)this.gpuDataManager.release(t.id);this.kernelPersistentData.delete(n)}this.kernelCustomData.delete(n),this.kernels.delete(n)}computeKernel(n,e,t){let i=this.kernels.get(n);if(!i)throw new Error(`kernel not created: ${n}`);let s=i.kernelType,r=i.kernelName,o=i.kernelEntry,l=i.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${r}" is not allowed to be called recursively`);this.currentKernelId=n,l[0]&&(l[1]=l[0](l[1]),l[0]=void 0),Zi("info",()=>`[WebGPU] Start to run kernel "[${s}] ${r}"...`);let c=this.env.debug;this.temporaryData=[];try{return c&&this.device.pushErrorScope("validation"),o(e,l[1]),0}catch(d){return t.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${r}" failed. ${d}`)),1}finally{c&&t.push(this.device.popErrorScope().then(d=>d?`GPU validation error for kernel "[${s}] ${r}": ${d.message}`:null));for(let d of this.temporaryData)this.gpuDataManager.release(d.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(n,e,t,i){let s=this.sessionExternalDataMapping.get(n);s||(s=new Map,this.sessionExternalDataMapping.set(n,s));let r=s.get(e),o=this.gpuDataManager.registerExternalBuffer(t,i,r);return s.set(e,[o,t]),o}unregisterBuffers(n){let e=this.sessionExternalDataMapping.get(n);e&&(e.forEach(t=>this.gpuDataManager.unregisterExternalBuffer(t[0])),this.sessionExternalDataMapping.delete(n))}getBuffer(n){let e=this.gpuDataManager.get(n);if(!e)throw new Error(`no GPU data for buffer: ${n}`);return e.buffer}createDownloader(n,e,t){return async()=>{let i=await JE(this,n,e);return yS(i.buffer,t)}}writeTimestamp(n){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,n)}setQueryType(){this.queryType="none",(this.env.webgpu.profiling?.mode==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){Zi("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){Zi("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){Zi("info","replay"),this.sessionStatus="replaying";let n=this.capturedCommandList.get(this.currentSessionId),e=this.capturedPendingKernels.get(this.currentSessionId),t=n.length;this.pendingKernels=[];for(let i=0;i<t;i++){let s=this.getComputePassEncoder(),r=n[i];this.writeTimestamp(this.pendingDispatchNumber*2),s.setPipeline(r.computePipeline),s.setBindGroup(0,r.bindGroup),s.dispatchWorkgroups(...r.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(e[i]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(n){this.unregisterBuffers(n),this.capturedCommandList.has(n)&&this.capturedCommandList.delete(n),this.capturedPendingKernels.has(n)&&this.capturedPendingKernels.delete(n),this.gpuDataManager.onReleaseSession(n)}onRunStart(n){this.currentSessionId=n,this.setQueryType()}}}),AN={};E0(AN,{init:()=>CN});var LM,mB,CN,vK=fn(()=>{ai(),qh(),vi(),SW(),LM=class PN{constructor(e,t,i,s){this.module=e,this.dataType=t,this.data=i,this.dims=s}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=Ut.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=Ut.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=Ut.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let e=Ut.size(this.dims);return e===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(Ut.size(e)!==Ut.size(this.dims))throw new Error("Invalid new shape");return new PN(this.module,this.dataType,this.data,e)}},mB=class{constructor(n,e,t){this.module=n,this.backend=e,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=e.adapterInfo;let i=n.PTR_SIZE,s=t/n.PTR_SIZE,r=i===4?"i32":"i64";this.opKernelContext=Number(n.getValue(i*s++,r));let o=Number(n.getValue(i*s++,r));this.outputCount=Number(n.getValue(i*s++,r)),this.customDataOffset=Number(n.getValue(i*s++,"*")),this.customDataSize=Number(n.getValue(i*s++,r));let l=[];for(let c=0;c<o;c++){let d=Number(n.getValue(i*s++,r)),g=Number(n.getValue(i*s++,"*")),p=Number(n.getValue(i*s++,r)),h=[];for(let v=0;v<p;v++)h.push(Number(n.getValue(i*s++,r)));l.push(new LM(n,d,g,h))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(n,e){let t=e?.inputs?.map(o=>typeof o=="number"?this.inputs[o]:o)??this.inputs,i=e?.outputs??[],s=(o,l,c)=>new LM(this.module,l,this.output(o,c),c),r=(o,l)=>{let c=Sg(o,l);if(!c)throw new Error(`Unsupported data type: ${o}`);let d=c>0?this.backend.gpuDataManager.create(c).id:0;return new LM(this.module,o,d,l)};return this.backend.run(n,t,i,s,r,this.outputCount)}output(n,e){let t=this.module.stackSave();try{let i=this.module.PTR_SIZE,s=i===4?"i32":"i64",r=this.module.stackAlloc((1+e.length)*i);this.module.setValue(r,e.length,s);for(let o=0;o<e.length;o++)this.module.setValue(r+i*(o+1),e[o],s);return this.module._JsepOutput(this.opKernelContext,n,r)}catch(i){throw new Error(`Failed to generate kernel's output[${n}] with dims [${e}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${i}`)}finally{this.module.stackRestore(t)}}},CN=async(n,e,t,i)=>{let s=e.jsepInit;if(!s)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(n==="webgpu"){let r=(_K(),Vv(TN)).WebGpuBackend,o=new r;await o.initialize(t,i),s("webgpu",[o,l=>o.alloc(Number(l)),l=>o.free(l),(l,c,d,g=!1)=>{if(g)Zi("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(l)}, dst=${Number(c)}, size=${Number(d)}`),o.memcpy(Number(l),Number(c));else{Zi("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(l)}, gpuDataId=${Number(c)}, size=${Number(d)}`);let p=e.HEAPU8.subarray(Number(l>>>0),Number(l>>>0)+Number(d));o.upload(Number(c),p)}},async(l,c,d)=>{Zi("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${l}, dataOffset=${c}, size=${d}`),await o.download(Number(l),()=>e.HEAPU8.subarray(Number(c)>>>0,Number(c+d)>>>0))},(l,c,d)=>o.createKernel(l,Number(c),d,e.UTF8ToString(e._JsepGetNodeName(Number(c)))),l=>o.releaseKernel(l),(l,c,d,g)=>{Zi("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${d}, kernel=${l}, contextDataOffset=${c}`);let p=new mB(e,o,Number(c));return o.computeKernel(Number(l),p,g)},()=>o.captureBegin(),()=>o.captureEnd(),()=>o.replay()])}else{let r=new U3(t);s("webnn",[r,()=>r.reserveTensorId(),o=>r.releaseTensorId(o),async(o,l,c,d,g)=>r.ensureTensor(o,l,c,d,g),(o,l)=>{r.uploadTensor(o,l)},async(o,l)=>r.downloadTensor(o,l)])}}}),gB,RS,DS,rm,_B,fE,$b,BS,IS,hE,OS,LS,FS,RN=fn(()=>{wW(),EW(),ai(),n_(),hS(),I3(),gB=(n,e)=>{er()._OrtInit(n,e)!==0&&Fs("Can't initialize onnxruntime.")},RS=async n=>{gB(n.wasm.numThreads,kb(n.logLevel))},DS=async(n,e)=>{er().asyncInit?.();{let t=(vK(),Vv(AN)).init;if(e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let i=n.webgpu.adapter;if(i){if(typeof i.limits!="object"||typeof i.features!="object"||typeof i.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let s=n.webgpu.powerPreference;if(s!==void 0&&s!=="low-power"&&s!=="high-performance")throw new Error(`Invalid powerPreference setting: "${s}"`);let r=n.webgpu.forceFallbackAdapter;if(r!==void 0&&typeof r!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${r}"`);if(i=await navigator.gpu.requestAdapter({powerPreference:s,forceFallbackAdapter:r}),!i)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await t("webgpu",er(),n,i)}if(e==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await t("webnn",er(),n)}}},rm=new Map,_B=n=>{let e=er(),t=e.stackSave();try{let i=e.PTR_SIZE,s=e.stackAlloc(2*i);e._OrtGetInputOutputCount(n,s,s+i)!==0&&Fs("Can't get session input/output count.");let r=i===4?"i32":"i64";return[Number(e.getValue(s,r)),Number(e.getValue(s+i,r))]}finally{e.stackRestore(t)}},fE=(n,e)=>{let t=er(),i=t.stackSave(),s=0;try{let r=t.PTR_SIZE,o=t.stackAlloc(2*r);t._OrtGetInputOutputMetadata(n,e,o,o+r)!==0&&Fs("Can't get session input/output metadata.");let l=Number(t.getValue(o,"*"));s=Number(t.getValue(o+r,"*"));let c=t.HEAP32[s/4];if(c===0)return[l,0];let d=t.HEAPU32[s/4+1],g=[];for(let p=0;p<d;p++){let h=Number(t.getValue(s+8+p*r,"*"));g.push(h!==0?t.UTF8ToString(h):Number(t.getValue(s+8+(p+d)*r,"*")))}return[l,c,g]}finally{t.stackRestore(i),s!==0&&t._OrtFree(s)}},$b=n=>{let e=er(),t=e._malloc(n.byteLength);if(t===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${n.byteLength}.`);return e.HEAPU8.set(n,t),[t,n.byteLength]},BS=async(n,e)=>{let t,i,s=er();Array.isArray(n)?[t,i]=n:n.buffer===s.HEAPU8.buffer?[t,i]=[n.byteOffset,n.byteLength]:[t,i]=$b(n);let r=0,o=0,l=0,c=[],d=[],g=[];try{if([o,c]=await B3(e),e?.externalData&&s.mountExternalData){let x=[];for(let R of e.externalData){let P=typeof R=="string"?R:R.path;x.push(_S(typeof R=="string"?R:R.data).then(D=>{s.mountExternalData(P,D)}))}await Promise.all(x)}for(let x of e?.executionProviders??[])if((typeof x=="string"?x:x.name)==="webnn"){if(s.shouldTransferToMLTensor=!1,typeof x!="string"){let R=x,P=R?.context,D=R?.gpuDevice,z=R?.deviceType,U=R?.powerPreference;P?s.currentContext=P:D?s.currentContext=await s.webnnCreateMLContext(D):s.currentContext=await s.webnnCreateMLContext({deviceType:z,powerPreference:U})}else s.currentContext=await s.webnnCreateMLContext();break}r=await s._OrtCreateSession(t,i,o),s.webgpuOnCreateSession?.(r),r===0&&Fs("Can't create a session."),s.jsepOnCreateSession?.(),s.currentContext&&(s.webnnRegisterMLContext(r,s.currentContext),s.currentContext=void 0,s.shouldTransferToMLTensor=!0);let[p,h]=_B(r),v=!!e?.enableGraphCapture,y=[],w=[],S=[],M=[],T=[];for(let x=0;x<p;x++){let[R,P,D]=fE(r,x);R===0&&Fs("Can't get an input name."),d.push(R);let z=s.UTF8ToString(R);y.push(z),S.push(P===0?{name:z,isTensor:!1}:{name:z,isTensor:!0,type:Gh(P),shape:D})}for(let x=0;x<h;x++){let[R,P,D]=fE(r,x+p);R===0&&Fs("Can't get an output name."),g.push(R);let z=s.UTF8ToString(R);w.push(z),M.push(P===0?{name:z,isTensor:!1}:{name:z,isTensor:!0,type:Gh(P),shape:D});{if(v&&e?.preferredOutputLocation===void 0){T.push("gpu-buffer");continue}let U=typeof e?.preferredOutputLocation=="string"?e.preferredOutputLocation:e?.preferredOutputLocation?.[z]??"cpu";if(U!=="cpu"&&U!=="cpu-pinned"&&U!=="gpu-buffer"&&U!=="ml-tensor")throw new Error(`Not supported preferred output location: ${U}.`);if(v&&U!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${U}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);T.push(U)}}let C=null;return T.some(x=>x==="gpu-buffer"||x==="ml-tensor")&&(l=s._OrtCreateBinding(r),l===0&&Fs("Can't create IO binding."),C={handle:l,outputPreferredLocations:T,outputPreferredLocationsEncoded:T.map(x=>XE(x))}),rm.set(r,[r,d,g,C,v,!1]),[r,y,w,S,M]}catch(p){throw d.forEach(h=>s._OrtFree(h)),g.forEach(h=>s._OrtFree(h)),l!==0&&s._OrtReleaseBinding(l)!==0&&Fs("Can't release IO binding."),r!==0&&s._OrtReleaseSession(r)!==0&&Fs("Can't release session."),p}finally{s._free(t),o!==0&&s._OrtReleaseSessionOptions(o)!==0&&Fs("Can't release session options."),c.forEach(p=>s._free(p)),s.unmountExternalData?.()}},IS=n=>{let e=er(),t=rm.get(n);if(!t)throw new Error(`cannot release session. invalid session id: ${n}`);let[i,s,r,o,l]=t;o&&(l&&e._OrtClearBoundOutputs(o.handle)!==0&&Fs("Can't clear bound outputs."),e._OrtReleaseBinding(o.handle)!==0&&Fs("Can't release IO binding.")),e.jsepOnReleaseSession?.(n),e.webnnOnReleaseSession?.(n),e.webgpuOnReleaseSession?.(n),s.forEach(c=>e._OrtFree(c)),r.forEach(c=>e._OrtFree(c)),e._OrtReleaseSession(i)!==0&&Fs("Can't release session."),rm.delete(n)},hE=async(n,e,t,i,s,r,o=!1)=>{if(!n){e.push(0);return}let l=er(),c=l.PTR_SIZE,d=n[0],g=n[1],p=n[3],h=p,v,y;if(d==="string"&&(p==="gpu-buffer"||p==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(o&&p!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);if(p==="gpu-buffer"){let M=n[2].gpuBuffer;y=Sg(W_(d),g);{let T=l.jsepRegisterBuffer;if(!T)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');v=T(i,r,M,y)}}else if(p==="ml-tensor"){let M=n[2].mlTensor;y=Sg(W_(d),g);let T=l.webnnRegisterMLTensor;if(!T)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');v=T(i,M,W_(d),g)}else{let M=n[2];if(Array.isArray(M)){y=c*M.length,v=l._malloc(y),t.push(v);for(let T=0;T<M.length;T++){if(typeof M[T]!="string")throw new TypeError(`tensor data at index ${T} is not a string`);l.setValue(v+T*c,Dd(M[T],t),"*")}}else{let T=l.webnnIsGraphInput;if(d!=="string"&&T){let C=l.UTF8ToString(s);if(T(i,C)){let x=W_(d);y=Sg(x,g),h="ml-tensor";let R=l.webnnCreateTemporaryTensor,P=l.webnnUploadTensor;if(!R||!P)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let D=await R(i,x,g);P(D,new Uint8Array(M.buffer,M.byteOffset,M.byteLength)),v=D}else y=M.byteLength,v=l._malloc(y),t.push(v),l.HEAPU8.set(new Uint8Array(M.buffer,M.byteOffset,y),v)}else y=M.byteLength,v=l._malloc(y),t.push(v),l.HEAPU8.set(new Uint8Array(M.buffer,M.byteOffset,y),v)}}let w=l.stackSave(),S=l.stackAlloc(4*g.length);try{g.forEach((T,C)=>l.setValue(S+C*c,T,c===4?"i32":"i64"));let M=l._OrtCreateTensor(W_(d),v,y,S,g.length,XE(h));M===0&&Fs(`Can't create tensor for input/output. session=${i}, index=${r}.`),e.push(M)}finally{l.stackRestore(w)}},OS=async(n,e,t,i,s,r)=>{let o=er(),l=o.PTR_SIZE,c=rm.get(n);if(!c)throw new Error(`cannot run inference. invalid session id: ${n}`);let d=c[0],g=c[1],p=c[2],h=c[3],v=c[4],y=c[5],w=e.length,S=i.length,M=0,T=[],C=[],x=[],R=[],P=o.stackSave(),D=o.stackAlloc(w*l),z=o.stackAlloc(w*l),U=o.stackAlloc(S*l),N=o.stackAlloc(S*l);try{[M,T]=D3(r);for(let W=0;W<w;W++)await hE(t[W],C,R,n,g[e[W]],e[W],v);for(let W=0;W<S;W++)await hE(s[W],x,R,n,p[i[W]],w+i[W],v);for(let W=0;W<w;W++)o.setValue(D+W*l,C[W],"*"),o.setValue(z+W*l,g[e[W]],"*");for(let W=0;W<S;W++)o.setValue(U+W*l,x[W],"*"),o.setValue(N+W*l,p[i[W]],"*");if(h&&!y){let{handle:W,outputPreferredLocations:oe,outputPreferredLocationsEncoded:ne}=h;if(g.length!==w)throw new Error(`input count from feeds (${w}) is expected to be always equal to model's input count (${g.length}).`);for(let q=0;q<w;q++){let le=e[q];await o._OrtBindInput(W,g[le],C[q])!==0&&Fs(`Can't bind input[${q}] for session=${n}.`)}for(let q=0;q<S;q++){let le=i[q];s[q]?.[3]?o._OrtBindOutput(W,p[le],x[q],0)!==0&&Fs(`Can't bind pre-allocated output[${q}] for session=${n}.`):o._OrtBindOutput(W,p[le],0,ne[le])!==0&&Fs(`Can't bind output[${q}] to ${oe[q]} for session=${n}.`)}rm.set(n,[d,g,p,h,v,!0])}o.jsepOnRunStart?.(d),o.webnnOnRunStart?.(d);let j;h?j=await o._OrtRunWithBinding(d,h.handle,S,U,M):j=await o._OrtRun(d,z,D,w,N,S,U,M),j!==0&&Fs("failed to call OrtRun().");let J=[];for(let W=0;W<S;W++){let oe=Number(o.getValue(U+W*l,"*"));if(oe===x[W]){J.push(s[W]);continue}let ne=o.stackSave(),q=o.stackAlloc(4*l),le=!1,se,pe=0;try{o._OrtGetTensorData(oe,q,q+l,q+2*l,q+3*l)!==0&&Fs(`Can't access output tensor data on index ${W}.`);let be=l===4?"i32":"i64",ee=Number(o.getValue(q,be));pe=o.getValue(q+l,"*");let te=o.getValue(q+l*2,"*"),ue=Number(o.getValue(q+l*3,be)),ae=[];for(let He=0;He<ue;He++)ae.push(Number(o.getValue(te+He*l,be)));o._OrtFree(te)!==0&&Fs("Can't free memory for tensor dims.");let ce=ae.reduce((He,Xe)=>He*Xe,1);se=Gh(ee);let Be=h?.outputPreferredLocations[i[W]];if(se==="string"){if(Be==="gpu-buffer"||Be==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let He=[];for(let Xe=0;Xe<ce;Xe++){let ot=o.getValue(pe+Xe*l,"*"),tt=o.getValue(pe+(Xe+1)*l,"*"),Ae=Xe===ce-1?void 0:tt-ot;He.push(o.UTF8ToString(ot,Ae))}J.push([se,ae,He,"cpu"])}else if(Be==="gpu-buffer"&&ce>0){let He=o.jsepGetBuffer;if(!He)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let Xe=He(pe),ot=Sg(ee,ce);if(ot===void 0||!mS(se))throw new Error(`Unsupported data type: ${se}`);le=!0,J.push([se,ae,{gpuBuffer:Xe,download:o.jsepCreateDownloader(Xe,ot,se),dispose:()=>{o._OrtReleaseTensor(oe)!==0&&Fs("Can't release tensor.")}},"gpu-buffer"])}else if(Be==="ml-tensor"&&ce>0){let He=o.webnnEnsureTensor,Xe=o.webnnIsInt64Supported;if(!He||!Xe)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(Sg(ee,ce)===void 0||!gS(se))throw new Error(`Unsupported data type: ${se}`);if(se==="int64"&&!Xe(n))throw new Error('preferredLocation "ml-tensor" for int64 output is not supported by current WebNN Context.');let ot=await He(n,pe,ee,ae,!1);le=!0,J.push([se,ae,{mlTensor:ot,download:o.webnnCreateMLTensorDownloader(pe,se),dispose:()=>{o.webnnReleaseTensorId(pe),o._OrtReleaseTensor(oe)}},"ml-tensor"])}else{let He=pS(se),Xe=new He(ce);new Uint8Array(Xe.buffer,Xe.byteOffset,Xe.byteLength).set(o.HEAPU8.subarray(pe,pe+Xe.byteLength)),J.push([se,ae,Xe,"cpu"])}}finally{o.stackRestore(ne),se==="string"&&pe&&o._free(pe),le||o._OrtReleaseTensor(oe),o.webnnOnRunEnd?.(d)}}return h&&!v&&(o._OrtClearBoundOutputs(h.handle)!==0&&Fs("Can't clear bound outputs."),rm.set(n,[d,g,p,h,v,!1])),J}finally{o.stackRestore(P),C.forEach(j=>o._OrtReleaseTensor(j)),x.forEach(j=>o._OrtReleaseTensor(j)),R.forEach(j=>o._free(j)),M!==0&&o._OrtReleaseRunOptions(M),T.forEach(j=>o._free(j))}},LS=n=>{let e=er(),t=rm.get(n);if(!t)throw new Error("invalid session id");let i=t[0],s=e._OrtEndProfiling(i);s===0&&Fs("Can't get an profile file name."),e._OrtFree(s)},FS=n=>{let e=[];for(let t of n){let i=t[2];!Array.isArray(i)&&"buffer"in i&&e.push(i.buffer)}return e}}),am,Rc,j_,ov,lv,FM,pE,NM,_g,vg,vB,DN,BN,IN,ON,LN,FN,NN,zN=fn(()=>{Gd(),RN(),n_(),dS(),am=()=>!!ur.wasm.proxy&&typeof document<"u",j_=!1,ov=!1,lv=!1,NM=new Map,_g=(n,e)=>{let t=NM.get(n);t?t.push(e):NM.set(n,[e])},vg=()=>{if(j_||!ov||lv||!Rc)throw new Error("worker not ready")},vB=n=>{switch(n.data.type){case"init-wasm":j_=!1,n.data.err?(lv=!0,pE[1](n.data.err)):(ov=!0,pE[0]()),FM&&(URL.revokeObjectURL(FM),FM=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=NM.get(n.data.type);n.data.err?e.shift()[1](n.data.err):e.shift()[0](n.data.out);break}}},DN=async()=>{if(!ov){if(j_)throw new Error("multiple calls to 'initWasm()' detected.");if(lv)throw new Error("previous call to 'initWasm()' failed.");if(j_=!0,am())return new Promise((n,e)=>{Rc?.terminate(),P3().then(([t,i])=>{try{Rc=i,Rc.onerror=r=>e(r),Rc.onmessage=vB,pE=[n,e];let s={type:"init-wasm",in:ur};!s.in.wasm.wasmPaths&&(t||qE)&&(s.in.wasm.wasmPaths={wasm:new URL("/assets/ort-wasm-simd-threaded.jsep-B0T3yYHD.wasm",import.meta.url).href}),Rc.postMessage(s),FM=t}catch(s){e(s)}},e)});try{await fS(ur.wasm),await RS(ur),ov=!0}catch(n){throw lv=!0,n}finally{j_=!1}}},BN=async n=>{if(am())return vg(),new Promise((e,t)=>{_g("init-ep",[e,t]);let i={type:"init-ep",in:{epName:n,env:ur}};Rc.postMessage(i)});await DS(ur,n)},IN=async n=>am()?(vg(),new Promise((e,t)=>{_g("copy-from",[e,t]);let i={type:"copy-from",in:{buffer:n}};Rc.postMessage(i,[n.buffer])})):$b(n),ON=async(n,e)=>{if(am()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return vg(),new Promise((t,i)=>{_g("create",[t,i]);let s={type:"create",in:{model:n,options:{...e}}},r=[];n instanceof Uint8Array&&r.push(n.buffer),Rc.postMessage(s,r)})}else return BS(n,e)},LN=async n=>{if(am())return vg(),new Promise((e,t)=>{_g("release",[e,t]);let i={type:"release",in:n};Rc.postMessage(i)});IS(n)},FN=async(n,e,t,i,s,r)=>{if(am()){if(t.some(o=>o[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(s.some(o=>o))throw new Error("pre-allocated output tensor is not supported for proxy.");return vg(),new Promise((o,l)=>{_g("run",[o,l]);let c=t,d={type:"run",in:{sessionId:n,inputIndices:e,inputs:c,outputIndices:i,options:r}};Rc.postMessage(d,FS(c))})}else return OS(n,e,t,i,s,r)},NN=async n=>{if(am())return vg(),new Promise((e,t)=>{_g("end-profiling",[e,t]);let i={type:"end-profiling",in:n};Rc.postMessage(i)});LS(n)}}),mE,yB,UN,yK=fn(()=>{Gd(),zN(),ai(),cS(),I3(),mE=(n,e)=>{switch(n.location){case"cpu":return[n.type,n.dims,n.data,"cpu"];case"gpu-buffer":return[n.type,n.dims,{gpuBuffer:n.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[n.type,n.dims,{mlTensor:n.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${n.location} for ${e()}`)}},yB=n=>{switch(n[3]){case"cpu":return new Id(n[0],n[2],n[1]);case"gpu-buffer":{let e=n[0];if(!mS(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:t,download:i,dispose:s}=n[2];return Id.fromGpuBuffer(t,{dataType:e,dims:n[1],download:i,dispose:s})}case"ml-tensor":{let e=n[0];if(!gS(e))throw new Error(`not supported data type: ${e} for deserializing MLTensor tensor`);let{mlTensor:t,download:i,dispose:s}=n[2];return Id.fromMLTensor(t,{dataType:e,dims:n[1],download:i,dispose:s})}default:throw new Error(`invalid data location: ${n[3]}`)}},UN=class{async fetchModelAndCopyToWasmMemory(n){return IN(await _S(n))}async loadModel(n,e){zd();let t;typeof n=="string"?t=await this.fetchModelAndCopyToWasmMemory(n):t=n,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await ON(t,e),Fc()}async dispose(){return LN(this.sessionId)}async run(n,e,t){zd();let i=[],s=[];Object.entries(n).forEach(p=>{let h=p[0],v=p[1],y=this.inputNames.indexOf(h);if(y===-1)throw new Error(`invalid input '${h}'`);i.push(v),s.push(y)});let r=[],o=[];Object.entries(e).forEach(p=>{let h=p[0],v=p[1],y=this.outputNames.indexOf(h);if(y===-1)throw new Error(`invalid output '${h}'`);r.push(v),o.push(y)});let l=i.map((p,h)=>mE(p,()=>`input "${this.inputNames[s[h]]}"`)),c=r.map((p,h)=>p?mE(p,()=>`output "${this.outputNames[o[h]]}"`):null),d=await FN(this.sessionId,s,l,o,c,t),g={};for(let p=0;p<d.length;p++)g[this.outputNames[o[p]]]=r[p]??yB(d[p]);return Fc(),g}startProfiling(){}endProfiling(){NN(this.sessionId)}}}),kN={};E0(kN,{OnnxruntimeWebAssemblyBackend:()=>uT,initializeFlags:()=>lT,wasmBackend:()=>GN});var lT,uT,GN,MK=fn(()=>{Gd(),zN(),yK(),lT=()=>{(typeof ur.wasm.initTimeout!="number"||ur.wasm.initTimeout<0)&&(ur.wasm.initTimeout=0);let n=ur.wasm.simd;if(typeof n!="boolean"&&n!==void 0&&n!=="fixed"&&n!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${n}". Reset it to \`false\` and ignore SIMD feature checking.`),ur.wasm.simd=!1),typeof ur.wasm.proxy!="boolean"&&(ur.wasm.proxy=!1),typeof ur.wasm.trace!="boolean"&&(ur.wasm.trace=!1),typeof ur.wasm.numThreads!="number"||!Number.isInteger(ur.wasm.numThreads)||ur.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)ur.wasm.numThreads=1;else{let e=typeof navigator>"u"?aW("node:os").cpus().length:navigator.hardwareConcurrency;ur.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},uT=class{async init(n){lT(),await DN(),await BN(n)}async createInferenceSessionHandler(n,e){let t=new UN;return await t.loadModel(n,e),t}},GN=new uT});Gd();Gd();Gd();var bK="1.22.0-dev.20250409-89f8206ba4",xK=w3;{let n=(MK(),Vv(kN)).wasmBackend;Ig("webgpu",n,5),Ig("webnn",n,5),Ig("cpu",n,10),Ig("wasm",n,10)}Object.defineProperty(ur.versions,"web",{value:bK,enumerable:!0});const wK=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return uS},get TRACE(){return Hv},get TRACE_FUNC_BEGIN(){return zd},get TRACE_FUNC_END(){return Fc},get Tensor(){return Id},default:xK,get env(){return ur},get registerBackend(){return Ig}},Symbol.toStringTag,{value:"Module"}));var gE={},EK={"onnxruntime-common":(n=>{n.exports=nW}),"onnxruntime-web":(n=>{n.exports=wK}),"?2ce3":(()=>{}),"?7992":(()=>{}),"?5af5":(()=>{}),"?2b25":(()=>{}),"?db59":(()=>{}),"?383f":(()=>{}),"?fa4b":(()=>{}),"./node_modules/@huggingface/jinja/dist/index.js":((n,e,t)=>{t.r(e),t.d(e,{Environment:()=>at,Interpreter:()=>Dt,Template:()=>Ee,parse:()=>Be,tokenize:()=>g});var i=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Comment:"Comment"}),s=class{constructor(k,re){this.value=k,this.type=re}};function r(k){return/\w/.test(k)}function o(k){return/[0-9]/.test(k)}var l=[["{%",i.OpenStatement],["%}",i.CloseStatement],["{{",i.OpenExpression],["}}",i.CloseExpression],["(",i.OpenParen],[")",i.CloseParen],["{",i.OpenCurlyBracket],["}",i.CloseCurlyBracket],["[",i.OpenSquareBracket],["]",i.CloseSquareBracket],[",",i.Comma],[".",i.Dot],[":",i.Colon],["|",i.Pipe],["<=",i.ComparisonBinaryOperator],[">=",i.ComparisonBinaryOperator],["==",i.ComparisonBinaryOperator],["!=",i.ComparisonBinaryOperator],["<",i.ComparisonBinaryOperator],[">",i.ComparisonBinaryOperator],["+",i.AdditiveBinaryOperator],["-",i.AdditiveBinaryOperator],["~",i.AdditiveBinaryOperator],["*",i.MultiplicativeBinaryOperator],["/",i.MultiplicativeBinaryOperator],["%",i.MultiplicativeBinaryOperator],["=",i.Equals]],c=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function d(k,re={}){return k.endsWith(`
`)&&(k=k.slice(0,-1)),re.lstrip_blocks&&(k=k.replace(/^[ \t]*({[#%-])/gm,"$1")),re.trim_blocks&&(k=k.replace(/([#%-]})\n/g,"$1")),k.replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{").replace(/-#}\s*/g,"#}").replace(/\s*{#-/g,"{#").replace(/{%\s*(end)?generation\s*%}/gs,"")}function g(k,re={}){const Q=[],ve=d(k,re);let ge=0,Le=0;const rt=nt=>{let ft="";for(;nt(ve[ge]);){if(ve[ge]==="\\"){if(++ge,ge>=ve.length)throw new SyntaxError("Unexpected end of input");const yt=ve[ge++],Ne=c.get(yt);if(Ne===void 0)throw new SyntaxError(`Unexpected escaped character: ${yt}`);ft+=Ne;continue}if(ft+=ve[ge++],ge>=ve.length)throw new SyntaxError("Unexpected end of input")}return ft};e:for(;ge<ve.length;){const nt=Q.at(-1)?.type;if(nt===void 0||nt===i.CloseStatement||nt===i.CloseExpression||nt===i.Comment){let yt="";for(;ge<ve.length&&!(ve[ge]==="{"&&(ve[ge+1]==="%"||ve[ge+1]==="{"||ve[ge+1]==="#"));)yt+=ve[ge++];if(yt.length>0){Q.push(new s(yt,i.Text));continue}}if(ve[ge]==="{"&&ve[ge+1]==="#"){ge+=2;let yt="";for(;ve[ge]!=="#"||ve[ge+1]!=="}";){if(ge+2>=ve.length)throw new SyntaxError("Missing end of comment tag");yt+=ve[ge++]}Q.push(new s(yt,i.Comment)),ge+=2;continue}rt(yt=>/\s/.test(yt));const ft=ve[ge];if(ft==="-"||ft==="+"){const yt=Q.at(-1)?.type;if(yt===i.Text||yt===void 0)throw new SyntaxError(`Unexpected character: ${ft}`);switch(yt){case i.Identifier:case i.NumericLiteral:case i.StringLiteral:case i.CloseParen:case i.CloseSquareBracket:break;default:{++ge;const Ne=rt(o);Q.push(new s(`${ft}${Ne}`,Ne.length>0?i.NumericLiteral:i.UnaryOperator));continue}}}for(const[yt,Ne]of l){if(yt==="}}"&&Le>0)continue;if(ve.slice(ge,ge+yt.length)===yt){Q.push(new s(yt,Ne)),Ne===i.OpenExpression?Le=0:Ne===i.OpenCurlyBracket?++Le:Ne===i.CloseCurlyBracket&&--Le,ge+=yt.length;continue e}}if(ft==="'"||ft==='"'){++ge;const yt=rt(Ne=>Ne!==ft);Q.push(new s(yt,i.StringLiteral)),++ge;continue}if(o(ft)){let yt=rt(o);if(ve[ge]==="."&&o(ve[ge+1])){++ge;const Ne=rt(o);yt=`${yt}.${Ne}`}Q.push(new s(yt,i.NumericLiteral));continue}if(r(ft)){const yt=rt(r);Q.push(new s(yt,i.Identifier));continue}throw new SyntaxError(`Unexpected character: ${ft}`)}return Q}var p=class{type="Statement"},h=class extends p{constructor(k){super(),this.body=k}type="Program"},v=class extends p{constructor(k,re,Q){super(),this.test=k,this.body=re,this.alternate=Q}type="If"},y=class extends p{constructor(k,re,Q,ve){super(),this.loopvar=k,this.iterable=re,this.body=Q,this.defaultBlock=ve}type="For"},w=class extends p{type="Break"},S=class extends p{type="Continue"},M=class extends p{constructor(k,re,Q){super(),this.assignee=k,this.value=re,this.body=Q}type="Set"},T=class extends p{constructor(k,re,Q){super(),this.name=k,this.args=re,this.body=Q}type="Macro"},C=class extends p{constructor(k){super(),this.value=k}type="Comment"},x=class extends p{type="Expression"},R=class extends x{constructor(k,re,Q){super(),this.object=k,this.property=re,this.computed=Q}type="MemberExpression"},P=class extends x{constructor(k,re){super(),this.callee=k,this.args=re}type="CallExpression"},D=class extends x{constructor(k){super(),this.value=k}type="Identifier"},z=class extends x{constructor(k){super(),this.value=k}type="Literal"},U=class extends z{type="IntegerLiteral"},N=class extends z{type="FloatLiteral"},j=class extends z{type="StringLiteral"},J=class extends z{type="ArrayLiteral"},W=class extends z{type="TupleLiteral"},oe=class extends z{type="ObjectLiteral"},ne=class extends x{constructor(k,re,Q){super(),this.operator=k,this.left=re,this.right=Q}type="BinaryExpression"},q=class extends x{constructor(k,re){super(),this.operand=k,this.filter=re}type="FilterExpression"},le=class extends p{constructor(k,re){super(),this.filter=k,this.body=re}type="FilterStatement"},se=class extends x{constructor(k,re){super(),this.lhs=k,this.test=re}type="SelectExpression"},pe=class extends x{constructor(k,re,Q){super(),this.operand=k,this.negate=re,this.test=Q}type="TestExpression"},be=class extends x{constructor(k,re){super(),this.operator=k,this.argument=re}type="UnaryExpression"},ee=class extends x{constructor(k=void 0,re=void 0,Q=void 0){super(),this.start=k,this.stop=re,this.step=Q}type="SliceExpression"},te=class extends x{constructor(k,re){super(),this.key=k,this.value=re}type="KeywordArgumentExpression"},ue=class extends x{constructor(k){super(),this.argument=k}type="SpreadExpression"},ae=class extends p{constructor(k,re,Q){super(),this.call=k,this.callerArgs=re,this.body=Q}type="CallStatement"},ce=class extends x{constructor(k,re,Q){super(),this.condition=k,this.trueExpr=re,this.falseExpr=Q}type="Ternary"};function Be(k){const re=new h([]);let Q=0;function ve(Ct,gt){const Qt=k[Q++];if(!Qt||Qt.type!==Ct)throw new Error(`Parser Error: ${gt}. ${Qt.type} !== ${Ct}.`);return Qt}function ge(Ct){if(!ft(Ct))throw new SyntaxError(`Expected ${Ct}`);++Q}function Le(){switch(k[Q].type){case i.Comment:return new C(k[Q++].value);case i.Text:return yt();case i.OpenStatement:return Ne();case i.OpenExpression:return Bt();default:throw new SyntaxError(`Unexpected token type: ${k[Q].type}`)}}function rt(...Ct){return Q+Ct.length<=k.length&&Ct.every((gt,Qt)=>gt===k[Q+Qt].type)}function nt(...Ct){return k[Q]?.type===i.OpenStatement&&k[Q+1]?.type===i.Identifier&&Ct.includes(k[Q+1]?.value)}function ft(...Ct){return Q+Ct.length<=k.length&&Ct.every((gt,Qt)=>k[Q+Qt].type==="Identifier"&&gt===k[Q+Qt].value)}function yt(){return new j(ve(i.Text,"Expected text token").value)}function Ne(){if(ve(i.OpenStatement,"Expected opening statement token"),k[Q].type!==i.Identifier)throw new SyntaxError(`Unknown statement, got ${k[Q].type}`);const Ct=k[Q].value;let gt;switch(Ct){case"set":++Q,gt=on();break;case"if":++Q,gt=xn(),ve(i.OpenStatement,"Expected {% token"),ge("endif"),ve(i.CloseStatement,"Expected %} token");break;case"macro":++Q,gt=Bn(),ve(i.OpenStatement,"Expected {% token"),ge("endmacro"),ve(i.CloseStatement,"Expected %} token");break;case"for":++Q,gt=gn(),ve(i.OpenStatement,"Expected {% token"),ge("endfor"),ve(i.CloseStatement,"Expected %} token");break;case"call":{++Q;let Qt=null;rt(i.OpenParen)&&(Qt=en());const Nn=Ln();if(Nn.type!=="Identifier")throw new SyntaxError("Expected identifier following call statement");const Ss=en();ve(i.CloseStatement,"Expected closing statement token");const yr=[];for(;!nt("endcall");)yr.push(Le());ve(i.OpenStatement,"Expected '{%'"),ge("endcall"),ve(i.CloseStatement,"Expected closing statement token");const $i=new P(Nn,Ss);gt=new ae($i,Qt,yr);break}case"break":++Q,ve(i.CloseStatement,"Expected closing statement token"),gt=new w;break;case"continue":++Q,ve(i.CloseStatement,"Expected closing statement token"),gt=new S;break;case"filter":{++Q;let Qt=Ln();Qt instanceof D&&rt(i.OpenParen)&&(Qt=tn(Qt)),ve(i.CloseStatement,"Expected closing statement token");const Nn=[];for(;!nt("endfilter");)Nn.push(Le());ve(i.OpenStatement,"Expected '{%'"),ge("endfilter"),ve(i.CloseStatement,"Expected '%}'"),gt=new le(Qt,Nn);break}default:throw new SyntaxError(`Unknown statement type: ${Ct}`)}return gt}function Bt(){ve(i.OpenExpression,"Expected opening expression token");const Ct=Mn();return ve(i.CloseExpression,"Expected closing expression token"),Ct}function on(){const Ct=bi();let gt=null;const Qt=[];if(rt(i.Equals))++Q,gt=bi();else{for(ve(i.CloseStatement,"Expected %} token");!nt("endset");)Qt.push(Le());ve(i.OpenStatement,"Expected {% token"),ge("endset")}return ve(i.CloseStatement,"Expected closing statement token"),new M(Ct,gt,Qt)}function xn(){const Ct=Mn();ve(i.CloseStatement,"Expected closing statement token");const gt=[],Qt=[];for(;!nt("elif","else","endif");)gt.push(Le());if(nt("elif")){++Q,++Q;const Nn=xn();Qt.push(Nn)}else if(nt("else"))for(++Q,++Q,ve(i.CloseStatement,"Expected closing statement token");!nt("endif");)Qt.push(Le());return new v(Ct,gt,Qt)}function Bn(){const Ct=Ln();if(Ct.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const gt=en();ve(i.CloseStatement,"Expected closing statement token");const Qt=[];for(;!nt("endmacro");)Qt.push(Le());return new T(Ct,gt,Qt)}function bi(Ct=!1){const gt=Ct?Ln:Mn,Qt=[gt()],Nn=rt(i.Comma);for(;Nn&&(++Q,Qt.push(gt()),!!rt(i.Comma)););return Nn?new W(Qt):Qt[0]}function gn(){const Ct=bi(!0);if(!(Ct instanceof D||Ct instanceof W))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${Ct.type} instead`);if(!ft("in"))throw new SyntaxError("Expected `in` keyword following loop variable");++Q;const gt=Mn();ve(i.CloseStatement,"Expected closing statement token");const Qt=[];for(;!nt("endfor","else");)Qt.push(Le());const Nn=[];if(nt("else"))for(++Q,++Q,ve(i.CloseStatement,"Expected closing statement token");!nt("endfor");)Nn.push(Le());return new y(Ct,gt,Qt,Nn)}function Mn(){return Se()}function Se(){const Ct=we();if(ft("if")){++Q;const gt=we();if(ft("else")){++Q;const Qt=Se();return new ce(gt,Ct,Qt)}else return new se(Ct,gt)}return Ct}function we(){let Ct=Ge();for(;ft("or");){const gt=k[Q];++Q;const Qt=Ge();Ct=new ne(gt,Ct,Qt)}return Ct}function Ge(){let Ct=Je();for(;ft("and");){const gt=k[Q];++Q;const Qt=Je();Ct=new ne(gt,Ct,Qt)}return Ct}function Je(){let Ct;for(;ft("not");){const gt=k[Q];++Q;const Qt=Je();Ct=new be(gt,Qt)}return Ct??Ue()}function Ue(){let Ct=Ot();for(;;){let gt;if(ft("not","in"))gt=new s("not in",i.Identifier),Q+=2;else if(ft("in"))gt=k[Q++];else if(rt(i.ComparisonBinaryOperator))gt=k[Q++];else break;const Qt=Ot();Ct=new ne(gt,Ct,Qt)}return Ct}function Ot(){let Ct=Fn();for(;rt(i.AdditiveBinaryOperator);){const gt=k[Q];++Q;const Qt=Fn();Ct=new ne(gt,Ct,Qt)}return Ct}function jt(){const Ct=_n(Ln());return rt(i.OpenParen)?tn(Ct):Ct}function tn(Ct){let gt=new P(Ct,en());return gt=_n(gt),rt(i.OpenParen)&&(gt=tn(gt)),gt}function en(){ve(i.OpenParen,"Expected opening parenthesis for arguments list");const Ct=dn();return ve(i.CloseParen,"Expected closing parenthesis for arguments list"),Ct}function dn(){const Ct=[];for(;!rt(i.CloseParen);){let gt;if(k[Q].type===i.MultiplicativeBinaryOperator&&k[Q].value==="*"){++Q;const Qt=Mn();gt=new ue(Qt)}else if(gt=Mn(),rt(i.Equals)){if(++Q,!(gt instanceof D))throw new SyntaxError("Expected identifier for keyword argument");const Qt=Mn();gt=new te(gt,Qt)}Ct.push(gt),rt(i.Comma)&&++Q}return Ct}function wn(){const Ct=[];let gt=!1;for(;!rt(i.CloseSquareBracket);)rt(i.Colon)?(Ct.push(void 0),++Q,gt=!0):(Ct.push(Mn()),rt(i.Colon)&&(++Q,gt=!0));if(Ct.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(gt){if(Ct.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new ee(...Ct)}return Ct[0]}function _n(Ct){for(;rt(i.Dot)||rt(i.OpenSquareBracket);){const gt=k[Q];++Q;let Qt;const Nn=gt.type===i.OpenSquareBracket;if(Nn)Qt=wn(),ve(i.CloseSquareBracket,"Expected closing square bracket");else if(Qt=Ln(),Qt.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");Ct=new R(Ct,Qt,Nn)}return Ct}function Fn(){let Ct=ti();for(;rt(i.MultiplicativeBinaryOperator);){const gt=k[Q++],Qt=ti();Ct=new ne(gt,Ct,Qt)}return Ct}function ti(){let Ct=Pn();for(;ft("is");){++Q;const gt=ft("not");gt&&++Q;const Qt=Ln();if(!(Qt instanceof D))throw new SyntaxError("Expected identifier for the test");Ct=new pe(Ct,gt,Qt)}return Ct}function Pn(){let Ct=jt();for(;rt(i.Pipe);){++Q;let gt=Ln();if(!(gt instanceof D))throw new SyntaxError("Expected identifier for the filter");rt(i.OpenParen)&&(gt=tn(gt)),Ct=new q(Ct,gt)}return Ct}function Ln(){const Ct=k[Q++];switch(Ct.type){case i.NumericLiteral:{const gt=Ct.value;return gt.includes(".")?new N(Number(gt)):new U(Number(gt))}case i.StringLiteral:{let gt=Ct.value;for(;rt(i.StringLiteral);)gt+=k[Q++].value;return new j(gt)}case i.Identifier:return new D(Ct.value);case i.OpenParen:{const gt=bi();return ve(i.CloseParen,"Expected closing parenthesis, got ${tokens[current].type} instead."),gt}case i.OpenSquareBracket:{const gt=[];for(;!rt(i.CloseSquareBracket);)gt.push(Mn()),rt(i.Comma)&&++Q;return++Q,new J(gt)}case i.OpenCurlyBracket:{const gt=new Map;for(;!rt(i.CloseCurlyBracket);){const Qt=Mn();ve(i.Colon,"Expected colon between key and value in object literal");const Nn=Mn();gt.set(Qt,Nn),rt(i.Comma)&&++Q}return++Q,new oe(gt)}default:throw new SyntaxError(`Unexpected token: ${Ct.type}`)}}for(;Q<k.length;)re.body.push(Le());return re}function He(k,re,Q=1){re===void 0&&(re=k,k=0);const ve=[];for(let ge=k;ge<re;ge+=Q)ve.push(ge);return ve}function Xe(k,re,Q,ve=1){const ge=Math.sign(ve);ge>=0?(re=(re??=0)<0?Math.max(k.length+re,0):Math.min(re,k.length),Q=(Q??=k.length)<0?Math.max(k.length+Q,0):Math.min(Q,k.length)):(re=(re??=k.length-1)<0?Math.max(k.length+re,-1):Math.min(re,k.length-1),Q=(Q??=-1)<-1?Math.max(k.length+Q,-1):Math.min(Q,k.length-1));const Le=[];for(let rt=re;ge*rt<ge*Q;rt+=ve)Le.push(k[rt]);return Le}function ot(k){return k.replace(/\b\w/g,re=>re.toUpperCase())}function tt(k){return Ae(new Date,k)}function Ae(k,re){const Q=new Intl.DateTimeFormat(void 0,{month:"long"}),ve=new Intl.DateTimeFormat(void 0,{month:"short"}),ge=Le=>Le<10?"0"+Le:Le.toString();return re.replace(/%[YmdbBHM%]/g,Le=>{switch(Le){case"%Y":return k.getFullYear().toString();case"%m":return ge(k.getMonth()+1);case"%d":return ge(k.getDate());case"%b":return ve.format(k);case"%B":return Q.format(k);case"%H":return ge(k.getHours());case"%M":return ge(k.getMinutes());case"%%":return"%";default:return Le}})}function ye(k){return k.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function xe(k,re,Q,ve){if(ve===0)return k;let ge=ve==null||ve<0?1/0:ve;const Le=re.length===0?new RegExp("(?=)","gu"):new RegExp(ye(re),"gu");return k.replaceAll(Le,rt=>ge>0?(--ge,Q):rt)}var ke=class extends Error{},ze=class extends Error{},je=class{type="RuntimeValue";value;builtins=new Map;constructor(k=void 0){this.value=k}__bool__(){return new Qe(!!this.value)}toString(){return String(this.value)}},Fe=class extends je{type="IntegerValue"},Ye=class extends je{type="FloatValue";toString(){return this.value%1===0?this.value.toFixed(1):this.value.toString()}},Ve=class extends je{type="StringValue";builtins=new Map([["upper",new $e(()=>new Ve(this.value.toUpperCase()))],["lower",new $e(()=>new Ve(this.value.toLowerCase()))],["strip",new $e(()=>new Ve(this.value.trim()))],["title",new $e(()=>new Ve(ot(this.value)))],["capitalize",new $e(()=>new Ve(this.value.charAt(0).toUpperCase()+this.value.slice(1)))],["length",new Fe(this.value.length)],["rstrip",new $e(()=>new Ve(this.value.trimEnd()))],["lstrip",new $e(()=>new Ve(this.value.trimStart()))],["startswith",new $e(k=>{if(k.length===0)throw new Error("startswith() requires at least one argument");const re=k[0];if(re instanceof Ve)return new Qe(this.value.startsWith(re.value));if(re instanceof Me){for(const Q of re.value){if(!(Q instanceof Ve))throw new Error("startswith() tuple elements must be strings");if(this.value.startsWith(Q.value))return new Qe(!0)}return new Qe(!1)}throw new Error("startswith() argument must be a string or tuple of strings")})],["endswith",new $e(k=>{if(k.length===0)throw new Error("endswith() requires at least one argument");const re=k[0];if(re instanceof Ve)return new Qe(this.value.endsWith(re.value));if(re instanceof Me){for(const Q of re.value){if(!(Q instanceof Ve))throw new Error("endswith() tuple elements must be strings");if(this.value.endsWith(Q.value))return new Qe(!0)}return new Qe(!1)}throw new Error("endswith() argument must be a string or tuple of strings")})],["split",new $e(k=>{const re=k[0]??new et;if(!(re instanceof Ve||re instanceof et))throw new Error("sep argument must be a string or null");const Q=k[1]??new Fe(-1);if(!(Q instanceof Fe))throw new Error("maxsplit argument must be a number");let ve=[];if(re instanceof et){const ge=this.value.trimStart();for(const{0:Le,index:rt}of ge.matchAll(/\S+/g)){if(Q.value!==-1&&ve.length>=Q.value&&rt!==void 0){ve.push(Le+ge.slice(rt+Le.length));break}ve.push(Le)}}else{if(re.value==="")throw new Error("empty separator");ve=this.value.split(re.value),Q.value!==-1&&ve.length>Q.value&&ve.push(ve.splice(Q.value).join(re.value))}return new Me(ve.map(ge=>new Ve(ge)))})],["replace",new $e(k=>{if(k.length<2)throw new Error("replace() requires at least two arguments");const re=k[0],Q=k[1];if(!(re instanceof Ve&&Q instanceof Ve))throw new Error("replace() arguments must be strings");let ve;if(k.length>2?k[2].type==="KeywordArgumentsValue"?ve=k[2].value.get("count")??new et:ve=k[2]:ve=new et,!(ve instanceof Fe||ve instanceof et))throw new Error("replace() count argument must be a number or null");return new Ve(xe(this.value,re.value,Q.value,ve.value))})]])},Qe=class extends je{type="BooleanValue"},mt=class extends je{type="ObjectValue";__bool__(){return new Qe(this.value.size>0)}builtins=new Map([["get",new $e(([k,re])=>{if(!(k instanceof Ve))throw new Error(`Object key must be a string: got ${k.type}`);return this.value.get(k.value)??re??new et})],["items",new $e(()=>this.items())],["keys",new $e(()=>this.keys())],["values",new $e(()=>this.values())]]);items(){return new Me(Array.from(this.value.entries()).map(([k,re])=>new Me([new Ve(k),re])))}keys(){return new Me(Array.from(this.value.keys()).map(k=>new Ve(k)))}values(){return new Me(Array.from(this.value.values()))}},Tt=class extends mt{type="KeywordArgumentsValue"},Me=class extends je{type="ArrayValue";builtins=new Map([["length",new Fe(this.value.length)]]);__bool__(){return new Qe(this.value.length>0)}},me=class extends Me{type="TupleValue"},$e=class extends je{type="FunctionValue"},et=class extends je{type="NullValue"},ht=class extends je{type="UndefinedValue"},at=class{constructor(k){this.parent=k}variables=new Map([["namespace",new $e(k=>{if(k.length===0)return new mt(new Map);if(k.length!==1||!(k[0]instanceof mt))throw new Error("`namespace` expects either zero arguments or a single object argument");return k[0]})]]);tests=new Map([["boolean",k=>k.type==="BooleanValue"],["callable",k=>k instanceof $e],["odd",k=>{if(!(k instanceof Fe))throw new Error(`cannot odd on ${k.type}`);return k.value%2!==0}],["even",k=>{if(!(k instanceof Fe))throw new Error(`cannot even on ${k.type}`);return k.value%2===0}],["false",k=>k.type==="BooleanValue"&&!k.value],["true",k=>k.type==="BooleanValue"&&k.value],["none",k=>k.type==="NullValue"],["string",k=>k.type==="StringValue"],["number",k=>k instanceof Fe||k instanceof Ye],["integer",k=>k instanceof Fe],["iterable",k=>k.type==="ArrayValue"||k.type==="StringValue"],["mapping",k=>k.type==="ObjectValue"],["lower",k=>{const re=k.value;return k.type==="StringValue"&&re===re.toLowerCase()}],["upper",k=>{const re=k.value;return k.type==="StringValue"&&re===re.toUpperCase()}],["none",k=>k.type==="NullValue"],["defined",k=>k.type!=="UndefinedValue"],["undefined",k=>k.type==="UndefinedValue"],["equalto",(k,re)=>k.value===re.value],["eq",(k,re)=>k.value===re.value]]);set(k,re){return this.declareVariable(k,Vt(re))}declareVariable(k,re){if(this.variables.has(k))throw new SyntaxError(`Variable already declared: ${k}`);return this.variables.set(k,re),re}setVariable(k,re){return this.variables.set(k,re),re}resolve(k){if(this.variables.has(k))return this;if(this.parent)return this.parent.resolve(k);throw new Error(`Unknown variable: ${k}`)}lookupVariable(k){try{return this.resolve(k).variables.get(k)??new ht}catch{return new ht}}};function Et(k){k.set("false",!1),k.set("true",!0),k.set("none",null),k.set("raise_exception",re=>{throw new Error(re)}),k.set("range",He),k.set("strftime_now",tt),k.set("True",!0),k.set("False",!1),k.set("None",null)}var Dt=class{global;constructor(k){this.global=k??new at}run(k){return this.evaluate(k,this.global)}evaluateBinaryExpression(k,re){const Q=this.evaluate(k.left,re);switch(k.operator.value){case"and":return Q.__bool__().value?this.evaluate(k.right,re):Q;case"or":return Q.__bool__().value?Q:this.evaluate(k.right,re)}const ve=this.evaluate(k.right,re);switch(k.operator.value){case"==":return new Qe(Q.value==ve.value);case"!=":return new Qe(Q.value!=ve.value)}if(Q instanceof ht||ve instanceof ht){if(ve instanceof ht&&["in","not in"].includes(k.operator.value))return new Qe(k.operator.value==="not in");throw new Error(`Cannot perform operation ${k.operator.value} on undefined values`)}else{if(Q instanceof et||ve instanceof et)throw new Error("Cannot perform operation on null values");if(k.operator.value==="~")return new Ve(Q.value.toString()+ve.value.toString());if((Q instanceof Fe||Q instanceof Ye)&&(ve instanceof Fe||ve instanceof Ye)){const ge=Q.value,Le=ve.value;switch(k.operator.value){case"+":case"-":case"*":{const rt=k.operator.value==="+"?ge+Le:k.operator.value==="-"?ge-Le:ge*Le;return Q instanceof Ye||ve instanceof Ye?new Ye(rt):new Fe(rt)}case"/":return new Ye(ge/Le);case"%":{const rt=ge%Le;return Q instanceof Ye||ve instanceof Ye?new Ye(rt):new Fe(rt)}case"<":return new Qe(ge<Le);case">":return new Qe(ge>Le);case">=":return new Qe(ge>=Le);case"<=":return new Qe(ge<=Le)}}else if(Q instanceof Me&&ve instanceof Me)switch(k.operator.value){case"+":return new Me(Q.value.concat(ve.value))}else if(ve instanceof Me){const ge=ve.value.find(Le=>Le.value===Q.value)!==void 0;switch(k.operator.value){case"in":return new Qe(ge);case"not in":return new Qe(!ge)}}}if(Q instanceof Ve||ve instanceof Ve)switch(k.operator.value){case"+":return new Ve(Q.value.toString()+ve.value.toString())}if(Q instanceof Ve&&ve instanceof Ve)switch(k.operator.value){case"in":return new Qe(ve.value.includes(Q.value));case"not in":return new Qe(!ve.value.includes(Q.value))}if(Q instanceof Ve&&ve instanceof mt)switch(k.operator.value){case"in":return new Qe(ve.value.has(Q.value));case"not in":return new Qe(!ve.value.has(Q.value))}throw new SyntaxError(`Unknown operator "${k.operator.value}" between ${Q.type} and ${ve.type}`)}evaluateArguments(k,re){const Q=[],ve=new Map;for(const ge of k)if(ge.type==="SpreadExpression"){const Le=ge,rt=this.evaluate(Le.argument,re);if(!(rt instanceof Me))throw new Error(`Cannot unpack non-iterable type: ${rt.type}`);for(const nt of rt.value)Q.push(nt)}else if(ge.type==="KeywordArgumentExpression"){const Le=ge;ve.set(Le.key.value,this.evaluate(Le.value,re))}else{if(ve.size>0)throw new Error("Positional arguments must come before keyword arguments");Q.push(this.evaluate(ge,re))}return[Q,ve]}applyFilter(k,re,Q){if(re.type==="Identifier"){const ve=re;if(ve.value==="tojson")return new Ve(an(k));if(k instanceof Me)switch(ve.value){case"list":return k;case"first":return k.value[0];case"last":return k.value[k.value.length-1];case"length":return new Fe(k.value.length);case"reverse":return new Me(k.value.reverse());case"sort":return new Me(k.value.sort((ge,Le)=>{if(ge.type!==Le.type)throw new Error(`Cannot compare different types: ${ge.type} and ${Le.type}`);switch(ge.type){case"IntegerValue":case"FloatValue":return ge.value-Le.value;case"StringValue":return ge.value.localeCompare(Le.value);default:throw new Error(`Cannot compare type: ${ge.type}`)}}));case"join":return new Ve(k.value.map(ge=>ge.value).join(""));case"string":return new Ve(an(k));case"unique":{const ge=new Set,Le=[];for(const rt of k.value)ge.has(rt.value)||(ge.add(rt.value),Le.push(rt));return new Me(Le)}default:throw new Error(`Unknown ArrayValue filter: ${ve.value}`)}else if(k instanceof Ve)switch(ve.value){case"length":case"upper":case"lower":case"title":case"capitalize":{const ge=k.builtins.get(ve.value);if(ge instanceof $e)return ge.value([],Q);if(ge instanceof Fe)return ge;throw new Error(`Unknown StringValue filter: ${ve.value}`)}case"trim":return new Ve(k.value.trim());case"indent":return new Ve(k.value.split(`
`).map((ge,Le)=>Le===0||ge.length===0?ge:"    "+ge).join(`
`));case"join":case"string":return k;case"int":{const ge=parseInt(k.value,10);return new Fe(isNaN(ge)?0:ge)}case"float":{const ge=parseFloat(k.value);return new Ye(isNaN(ge)?0:ge)}default:throw new Error(`Unknown StringValue filter: ${ve.value}`)}else if(k instanceof Fe||k instanceof Ye)switch(ve.value){case"abs":return k instanceof Fe?new Fe(Math.abs(k.value)):new Ye(Math.abs(k.value));case"int":return new Fe(Math.floor(k.value));case"float":return new Ye(k.value);default:throw new Error(`Unknown NumericValue filter: ${ve.value}`)}else if(k instanceof mt)switch(ve.value){case"items":return new Me(Array.from(k.value.entries()).map(([ge,Le])=>new Me([new Ve(ge),Le])));case"length":return new Fe(k.value.size);default:throw new Error(`Unknown ObjectValue filter: ${ve.value}`)}else if(k instanceof Qe)switch(ve.value){case"bool":return new Qe(k.value);case"int":return new Fe(k.value?1:0);case"float":return new Ye(k.value?1:0);case"string":return new Ve(k.value?"true":"false");default:throw new Error(`Unknown BooleanValue filter: ${ve.value}`)}throw new Error(`Cannot apply filter "${ve.value}" to type: ${k.type}`)}else if(re.type==="CallExpression"){const ve=re;if(ve.callee.type!=="Identifier")throw new Error(`Unknown filter: ${ve.callee.type}`);const ge=ve.callee.value;if(ge==="tojson"){const[,Le]=this.evaluateArguments(ve.args,Q),rt=Le.get("indent")??new et;if(!(rt instanceof Fe||rt instanceof et))throw new Error("If set, indent must be a number");return new Ve(an(k,rt.value))}else if(ge==="join"){let Le;if(k instanceof Ve)Le=Array.from(k.value);else if(k instanceof Me)Le=k.value.map(yt=>yt.value);else throw new Error(`Cannot apply filter "${ge}" to type: ${k.type}`);const[rt,nt]=this.evaluateArguments(ve.args,Q),ft=rt.at(0)??nt.get("separator")??new Ve("");if(!(ft instanceof Ve))throw new Error("separator must be a string");return new Ve(Le.join(ft.value))}else if(ge==="int"||ge==="float"){const[Le,rt]=this.evaluateArguments(ve.args,Q),nt=Le.at(0)??rt.get("default")??(ge==="int"?new Fe(0):new Ye(0));if(k instanceof Ve){const ft=ge==="int"?parseInt(k.value,10):parseFloat(k.value);return isNaN(ft)?nt:ge==="int"?new Fe(ft):new Ye(ft)}else{if(k instanceof Fe||k instanceof Ye)return k;if(k instanceof Qe)return ge==="int"?new Fe(k.value?1:0):new Ye(k.value?1:0);throw new Error(`Cannot apply filter "${ge}" to type: ${k.type}`)}}else if(ge==="default"){const[Le,rt]=this.evaluateArguments(ve.args,Q),nt=Le[0]??new Ve(""),ft=Le[1]??rt.get("boolean")??new Qe(!1);if(!(ft instanceof Qe))throw new Error("`default` filter flag must be a boolean");return k instanceof ht||ft.value&&!k.__bool__().value?nt:k}if(k instanceof Me){switch(ge){case"selectattr":case"rejectattr":{const Le=ge==="selectattr";if(k.value.some(Bt=>!(Bt instanceof mt)))throw new Error(`\`${ge}\` can only be applied to array of objects`);if(ve.args.some(Bt=>Bt.type!=="StringLiteral"))throw new Error(`arguments of \`${ge}\` must be strings`);const[rt,nt,ft]=ve.args.map(Bt=>this.evaluate(Bt,Q));let yt;if(nt){const Bt=Q.tests.get(nt.value);if(!Bt)throw new Error(`Unknown test: ${nt.value}`);yt=Bt}else yt=(...Bt)=>Bt[0].__bool__().value;const Ne=k.value.filter(Bt=>{const on=Bt.value.get(rt.value),xn=on?yt(on,ft):!1;return Le?xn:!xn});return new Me(Ne)}case"map":{const[,Le]=this.evaluateArguments(ve.args,Q);if(Le.has("attribute")){const rt=Le.get("attribute");if(!(rt instanceof Ve))throw new Error("attribute must be a string");const nt=Le.get("default"),ft=k.value.map(yt=>{if(!(yt instanceof mt))throw new Error("items in map must be an object");return yt.value.get(rt.value)??nt??new ht});return new Me(ft)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${ge}`)}else if(k instanceof Ve){switch(ge){case"indent":{const[Le,rt]=this.evaluateArguments(ve.args,Q),nt=Le.at(0)??rt.get("width")??new Fe(4);if(!(nt instanceof Fe))throw new Error("width must be a number");const ft=Le.at(1)??rt.get("first")??new Qe(!1),yt=Le.at(2)??rt.get("blank")??new Qe(!1),Ne=k.value.split(`
`),Bt=" ".repeat(nt.value),on=Ne.map((xn,Bn)=>!ft.value&&Bn===0||!yt.value&&xn.length===0?xn:Bt+xn);return new Ve(on.join(`
`))}case"replace":{const Le=k.builtins.get("replace");if(!(Le instanceof $e))throw new Error("replace filter not available");const[rt,nt]=this.evaluateArguments(ve.args,Q);return Le.value([...rt,new Tt(nt)],Q)}}throw new Error(`Unknown StringValue filter: ${ge}`)}else throw new Error(`Cannot apply filter "${ge}" to type: ${k.type}`)}throw new Error(`Unknown filter: ${re.type}`)}evaluateFilterExpression(k,re){const Q=this.evaluate(k.operand,re);return this.applyFilter(Q,k.filter,re)}evaluateTestExpression(k,re){const Q=this.evaluate(k.operand,re),ve=re.tests.get(k.test.value);if(!ve)throw new Error(`Unknown test: ${k.test.value}`);const ge=ve(Q);return new Qe(k.negate?!ge:ge)}evaluateSelectExpression(k,re){return this.evaluate(k.test,re).__bool__().value?this.evaluate(k.lhs,re):new ht}evaluateUnaryExpression(k,re){const Q=this.evaluate(k.argument,re);switch(k.operator.value){case"not":return new Qe(!Q.value);default:throw new SyntaxError(`Unknown operator: ${k.operator.value}`)}}evaluateTernaryExpression(k,re){return this.evaluate(k.condition,re).__bool__().value?this.evaluate(k.trueExpr,re):this.evaluate(k.falseExpr,re)}evalProgram(k,re){return this.evaluateBlock(k.body,re)}evaluateBlock(k,re){let Q="";for(const ve of k){const ge=this.evaluate(ve,re);ge.type!=="NullValue"&&ge.type!=="UndefinedValue"&&(Q+=ge.toString())}return new Ve(Q)}evaluateIdentifier(k,re){return re.lookupVariable(k.value)}evaluateCallExpression(k,re){const[Q,ve]=this.evaluateArguments(k.args,re);ve.size>0&&Q.push(new Tt(ve));const ge=this.evaluate(k.callee,re);if(ge.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${ge.type}`);return ge.value(Q,re)}evaluateSliceExpression(k,re,Q){if(!(k instanceof Me||k instanceof Ve))throw new Error("Slice object must be an array or string");const ve=this.evaluate(re.start,Q),ge=this.evaluate(re.stop,Q),Le=this.evaluate(re.step,Q);if(!(ve instanceof Fe||ve instanceof ht))throw new Error("Slice start must be numeric or undefined");if(!(ge instanceof Fe||ge instanceof ht))throw new Error("Slice stop must be numeric or undefined");if(!(Le instanceof Fe||Le instanceof ht))throw new Error("Slice step must be numeric or undefined");return k instanceof Me?new Me(Xe(k.value,ve.value,ge.value,Le.value)):new Ve(Xe(Array.from(k.value),ve.value,ge.value,Le.value).join(""))}evaluateMemberExpression(k,re){const Q=this.evaluate(k.object,re);let ve;if(k.computed){if(k.property.type==="SliceExpression")return this.evaluateSliceExpression(Q,k.property,re);ve=this.evaluate(k.property,re)}else ve=new Ve(k.property.value);let ge;if(Q instanceof mt){if(!(ve instanceof Ve))throw new Error(`Cannot access property with non-string: got ${ve.type}`);ge=Q.value.get(ve.value)??Q.builtins.get(ve.value)}else if(Q instanceof Me||Q instanceof Ve)if(ve instanceof Fe)ge=Q.value.at(ve.value),Q instanceof Ve&&(ge=new Ve(Q.value.at(ve.value)));else if(ve instanceof Ve)ge=Q.builtins.get(ve.value);else throw new Error(`Cannot access property with non-string/non-number: got ${ve.type}`);else{if(!(ve instanceof Ve))throw new Error(`Cannot access property with non-string: got ${ve.type}`);ge=Q.builtins.get(ve.value)}return ge instanceof je?ge:new ht}evaluateSet(k,re){const Q=k.value?this.evaluate(k.value,re):this.evaluateBlock(k.body,re);if(k.assignee.type==="Identifier"){const ve=k.assignee.value;re.setVariable(ve,Q)}else if(k.assignee.type==="TupleLiteral"){const ve=k.assignee;if(!(Q instanceof Me))throw new Error(`Cannot unpack non-iterable type in set: ${Q.type}`);const ge=Q.value;if(ge.length!==ve.value.length)throw new Error(`Too ${ve.value.length>ge.length?"few":"many"} items to unpack in set`);for(let Le=0;Le<ve.value.length;++Le){const rt=ve.value[Le];if(rt.type!=="Identifier")throw new Error(`Cannot unpack to non-identifier in set: ${rt.type}`);re.setVariable(rt.value,ge[Le])}}else if(k.assignee.type==="MemberExpression"){const ve=k.assignee,ge=this.evaluate(ve.object,re);if(!(ge instanceof mt))throw new Error("Cannot assign to member of non-object");if(ve.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");ge.value.set(ve.property.value,Q)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(k.assignee)}`);return new et}evaluateIf(k,re){const Q=this.evaluate(k.test,re);return this.evaluateBlock(Q.__bool__().value?k.body:k.alternate,re)}evaluateFor(k,re){const Q=new at(re);let ve,ge;if(k.iterable.type==="SelectExpression"){const yt=k.iterable;ge=this.evaluate(yt.lhs,Q),ve=yt.test}else ge=this.evaluate(k.iterable,Q);if(!(ge instanceof Me||ge instanceof mt))throw new Error(`Expected iterable or object type in for loop: got ${ge.type}`);ge instanceof mt&&(ge=ge.keys());const Le=[],rt=[];for(let yt=0;yt<ge.value.length;++yt){const Ne=new at(Q),Bt=ge.value[yt];let on;if(k.loopvar.type==="Identifier")on=xn=>xn.setVariable(k.loopvar.value,Bt);else if(k.loopvar.type==="TupleLiteral"){const xn=k.loopvar;if(Bt.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${Bt.type}`);const Bn=Bt;if(xn.value.length!==Bn.value.length)throw new Error(`Too ${xn.value.length>Bn.value.length?"few":"many"} items to unpack`);on=bi=>{for(let gn=0;gn<xn.value.length;++gn){if(xn.value[gn].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${xn.value[gn].type}`);bi.setVariable(xn.value[gn].value,Bn.value[gn])}}}else throw new Error(`Invalid loop variable(s): ${k.loopvar.type}`);ve&&(on(Ne),!this.evaluate(ve,Ne).__bool__().value)||(Le.push(Bt),rt.push(on))}let nt="",ft=!0;for(let yt=0;yt<Le.length;++yt){const Ne=new Map([["index",new Fe(yt+1)],["index0",new Fe(yt)],["revindex",new Fe(Le.length-yt)],["revindex0",new Fe(Le.length-yt-1)],["first",new Qe(yt===0)],["last",new Qe(yt===Le.length-1)],["length",new Fe(Le.length)],["previtem",yt>0?Le[yt-1]:new ht],["nextitem",yt<Le.length-1?Le[yt+1]:new ht]]);Q.setVariable("loop",new mt(Ne)),rt[yt](Q);try{const Bt=this.evaluateBlock(k.body,Q);nt+=Bt.value}catch(Bt){if(Bt instanceof ze)continue;if(Bt instanceof ke)break;throw Bt}ft=!1}if(ft){const yt=this.evaluateBlock(k.defaultBlock,Q);nt+=yt.value}return new Ve(nt)}evaluateMacro(k,re){return re.setVariable(k.name.value,new $e((Q,ve)=>{const ge=new at(ve);Q=Q.slice();let Le;Q.at(-1)?.type==="KeywordArgumentsValue"&&(Le=Q.pop());for(let rt=0;rt<k.args.length;++rt){const nt=k.args[rt],ft=Q[rt];if(nt.type==="Identifier"){const yt=nt;if(!ft)throw new Error(`Missing positional argument: ${yt.value}`);ge.setVariable(yt.value,ft)}else if(nt.type==="KeywordArgumentExpression"){const yt=nt,Ne=ft??Le?.value.get(yt.key.value)??this.evaluate(yt.value,ge);ge.setVariable(yt.key.value,Ne)}else throw new Error(`Unknown argument type: ${nt.type}`)}return this.evaluateBlock(k.body,ge)})),new et}evaluateCallStatement(k,re){const Q=new $e((nt,ft)=>{const yt=new at(ft);if(k.callerArgs)for(let Ne=0;Ne<k.callerArgs.length;++Ne){const Bt=k.callerArgs[Ne];if(Bt.type!=="Identifier")throw new Error(`Caller parameter must be an identifier, got ${Bt.type}`);yt.setVariable(Bt.value,nt[Ne]??new ht)}return this.evaluateBlock(k.body,yt)}),[ve,ge]=this.evaluateArguments(k.call.args,re);ve.push(new Tt(ge));const Le=this.evaluate(k.call.callee,re);if(Le.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${Le.type}`);const rt=new at(re);return rt.setVariable("caller",Q),Le.value(ve,rt)}evaluateFilterStatement(k,re){const Q=this.evaluateBlock(k.body,re);return this.applyFilter(Q,k.filter,re)}evaluate(k,re){if(!k)return new ht;switch(k.type){case"Program":return this.evalProgram(k,re);case"Set":return this.evaluateSet(k,re);case"If":return this.evaluateIf(k,re);case"For":return this.evaluateFor(k,re);case"Macro":return this.evaluateMacro(k,re);case"CallStatement":return this.evaluateCallStatement(k,re);case"Break":throw new ke;case"Continue":throw new ze;case"IntegerLiteral":return new Fe(k.value);case"FloatLiteral":return new Ye(k.value);case"StringLiteral":return new Ve(k.value);case"ArrayLiteral":return new Me(k.value.map(Q=>this.evaluate(Q,re)));case"TupleLiteral":return new me(k.value.map(Q=>this.evaluate(Q,re)));case"ObjectLiteral":{const Q=new Map;for(const[ve,ge]of k.value){const Le=this.evaluate(ve,re);if(!(Le instanceof Ve))throw new Error(`Object keys must be strings: got ${Le.type}`);Q.set(Le.value,this.evaluate(ge,re))}return new mt(Q)}case"Identifier":return this.evaluateIdentifier(k,re);case"CallExpression":return this.evaluateCallExpression(k,re);case"MemberExpression":return this.evaluateMemberExpression(k,re);case"UnaryExpression":return this.evaluateUnaryExpression(k,re);case"BinaryExpression":return this.evaluateBinaryExpression(k,re);case"FilterExpression":return this.evaluateFilterExpression(k,re);case"FilterStatement":return this.evaluateFilterStatement(k,re);case"TestExpression":return this.evaluateTestExpression(k,re);case"SelectExpression":return this.evaluateSelectExpression(k,re);case"Ternary":return this.evaluateTernaryExpression(k,re);case"Comment":return new et;default:throw new SyntaxError(`Unknown node type: ${k.type}`)}}};function Vt(k){switch(typeof k){case"number":return Number.isInteger(k)?new Fe(k):new Ye(k);case"string":return new Ve(k);case"boolean":return new Qe(k);case"undefined":return new ht;case"object":return k===null?new et:Array.isArray(k)?new Me(k.map(Vt)):new mt(new Map(Object.entries(k).map(([re,Q])=>[re,Vt(Q)])));case"function":return new $e((re,Q)=>{const ve=k(...re.map(ge=>ge.value))??null;return Vt(ve)});default:throw new Error(`Cannot convert to runtime value: ${k}`)}}function an(k,re,Q){const ve=Q??0;switch(k.type){case"NullValue":case"UndefinedValue":return"null";case"IntegerValue":case"FloatValue":case"StringValue":case"BooleanValue":return JSON.stringify(k.value);case"ArrayValue":case"ObjectValue":{const ge=re?" ".repeat(re):"",Le=`
`+ge.repeat(ve),rt=Le+ge;if(k.type==="ArrayValue"){const nt=k.value.map(ft=>an(ft,re,ve+1));return re?`[${rt}${nt.join(`,${rt}`)}${Le}]`:`[${nt.join(", ")}]`}else{const nt=Array.from(k.value.entries()).map(([ft,yt])=>{const Ne=`"${ft}": ${an(yt,re,ve+1)}`;return re?`${rt}${Ne}`:Ne});return re?`{${nt.join(",")}${Le}}`:`{${nt.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${k.type}`)}}var bt=`
`,Jt="{%- ",Tn=" -%}";function We(k){switch(k.operator.type){case"MultiplicativeBinaryOperator":return 4;case"AdditiveBinaryOperator":return 3;case"ComparisonBinaryOperator":return 2;case"Identifier":return k.operator.value==="and"?1:k.operator.value==="in"||k.operator.value==="not in"?2:0}return 0}function vt(k,re="	"){const Q=typeof re=="number"?" ".repeat(re):re;return qe(k.body,0,Q).replace(/\n$/,"")}function Yt(...k){return Jt+k.join(" ")+Tn}function qe(k,re,Q){return k.map(ve=>Kt(ve,re,Q)).join(bt)}function Kt(k,re,Q){const ve=Q.repeat(re);switch(k.type){case"Program":return qe(k.body,re,Q);case"If":return rn(k,re,Q);case"For":return fe(k,re,Q);case"Set":return B(k,re,Q);case"Macro":return I(k,re,Q);case"Break":return ve+Yt("break");case"Continue":return ve+Yt("continue");case"CallStatement":return A(k,re,Q);case"FilterStatement":return F(k,re,Q);case"Comment":return ve+"{# "+k.value+" #}";default:return ve+"{{- "+K(k)+" -}}"}}function rn(k,re,Q){const ve=Q.repeat(re),ge=[];let Le=k;for(;Le&&(ge.push({test:Le.test,body:Le.body}),Le.alternate.length===1&&Le.alternate[0].type==="If");)Le=Le.alternate[0];let rt=ve+Yt("if",K(ge[0].test))+bt+qe(ge[0].body,re+1,Q);for(let nt=1;nt<ge.length;++nt)rt+=bt+ve+Yt("elif",K(ge[nt].test))+bt+qe(ge[nt].body,re+1,Q);return Le&&Le.alternate.length>0&&(rt+=bt+ve+Yt("else")+bt+qe(Le.alternate,re+1,Q)),rt+=bt+ve+Yt("endif"),rt}function fe(k,re,Q){const ve=Q.repeat(re);let ge="";if(k.iterable.type==="SelectExpression"){const rt=k.iterable;ge=`${K(rt.lhs)} if ${K(rt.test)}`}else ge=K(k.iterable);let Le=ve+Yt("for",K(k.loopvar),"in",ge)+bt+qe(k.body,re+1,Q);return k.defaultBlock.length>0&&(Le+=bt+ve+Yt("else")+bt+qe(k.defaultBlock,re+1,Q)),Le+=bt+ve+Yt("endfor"),Le}function B(k,re,Q){const ve=Q.repeat(re),ge=K(k.assignee),Le=k.value?K(k.value):"",rt=ve+Yt("set",`${ge}${k.value?" = "+Le:""}`);return k.body.length===0?rt:rt+bt+qe(k.body,re+1,Q)+bt+ve+Yt("endset")}function I(k,re,Q){const ve=Q.repeat(re),ge=k.args.map(K).join(", ");return ve+Yt("macro",`${k.name.value}(${ge})`)+bt+qe(k.body,re+1,Q)+bt+ve+Yt("endmacro")}function A(k,re,Q){const ve=Q.repeat(re),ge=k.callerArgs&&k.callerArgs.length>0?`(${k.callerArgs.map(K).join(", ")})`:"",Le=K(k.call);let rt=ve+Yt(`call${ge}`,Le)+bt;return rt+=qe(k.body,re+1,Q)+bt,rt+=ve+Yt("endcall"),rt}function F(k,re,Q){const ve=Q.repeat(re),ge=k.filter.type==="Identifier"?k.filter.value:K(k.filter);let Le=ve+Yt("filter",ge)+bt;return Le+=qe(k.body,re+1,Q)+bt,Le+=ve+Yt("endfilter"),Le}function K(k,re=-1){switch(k.type){case"SpreadExpression":return`*${K(k.argument)}`;case"Identifier":return k.value;case"IntegerLiteral":return`${k.value}`;case"FloatLiteral":return`${k.value}`;case"StringLiteral":return JSON.stringify(k.value);case"BinaryExpression":{const Q=k,ve=We(Q),ge=K(Q.left,ve),Le=K(Q.right,ve+1),rt=`${ge} ${Q.operator.value} ${Le}`;return ve<re?`(${rt})`:rt}case"UnaryExpression":{const Q=k;return Q.operator.value+(Q.operator.value==="not"?" ":"")+K(Q.argument,1/0)}case"CallExpression":{const Q=k,ve=Q.args.map(K).join(", ");return`${K(Q.callee)}(${ve})`}case"MemberExpression":{const Q=k;let ve=K(Q.object);["Identifier","MemberExpression","CallExpression","StringLiteral","IntegerLiteral","FloatLiteral","ArrayLiteral","TupleLiteral","ObjectLiteral"].includes(Q.object.type)||(ve=`(${ve})`);let ge=K(Q.property);return!Q.computed&&Q.property.type!=="Identifier"&&(ge=`(${ge})`),Q.computed?`${ve}[${ge}]`:`${ve}.${ge}`}case"FilterExpression":{const Q=k,ve=K(Q.operand,1/0);return Q.filter.type==="CallExpression"?`${ve} | ${K(Q.filter)}`:`${ve} | ${Q.filter.value}`}case"SelectExpression":{const Q=k;return`${K(Q.lhs)} if ${K(Q.test)}`}case"TestExpression":{const Q=k;return`${K(Q.operand)} is${Q.negate?" not":""} ${Q.test.value}`}case"ArrayLiteral":case"TupleLiteral":{const Q=k.value.map(K),ve=k.type==="ArrayLiteral"?"[]":"()";return`${ve[0]}${Q.join(", ")}${ve[1]}`}case"ObjectLiteral":return`{${Array.from(k.value.entries()).map(([ve,ge])=>`${K(ve)}: ${K(ge)}`).join(", ")}}`;case"SliceExpression":{const Q=k,ve=Q.start?K(Q.start):"",ge=Q.stop?K(Q.stop):"",Le=Q.step?`:${K(Q.step)}`:"";return`${ve}:${ge}${Le}`}case"KeywordArgumentExpression":{const Q=k;return`${Q.key.value}=${K(Q.value)}`}case"Ternary":{const Q=k,ve=`${K(Q.trueExpr)} if ${K(Q.condition,0)} else ${K(Q.falseExpr)}`;return re>-1?`(${ve})`:ve}default:throw new Error(`Unknown expression type: ${k.type}`)}}var Ee=class{parsed;constructor(k){const re=g(k,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=Be(re)}render(k){const re=new at;if(Et(re),k)for(const[ge,Le]of Object.entries(k))re.set(ge,Le);return new Dt(re).run(this.parsed).value}format(k){return vt(this.parsed,k?.indent||"	")}}}),"./src/backends/onnx.js":((n,e,t)=>{var i;t.r(e),t.d(e,{Tensor:()=>l.Tensor,createInferenceSession:()=>S,deviceToExecutionProviders:()=>y,isONNXProxy:()=>P,isONNXTensor:()=>x,runInferenceSession:()=>C});var s=t("./src/env.js"),r=t("?2ce3"),o=t("onnxruntime-web"),l=t("onnxruntime-common");const c=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),d=[];let g,p;const h=Symbol.for("onnxruntime");if(h in globalThis)p=globalThis[h];else if(s.apis.IS_NODE_ENV){switch(p=r??(i||(i=t.t(r,2))),process.platform){case"win32":d.push("dml");break;case"linux":process.arch==="x64"&&d.push("cuda");break}d.push("cpu"),g=["cpu"]}else p=o,s.apis.IS_WEBNN_AVAILABLE&&d.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),s.apis.IS_WEBGPU_AVAILABLE&&d.push("webgpu"),d.push("wasm"),g=["wasm"];const v=p.InferenceSession;function y(D=null){if(!D)return g;switch(D){case"auto":return d;case"gpu":return d.filter(z=>["webgpu","cuda","dml","webnn-gpu"].includes(z))}if(d.includes(D))return[c[D]??D];throw new Error(`Unsupported device: "${D}". Should be one of: ${d.join(", ")}.`)}let w=null;async function S(D,z,U){w&&await w;const N=v.create(D,z);w??=N;const j=await N;return j.config=U,j}let M=Promise.resolve();const T=s.apis.IS_BROWSER_ENV||s.apis.IS_WEBWORKER_ENV;async function C(D,z){const U=()=>D.run(z);return await(T?M=M.then(U):U())}function x(D){return D instanceof p.Tensor}const R=p?.env;R?.wasm&&(!(typeof ServiceWorkerGlobalScope<"u"&&self instanceof ServiceWorkerGlobalScope)&&!R.wasm.wasmPaths&&(R.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${s.env.version}/dist/`),R.wasm.proxy=!1),R?.webgpu&&(R.webgpu.powerPreference="high-performance");function P(){return R?.wasm?.proxy}s.env.backends.onnx=R}),"./src/base/feature_extraction_utils.js":((n,e,t)=>{t.r(e),t.d(e,{FeatureExtractor:()=>o,validate_audio_inputs:()=>l});var i=t("./src/utils/constants.js"),s=t("./src/utils/generic.js"),r=t("./src/utils/hub.js");class o extends s.Callable{constructor(d){super(),this.config=d}static async from_pretrained(d,g={}){const p=await(0,r.getModelJSON)(d,i.FEATURE_EXTRACTOR_NAME,!0,g);return new this(p)}}function l(c,d){if(!(c instanceof Float32Array||c instanceof Float64Array))throw new Error(`${d} expects input to be a Float32Array or a Float64Array, but got ${c?.constructor?.name??typeof c} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}}),"./src/base/image_processors_utils.js":((n,e,t)=>{t.r(e),t.d(e,{ImageProcessor:()=>x,center_to_corners_format:()=>p,post_process_instance_segmentation:()=>C,post_process_object_detection:()=>h,post_process_panoptic_segmentation:()=>T,post_process_semantic_segmentation:()=>v});var i=t("./src/utils/generic.js"),s=t("./src/utils/tensor.js"),r=t("./src/utils/maths.js");t("./src/utils/image.js");var o=t("./src/utils/core.js"),l=t("./src/utils/hub.js"),c=t("./src/utils/constants.js");function d(R,P,D=0,z=null){const U=R/P;let N=(0,r.bankers_round)(U)*P;return z!==null&&N>z&&(N=Math.floor(U)*P),N<D&&(N=Math.ceil(U)*P),N}function g([R,P],D){return[Math.max(Math.floor(R/D),1)*D,Math.max(Math.floor(P/D),1)*D]}function p([R,P,D,z]){return[R-D/2,P-z/2,R+D/2,P+z/2]}function h(R,P=.5,D=null,z=!1){const U=R.logits,N=R.pred_boxes,[j,J,W]=U.dims;if(D!==null&&D.length!==j)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let oe=[];for(let ne=0;ne<j;++ne){let q=D!==null?D[ne]:null,le={boxes:[],classes:[],scores:[]},se=U[ne],pe=N[ne];for(let be=0;be<J;++be){let ee=se[be],te=[],ue;if(z){ue=ee.sigmoid().data;for(let ae=0;ae<ue.length;++ae)ue[ae]>P&&te.push(ae)}else{let ae=(0,r.max)(ee.data)[1];if(ae===W-1||(ue=(0,r.softmax)(ee.data),ue[ae]<P))continue;te.push(ae)}for(const ae of te){let ce=pe[be].data;ce=p(ce),q!==null&&(ce=ce.map((Be,He)=>Be*q[(He+1)%2])),le.boxes.push(ce),le.classes.push(ae),le.scores.push(ue[ae])}}oe.push(le)}return oe}function v(R,P=null){const D=R.logits,z=D.dims[0];if(P!==null&&P.length!==z)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const U=[];for(let N=0;N<z;++N){const j=P!==null?P[N]:null;let J=D[N];j!==null&&(J=(0,s.interpolate)(J,j,"bilinear",!1));const[W,oe]=j??J.dims.slice(-2),ne=new s.Tensor("int32",new Int32Array(W*oe),[W,oe]),q=J[0].data,le=ne.data;for(let be=1;be<J.dims[0];++be){const ee=J[be].data;for(let te=0;te<ee.length;++te)ee[te]>q[te]&&(q[te]=ee[te],le[te]=be)}const se=new Array(J.dims[0]);for(let be=0;be<le.length;++be){const ee=le[be];se[ee]=ee}const pe=se.filter(be=>be!==void 0);U.push({segmentation:ne,labels:pe})}return U}function y(R,P,D,z){const U=[],N=[],j=[];for(let J=0;J<R.dims[0];++J){const W=R[J],oe=P[J],ne=(0,r.max)(W.data)[1];if(ne===z)continue;const le=(0,r.softmax)(W.data)[ne];le>D&&(U.push(oe),N.push(le),j.push(ne))}return[U,N,j]}function w(R,P,D,z=.5,U=.8){const N=[];let j=0,J=0;const W=P[D].data;for(let ne=0;ne<R.length;++ne)R[ne]===D&&(N.push(ne),++j),W[ne]>=z&&++J;let oe=j>0&&J>0;return oe&&(oe=j/J>U),[oe,N]}function S(R,P,D,z,U,N=null,j=null){const[J,W]=j??R[0].dims,oe=new s.Tensor("int32",new Int32Array(J*W),[J,W]),ne=[];if(j!==null)for(let be=0;be<R.length;++be)R[be]=(0,s.interpolate)(R[be],j,"bilinear",!1);const q=new Int32Array(R[0].data.length),le=new Float32Array(R[0].data.length);for(let be=0;be<R.length;++be){let ee=P[be];const te=R[be].data;for(let ue=0;ue<te.length;++ue)te[ue]*=ee,te[ue]>le[ue]&&(q[ue]=be,le[ue]=te[ue])}let se=0;const pe=oe.data;for(let be=0;be<D.length;++be){const ee=D[be],[te,ue]=w(q,R,be,z,U);if(te){++se;for(const ae of ue)pe[ae]=se;ne.push({id:se,label_id:ee,score:P[be]})}}return[oe,ne]}function M(R,P,D=28,z=3136,U=784*1280){if(R<D||P<D)throw new Error(`height:${R} or width:${P} must be larger than factor:${D}`);if(Math.max(R,P)/Math.min(R,P)>200)throw new Error(`absolute aspect ratio must be smaller than 200, got ${Math.max(R,P)/Math.min(R,P)}`);let N=Math.round(R/D)*D,j=Math.round(P/D)*D;if(N*j>U){const J=Math.sqrt(R*P/U);N=Math.floor(R/J/D)*D,j=Math.floor(P/J/D)*D}else if(N*j<z){const J=Math.sqrt(z/(R*P));N=Math.ceil(R*J/D)*D,j=Math.ceil(P*J/D)*D}return[N,j]}function T(R,P=.5,D=.5,z=.8,U=null,N=null){U===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),U=new Set);const j=R.class_queries_logits??R.logits,W=(R.masks_queries_logits??R.pred_masks).sigmoid();let[oe,ne,q]=j.dims;if(q-=1,N!==null&&N.length!==oe)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let le=[];for(let se=0;se<oe;++se){let pe=N!==null?N[se]:null,be=j[se],ee=W[se],[te,ue,ae]=y(be,ee,P,q);if(ae.length===0){let[He,Xe]=pe??ee.dims.slice(-2),ot=new s.Tensor("int32",new Int32Array(He*Xe).fill(-1),[He,Xe]);le.push({segmentation:ot,segments_info:[]});continue}let[ce,Be]=S(te,ue,ae,D,z,U,pe);le.push({segmentation:ce,segments_info:Be})}return le}function C(R,P=.5,D=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class x extends i.Callable{constructor(P){super(),this.image_mean=P.image_mean??P.mean,this.image_std=P.image_std??P.std,this.resample=P.resample??2,this.do_rescale=P.do_rescale??!0,this.rescale_factor=P.rescale_factor??1/255,this.do_normalize=P.do_normalize,this.do_thumbnail=P.do_thumbnail,this.size=P.size??P.image_size,this.do_resize=P.do_resize??this.size!==void 0,this.size_divisibility=P.size_divisibility??P.size_divisor,this.do_center_crop=P.do_center_crop,this.crop_size=P.crop_size,this.do_convert_rgb=P.do_convert_rgb??!0,this.do_crop_margin=P.do_crop_margin,this.pad_size=P.pad_size,this.do_pad=P.do_pad,this.min_pixels=P.min_pixels,this.max_pixels=P.max_pixels,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=P.do_flip_channel_order??!1,this.config=P}async thumbnail(P,D,z=2){const U=P.height,N=P.width,j=D.height,J=D.width;let W=Math.min(U,j),oe=Math.min(N,J);return W===U&&oe===N?P:(U>N?oe=Math.floor(N*W/U):N>U&&(W=Math.floor(U*oe/N)),await P.resize(oe,W,{resample:z}))}async crop_margin(P,D=200){const z=P.clone().grayscale(),U=(0,r.min)(z.data)[0],j=(0,r.max)(z.data)[0]-U;if(j===0)return P;const J=D/255;let W=z.width,oe=z.height,ne=0,q=0;const le=z.data;for(let se=0;se<z.height;++se){const pe=se*z.width;for(let be=0;be<z.width;++be)(le[pe+be]-U)/j<J&&(W=Math.min(W,be),oe=Math.min(oe,se),ne=Math.max(ne,be),q=Math.max(q,se))}return P=await P.crop([W,oe,ne,q]),P}pad_image(P,D,z,{mode:U="constant",center:N=!1,constant_values:j=0}={}){const[J,W,oe]=D;let ne,q;if(typeof z=="number"?(ne=z,q=z):z==="square"?ne=q=Math.max(J,W):(ne=z.width,q=z.height),ne!==W||q!==J){const le=new Float32Array(ne*q*oe);if(Array.isArray(j))for(let be=0;be<le.length;++be)le[be]=j[be%oe];else j!==0&&le.fill(j);const[se,pe]=N?[Math.floor((ne-W)/2),Math.floor((q-J)/2)]:[0,0];for(let be=0;be<J;++be){const ee=(be+pe)*ne,te=be*W;for(let ue=0;ue<W;++ue){const ae=(ee+ue+se)*oe,ce=(te+ue)*oe;for(let Be=0;Be<oe;++Be)le[ae+Be]=P[ce+Be]}}if(U==="symmetric"){if(N)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const be=J-1,ee=W-1;for(let te=0;te<q;++te){const ue=te*ne,ae=(0,o.calculateReflectOffset)(te,be)*W;for(let ce=0;ce<ne;++ce){if(te<J&&ce<W)continue;const Be=(ue+ce)*oe,He=(ae+(0,o.calculateReflectOffset)(ce,ee))*oe;for(let Xe=0;Xe<oe;++Xe)le[Be+Xe]=P[He+Xe]}}}P=le,D=[q,ne,oe]}return[P,D]}rescale(P){for(let D=0;D<P.length;++D)P[D]=this.rescale_factor*P[D]}get_resize_output_image_size(P,D){const[z,U]=P.size;let N,j;if(this.do_thumbnail){const{height:J,width:W}=D;N=Math.min(J,W)}else Number.isInteger(D)?(N=D,j=this.config.max_size??N):D!==void 0&&(N=D.shortest_edge,j=D.longest_edge);if(N!==void 0||j!==void 0){const J=N===void 0?1:Math.max(N/z,N/U),W=z*J,oe=U*J,ne=j===void 0?1:Math.min(j/W,j/oe);let q=Math.floor(Number((W*ne).toFixed(2))),le=Math.floor(Number((oe*ne).toFixed(2)));return this.size_divisibility!==void 0&&([q,le]=g([q,le],this.size_divisibility)),[q,le]}else if(D!==void 0&&D.width!==void 0&&D.height!==void 0){let J=D.width,W=D.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let oe=W/U,ne=J/z;Math.abs(1-ne)<Math.abs(1-oe)?oe=ne:ne=oe,W=d(oe*U,this.config.ensure_multiple_of),J=d(ne*z,this.config.ensure_multiple_of)}return[J,W]}else{if(this.size_divisibility!==void 0)return g([z,U],this.size_divisibility);if(this.min_pixels!==void 0&&this.max_pixels!==void 0){const J=this.config.patch_size*this.config.merge_size;return M(U,z,J,this.min_pixels,this.max_pixels)}else throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(D)}`)}}async resize(P){const[D,z]=this.get_resize_output_image_size(P,this.size);return await P.resize(D,z,{resample:this.resample})}async preprocess(P,{do_normalize:D=null,do_pad:z=null,do_convert_rgb:U=null,do_convert_grayscale:N=null,do_flip_channel_order:j=null}={}){this.do_crop_margin&&(P=await this.crop_margin(P));const[J,W]=P.size;if(U??this.do_convert_rgb?P=P.rgb():N&&(P=P.grayscale()),this.do_resize&&(P=await this.resize(P)),this.do_thumbnail&&(P=await this.thumbnail(P,this.size,this.resample)),this.do_center_crop){let se,pe;Number.isInteger(this.crop_size)?(se=this.crop_size,pe=this.crop_size):(se=this.crop_size.width,pe=this.crop_size.height),P=await P.center_crop(se,pe)}const oe=[P.height,P.width];let ne=Float32Array.from(P.data),q=[P.height,P.width,P.channels];if(this.do_rescale&&this.rescale(ne),D??this.do_normalize){let se=this.image_mean;Array.isArray(this.image_mean)||(se=new Array(P.channels).fill(se));let pe=this.image_std;if(Array.isArray(this.image_std)||(pe=new Array(P.channels).fill(pe)),se.length!==P.channels||pe.length!==P.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${se.length}) and \`image_std\` (${pe.length}) must match the number of channels in the image (${P.channels}).`);for(let be=0;be<ne.length;be+=P.channels)for(let ee=0;ee<P.channels;++ee)ne[be+ee]=(ne[be+ee]-se[ee])/pe[ee]}if(z??this.do_pad){if(this.pad_size)[ne,q]=this.pad_image(ne,[P.height,P.width,P.channels],this.pad_size);else if(this.size_divisibility){const[se,pe]=g([q[1],q[0]],this.size_divisibility);[ne,q]=this.pad_image(ne,q,{width:se,height:pe})}}if(j??this.do_flip_channel_order){if(q[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let se=0;se<ne.length;se+=3){const pe=ne[se];ne[se]=ne[se+2],ne[se+2]=pe}}const le=new s.Tensor("float32",ne,q).permute(2,0,1);return{original_size:[W,J],reshaped_input_size:oe,pixel_values:le}}async _call(P,...D){Array.isArray(P)||(P=[P]);const z=await Promise.all(P.map(N=>this.preprocess(N)));return{pixel_values:(0,s.stack)(z.map(N=>N.pixel_values),0),original_sizes:z.map(N=>N.original_size),reshaped_input_sizes:z.map(N=>N.reshaped_input_size)}}static async from_pretrained(P,D={}){const z=await(0,l.getModelJSON)(P,c.IMAGE_PROCESSOR_NAME,!0,D);return new this(z)}}}),"./src/base/processing_utils.js":((n,e,t)=>{t.r(e),t.d(e,{Processor:()=>o});var i=t("./src/utils/constants.js"),s=t("./src/utils/generic.js"),r=t("./src/utils/hub.js");class o extends s.Callable{static classes=["image_processor_class","tokenizer_class","feature_extractor_class"];static uses_processor_config=!1;static uses_chat_template_file=!1;constructor(c,d,g){super(),this.config=c,this.components=d,this.chat_template=g}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(c,d={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(c,{tokenize:!1,chat_template:this.chat_template??void 0,...d})}batch_decode(...c){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...c)}decode(...c){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.decode(...c)}async _call(c,...d){for(const g of[this.image_processor,this.feature_extractor,this.tokenizer])if(g)return g(c,...d);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(c,d={}){const[g,p,h]=await Promise.all([this.uses_processor_config?(0,r.getModelJSON)(c,i.PROCESSOR_NAME,!0,d):{},Promise.all(this.classes.filter(v=>v in this).map(async v=>{const y=await this[v].from_pretrained(c,d);return[v.replace(/_class$/,""),y]})).then(Object.fromEntries),this.uses_chat_template_file?(0,r.getModelText)(c,i.CHAT_TEMPLATE_NAME,!0,d):null]);return new this(g,p,h)}}}),"./src/configs.js":((n,e,t)=>{t.r(e),t.d(e,{AutoConfig:()=>g,PretrainedConfig:()=>d,getCacheShapes:()=>l});var i=t("./src/utils/core.js"),s=t("./src/utils/hub.js");async function r(p,h){return await(0,s.getModelJSON)(p,"config.json",!0,h)}function o(p){const h={};let v={};switch(p.model_type){case"llava":case"paligemma":case"gemma3":case"florence2":case"llava_onevision":case"idefics3":case"ultravox":case"voxtral":case"smolvlm":case"gemma3n":v=o(p.text_config);break;case"moondream1":v=o(p.phi_config);break;case"musicgen":v=o(p.decoder);break;case"multi_modality":v=o(p.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":h.num_heads="n_head",h.num_layers="n_layer",h.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":case"modernbert-decoder":h.num_heads="num_attention_heads",h.num_layers="num_hidden_layers",h.hidden_size="hidden_size";break;case"llama":case"llama4_text":case"nanochat":case"arcee":case"lfm2":case"smollm3":case"olmo":case"olmo2":case"mobilellm":case"granite":case"granitemoehybrid":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":case"llava_qwen2":h.num_heads="num_key_value_heads",h.num_layers="num_hidden_layers",h.hidden_size="hidden_size",h.num_attention_heads="num_attention_heads",h.dim_kv="head_dim";break;case"qwen3":case"gemma":case"gemma2":case"vaultgemma":case"gemma3_text":case"gemma3n_text":case"glm":case"helium":case"ernie4_5":h.num_heads="num_key_value_heads",h.num_layers="num_hidden_layers",h.dim_kv="head_dim";break;case"openelm":h.num_heads="num_kv_heads",h.num_layers="num_transformer_layers",h.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":h.num_heads="num_heads",h.num_layers="num_layers",h.hidden_size="hidden_size";break;case"bloom":h.num_heads="n_head",h.num_layers="n_layer",h.hidden_size="hidden_size";break;case"mpt":h.num_heads="n_heads",h.num_layers="n_layers",h.hidden_size="d_model";break;case"exaone":h.num_heads="num_key_value_heads",h.num_layers="num_layers",h.dim_kv="head_dim",h.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":h.num_decoder_layers="num_decoder_layers",h.num_decoder_heads="num_heads",h.decoder_dim_kv="d_kv",h.num_encoder_layers="num_layers",h.num_encoder_heads="num_heads",h.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"lite-whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":h.num_decoder_layers="decoder_layers",h.num_decoder_heads="decoder_attention_heads",h.decoder_hidden_size="d_model",h.num_encoder_layers="encoder_layers",h.num_encoder_heads="encoder_attention_heads",h.encoder_hidden_size="d_model";break;case"speecht5":h.num_decoder_layers="decoder_layers",h.num_decoder_heads="decoder_attention_heads",h.decoder_hidden_size="hidden_size",h.num_encoder_layers="encoder_layers",h.num_encoder_heads="encoder_attention_heads",h.encoder_hidden_size="hidden_size";break;case"trocr":h.num_encoder_layers=h.num_decoder_layers="decoder_layers",h.num_encoder_heads=h.num_decoder_heads="decoder_attention_heads",h.encoder_hidden_size=h.decoder_hidden_size="d_model";break;case"musicgen_decoder":h.num_encoder_layers=h.num_decoder_layers="num_hidden_layers",h.num_encoder_heads=h.num_decoder_heads="num_attention_heads",h.encoder_hidden_size=h.decoder_hidden_size="hidden_size";break;case"moonshine":h.num_decoder_layers="decoder_num_hidden_layers",h.num_decoder_heads="decoder_num_key_value_heads",h.num_encoder_layers="encoder_num_hidden_layers",h.num_encoder_heads="encoder_num_key_value_heads",h.encoder_hidden_size=h.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const w=o(p.decoder),S="num_decoder_layers"in w,M=(0,i.pick)(p,["model_type","is_encoder_decoder"]);return S?(M.num_decoder_layers=w.num_decoder_layers,M.num_decoder_heads=w.num_decoder_heads,M.decoder_hidden_size=w.decoder_hidden_size,M.num_encoder_layers=w.num_encoder_layers,M.num_encoder_heads=w.num_encoder_heads,M.encoder_hidden_size=w.encoder_hidden_size):(M.num_layers=w.num_layers,M.num_heads=w.num_heads,M.hidden_size=w.hidden_size),M}const y={...v,...(0,i.pick)(p,["model_type","multi_query","is_encoder_decoder"])};for(const w in h)y[w]=p[h[w]];return y}function l(p,h){if(p.model_type==="lfm2"){const v=h?.prefix??"past_key_values",y=v==="present"?"present":"past",w={},{layer_types:S,num_attention_heads:M,num_key_value_heads:T,hidden_size:C,conv_L_cache:x}=p,R=C/M,P=h?.batch_size??1;for(let D=0;D<S.length;++D)if(S[D]==="full_attention")for(const z of["key","value"])w[`${v}.${D}.${z}`]=[P,T,0,R];else if(S[D]==="conv")w[`${y}_conv.${D}`]=[P,C,x];else throw new Error(`Unsupported layer type: ${S[D]}`);return w}return c(p,h)}function c(p,{prefix:h="past_key_values",batch_size:v=1}={}){const y={},w=p.normalized_config;if(w.is_encoder_decoder&&"num_encoder_heads"in w&&"num_decoder_heads"in w){const S=w.encoder_dim_kv??w.encoder_hidden_size/w.num_encoder_heads,M=w.decoder_dim_kv??w.decoder_hidden_size/w.num_decoder_heads,T=[v,w.num_encoder_heads,0,S],C=[v,w.num_decoder_heads,0,M];for(let x=0;x<w.num_decoder_layers;++x)y[`${h}.${x}.encoder.key`]=T,y[`${h}.${x}.encoder.value`]=T,y[`${h}.${x}.decoder.key`]=C,y[`${h}.${x}.decoder.value`]=C}else{const S=w.num_heads,M=w.num_layers,T=w.dim_kv??w.hidden_size/(w.num_attention_heads??S);if(w.model_type==="falcon"){const C=[v*S,0,T];for(let x=0;x<M;++x)y[`${h}.${x}.key`]=C,y[`${h}.${x}.value`]=C}else if(w.multi_query){const C=[v*S,0,2*T];for(let x=0;x<M;++x)y[`${h}.${x}.key_value`]=C}else if(w.model_type==="bloom"){const C=[v*S,T,0],x=[v*S,0,T];for(let R=0;R<M;++R)y[`${h}.${R}.key`]=C,y[`${h}.${R}.value`]=x}else if(w.model_type==="openelm")for(let C=0;C<M;++C){const x=[v,S[C],0,T];y[`${h}.${C}.key`]=x,y[`${h}.${C}.value`]=x}else{const C=[v,S,0,T];for(let x=0;x<M;++x)y[`${h}.${x}.key`]=C,y[`${h}.${x}.value`]=C}}return y}class d{model_type=null;is_encoder_decoder=!1;max_position_embeddings;"transformers.js_config";constructor(h){Object.assign(this,h),this.normalized_config=o(this)}static async from_pretrained(h,{progress_callback:v=null,config:y=null,cache_dir:w=null,local_files_only:S=!1,revision:M="main"}={}){y&&!(y instanceof d)&&(y=new d(y));const T=y??await r(h,{progress_callback:v,config:y,cache_dir:w,local_files_only:S,revision:M});return new this(T)}}class g{static async from_pretrained(...h){return d.from_pretrained(...h)}}}),"./src/env.js":((n,e,t)=>{t.r(e),t.d(e,{apis:()=>M,env:()=>D});var i=t("?db59"),s=t("?383f"),r=t("?fa4b");const o="3.8.0",l=typeof window<"u"&&typeof window.document<"u",c=typeof self<"u"&&["DedicatedWorkerGlobalScope","ServiceWorkerGlobalScope","SharedWorkerGlobalScope"].includes(self.constructor?.name),d=typeof self<"u"&&"caches"in self,g=typeof navigator<"u"&&"gpu"in navigator,p=typeof navigator<"u"&&"ml"in navigator,h=typeof process<"u",v=h&&process?.release?.name==="node",y=!z(i),w=!z(s),S=typeof globalThis.Deno<"u",M=Object.freeze({IS_BROWSER_ENV:l,IS_WEBWORKER_ENV:c,IS_WEB_CACHE_AVAILABLE:d,IS_WEBGPU_AVAILABLE:g,IS_WEBNN_AVAILABLE:p,IS_PROCESS_AVAILABLE:h,IS_NODE_ENV:v,IS_FS_AVAILABLE:y,IS_PATH_AVAILABLE:w}),T=y&&w;let C="./";if(T){const U=Object(import.meta).url;U?C=s.dirname(s.dirname(r.fileURLToPath(U))):typeof __dirname<"u"&&(C=s.dirname(__dirname))}const x=T?s.join(C,"/.cache/"):null,R="/models/",P=T?s.join(C,R):R,D={version:o,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(l||c),localModelPath:P,useFS:y,useBrowserCache:d&&!S,useFSCache:y,cacheDir:x,useCustomCache:!1,customCache:null};function z(U){return Object.keys(U).length===0}}),"./src/generation/configuration_utils.js":((n,e,t)=>{t.r(e),t.d(e,{GenerationConfig:()=>s});var i=t("./src/utils/core.js");class s{max_length=20;max_new_tokens=null;min_length=0;min_new_tokens=null;early_stopping=!1;max_time=null;do_sample=!1;num_beams=1;num_beam_groups=1;penalty_alpha=null;use_cache=!0;temperature=1;top_k=50;top_p=1;typical_p=1;epsilon_cutoff=0;eta_cutoff=0;diversity_penalty=0;repetition_penalty=1;encoder_repetition_penalty=1;length_penalty=1;no_repeat_ngram_size=0;bad_words_ids=null;force_words_ids=null;renormalize_logits=!1;constraints=null;forced_bos_token_id=null;forced_eos_token_id=null;remove_invalid_values=!1;exponential_decay_length_penalty=null;suppress_tokens=null;streamer=null;begin_suppress_tokens=null;forced_decoder_ids=null;guidance_scale=null;num_return_sequences=1;output_attentions=!1;output_hidden_states=!1;output_scores=!1;return_dict_in_generate=!1;pad_token_id=null;bos_token_id=null;eos_token_id=null;encoder_no_repeat_ngram_size=0;decoder_start_token_id=null;generation_kwargs={};constructor(o){Object.assign(this,(0,i.pick)(o,Object.getOwnPropertyNames(this)))}}}),"./src/generation/logits_process.js":((n,e,t)=>{t.r(e),t.d(e,{ClassifierFreeGuidanceLogitsProcessor:()=>M,ForcedBOSTokenLogitsProcessor:()=>c,ForcedEOSTokenLogitsProcessor:()=>d,LogitsProcessor:()=>r,LogitsProcessorList:()=>l,LogitsWarper:()=>o,MinLengthLogitsProcessor:()=>y,MinNewTokensLengthLogitsProcessor:()=>w,NoBadWordsLogitsProcessor:()=>S,NoRepeatNGramLogitsProcessor:()=>h,RepetitionPenaltyLogitsProcessor:()=>v,SuppressTokensAtBeginLogitsProcessor:()=>g,TemperatureLogitsWarper:()=>T,TopKLogitsWarper:()=>x,TopPLogitsWarper:()=>C,WhisperTimeStampLogitsProcessor:()=>p});var i=t("./src/utils/generic.js");t("./src/utils/tensor.js");var s=t("./src/utils/maths.js");class r extends i.Callable{_call(P,D){throw Error("`_call` should be implemented in a subclass")}}class o extends i.Callable{_call(P,D){throw Error("`_call` should be implemented in a subclass")}}class l extends i.Callable{constructor(){super(),this.processors=[]}push(P){this.processors.push(P)}extend(P){this.processors.push(...P)}_call(P,D){let z=D;for(const U of this.processors)z=U(P,z);return z}[Symbol.iterator](){return this.processors.values()}}class c extends r{constructor(P){super(),this.bos_token_id=P}_call(P,D){for(let z=0;z<P.length;++z)if(P[z].length===1){const U=D[z].data;U.fill(-1/0),U[this.bos_token_id]=0}return D}}class d extends r{constructor(P,D){super(),this.max_length=P,this.eos_token_id=Array.isArray(D)?D:[D]}_call(P,D){for(let z=0;z<P.length;++z)if(P[z].length===this.max_length-1){const U=D[z].data;U.fill(-1/0);for(const N of this.eos_token_id)U[N]=0}return D}}class g extends r{constructor(P,D){super(),this.begin_suppress_tokens=P,this.begin_index=D}_call(P,D){for(let z=0;z<P.length;++z)if(P[z].length===this.begin_index){const U=D[z].data;for(const N of this.begin_suppress_tokens)U[N]=-1/0}return D}}class p extends r{constructor(P,D){super(),this.eos_token_id=Array.isArray(P.eos_token_id)?P.eos_token_id[0]:P.eos_token_id,this.no_timestamps_token_id=P.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=D.length,D.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=P.max_initial_timestamp_index}_call(P,D){for(let z=0;z<P.length;++z){const U=D[z].data;if(U[this.no_timestamps_token_id]=-1/0,P[z].length===this.begin_index-1){U.fill(-1/0),U[this.timestamp_begin]=0;continue}const N=P[z].slice(this.begin_index),j=N.length>=1&&N[N.length-1]>=this.timestamp_begin,J=N.length<2||N[N.length-2]>=this.timestamp_begin;if(j&&(J?U.subarray(this.timestamp_begin).fill(-1/0):U.subarray(0,this.eos_token_id).fill(-1/0)),P[z].length===this.begin_index&&this.max_initial_timestamp_index!==null){const q=this.timestamp_begin+this.max_initial_timestamp_index;U.subarray(q+1).fill(-1/0)}const W=(0,s.log_softmax)(U),oe=Math.log(W.subarray(this.timestamp_begin).map(Math.exp).reduce((q,le)=>q+le)),ne=(0,s.max)(W.subarray(0,this.timestamp_begin))[0];oe>ne&&U.subarray(0,this.timestamp_begin).fill(-1/0)}return D}}class h extends r{constructor(P){super(),this.no_repeat_ngram_size=P}getNgrams(P){const D=P.length,z=[];for(let N=0;N<D+1-this.no_repeat_ngram_size;++N){const j=[];for(let J=0;J<this.no_repeat_ngram_size;++J)j.push(P[N+J]);z.push(j.map(Number))}const U=new Map;for(const N of z){const j=N.slice(0,N.length-1),J=JSON.stringify(j),W=U.get(J)??[];W.push(N[N.length-1]),U.set(J,W)}return U}getGeneratedNgrams(P,D){const z=D.slice(D.length+1-this.no_repeat_ngram_size,D.length);return P.get(JSON.stringify(z.map(Number)))??[]}calcBannedNgramTokens(P){const D=[];if(P.length+1<this.no_repeat_ngram_size)return D;{const z=this.getNgrams(P);return this.getGeneratedNgrams(z,P)}}_call(P,D){for(let z=0;z<P.length;++z){const U=D[z].data,N=this.calcBannedNgramTokens(P[z]);for(const j of N)U[j]=-1/0}return D}}class v extends r{constructor(P){super(),this.penalty=P}_call(P,D){for(let z=0;z<P.length;++z){const U=D[z].data;for(const N of new Set(P[z])){const j=Number(N);U[j]<0?U[j]*=this.penalty:U[j]/=this.penalty}}return D}}class y extends r{constructor(P,D){super(),this.min_length=P,this.eos_token_id=Array.isArray(D)?D:[D]}_call(P,D){for(let z=0;z<P.length;++z)if(P[z].length<this.min_length){const U=D[z].data;for(const N of this.eos_token_id)U[N]=-1/0}return D}}class w extends r{constructor(P,D,z){super(),this.prompt_length_to_skip=P,this.min_new_tokens=D,this.eos_token_id=Array.isArray(z)?z:[z]}_call(P,D){for(let z=0;z<P.length;++z)if(P[z].length-this.prompt_length_to_skip<this.min_new_tokens){const N=D[z].data;for(const j of this.eos_token_id)N[j]=-1/0}return D}}class S extends r{constructor(P,D){super(),this.bad_words_ids=P,this.eos_token_id=Array.isArray(D)?D:[D]}_call(P,D){for(let z=0;z<P.length;++z){const U=D[z].data,N=P[z];for(const j of this.bad_words_ids){if(N.length<j.length-1)continue;let J=!0;for(let W=1;W<=j.length-1;++W)if(j.at(-W-1)!=N.at(-W)){J=!1;break}J&&(U[j.at(-1)]=-1/0)}}return D}}class M extends r{constructor(P){if(super(),P<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${P}.`);this.guidance_scale=P}_call(P,D){if(D.dims[0]!==2*P.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${D.dims[0]} for the logits and ${P.length} for the input ids.`);const z=P.length,U=D.slice([0,z],null),N=D.slice([z,D.dims[0]],null);for(let j=0;j<N.data.length;++j)N.data[j]+=(U.data[j]-N.data[j])*this.guidance_scale;return N}}class T extends o{constructor(P){super(),this.temperature=P}_call(P,D){const z=D.data;for(let U=0;U<z.length;++U)z[U]/=this.temperature;return D}}class C extends o{constructor(P,{filter_value:D=-1/0,min_tokens_to_keep:z=1}={}){if(super(),P<0||P>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${P}`);if(!Number.isInteger(z)||z<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${z}`);this.top_p=P,this.filter_value=D,this.min_tokens_to_keep=z}}class x extends o{constructor(P,{filter_value:D=-1/0,min_tokens_to_keep:z=1}={}){if(super(),!Number.isInteger(P)||P<0)throw new Error(`\`top_k\` must be a positive integer, but is ${P}`);this.top_k=Math.max(P,z),this.filter_value=D}}}),"./src/generation/logits_sampler.js":((n,e,t)=>{t.r(e),t.d(e,{LogitsSampler:()=>o});var i=t("./src/utils/generic.js"),s=t("./src/utils/tensor.js"),r=t("./src/utils/maths.js");t("./src/generation/configuration_utils.js");class o extends i.Callable{constructor(p){super(),this.generation_config=p}async _call(p){return this.sample(p)}async sample(p){throw Error("sample should be implemented in subclasses.")}getLogits(p,h){let v=p.dims.at(-1),y=p.data;if(h===-1)y=y.slice(-v);else{let w=h*v;y=y.slice(w,w+v)}return y}randomSelect(p){let h=0;for(let y=0;y<p.length;++y)h+=p[y];let v=Math.random()*h;for(let y=0;y<p.length;++y)if(v-=p[y],v<=0)return y;return 0}static getSampler(p){if(p.do_sample)return new c(p);if(p.num_beams>1)return new d(p);if(p.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${p.num_return_sequences}.`);return new l(p)}}class l extends o{async sample(p){const h=(0,r.max)(p.data)[1];return[[BigInt(h),0]]}}class c extends o{async sample(p){let h=p.dims.at(-1);this.generation_config.top_k>0&&(h=Math.min(this.generation_config.top_k,h));const[v,y]=await(0,s.topk)(p,h),w=(0,r.softmax)(v.data);return Array.from({length:this.generation_config.num_beams},()=>{const S=this.randomSelect(w);return[y.data[S],Math.log(w[S])]})}}class d extends o{async sample(p){let h=p.dims.at(-1);this.generation_config.top_k>0&&(h=Math.min(this.generation_config.top_k,h));const[v,y]=await(0,s.topk)(p,h),w=(0,r.softmax)(v.data);return Array.from({length:this.generation_config.num_beams},(S,M)=>[y.data[M],Math.log(w[M])])}}}),"./src/generation/stopping_criteria.js":((n,e,t)=>{t.r(e),t.d(e,{EosTokenCriteria:()=>l,InterruptableStoppingCriteria:()=>c,MaxLengthCriteria:()=>o,StoppingCriteria:()=>s,StoppingCriteriaList:()=>r});var i=t("./src/utils/generic.js");class s extends i.Callable{_call(g,p){throw Error("StoppingCriteria needs to be subclassed")}}class r extends i.Callable{constructor(){super(),this.criteria=[]}push(g){this.criteria.push(g)}extend(g){g instanceof r?g=g.criteria:g instanceof s&&(g=[g]),this.criteria.push(...g)}_call(g,p){const h=new Array(g.length).fill(!1);for(const v of this.criteria){const y=v(g,p);for(let w=0;w<h.length;++w)h[w]||=y[w]}return h}[Symbol.iterator](){return this.criteria.values()}}class o extends s{constructor(g,p=null){super(),this.max_length=g,this.max_position_embeddings=p}_call(g){return g.map(p=>p.length>=this.max_length)}}class l extends s{constructor(g){super(),Array.isArray(g)||(g=[g]),this.eos_token_id=g}_call(g,p){return g.map(h=>{const v=h.at(-1);return this.eos_token_id.some(y=>v==y)})}}class c extends s{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(g,p){return new Array(g.length).fill(this.interrupted)}}}),"./src/generation/streamers.js":((n,e,t)=>{t.r(e),t.d(e,{BaseStreamer:()=>o,TextStreamer:()=>c,WhisperTextStreamer:()=>d});var i=t("./src/utils/core.js"),s=t("./src/tokenizers.js"),r=t("./src/env.js");class o{put(p){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const l=r.apis.IS_PROCESS_AVAILABLE?g=>process.stdout.write(g):g=>console.log(g);class c extends o{constructor(p,{skip_prompt:h=!1,callback_function:v=null,token_callback_function:y=null,skip_special_tokens:w=!0,decode_kwargs:S={},...M}={}){super(),this.tokenizer=p,this.skip_prompt=h,this.callback_function=v??l,this.token_callback_function=y,this.decode_kwargs={skip_special_tokens:w,...S,...M},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(p){if(p.length>1)throw Error("TextStreamer only supports batch size of 1");const h=this.next_tokens_are_prompt;if(h&&(this.next_tokens_are_prompt=!1,this.skip_prompt))return;const v=p[0];this.token_callback_function?.(v),this.token_cache=(0,i.mergeArrays)(this.token_cache,v);const y=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let w;h||y.endsWith(`
`)?(w=y.slice(this.print_len),this.token_cache=[],this.print_len=0):y.length>0&&(0,s.is_chinese_char)(y.charCodeAt(y.length-1))?(w=y.slice(this.print_len),this.print_len+=w.length):(w=y.slice(this.print_len,y.lastIndexOf(" ")+1),this.print_len+=w.length),this.on_finalized_text(w,!1)}end(){let p;this.token_cache.length>0?(p=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):p="",this.next_tokens_are_prompt=!0,this.on_finalized_text(p,!0)}on_finalized_text(p,h){p.length>0&&this.callback_function?.(p),h&&this.callback_function===l&&r.apis.IS_PROCESS_AVAILABLE&&this.callback_function?.(`
`)}}class d extends c{constructor(p,{skip_prompt:h=!1,callback_function:v=null,token_callback_function:y=null,on_chunk_start:w=null,on_chunk_end:S=null,on_finalize:M=null,time_precision:T=.02,skip_special_tokens:C=!0,decode_kwargs:x={}}={}){super(p,{skip_prompt:h,skip_special_tokens:C,callback_function:v,token_callback_function:y,decode_kwargs:x}),this.timestamp_begin=p.timestamp_begin,this.on_chunk_start=w,this.on_chunk_end=S,this.on_finalize=M,this.time_precision=T,this.waiting_for_timestamp=!1}put(p){if(p.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const h=p[0];if(h.length===1){const v=Number(h[0])-this.timestamp_begin;if(v>=0){const y=v*this.time_precision;this.waiting_for_timestamp?this.on_chunk_end?.(y):this.on_chunk_start?.(y),this.waiting_for_timestamp=!this.waiting_for_timestamp,this.token_callback_function?.(h);return}}return super.put(p)}end(){super.end(),this.on_finalize?.()}}}),"./src/models.js":((n,e,t)=>{t.r(e),t.d(e,{ASTForAudioClassification:()=>cu,ASTModel:()=>Wd,ASTPreTrainedModel:()=>Gc,AlbertForMaskedLM:()=>En,AlbertForQuestionAnswering:()=>bn,AlbertForSequenceClassification:()=>vn,AlbertModel:()=>$t,AlbertPreTrainedModel:()=>wt,ArceeForCausalLM:()=>qf,ArceeModel:()=>cc,ArceePreTrainedModel:()=>dr,AutoModel:()=>Yi,AutoModelForAudioClassification:()=>Xm,AutoModelForAudioFrameClassification:()=>oy,AutoModelForAudioTextToText:()=>P0,AutoModelForCTC:()=>Sc,AutoModelForCausalLM:()=>Dx,AutoModelForDepthEstimation:()=>Fx,AutoModelForDocumentQuestionAnswering:()=>ly,AutoModelForImageClassification:()=>Ox,AutoModelForImageFeatureExtraction:()=>fy,AutoModelForImageMatting:()=>uy,AutoModelForImageSegmentation:()=>c_,AutoModelForImageTextToText:()=>Nx,AutoModelForImageToImage:()=>cy,AutoModelForMaskGeneration:()=>If,AutoModelForMaskedLM:()=>ay,AutoModelForNormalEstimation:()=>C0,AutoModelForObjectDetection:()=>d_,AutoModelForPoseEstimation:()=>dy,AutoModelForQuestionAnswering:()=>Bx,AutoModelForSemanticSegmentation:()=>Gp,AutoModelForSeq2SeqLM:()=>sy,AutoModelForSequenceClassification:()=>Nu,AutoModelForSpeechSeq2Seq:()=>ry,AutoModelForTextToSpectrogram:()=>Ls,AutoModelForTextToWaveform:()=>T0,AutoModelForTokenClassification:()=>kp,AutoModelForUniversalSegmentation:()=>S0,AutoModelForVision2Seq:()=>Ix,AutoModelForXVector:()=>Lx,AutoModelForZeroShotObjectDetection:()=>A0,BartForConditionalGeneration:()=>co,BartForSequenceClassification:()=>es,BartModel:()=>Bs,BartPretrainedModel:()=>Kr,BaseModelOutput:()=>ke,BeitForImageClassification:()=>Ma,BeitModel:()=>qa,BeitPreTrainedModel:()=>zr,BertForMaskedLM:()=>Fe,BertForQuestionAnswering:()=>Qe,BertForSequenceClassification:()=>Ye,BertForTokenClassification:()=>Ve,BertModel:()=>je,BertPreTrainedModel:()=>ze,BlenderbotForConditionalGeneration:()=>Pi,BlenderbotModel:()=>Gs,BlenderbotPreTrainedModel:()=>ia,BlenderbotSmallForConditionalGeneration:()=>Vs,BlenderbotSmallModel:()=>Ns,BlenderbotSmallPreTrainedModel:()=>ns,BloomForCausalLM:()=>Xr,BloomModel:()=>ip,BloomPreTrainedModel:()=>Kn,CLIPModel:()=>jc,CLIPPreTrainedModel:()=>cr,CLIPSegForImageSegmentation:()=>ol,CLIPSegModel:()=>Xc,CLIPSegPreTrainedModel:()=>pu,CLIPTextModel:()=>$c,CLIPTextModelWithProjection:()=>Ol,CLIPVisionModel:()=>fu,CLIPVisionModelWithProjection:()=>Wc,CamembertForMaskedLM:()=>ft,CamembertForQuestionAnswering:()=>Bt,CamembertForSequenceClassification:()=>yt,CamembertForTokenClassification:()=>Ne,CamembertModel:()=>nt,CamembertPreTrainedModel:()=>rt,CausalLMOutput:()=>yi,CausalLMOutputWithPast:()=>D0,ChineseCLIPModel:()=>Kf,ChineseCLIPPreTrainedModel:()=>yn,ClapAudioModelWithProjection:()=>xr,ClapModel:()=>to,ClapPreTrainedModel:()=>Ea,ClapTextModelWithProjection:()=>xo,CodeGenForCausalLM:()=>Nt,CodeGenModel:()=>ct,CodeGenPreTrainedModel:()=>Re,CohereForCausalLM:()=>tf,CohereModel:()=>_u,CoherePreTrainedModel:()=>ef,ConvBertForMaskedLM:()=>A,ConvBertForQuestionAnswering:()=>Ee,ConvBertForSequenceClassification:()=>F,ConvBertForTokenClassification:()=>K,ConvBertModel:()=>I,ConvBertPreTrainedModel:()=>B,ConvNextForImageClassification:()=>zm,ConvNextModel:()=>mh,ConvNextPreTrainedModel:()=>mf,ConvNextV2ForImageClassification:()=>km,ConvNextV2Model:()=>Um,ConvNextV2PreTrainedModel:()=>gh,DFineForObjectDetection:()=>cf,DFineModel:()=>lh,DFinePreTrainedModel:()=>Au,DINOv3ConvNextModel:()=>Pp,DINOv3ConvNextPreTrainedModel:()=>Cp,DINOv3ViTModel:()=>Ap,DINOv3ViTPreTrainedModel:()=>Sp,DPTForDepthEstimation:()=>Pm,DPTModel:()=>_p,DPTPreTrainedModel:()=>ff,DacDecoderModel:()=>io,DacDecoderOutput:()=>tu,DacEncoderModel:()=>Hi,DacEncoderOutput:()=>no,DacModel:()=>Ho,DacPreTrainedModel:()=>qi,DebertaForMaskedLM:()=>Bn,DebertaForQuestionAnswering:()=>Mn,DebertaForSequenceClassification:()=>bi,DebertaForTokenClassification:()=>gn,DebertaModel:()=>xn,DebertaPreTrainedModel:()=>on,DebertaV2ForMaskedLM:()=>Ge,DebertaV2ForQuestionAnswering:()=>Ot,DebertaV2ForSequenceClassification:()=>Je,DebertaV2ForTokenClassification:()=>Ue,DebertaV2Model:()=>we,DebertaV2PreTrainedModel:()=>Se,DecisionTransformerModel:()=>vd,DecisionTransformerPreTrainedModel:()=>Ou,DeiTForImageClassification:()=>Am,DeiTModel:()=>Sm,DeiTPreTrainedModel:()=>uh,DepthAnythingForDepthEstimation:()=>yp,DepthAnythingPreTrainedModel:()=>vp,DepthProForDepthEstimation:()=>Dm,DepthProPreTrainedModel:()=>r_,DetrForObjectDetection:()=>oa,DetrForSegmentation:()=>Mr,DetrModel:()=>dp,DetrObjectDetectionOutput:()=>Xa,DetrPreTrainedModel:()=>uf,DetrSegmentationOutput:()=>Su,Dinov2ForImageClassification:()=>Ep,Dinov2Model:()=>Ya,Dinov2PreTrainedModel:()=>wp,Dinov2WithRegistersForImageClassification:()=>Tp,Dinov2WithRegistersModel:()=>_h,Dinov2WithRegistersPreTrainedModel:()=>gf,DistilBertForMaskedLM:()=>_n,DistilBertForQuestionAnswering:()=>wn,DistilBertForSequenceClassification:()=>en,DistilBertForTokenClassification:()=>dn,DistilBertModel:()=>tn,DistilBertPreTrainedModel:()=>jt,DonutSwinModel:()=>Nm,DonutSwinPreTrainedModel:()=>ld,EdgeTamModel:()=>Xl,EfficientNetForImageClassification:()=>xh,EfficientNetModel:()=>Km,EfficientNetPreTrainedModel:()=>bc,ElectraForMaskedLM:()=>Q,ElectraForQuestionAnswering:()=>Le,ElectraForSequenceClassification:()=>ve,ElectraForTokenClassification:()=>ge,ElectraModel:()=>re,ElectraPreTrainedModel:()=>k,Ernie4_5_ForCausalLM:()=>bh,Ernie4_5_Model:()=>Np,Ernie4_5_PretrainedModel:()=>is,EsmForMaskedLM:()=>Pn,EsmForSequenceClassification:()=>Ln,EsmForTokenClassification:()=>Ct,EsmModel:()=>ti,EsmPreTrainedModel:()=>Fn,ExaoneForCausalLM:()=>Yf,ExaoneModel:()=>Gl,ExaonePreTrainedModel:()=>Zc,FalconForCausalLM:()=>bl,FalconModel:()=>zp,FalconPreTrainedModel:()=>Jl,FastViTForImageClassification:()=>lf,FastViTModel:()=>of,FastViTPreTrainedModel:()=>af,Florence2ForConditionalGeneration:()=>Bl,Florence2PreTrainedModel:()=>Qd,GLPNForDepthEstimation:()=>Fm,GLPNModel:()=>a_,GLPNPreTrainedModel:()=>xp,GPT2LMHeadModel:()=>ac,GPT2Model:()=>Fl,GPT2PreTrainedModel:()=>gs,GPTBigCodeForCausalLM:()=>Te,GPTBigCodeModel:()=>_e,GPTBigCodePreTrainedModel:()=>Z,GPTJForCausalLM:()=>G,GPTJModel:()=>Oo,GPTJPreTrainedModel:()=>gu,GPTNeoForCausalLM:()=>ll,GPTNeoModel:()=>Yc,GPTNeoPreTrainedModel:()=>po,GPTNeoXForCausalLM:()=>sa,GPTNeoXModel:()=>Nl,GPTNeoXPreTrainedModel:()=>mu,Gemma2ForCausalLM:()=>Jf,Gemma2Model:()=>Nr,Gemma2PreTrainedModel:()=>fl,Gemma3ForCausalLM:()=>Qh,Gemma3Model:()=>fc,Gemma3PreTrainedModel:()=>vu,Gemma3nForConditionalGeneration:()=>sl,Gemma3nPreTrainedModel:()=>il,GemmaForCausalLM:()=>Ui,GemmaModel:()=>Is,GemmaPreTrainedModel:()=>Pr,GlmForCausalLM:()=>aa,GlmModel:()=>ul,GlmPreTrainedModel:()=>ra,GraniteForCausalLM:()=>dl,GraniteModel:()=>cl,GraniteMoeHybridForCausalLM:()=>Jh,GraniteMoeHybridModel:()=>Vl,GraniteMoeHybridPreTrainedModel:()=>No,GranitePreTrainedModel:()=>ya,GroundingDinoForObjectDetection:()=>Rp,GroundingDinoPreTrainedModel:()=>o_,GroupViTModel:()=>Eu,GroupViTPreTrainedModel:()=>wu,HeliumForCausalLM:()=>_a,HeliumModel:()=>Mm,HeliumPreTrainedModel:()=>kl,HieraForImageClassification:()=>pp,HieraModel:()=>hp,HieraPreTrainedModel:()=>Cm,HubertForCTC:()=>ua,HubertForSequenceClassification:()=>Qr,HubertModel:()=>fd,HubertPreTrainedModel:()=>vl,IJepaForImageClassification:()=>th,IJepaModel:()=>rd,IJepaPreTrainedModel:()=>zo,Idefics3ForConditionalGeneration:()=>rl,Idefics3PreTrainedModel:()=>ic,ImageMattingOutput:()=>Ym,JAISLMHeadModel:()=>uc,JAISModel:()=>lc,JAISPreTrainedModel:()=>oc,JinaCLIPModel:()=>qc,JinaCLIPPreTrainedModel:()=>rc,JinaCLIPTextModel:()=>al,JinaCLIPVisionModel:()=>Cr,Lfm2ForCausalLM:()=>Jc,Lfm2Model:()=>Zd,Lfm2PreTrainedModel:()=>zl,LiteWhisperForConditionalGeneration:()=>Hc,Llama4ForCausalLM:()=>hi,Llama4PreTrainedModel:()=>Zn,LlamaForCausalLM:()=>On,LlamaModel:()=>pn,LlamaPreTrainedModel:()=>sn,LlavaForConditionalGeneration:()=>fo,LlavaOnevisionForConditionalGeneration:()=>Bo,LlavaPreTrainedModel:()=>Yd,LlavaQwen2ForCausalLM:()=>Ar,LongT5ForConditionalGeneration:()=>Ci,LongT5Model:()=>bs,LongT5PreTrainedModel:()=>Ms,M2M100ForConditionalGeneration:()=>cd,M2M100Model:()=>vf,M2M100PreTrainedModel:()=>Mc,MBartForCausalLM:()=>Ks,MBartForConditionalGeneration:()=>Fr,MBartForSequenceClassification:()=>na,MBartModel:()=>Sr,MBartPreTrainedModel:()=>ms,MPNetForMaskedLM:()=>fi,MPNetForQuestionAnswering:()=>Ds,MPNetForSequenceClassification:()=>ks,MPNetForTokenClassification:()=>$s,MPNetModel:()=>ma,MPNetPreTrainedModel:()=>$i,MT5ForConditionalGeneration:()=>Wr,MT5Model:()=>Ws,MT5PreTrainedModel:()=>ps,MarianMTModel:()=>Vm,MarianModel:()=>_f,MarianPreTrainedModel:()=>xa,MaskFormerForInstanceSegmentation:()=>Lm,MaskFormerModel:()=>Om,MaskFormerPreTrainedModel:()=>bp,MaskedLMOutput:()=>da,Metric3DForDepthEstimation:()=>Mp,Metric3DPreTrainedModel:()=>Bm,Metric3Dv2ForDepthEstimation:()=>Im,Metric3Dv2PreTrainedModel:()=>ph,MgpstrForSceneTextRecognition:()=>Sa,MgpstrModelOutput:()=>pr,MgpstrPreTrainedModel:()=>Na,MimiDecoderModel:()=>mr,MimiDecoderOutput:()=>pi,MimiEncoderModel:()=>xs,MimiEncoderOutput:()=>Si,MimiModel:()=>wi,MimiPreTrainedModel:()=>jn,MistralForCausalLM:()=>Sf,MistralModel:()=>md,MistralPreTrainedModel:()=>yl,MobileBertForMaskedLM:()=>Nn,MobileBertForQuestionAnswering:()=>yr,MobileBertForSequenceClassification:()=>Ss,MobileBertModel:()=>Qt,MobileBertPreTrainedModel:()=>gt,MobileLLMForCausalLM:()=>Yh,MobileLLMModel:()=>Lo,MobileLLMPreTrainedModel:()=>Xh,MobileNetV1ForImageClassification:()=>qm,MobileNetV1ForSemanticSegmentation:()=>hr,MobileNetV1Model:()=>Up,MobileNetV1PreTrainedModel:()=>gd,MobileNetV2ForImageClassification:()=>Iu,MobileNetV2ForSemanticSegmentation:()=>sr,MobileNetV2Model:()=>Fa,MobileNetV2PreTrainedModel:()=>kr,MobileNetV3ForImageClassification:()=>xc,MobileNetV3ForSemanticSegmentation:()=>ss,MobileNetV3Model:()=>Zl,MobileNetV3PreTrainedModel:()=>wh,MobileNetV4ForImageClassification:()=>Br,MobileNetV4ForSemanticSegmentation:()=>Ys,MobileNetV4Model:()=>eu,MobileNetV4PreTrainedModel:()=>_d,MobileViTForImageClassification:()=>up,MobileViTModel:()=>Tu,MobileViTPreTrainedModel:()=>lp,MobileViTV2ForImageClassification:()=>Wl,MobileViTV2Model:()=>pl,MobileViTV2PreTrainedModel:()=>ih,ModelOutput:()=>xe,ModernBertDecoderForCausalLM:()=>Jt,ModernBertDecoderModel:()=>bt,ModernBertDecoderPreTrainedModel:()=>an,ModernBertForMaskedLM:()=>Et,ModernBertForSequenceClassification:()=>Dt,ModernBertForTokenClassification:()=>Vt,ModernBertModel:()=>at,ModernBertPreTrainedModel:()=>ht,Moondream1ForConditionalGeneration:()=>Jd,MoonshineForConditionalGeneration:()=>nc,MoonshineModel:()=>tl,MoonshinePreTrainedModel:()=>qd,MptForCausalLM:()=>$l,MptModel:()=>sp,MptPreTrainedModel:()=>Mu,MultiModalityCausalLM:()=>wc,MultiModalityPreTrainedModel:()=>rr,MusicgenForCausalLM:()=>Ta,MusicgenForConditionalGeneration:()=>Ql,MusicgenModel:()=>Dr,MusicgenPreTrainedModel:()=>Gi,NanoChatForCausalLM:()=>ga,NanoChatModel:()=>ki,NanoChatPreTrainedModel:()=>zi,NeoBertForMaskedLM:()=>Me,NeoBertForQuestionAnswering:()=>et,NeoBertForSequenceClassification:()=>me,NeoBertForTokenClassification:()=>$e,NeoBertModel:()=>Tt,NeoBertPreTrainedModel:()=>mt,NomicBertModel:()=>We,NomicBertPreTrainedModel:()=>Tn,OPTForCausalLM:()=>rp,OPTModel:()=>sd,OPTPreTrainedModel:()=>go,Olmo2ForCausalLM:()=>Ka,Olmo2Model:()=>td,Olmo2PreTrainedModel:()=>ed,OlmoForCausalLM:()=>dc,OlmoModel:()=>Fo,OlmoPreTrainedModel:()=>va,OpenELMForCausalLM:()=>Hl,OpenELMModel:()=>Zh,OpenELMPreTrainedModel:()=>nd,OwlViTForObjectDetection:()=>cp,OwlViTModel:()=>sh,OwlViTPreTrainedModel:()=>Kl,Owlv2ForObjectDetection:()=>ml,Owlv2Model:()=>gc,Owlv2PreTrainedModel:()=>od,PaliGemmaForConditionalGeneration:()=>Il,PaliGemmaPreTrainedModel:()=>nl,ParakeetForCTC:()=>vh,ParakeetPreTrainedModel:()=>$m,PatchTSMixerForPrediction:()=>Vi,PatchTSMixerModel:()=>Th,PatchTSMixerPreTrainedModel:()=>Pf,PatchTSTForPrediction:()=>Cf,PatchTSTModel:()=>Eh,PatchTSTPreTrainedModel:()=>Lu,Phi3ForCausalLM:()=>np,Phi3Model:()=>xm,Phi3PreTrainedModel:()=>tp,Phi3VForCausalLM:()=>sc,Phi3VPreTrainedModel:()=>du,PhiForCausalLM:()=>ep,PhiModel:()=>nf,PhiPreTrainedModel:()=>Rr,PreTrainedModel:()=>ye,PretrainedMixin:()=>Li,PvtForImageClassification:()=>Em,PvtModel:()=>rf,PvtPreTrainedModel:()=>_o,PyAnnoteForAudioFrameClassification:()=>Fp,PyAnnoteModel:()=>Wm,PyAnnotePreTrainedModel:()=>yf,QuestionAnsweringModelOutput:()=>Ca,Qwen2ForCausalLM:()=>mo,Qwen2Model:()=>jl,Qwen2PreTrainedModel:()=>qr,Qwen2VLForConditionalGeneration:()=>hc,Qwen2VLPreTrainedModel:()=>id,Qwen3ForCausalLM:()=>yu,Qwen3Model:()=>Zf,Qwen3PreTrainedModel:()=>hl,RFDetrForObjectDetection:()=>oh,RFDetrModel:()=>br,RFDetrObjectDetectionOutput:()=>gl,RFDetrPreTrainedModel:()=>_s,RTDetrForObjectDetection:()=>ql,RTDetrModel:()=>Tm,RTDetrObjectDetectionOutput:()=>la,RTDetrPreTrainedModel:()=>rh,RTDetrV2ForObjectDetection:()=>Ia,RTDetrV2Model:()=>ah,RTDetrV2ObjectDetectionOutput:()=>si,RTDetrV2PreTrainedModel:()=>Xs,ResNetForImageClassification:()=>fr,ResNetModel:()=>ba,ResNetPreTrainedModel:()=>ch,RoFormerForMaskedLM:()=>qe,RoFormerForQuestionAnswering:()=>fe,RoFormerForSequenceClassification:()=>Kt,RoFormerForTokenClassification:()=>rn,RoFormerModel:()=>Yt,RoFormerPreTrainedModel:()=>vt,RobertaForMaskedLM:()=>ec,RobertaForQuestionAnswering:()=>Vf,RobertaForSequenceClassification:()=>uu,RobertaForTokenClassification:()=>tc,RobertaModel:()=>Dl,RobertaPreTrainedModel:()=>Ba,Sam2ImageSegmentationOutput:()=>Gm,Sam2Model:()=>vc,Sam2PreTrainedModel:()=>ud,Sam3TrackerModel:()=>yc,SamImageSegmentationOutput:()=>u_,SamModel:()=>l_,SamPreTrainedModel:()=>Op,SapiensForDepthEstimation:()=>pf,SapiensForNormalEstimation:()=>Rm,SapiensForSemanticSegmentation:()=>hh,SapiensPreTrainedModel:()=>hf,SegformerForImageClassification:()=>wo,SegformerForSemanticSegmentation:()=>Us,SegformerModel:()=>wr,SegformerPreTrainedModel:()=>Wi,Seq2SeqLMOutput:()=>R0,SequenceClassifierOutput:()=>di,SiglipModel:()=>Kc,SiglipPreTrainedModel:()=>Ll,SiglipTextModel:()=>hu,SiglipVisionModel:()=>ho,SmolLM3ForCausalLM:()=>Qc,SmolLM3Model:()=>Xf,SmolLM3PreTrainedModel:()=>Ul,SmolVLMForConditionalGeneration:()=>Io,SnacDecoderModel:()=>nu,SnacEncoderModel:()=>za,SnacModel:()=>ca,SnacPreTrainedModel:()=>so,SpeechT5ForSpeechToText:()=>wf,SpeechT5ForTextToSpeech:()=>Vo,SpeechT5HifiGan:()=>Ru,SpeechT5Model:()=>Mh,SpeechT5PreTrainedModel:()=>Yl,SqueezeBertForMaskedLM:()=>Ie,SqueezeBertForQuestionAnswering:()=>Ze,SqueezeBertForSequenceClassification:()=>Ke,SqueezeBertModel:()=>de,SqueezeBertPreTrainedModel:()=>lt,StableLmForCausalLM:()=>ir,StableLmModel:()=>Af,StableLmPreTrainedModel:()=>wl,Starcoder2ForCausalLM:()=>bo,Starcoder2Model:()=>Ml,Starcoder2PreTrainedModel:()=>Bu,StyleTextToSpeech2Model:()=>pd,StyleTextToSpeech2PreTrainedModel:()=>hd,SupertonicForConditionalGeneration:()=>Tf,SupertonicPreTrainedModel:()=>Ef,Swin2SRForImageSuperResolution:()=>gp,Swin2SRModel:()=>fh,Swin2SRPreTrainedModel:()=>_l,SwinForImageClassification:()=>dh,SwinForSemanticSegmentation:()=>mp,SwinModel:()=>df,SwinPreTrainedModel:()=>_c,T5ForConditionalGeneration:()=>ni,T5Model:()=>Qn,T5PreTrainedModel:()=>un,TableTransformerForObjectDetection:()=>tr,TableTransformerModel:()=>s_,TableTransformerObjectDetectionOutput:()=>fp,TableTransformerPreTrainedModel:()=>Uo,TokenClassifierOutput:()=>gr,TrOCRForCausalLM:()=>Du,TrOCRPreTrainedModel:()=>La,UltravoxModel:()=>_i,UltravoxPreTrainedModel:()=>rs,UniSpeechForCTC:()=>zs,UniSpeechForSequenceClassification:()=>nr,UniSpeechModel:()=>yh,UniSpeechPreTrainedModel:()=>wa,UniSpeechSatForAudioFrameClassification:()=>Go,UniSpeechSatForCTC:()=>Ja,UniSpeechSatForSequenceClassification:()=>Qa,UniSpeechSatModel:()=>Mf,UniSpeechSatPreTrainedModel:()=>Cu,VaultGemmaForCausalLM:()=>bm,VaultGemmaModel:()=>Qf,VaultGemmaPreTrainedModel:()=>Ri,ViTForImageClassification:()=>bu,ViTMAEModel:()=>pc,ViTMAEPreTrainedModel:()=>ap,ViTMSNForImageClassification:()=>op,ViTMSNModel:()=>nh,ViTMSNPreTrainedModel:()=>Jn,ViTModel:()=>wm,ViTPreTrainedModel:()=>eh,VisionEncoderDecoderModel:()=>Xd,VitMatteForImageMatting:()=>mc,VitMattePreTrainedModel:()=>ad,VitPoseForPoseEstimation:()=>sf,VitPosePreTrainedModel:()=>xu,VitsModel:()=>gi,VitsModelOutput:()=>f_,VitsPreTrainedModel:()=>xl,VoxtralForConditionalGeneration:()=>Oi,Wav2Vec2BertForCTC:()=>Ur,Wav2Vec2BertForSequenceClassification:()=>bf,Wav2Vec2BertModel:()=>yo,Wav2Vec2BertPreTrainedModel:()=>vo,Wav2Vec2ForAudioFrameClassification:()=>Lp,Wav2Vec2ForCTC:()=>jm,Wav2Vec2ForSequenceClassification:()=>Jr,Wav2Vec2Model:()=>Hm,Wav2Vec2PreTrainedModel:()=>ko,WavLMForAudioFrameClassification:()=>Pu,WavLMForCTC:()=>Mo,WavLMForSequenceClassification:()=>xf,WavLMForXVector:()=>eo,WavLMModel:()=>Za,WavLMPreTrainedModel:()=>Di,WeSpeakerResNetModel:()=>Oa,WeSpeakerResNetPreTrainedModel:()=>dd,WhisperForConditionalGeneration:()=>Vc,WhisperModel:()=>Kd,WhisperPreTrainedModel:()=>el,XLMForQuestionAnswering:()=>Wf,XLMForSequenceClassification:()=>Uc,XLMForTokenClassification:()=>$f,XLMModel:()=>Hf,XLMPreTrainedModel:()=>qs,XLMRobertaForMaskedLM:()=>Hd,XLMRobertaForQuestionAnswering:()=>$d,XLMRobertaForSequenceClassification:()=>kc,XLMRobertaForTokenClassification:()=>jd,XLMRobertaModel:()=>Vd,XLMRobertaPreTrainedModel:()=>Do,XLMWithLMHeadModel:()=>jf,XVectorOutput:()=>hy,YolosForObjectDetection:()=>Ip,YolosModel:()=>Bp,YolosObjectDetectionOutput:()=>Yr,YolosPreTrainedModel:()=>Dp});var i=t("./src/configs.js"),s=t("./src/backends/onnx.js"),r=t("./src/utils/dtypes.js"),o=t("./src/utils/generic.js"),l=t("./src/utils/core.js"),c=t("./src/utils/hub.js"),d=t("./src/utils/constants.js"),g=t("./src/generation/logits_process.js"),p=t("./src/generation/configuration_utils.js"),h=t("./src/utils/tensor.js"),v=t("./src/utils/image.js"),y=t("./src/utils/maths.js"),w=t("./src/generation/stopping_criteria.js"),S=t("./src/generation/logits_sampler.js"),M=t("./src/env.js"),T=t("./src/models/whisper/generation_whisper.js"),C=t("./src/models/whisper/common_whisper.js");const x={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7,MultiModality:8,Phi3V:9,AudioTextToText:10,AutoEncoder:11,ImageAudioTextToText:12,Supertonic:13},R=new Map,P=new Map,D=new Map;async function z(Y,X,Pe){let ut=Pe.config?.["transformers.js_config"]??{},xt=Pe.device??ut.device;xt&&typeof xt!="string"&&(xt.hasOwnProperty(X)?xt=xt[X]:(console.warn(`device not specified for "${X}". Using the default device.`),xt=null));const St=xt??(M.apis.IS_NODE_ENV?"cpu":"wasm"),Ht=(0,s.deviceToExecutionProviders)(St),ln=ut.device_config??{};ln.hasOwnProperty(St)&&(ut={...ut,...ln[St]});let hn=Pe.dtype??ut.dtype;if(typeof hn!="string"&&(hn&&hn.hasOwnProperty(X)?hn=hn[X]:(hn=r.DEFAULT_DEVICE_DTYPE_MAPPING[St]??r.DATA_TYPES.fp32,console.warn(`dtype not specified for "${X}". Using the default dtype (${hn}) for this device (${St}).`))),hn===r.DATA_TYPES.auto){let Ei=ut.dtype;typeof Ei!="string"&&(Ei=Ei?.[X]),Ei&&Ei!==r.DATA_TYPES.auto&&r.DATA_TYPES.hasOwnProperty(Ei)?hn=Ei:hn=r.DEFAULT_DEVICE_DTYPE_MAPPING[St]??r.DATA_TYPES.fp32}const In=hn;if(r.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(In)){if(In===r.DATA_TYPES.fp16&&St==="webgpu"&&!await(0,r.isWebGpuFp16Supported)())throw new Error(`The device (${St}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${In}. Should be one of: ${Object.keys(r.DATA_TYPES).join(", ")}`);const Cn=ut.kv_cache_dtype,ii=Cn?typeof Cn=="string"?Cn:Cn[In]??"float32":void 0;if(ii&&!["float32","float16"].includes(ii))throw new Error(`Invalid kv_cache_dtype: ${ii}. Should be one of: float32, float16`);const Un={dtype:In,kv_cache_dtype:ii,device:St},qn=r.DEFAULT_DTYPE_SUFFIX_MAPPING[In],Ki=`${X}${qn}.onnx`,Xn=`${Pe.subfolder??""}/${Ki}`,kn={...Pe.session_options};kn.executionProviders??=Ht;const Bi=ut.free_dimension_overrides;Bi?kn.freeDimensionOverrides??=Bi:St.startsWith("webnn")&&!kn.freeDimensionOverrides&&console.warn(`WebNN does not currently support dynamic shapes and requires 'free_dimension_overrides' to be set in config.json, preferably as a field within config["transformers.js_config"]["device_config"]["${St}"]. When 'free_dimension_overrides' is not set, you may experience significant performance degradation.`);const Ji=M.apis.IS_NODE_ENV&&M.env.useFSCache,Hs=(0,c.getModelFile)(Y,Xn,!0,Pe,Ji),Js=Pe.use_external_data_format??ut.use_external_data_format;let or=[];if(Js){let Ei;typeof Js=="object"?Js.hasOwnProperty(Ki)?Ei=Js[Ki]:Js.hasOwnProperty(X)?Ei=Js[X]:Ei=!1:Ei=Js;const lr=+Ei;if(lr>c.MAX_EXTERNAL_DATA_CHUNKS)throw new Error(`The number of external data chunks (${lr}) exceeds the maximum allowed value (${c.MAX_EXTERNAL_DATA_CHUNKS}).`);for(let fa=0;fa<lr;++fa){const Of=`${Ki}_data${fa===0?"":"_"+fa}`,Ao=`${Pe.subfolder??""}/${Of}`;or.push(new Promise(async(zu,El)=>{const Sh=await(0,c.getModelFile)(Y,Ao,!0,Pe,Ji);zu(Sh instanceof Uint8Array?{path:Of,data:Sh}:Of)}))}}else kn.externalData!==void 0&&(or=kn.externalData.map(async Ei=>{if(typeof Ei.data=="string"){const lr=await(0,c.getModelFile)(Y,Ei.data,!0,Pe);return{...Ei,data:lr}}return Ei}));if(or.length>0){const Ei=await Promise.all(or);M.apis.IS_NODE_ENV||(kn.externalData=Ei)}if(St==="webgpu"){const Ei=(0,i.getCacheShapes)(Pe.config,{prefix:"present"});if(Object.keys(Ei).length>0&&!(0,s.isONNXProxy)()){const lr={};for(const fa in Ei)lr[fa]="gpu-buffer";kn.preferredOutputLocation=lr}}return{buffer_or_path:await Hs,session_options:kn,session_config:Un}}async function U(Y,X,Pe){return Object.fromEntries(await Promise.all(Object.keys(X).map(async ut=>{const{buffer_or_path:xt,session_options:St,session_config:Ht}=await z(Y,X[ut],Pe),ln=await(0,s.createInferenceSession)(xt,St,Ht);return[ut,ln]})))}async function N(Y,X,Pe){return Object.fromEntries(await Promise.all(Object.keys(X).map(async ut=>{const xt=await(0,c.getModelJSON)(Y,X[ut],!1,Pe);return[ut,xt]})))}function j(Y,X){const Pe=Object.create(null),ut=[];for(const Ht of Y.inputNames){const ln=X[Ht];if(!(ln instanceof h.Tensor)){ut.push(Ht);continue}Pe[Ht]=(0,s.isONNXProxy)()?ln.clone():ln}if(ut.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${ut.join(", ")}.`);const xt=Object.keys(X).length,St=Y.inputNames.length;if(xt>St){let Ht=Object.keys(X).filter(ln=>!Y.inputNames.includes(ln));console.warn(`WARNING: Too many inputs were provided (${xt} > ${St}). The following inputs will be ignored: "${Ht.join(", ")}".`)}return Pe}async function J(Y,X){const Pe=j(Y,X);try{const ut=Object.fromEntries(Object.entries(Pe).map(([St,Ht])=>[St,Ht.ort_tensor])),xt=await(0,s.runInferenceSession)(Y,ut);return W(xt)}catch(ut){const xt=Object.fromEntries(Object.entries(Pe).map(([St,Ht])=>{const ln={type:Ht.type,dims:Ht.dims,location:Ht.location};return ln.location!=="gpu-buffer"&&(ln.data=Ht.data),[St,ln]}));throw console.error(`An error occurred during model execution: "${ut}".`),console.error("Inputs given to model:",xt),ut}}function W(Y){for(let X in Y)(0,s.isONNXTensor)(Y[X])?Y[X]=new h.Tensor(Y[X]):typeof Y[X]=="object"&&W(Y[X]);return Y}function oe(Y){if(Y instanceof h.Tensor)return Y;if(Y.length===0)throw Error("items must be non-empty");if(Array.isArray(Y[0])){if(Y.some(X=>X.length!==Y[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new h.Tensor("int64",BigInt64Array.from(Y.flat().map(X=>BigInt(X))),[Y.length,Y[0].length])}else return new h.Tensor("int64",BigInt64Array.from(Y.map(X=>BigInt(X))),[1,Y.length])}function ne(Y){return new h.Tensor("bool",[Y],[1])}async function q(Y,X){let{encoder_outputs:Pe,input_ids:ut,decoder_input_ids:xt,...St}=X;if(!Pe){const ln=(0,l.pick)(X,Y.sessions.model.inputNames);Pe=(await le(Y,ln)).last_hidden_state}return St.input_ids=xt,St.encoder_hidden_states=Pe,Y.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(St.encoder_attention_mask=X.attention_mask),await pe(Y,St,!0)}async function le(Y,X){const Pe=Y.sessions.model,ut=(0,l.pick)(X,Pe.inputNames);if(Pe.inputNames.includes("inputs_embeds")&&!ut.inputs_embeds){if(!X.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");ut.inputs_embeds=await Y.encode_text({input_ids:X.input_ids})}if(Pe.inputNames.includes("token_type_ids")&&!ut.token_type_ids){if(!ut.input_ids)throw new Error("Both `input_ids` and `token_type_ids` are missing in the model inputs.");ut.token_type_ids=(0,h.zeros_like)(ut.input_ids)}if(Pe.inputNames.includes("pixel_mask")&&!ut.pixel_mask){if(!ut.pixel_values)throw new Error("Both `pixel_values` and `pixel_mask` are missing in the model inputs.");const xt=ut.pixel_values.dims;ut.pixel_mask=(0,h.ones)([xt[0],xt[2],xt[3]])}return await J(Pe,ut)}async function se(Y,X){const Pe=await Y.encode(X);return await Y.decode(Pe)}async function pe(Y,X,Pe=!1){const ut=Y.sessions[Pe?"decoder_model_merged":"model"],{past_key_values:xt,...St}=X;if(ut.inputNames.includes("use_cache_branch")&&(St.use_cache_branch=ne(!!xt)),ut.inputNames.includes("position_ids")&&St.attention_mask&&!St.position_ids){const ln=["paligemma","gemma3_text","gemma3"].includes(Y.config.model_type)?1:0;St.position_ids=He(St,xt,ln)}Y.addPastKeyValues(St,xt);const Ht=(0,l.pick)(St,ut.inputNames);return await J(ut,Ht)}function be({modality_token_id:Y,inputs_embeds:X,modality_features:Pe,input_ids:ut,attention_mask:xt}){const St=ut.tolist().map(In=>In.reduce((Cn,ii,Un)=>(ii==Y&&Cn.push(Un),Cn),[])),Ht=St.reduce((In,Cn)=>In+Cn.length,0),ln=Pe.dims[0];if(Ht!==ln)throw new Error(`Number of tokens and features do not match: tokens: ${Ht}, features ${ln}`);let hn=0;for(let In=0;In<St.length;++In){const Cn=St[In],ii=X[In];for(let Un=0;Un<Cn.length;++Un)ii[Cn[Un]].data.set(Pe[hn++].data)}return{inputs_embeds:X,attention_mask:xt}}function ee({image_token_id:Y,inputs_embeds:X,image_features:Pe,input_ids:ut,attention_mask:xt}){return be({modality_token_id:Y,inputs_embeds:X,modality_features:Pe,input_ids:ut,attention_mask:xt})}function te({audio_token_id:Y,inputs_embeds:X,audio_features:Pe,input_ids:ut,attention_mask:xt}){return be({modality_token_id:Y,inputs_embeds:X,modality_features:Pe,input_ids:ut,attention_mask:xt})}async function ue(Y,{encode_function:X,merge_function:Pe,modality_input_name:ut,modality_output_name:xt,input_ids:St=null,attention_mask:Ht=null,position_ids:ln=null,inputs_embeds:hn=null,past_key_values:In=null,generation_config:Cn=null,logits_processor:ii=null,...Un}){const qn=Un[ut];if(!hn){if(hn=await Y.encode_text({input_ids:St,...Un}),qn&&St.dims[1]!==1){const Xn=await X({[ut]:qn,...Un});({inputs_embeds:hn,attention_mask:Ht}=Pe({[xt]:Xn,inputs_embeds:hn,input_ids:St,attention_mask:Ht}))}else if(In&&qn&&St.dims[1]===1){const Xn=St.dims[1],kn=Object.values(In)[0].dims.at(-2);Ht=(0,h.cat)([(0,h.ones)([St.dims[0],kn]),Ht.slice(null,[Ht.dims[1]-Xn,Ht.dims[1]])],1)}}if(!ln&&Y.config.model_type==="qwen2_vl"){const{image_grid_thw:Xn,video_grid_thw:kn}=Un;[ln]=Y.get_rope_index(St,Xn,kn,Ht)}return await pe(Y,{inputs_embeds:hn,past_key_values:In,attention_mask:Ht,position_ids:ln,generation_config:Cn,logits_processor:ii},!0)}async function ae(Y,X){return await ue(Y,{...X,modality_input_name:"audio_values",modality_output_name:"audio_features",encode_function:Y.encode_audio.bind(Y),merge_function:Y._merge_input_ids_with_audio_features.bind(Y)})}async function ce(Y,X){return await ue(Y,{...X,modality_input_name:"pixel_values",modality_output_name:"image_features",encode_function:Y.encode_image.bind(Y),merge_function:Y._merge_input_ids_with_image_features.bind(Y)})}function Be(Y,X=0){const[Pe,ut]=Y.dims,xt=Y.data,St=new BigInt64Array(xt.length);for(let Ht=0;Ht<Pe;++Ht){const ln=Ht*ut;let hn=BigInt(X);for(let In=0;In<ut;++In){const Cn=ln+In;xt[Cn]===0n?St[Cn]=BigInt(1):(St[Cn]=hn,hn+=xt[Cn])}}return{data:St,dims:Y.dims}}function He(Y,X=null,Pe=0){const{input_ids:ut,inputs_embeds:xt,attention_mask:St}=Y,{data:Ht,dims:ln}=Be(St,Pe);let hn=new h.Tensor("int64",Ht,ln);if(X){const In=-(ut??xt).dims.at(1);hn=hn.slice(null,[In,null])}return hn}function Xe(Y,X,Pe,ut){const xt=Pe.past_key_values?Object.values(Pe.past_key_values)[0].dims.at(-2):0;if(!Pe.attention_mask){let St;for(const Ht of["input_ids","inputs_embeds","position_ids"])if(Pe[Ht]){St=Pe[Ht].dims;break}if(!St)throw new Error("attention_mask is not provided, and unable to infer its shape from model inputs.");Pe.attention_mask=(0,h.ones)([St[0],xt+St[1]])}if(Pe.past_key_values){const{input_ids:St,attention_mask:Ht}=Pe;Ht&&Ht.dims[1]>St.dims[1]||xt<St.dims[1]&&(Pe.input_ids=St.slice(null,[xt,null]))}return Pe}function ot(Y,X,Pe,ut){return Pe.past_key_values&&(X=X.map(xt=>[xt.at(-1)])),{...Pe,decoder_input_ids:oe(X)}}function tt(Y,...X){return Y.config.is_encoder_decoder?ot(Y,...X):Xe(Y,...X)}function Ae(Y,X,Pe,ut){const xt=!!Pe.past_key_values;return ut.guidance_scale!==null&&ut.guidance_scale>1&&(xt?Pe.input_ids=(0,h.cat)([Pe.input_ids,Pe.input_ids],0):(Pe.input_ids=(0,h.cat)([Pe.input_ids,(0,h.full_like)(Pe.input_ids,BigInt(ut.pad_token_id))],0),Pe.attention_mask=(0,h.cat)([Pe.attention_mask,(0,h.full_like)(Pe.attention_mask,0n)],0))),(xt||!Pe.pixel_values)&&(Pe.pixel_values=(0,h.full)([0,0,3,384,384],1)),xt&&(Pe.images_seq_mask=new h.Tensor("bool",new Array(1).fill(!0).fill(!1,0,1),[1,1]),Pe.images_emb_mask=new h.Tensor("bool",new Array(0).fill(!1),[1,1,0])),Pe}class ye extends o.Callable{main_input_name="input_ids";forward_params=["input_ids","attention_mask"];constructor(X,Pe,ut){super(),this.config=X,this.sessions=Pe,this.configs=ut;const xt=D.get(this.constructor),St=R.get(xt);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,St){case x.DecoderOnly:this.can_generate=!0,this._forward=pe,this._prepare_inputs_for_generation=Xe;break;case x.Seq2Seq:case x.Vision2Seq:case x.Musicgen:this.can_generate=!0,this._forward=q,this._prepare_inputs_for_generation=ot;break;case x.EncoderDecoder:this._forward=q;break;case x.ImageTextToText:this.can_generate=!0,this._forward=ce,this._prepare_inputs_for_generation=tt;break;case x.AudioTextToText:this.can_generate=!0,this._forward=ae,this._prepare_inputs_for_generation=tt;break;case x.Phi3V:case x.ImageAudioTextToText:this.can_generate=!0,this._prepare_inputs_for_generation=tt;break;case x.MultiModality:this.can_generate=!0,this._prepare_inputs_for_generation=Ae;break;case x.AutoEncoder:this._forward=se;break;default:this._forward=le;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){const X=[];for(const Pe of Object.values(this.sessions))Pe?.handler?.dispose&&X.push(Pe.handler.dispose());return await Promise.all(X)}static async from_pretrained(X,{progress_callback:Pe=null,config:ut=null,cache_dir:xt=null,local_files_only:St=!1,revision:Ht="main",model_file_name:ln=null,subfolder:hn="onnx",device:In=null,dtype:Cn=null,use_external_data_format:ii=null,session_options:Un={}}={}){let qn={progress_callback:Pe,config:ut,cache_dir:xt,local_files_only:St,revision:Ht,model_file_name:ln,subfolder:hn,device:In,dtype:Cn,use_external_data_format:ii,session_options:Un};const Ki=D.get(this),Xn=R.get(Ki);ut=qn.config=await i.AutoConfig.from_pretrained(X,qn);let kn;if(Xn===x.DecoderOnly)kn=await Promise.all([U(X,{model:qn.model_file_name??"model"},qn),N(X,{generation_config:"generation_config.json"},qn)]);else if(Xn===x.Seq2Seq||Xn===x.Vision2Seq)kn=await Promise.all([U(X,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},qn),N(X,{generation_config:"generation_config.json"},qn)]);else if(Xn===x.MaskGeneration)kn=await Promise.all([U(X,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},qn)]);else if(Xn===x.EncoderDecoder)kn=await Promise.all([U(X,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},qn)]);else if(Xn===x.ImageTextToText){const Bi={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};ut.is_encoder_decoder&&(Bi.model="encoder_model"),kn=await Promise.all([U(X,Bi,qn),N(X,{generation_config:"generation_config.json"},qn)])}else if(Xn===x.AudioTextToText){const Bi={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",decoder_model_merged:"decoder_model_merged"};kn=await Promise.all([U(X,Bi,qn),N(X,{generation_config:"generation_config.json"},qn)])}else if(Xn===x.ImageAudioTextToText){const Bi={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};kn=await Promise.all([U(X,Bi,qn),N(X,{generation_config:"generation_config.json"},qn)])}else if(Xn===x.Musicgen)kn=await Promise.all([U(X,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},qn),N(X,{generation_config:"generation_config.json"},qn)]);else if(Xn===x.MultiModality)kn=await Promise.all([U(X,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},qn),N(X,{generation_config:"generation_config.json"},qn)]);else if(Xn===x.Phi3V)kn=await Promise.all([U(X,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},qn),N(X,{generation_config:"generation_config.json"},qn)]);else if(Xn===x.AutoEncoder)kn=await Promise.all([U(X,{encoder_model:"encoder_model",decoder_model:"decoder_model"},qn)]);else if(Xn===x.Supertonic)kn=await Promise.all([U(X,{text_encoder:"text_encoder",latent_denoiser:"latent_denoiser",voice_decoder:"voice_decoder"},qn)]);else{if(Xn!==x.EncoderOnly){const Bi=Ki??ut?.model_type;Bi!=="custom"&&console.warn(`Model type for '${Bi}' not found, assuming encoder-only architecture. Please report this at ${d.GITHUB_ISSUE_URL}.`)}kn=await Promise.all([U(X,{model:qn.model_file_name??"model"},qn)])}return new this(ut,...kn)}async _call(X){return await this.forward(X)}async forward(X){return await this._forward(this,X)}get generation_config(){return this.configs?.generation_config??null}_get_logits_processor(X,Pe,ut=null){const xt=new g.LogitsProcessorList;if(X.repetition_penalty!==null&&X.repetition_penalty!==1&&xt.push(new g.RepetitionPenaltyLogitsProcessor(X.repetition_penalty)),X.no_repeat_ngram_size!==null&&X.no_repeat_ngram_size>0&&xt.push(new g.NoRepeatNGramLogitsProcessor(X.no_repeat_ngram_size)),X.bad_words_ids!==null&&xt.push(new g.NoBadWordsLogitsProcessor(X.bad_words_ids,X.eos_token_id)),X.min_length!==null&&X.eos_token_id!==null&&X.min_length>0&&xt.push(new g.MinLengthLogitsProcessor(X.min_length,X.eos_token_id)),X.min_new_tokens!==null&&X.eos_token_id!==null&&X.min_new_tokens>0&&xt.push(new g.MinNewTokensLengthLogitsProcessor(Pe,X.min_new_tokens,X.eos_token_id)),X.forced_bos_token_id!==null&&xt.push(new g.ForcedBOSTokenLogitsProcessor(X.forced_bos_token_id)),X.forced_eos_token_id!==null&&xt.push(new g.ForcedEOSTokenLogitsProcessor(X.max_length,X.forced_eos_token_id)),X.begin_suppress_tokens!==null){const St=Pe>1||X.forced_bos_token_id===null?Pe:Pe+1;xt.push(new g.SuppressTokensAtBeginLogitsProcessor(X.begin_suppress_tokens,St))}return X.guidance_scale!==null&&X.guidance_scale>1&&xt.push(new g.ClassifierFreeGuidanceLogitsProcessor(X.guidance_scale)),X.temperature===0&&X.do_sample&&(console.warn("`do_sample` changed to false because `temperature: 0` implies greedy sampling (always selecting the most likely token), which is incompatible with `do_sample: true`."),X.do_sample=!1),X.do_sample&&X.temperature!==null&&X.temperature!==1&&xt.push(new g.TemperatureLogitsWarper(X.temperature)),ut!==null&&xt.extend(ut),xt}_prepare_generation_config(X,Pe,ut=p.GenerationConfig){const xt={...this.config};for(const Ht of["decoder","generator","text_config"])Ht in xt&&Object.assign(xt,xt[Ht]);const St=new ut(xt);return Object.assign(St,this.generation_config??{}),X&&Object.assign(St,X),Pe&&Object.assign(St,(0,l.pick)(Pe,Object.getOwnPropertyNames(St))),St}_get_stopping_criteria(X,Pe=null){const ut=new w.StoppingCriteriaList;return X.max_length!==null&&ut.push(new w.MaxLengthCriteria(X.max_length,this.config.max_position_embeddings??null)),X.eos_token_id!==null&&ut.push(new w.EosTokenCriteria(X.eos_token_id)),Pe&&ut.extend(Pe),ut}_validate_model_class(){if(!this.can_generate){const X=[Fu,m,Df,To],Pe=D.get(this.constructor),ut=new Set,xt=this.config.model_type;for(const Ht of X){const ln=Ht.get(xt);ln&&ut.add(ln[0])}let St=`The current model class (${Pe}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw ut.size>0&&(St+=` Please use the following class instead: ${[...ut].join(", ")}`),Error(St)}}prepare_inputs_for_generation(...X){return this._prepare_inputs_for_generation(this,...X)}_update_model_kwargs_for_generation({generated_input_ids:X,outputs:Pe,model_inputs:ut,is_encoder_decoder:xt}){return ut.past_key_values=this.getPastKeyValues(Pe,ut.past_key_values),ut.input_ids=new h.Tensor("int64",X.flat(),[X.length,1]),xt||(ut.attention_mask=(0,h.cat)([ut.attention_mask,(0,h.ones)([ut.attention_mask.dims[0],1])],1)),ut.position_ids=null,ut}_prepare_model_inputs({inputs:X,bos_token_id:Pe,model_kwargs:ut}){const xt=(0,l.pick)(ut,this.forward_params),St=this.main_input_name;if(St in xt){if(X)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else xt[St]=X;return{inputs_tensor:xt[St],model_inputs:xt,model_input_name:St}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:X,model_inputs:Pe,model_input_name:ut,generation_config:xt}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!Pe.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:Ht,pixel_values:ln,attention_mask:hn,...In}=Pe,Cn=await this._prepare_inputs_embeds(Pe);Pe={...In,...(0,l.pick)(Cn,["inputs_embeds","attention_mask"])}}let{last_hidden_state:St}=await le(this,Pe);if(xt.guidance_scale!==null&&xt.guidance_scale>1)St=(0,h.cat)([St,(0,h.full_like)(St,0)],0),"attention_mask"in Pe&&(Pe.attention_mask=(0,h.cat)([Pe.attention_mask,(0,h.zeros_like)(Pe.attention_mask)],0));else if(Pe.decoder_input_ids){const Ht=oe(Pe.decoder_input_ids).dims[0];if(Ht!==St.dims[0]){if(St.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${St.dims[0]}) than the decoder inputs (${Ht}).`);St=(0,h.cat)(Array.from({length:Ht},()=>St),0)}}return Pe.encoder_outputs=St,Pe}_prepare_decoder_input_ids_for_generation({batch_size:X,model_input_name:Pe,model_kwargs:ut,decoder_start_token_id:xt,bos_token_id:St,generation_config:Ht}){let{decoder_input_ids:ln,...hn}=ut;if(!(ln instanceof h.Tensor)){if(ln)Array.isArray(ln[0])||(ln=Array.from({length:X},()=>ln));else if(xt??=St,this.config.model_type==="musicgen")ln=Array.from({length:X*this.config.decoder.num_codebooks},()=>[xt]);else if(Array.isArray(xt)){if(xt.length!==X)throw new Error(`\`decoder_start_token_id\` expcted to have length ${X} but got ${xt.length}`);ln=xt}else ln=Array.from({length:X},()=>[xt]);ln=oe(ln)}return ut.decoder_attention_mask=(0,h.ones_like)(ln),{input_ids:ln,model_inputs:hn}}async generate({inputs:X=null,generation_config:Pe=null,logits_processor:ut=null,stopping_criteria:xt=null,streamer:St=null,...Ht}){this._validate_model_class(),Pe=this._prepare_generation_config(Pe,Ht);let{inputs_tensor:ln,model_inputs:hn,model_input_name:In}=this._prepare_model_inputs({inputs:X,model_kwargs:Ht});const Cn=this.config.is_encoder_decoder;Cn&&("encoder_outputs"in hn||(hn=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:ln,model_inputs:hn,model_input_name:In,generation_config:Pe})));let ii;Cn?{input_ids:ii,model_inputs:hn}=this._prepare_decoder_input_ids_for_generation({batch_size:hn[In].dims.at(0),model_input_name:In,model_kwargs:hn,decoder_start_token_id:Pe.decoder_start_token_id,bos_token_id:Pe.bos_token_id,generation_config:Pe}):ii=hn[In];let Un=ii.dims.at(-1);Pe.max_new_tokens!==null&&(Pe.max_length=Un+Pe.max_new_tokens);const qn=this._get_logits_processor(Pe,Un,ut),Ki=this._get_stopping_criteria(Pe,xt),Xn=hn[In].dims.at(0),kn=S.LogitsSampler.getSampler(Pe),Bi=new Array(Xn).fill(0),Ji=ii.tolist();St&&St.put(Ji);let Hs,Js={};for(;;){if(hn=this.prepare_inputs_for_generation(Ji,hn,Pe),Hs=await this.forward(hn),Pe.output_attentions&&Pe.return_dict_in_generate){const Ao=this.getAttentions(Hs);for(const zu in Ao)zu in Js||(Js[zu]=[]),Js[zu].push(Ao[zu])}const Ei=Hs.logits.slice(null,-1,null),lr=qn(Ji,Ei),fa=[];for(let Ao=0;Ao<lr.dims.at(0);++Ao){const zu=lr[Ao],El=await kn(zu);for(const[Sh,Jm]of El){const Ah=BigInt(Sh);Bi[Ao]+=Jm,Ji[Ao].push(Ah),fa.push([Ah]);break}}if(St&&St.put(fa),Ki(Ji).every(Ao=>Ao))break;hn=this._update_model_kwargs_for_generation({generated_input_ids:fa,outputs:Hs,model_inputs:hn,is_encoder_decoder:Cn})}St&&St.end();const or=this.getPastKeyValues(Hs,hn.past_key_values,!0),_r=new h.Tensor("int64",Ji.flat(),[Ji.length,Ji[0].length]);if(Pe.return_dict_in_generate)return{sequences:_r,past_key_values:or,...Js};for(const Ei of Object.values(Hs))Ei.location==="gpu-buffer"&&Ei.dispose();return _r}getPastKeyValues(X,Pe,ut=!1){const xt=Object.create(null);for(const St in X)if(St.startsWith("present")){const Ht=St.replace("present_conv","past_conv").replace("present","past_key_values"),ln=St.includes("encoder");if(ln&&Pe?xt[Ht]=Pe[Ht]:xt[Ht]=X[St],Pe&&(!ln||ut)){const hn=Pe[Ht];hn.location==="gpu-buffer"&&hn.dispose()}}return xt}getAttentions(X){const Pe={};for(const ut of["cross_attentions","encoder_attentions","decoder_attentions"])for(const xt in X)xt.startsWith(ut)&&(ut in Pe||(Pe[ut]=[]),Pe[ut].push(X[xt]));return Pe}addPastKeyValues(X,Pe){if(Pe)Object.assign(X,Pe);else{const ut=this.sessions.decoder_model_merged??this.sessions.model,xt=(X[this.main_input_name]??X.attention_mask)?.dims?.[0]??1,St=ut?.config?.kv_cache_dtype??"float32",Ht=St==="float16"?h.DataTypeMap.float16:h.DataTypeMap.float32,ln=(0,i.getCacheShapes)(this.config,{batch_size:xt});for(const hn in ln){const In=ln[hn].reduce((Cn,ii)=>Cn*ii,1);X[hn]=new h.Tensor(St,new Ht(In),ln[hn])}}}async encode_image({pixel_values:X}){return(await J(this.sessions.vision_encoder,{pixel_values:X})).image_features}async encode_text({input_ids:X}){return(await J(this.sessions.embed_tokens,{input_ids:X})).inputs_embeds}async encode_audio({audio_values:X}){return(await J(this.sessions.audio_encoder,{audio_values:X})).audio_features}}class xe{}class ke extends xe{constructor({last_hidden_state:X,hidden_states:Pe=null,attentions:ut=null}){super(),this.last_hidden_state=X,this.hidden_states=Pe,this.attentions=ut}}class ze extends ye{}class je extends ze{}class Fe extends ze{async _call(X){return new da(await super._call(X))}}class Ye extends ze{async _call(X){return new di(await super._call(X))}}class Ve extends ze{async _call(X){return new gr(await super._call(X))}}class Qe extends ze{async _call(X){return new Ca(await super._call(X))}}class mt extends ye{}class Tt extends mt{}class Me extends mt{async _call(X){return new da(await super._call(X))}}class me extends mt{async _call(X){return new di(await super._call(X))}}class $e extends mt{async _call(X){return new gr(await super._call(X))}}class et extends mt{async _call(X){return new Ca(await super._call(X))}}class ht extends ye{}class at extends ht{}class Et extends ht{async _call(X){return new da(await super._call(X))}}class Dt extends ht{async _call(X){return new di(await super._call(X))}}class Vt extends ht{async _call(X){return new gr(await super._call(X))}}class an extends ye{}class bt extends an{}class Jt extends an{}class Tn extends ye{}class We extends Tn{}class vt extends ye{}class Yt extends vt{}class qe extends vt{async _call(X){return new da(await super._call(X))}}class Kt extends vt{async _call(X){return new di(await super._call(X))}}class rn extends vt{async _call(X){return new gr(await super._call(X))}}class fe extends vt{async _call(X){return new Ca(await super._call(X))}}class B extends ye{}class I extends B{}class A extends B{async _call(X){return new da(await super._call(X))}}class F extends B{async _call(X){return new di(await super._call(X))}}class K extends B{async _call(X){return new gr(await super._call(X))}}class Ee extends B{async _call(X){return new Ca(await super._call(X))}}class k extends ye{}class re extends k{}class Q extends k{async _call(X){return new da(await super._call(X))}}class ve extends k{async _call(X){return new di(await super._call(X))}}class ge extends k{async _call(X){return new gr(await super._call(X))}}class Le extends k{async _call(X){return new Ca(await super._call(X))}}class rt extends ye{}class nt extends rt{}class ft extends rt{async _call(X){return new da(await super._call(X))}}class yt extends rt{async _call(X){return new di(await super._call(X))}}class Ne extends rt{async _call(X){return new gr(await super._call(X))}}class Bt extends rt{async _call(X){return new Ca(await super._call(X))}}class on extends ye{}class xn extends on{}class Bn extends on{async _call(X){return new da(await super._call(X))}}class bi extends on{async _call(X){return new di(await super._call(X))}}class gn extends on{async _call(X){return new gr(await super._call(X))}}class Mn extends on{async _call(X){return new Ca(await super._call(X))}}class Se extends ye{}class we extends Se{}class Ge extends Se{async _call(X){return new da(await super._call(X))}}class Je extends Se{async _call(X){return new di(await super._call(X))}}class Ue extends Se{async _call(X){return new gr(await super._call(X))}}class Ot extends Se{async _call(X){return new Ca(await super._call(X))}}class jt extends ye{}class tn extends jt{}class en extends jt{async _call(X){return new di(await super._call(X))}}class dn extends jt{async _call(X){return new gr(await super._call(X))}}class wn extends jt{async _call(X){return new Ca(await super._call(X))}}class _n extends jt{async _call(X){return new da(await super._call(X))}}class Fn extends ye{}class ti extends Fn{}class Pn extends Fn{async _call(X){return new da(await super._call(X))}}class Ln extends Fn{async _call(X){return new di(await super._call(X))}}class Ct extends Fn{async _call(X){return new gr(await super._call(X))}}class gt extends ye{}class Qt extends gt{}class Nn extends gt{async _call(X){return new da(await super._call(X))}}class Ss extends gt{async _call(X){return new di(await super._call(X))}}class yr extends gt{async _call(X){return new Ca(await super._call(X))}}class $i extends ye{}class ma extends $i{}class fi extends $i{async _call(X){return new da(await super._call(X))}}class ks extends $i{async _call(X){return new di(await super._call(X))}}class $s extends $i{async _call(X){return new gr(await super._call(X))}}class Ds extends $i{async _call(X){return new Ca(await super._call(X))}}class lt extends ye{}class de extends lt{}class Ie extends lt{async _call(X){return new da(await super._call(X))}}class Ke extends lt{async _call(X){return new di(await super._call(X))}}class Ze extends lt{async _call(X){return new Ca(await super._call(X))}}class wt extends ye{}class $t extends wt{}class vn extends wt{async _call(X){return new di(await super._call(X))}}class bn extends wt{async _call(X){return new Ca(await super._call(X))}}class En extends wt{async _call(X){return new da(await super._call(X))}}class un extends ye{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"]}class Qn extends un{}class ni extends un{}class Ms extends ye{}class bs extends Ms{}class Ci extends Ms{}class ps extends ye{}class Ws extends ps{}class Wr extends ps{}class Kr extends ye{}class Bs extends Kr{}class co extends Kr{}class es extends Kr{async _call(X){return new di(await super._call(X))}}class ms extends ye{}class Sr extends ms{}class Fr extends ms{}class na extends ms{async _call(X){return new di(await super._call(X))}}class Ks extends ms{}class ia extends ye{}class Gs extends ia{}class Pi extends ia{}class ns extends ye{}class Ns extends ns{}class Vs extends ns{}class Ba extends ye{}class Dl extends Ba{}class ec extends Ba{async _call(X){return new da(await super._call(X))}}class uu extends Ba{async _call(X){return new di(await super._call(X))}}class tc extends Ba{async _call(X){return new gr(await super._call(X))}}class Vf extends Ba{async _call(X){return new Ca(await super._call(X))}}class qs extends ye{}class Hf extends qs{}class jf extends qs{async _call(X){return new da(await super._call(X))}}class Uc extends qs{async _call(X){return new di(await super._call(X))}}class $f extends qs{async _call(X){return new gr(await super._call(X))}}class Wf extends qs{async _call(X){return new Ca(await super._call(X))}}class Do extends ye{}class Vd extends Do{}class Hd extends Do{async _call(X){return new da(await super._call(X))}}class kc extends Do{async _call(X){return new di(await super._call(X))}}class jd extends Do{async _call(X){return new gr(await super._call(X))}}class $d extends Do{async _call(X){return new Ca(await super._call(X))}}class Gc extends ye{}class Wd extends Gc{}class cu extends Gc{}class el extends ye{requires_attention_mask=!1;main_input_name="input_features";forward_params=["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"]}class Kd extends el{}class Vc extends el{_prepare_generation_config(X,Pe){return super._prepare_generation_config(X,Pe,T.WhisperGenerationConfig)}_retrieve_init_tokens(X){const Pe=[X.decoder_start_token_id];let ut=X.language;const xt=X.task;if(X.is_multilingual){ut||(console.warn("No language specified - defaulting to English (en)."),ut="en");const Ht=`<|${(0,C.whisper_language_to_code)(ut)}|>`;Pe.push(X.lang_to_id[Ht]),Pe.push(X.task_to_id[xt??"transcribe"])}else if(ut||xt)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!X.return_timestamps&&X.no_timestamps_token_id&&Pe.at(-1)!==X.no_timestamps_token_id?Pe.push(X.no_timestamps_token_id):X.return_timestamps&&Pe.at(-1)===X.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),Pe.pop()),Pe.filter(St=>St!=null)}async generate({inputs:X=null,generation_config:Pe=null,logits_processor:ut=null,stopping_criteria:xt=null,...St}){Pe=this._prepare_generation_config(Pe,St);const Ht=St.decoder_input_ids??this._retrieve_init_tokens(Pe);if(Pe.return_timestamps&&(ut??=new g.LogitsProcessorList,ut.push(new g.WhisperTimeStampLogitsProcessor(Pe,Ht))),Pe.begin_suppress_tokens&&(ut??=new g.LogitsProcessorList,ut.push(new g.SuppressTokensAtBeginLogitsProcessor(Pe.begin_suppress_tokens,Ht.length))),Pe.return_token_timestamps){if(!Pe.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");Pe.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),Pe.output_attentions=!0,Pe.return_dict_in_generate=!0}const ln=await super.generate({inputs:X,generation_config:Pe,logits_processor:ut,decoder_input_ids:Ht,...St});return Pe.return_token_timestamps&&(ln.token_timestamps=this._extract_token_timestamps(ln,Pe.alignment_heads,Pe.num_frames)),ln}_extract_token_timestamps(X,Pe,ut=null,xt=.02){if(!X.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");ut==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let St=this.config.median_filter_width;St===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),St=7);const Ht=X.cross_attentions,ln=Array.from({length:this.config.decoder_layers},(Xn,kn)=>(0,h.cat)(Ht.map(Bi=>Bi[kn]),2)),hn=(0,h.stack)(Pe.map(([Xn,kn])=>{if(Xn>=ln.length)throw new Error(`Layer index ${Xn} is out of bounds for cross attentions (length ${ln.length}).`);return ut?ln[Xn].slice(null,kn,null,[0,ut]):ln[Xn].slice(null,kn)})).transpose(1,0,2,3),[In,Cn]=(0,h.std_mean)(hn,-2,0,!0),ii=hn.clone();for(let Xn=0;Xn<ii.dims[0];++Xn){const kn=ii[Xn];for(let Bi=0;Bi<kn.dims[0];++Bi){const Ji=kn[Bi],Hs=In[Xn][Bi][0].data,Js=Cn[Xn][Bi][0].data;for(let or=0;or<Ji.dims[0];++or){let _r=Ji[or].data;for(let Ei=0;Ei<_r.length;++Ei)_r[Ei]=(_r[Ei]-Js[Ei])/Hs[Ei];_r.set((0,y.medianFilter)(_r,St))}}}const Un=[(0,h.mean)(ii,1)],qn=X.sequences.dims,Ki=new h.Tensor("float32",new Float32Array(qn[0]*qn[1]),qn);for(let Xn=0;Xn<qn[0];++Xn){const kn=Un[Xn].neg().squeeze_(0),[Bi,Ji]=(0,y.dynamic_time_warping)(kn.tolist()),Hs=Array.from({length:Bi.length-1},(_r,Ei)=>Bi[Ei+1]-Bi[Ei]),Js=(0,l.mergeArrays)([1],Hs).map(_r=>!!_r),or=[];for(let _r=0;_r<Js.length;++_r)Js[_r]&&or.push(Ji[_r]*xt);Ki[Xn].data.set(or,1)}return Ki}}class Hc extends Vc{}class qd extends ye{requires_attention_mask=!1;main_input_name="input_values";forward_params=["input_values","decoder_input_ids","past_key_values"]}class tl extends qd{}class nc extends qd{}class Xd extends ye{main_input_name="pixel_values";forward_params=["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"]}class Yd extends ye{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class fo extends Yd{_merge_input_ids_with_image_features(X){const Pe=X.image_features.dims.at(-1),ut=X.image_features.view(-1,Pe);return ee({image_token_id:this.config.image_token_index,...X,image_features:ut})}}class Bo extends fo{}class Jd extends fo{}class Qd extends ye{forward_params=["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"];main_input_name="inputs_embeds"}class Bl extends Qd{_merge_input_ids_with_image_features({inputs_embeds:X,image_features:Pe,input_ids:ut,attention_mask:xt}){return{inputs_embeds:(0,h.cat)([Pe,X],1),attention_mask:(0,h.cat)([(0,h.ones)(Pe.dims.slice(0,2)),xt],1)}}async _prepare_inputs_embeds({input_ids:X,pixel_values:Pe,inputs_embeds:ut,attention_mask:xt}){if(!X&&!Pe)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let St,Ht;return X&&(St=await this.encode_text({input_ids:X})),Pe&&(Ht=await this.encode_image({pixel_values:Pe})),St&&Ht?{inputs_embeds:ut,attention_mask:xt}=this._merge_input_ids_with_image_features({inputs_embeds:St,image_features:Ht,input_ids:X,attention_mask:xt}):ut=St||Ht,{inputs_embeds:ut,attention_mask:xt}}async forward({input_ids:X,pixel_values:Pe,attention_mask:ut,decoder_input_ids:xt,decoder_attention_mask:St,encoder_outputs:Ht,past_key_values:ln,inputs_embeds:hn,decoder_inputs_embeds:In}){if(hn||({inputs_embeds:hn,attention_mask:ut}=await this._prepare_inputs_embeds({input_ids:X,pixel_values:Pe,inputs_embeds:hn,attention_mask:ut})),!Ht){let{last_hidden_state:Un}=await le(this,{inputs_embeds:hn,attention_mask:ut});Ht=Un}if(!In){if(!xt)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");In=await this.encode_text({input_ids:xt})}return await pe(this,{inputs_embeds:In,attention_mask:St,encoder_attention_mask:ut,encoder_hidden_states:Ht,past_key_values:ln},!0)}}class nl extends ye{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class Il extends nl{_merge_input_ids_with_image_features(X){const Pe=X.image_features.dims.at(-1),ut=X.image_features.view(-1,Pe);return ee({image_token_id:this.config.image_token_index,...X,image_features:ut})}}class Ar extends Yd{_merge_input_ids_with_image_features(X){const Pe=X.image_features.dims.at(-1),ut=X.image_features.view(-1,Pe);return ee({image_token_id:this.config.image_token_index,...X,image_features:ut})}}class il extends ye{forward_params=["input_ids","attention_mask","inputs_embeds","per_layer_inputs","position_ids","pixel_values","input_features","input_features_mask","past_key_values"]}class sl extends il{async forward({input_ids:X=null,attention_mask:Pe=null,pixel_values:ut=null,input_features:xt=null,input_features_mask:St=null,position_ids:Ht=null,inputs_embeds:ln=null,per_layer_inputs:hn=null,past_key_values:In=null,generation_config:Cn=null,logits_processor:ii=null,...Un}){if((!ln||!hn)&&({inputs_embeds:ln,per_layer_inputs:hn}=await J(this.sessions.embed_tokens,{input_ids:X}),X.dims[1]!==1)){if(ut){const{image_features:Ki}=await J(this.sessions.vision_encoder,{pixel_values:ut});({inputs_embeds:ln,attention_mask:Pe}=this._merge_input_ids_with_image_features({image_features:Ki,inputs_embeds:ln,input_ids:X,attention_mask:Pe}))}if(xt){const{audio_features:Ki}=await J(this.sessions.audio_encoder,{input_features:xt,input_features_mask:St});({inputs_embeds:ln,attention_mask:Pe}=this._merge_input_ids_with_audio_features({audio_features:Ki,inputs_embeds:ln,input_ids:X,attention_mask:Pe}))}}return await pe(this,{inputs_embeds:ln,per_layer_inputs:hn,past_key_values:In,attention_mask:Pe,position_ids:Ht,generation_config:Cn,logits_processor:ii},!0)}_merge_input_ids_with_image_features(X){const Pe=X.image_features.dims.at(-1),ut=X.image_features.view(-1,Pe);return ee({image_token_id:this.config.image_token_id,...X,image_features:ut})}_merge_input_ids_with_audio_features(X){const Pe=X.audio_features.dims.at(-1),ut=X.audio_features.view(-1,Pe);return te({audio_token_id:this.config.audio_token_id,...X,audio_features:ut})}}class ic extends ye{forward_params=["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"]}class rl extends ic{async encode_image({pixel_values:X,pixel_attention_mask:Pe}){return(await J(this.sessions.vision_encoder,{pixel_values:X,pixel_attention_mask:Pe})).image_features}_merge_input_ids_with_image_features(X){const Pe=X.image_features.dims.at(-1),ut=X.image_features.view(-1,Pe);return ee({image_token_id:this.config.image_token_id,...X,image_features:ut})}}class Io extends rl{}class du extends ye{forward_params=["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"]}class sc extends du{async forward({input_ids:X=null,attention_mask:Pe=null,pixel_values:ut=null,image_sizes:xt=null,position_ids:St=null,inputs_embeds:Ht=null,past_key_values:ln=null,generation_config:hn=null,logits_processor:In=null,...Cn}){if(!Ht){let Un;if(ut&&X.dims[1]!==1){if(!xt)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:Un}=await J(this.sessions.vision_encoder,{pixel_values:ut,image_sizes:xt}))}else{const qn=this.config.normalized_config.hidden_size;Un=new h.Tensor("float32",[],[0,qn])}({inputs_embeds:Ht}=await J(this.sessions.prepare_inputs_embeds,{input_ids:X,image_features:Un}))}return await pe(this,{inputs_embeds:Ht,past_key_values:ln,attention_mask:Pe,position_ids:St,generation_config:hn,logits_processor:In},!1)}}class cr extends ye{}class jc extends cr{}class $c extends cr{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"text_model"})}}class Ol extends cr{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"text_model"})}}class fu extends cr{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"vision_model"})}}class Wc extends cr{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"vision_model"})}}class Ll extends ye{}class Kc extends Ll{}class hu extends Ll{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"text_model"})}}class ho extends cr{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"vision_model"})}}class yn extends ye{}class Kf extends yn{}class rc extends ye{}class qc extends rc{async forward(X){const Pe=!X.input_ids,ut=!X.pixel_values;if(Pe&&ut)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(Pe&&(X.input_ids=(0,h.ones)([X.pixel_values.dims[0],1])),ut){const{image_size:In}=this.config.vision_config;X.pixel_values=(0,h.full)([0,3,In,In],0)}const{text_embeddings:xt,image_embeddings:St,l2norm_text_embeddings:Ht,l2norm_image_embeddings:ln}=await super.forward(X),hn={};return Pe||(hn.text_embeddings=xt,hn.l2norm_text_embeddings=Ht),ut||(hn.image_embeddings=St,hn.l2norm_image_embeddings=ln),hn}}class al extends rc{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"text_model"})}}class Cr extends rc{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"vision_model"})}}class pu extends ye{}class Xc extends pu{}class ol extends pu{}class gs extends ye{}class Fl extends gs{}class ac extends gs{}class oc extends ye{}class lc extends oc{}class uc extends oc{}class po extends ye{}class Yc extends po{}class ll extends po{}class mu extends ye{}class Nl extends mu{}class sa extends mu{}class gu extends ye{}class Oo extends gu{}class G extends gu{}class Z extends ye{}class _e extends Z{}class Te extends Z{}class Re extends ye{}class ct extends Re{}class Nt extends Re{}class sn extends ye{}class pn extends sn{}class On extends sn{}class Zn extends ye{}class hi extends Zn{}class zi extends ye{}class ki extends zi{}class ga extends zi{}class dr extends ye{}class cc extends dr{}class qf extends dr{}class zl extends ye{}class Zd extends zl{}class Jc extends zl{}class Ul extends ye{}class Xf extends Ul{}class Qc extends Ul{}class kl extends ye{}class Mm extends kl{}class _a extends kl{}class ra extends ye{}class ul extends ra{}class aa extends ra{}class Zc extends ye{}class Gl extends Zc{}class Yf extends Zc{}class Xh extends ye{}class Lo extends Xh{}class Yh extends Xh{}class va extends ye{}class Fo extends va{}class dc extends va{}class ed extends ye{}class td extends ed{}class Ka extends ed{}class ya extends ye{}class cl extends ya{}class dl extends ya{}class No extends ye{}class Vl extends No{}class Jh extends No{}class ef extends ye{}class _u extends ef{}class tf extends ef{}class Pr extends ye{}class Is extends Pr{}class Ui extends Pr{}class fl extends ye{}class Nr extends fl{}class Jf extends fl{}class Ri extends ye{}class Qf extends Ri{}class bm extends Ri{}class vu extends ye{}class fc extends vu{}class Qh extends vu{}class nd extends ye{}class Zh extends nd{}class Hl extends nd{}class qr extends ye{}class jl extends qr{}class mo extends qr{}class hl extends ye{}class Zf extends hl{}class yu extends hl{}class id extends ye{forward_params=["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"]}class hc extends id{get_rope_index(X,Pe,ut,xt){const{vision_config:St,image_token_id:Ht,video_token_id:ln,vision_start_token_id:hn}=this.config,In=St.spatial_merge_size??2,Cn=[];if(Pe||ut){let ii=X.tolist();xt||(xt=(0,h.ones_like)(X));const Un=xt.tolist(),qn=Array.from({length:3},Ji=>Array.from({length:X.dims[0]},Hs=>Array.from({length:X.dims[1]},Js=>1))),Ki=Pe?Pe.tolist():[],Xn=ut?ut.tolist():[];let kn=0,Bi=0;for(let Ji=0;Ji<ii.length;++Ji){const Hs=ii[Ji].filter((Qs,Gr)=>Un[Ji][Gr]==1),or=Hs.reduce((Qs,Gr,Ac)=>(Gr==hn&&Qs.push(Ac),Qs),[]).map(Qs=>Hs[Qs+1]),_r=or.filter(Qs=>Qs==Ht).length,Ei=or.filter(Qs=>Qs==ln).length;let lr=[],fa=0,Of=_r,Ao=Ei;for(let Qs=0;Qs<or.length;++Qs){const Gr=Hs.findIndex((Ph,ku)=>ku>fa&&Ph==Ht),Ac=Hs.findIndex((Ph,ku)=>ku>fa&&Ph==ln),Md=Of>0&&Gr!==-1?Gr:Hs.length+1,Vp=Ao>0&&Ac!==-1?Ac:Hs.length+1;let Co,Qm,h_,p_;Md<Vp?([Qm,h_,p_]=Ki[kn],++kn,--Of,Co=Md):([Qm,h_,p_]=Xn[Bi],++Bi,--Ao,Co=Vp);const[py,Ch,Po]=[Number(Qm),Math.floor(Number(h_)/In),Math.floor(Number(p_)/In)],m_=Co-fa,Zm=lr.length>0?(0,y.max)(lr.at(-1))[0]+1:0;lr.push(Array.from({length:3*m_},(Ph,ku)=>Zm+ku%m_));const Uu=m_+Zm,g_=py*Ch*Po,Ux=Array.from({length:g_},(Ph,ku)=>Uu+Math.floor(ku/(Ch*Po))),Hp=Array.from({length:g_},(Ph,ku)=>Uu+Math.floor(ku/Po)%Ch),my=Array.from({length:g_},(Ph,ku)=>Uu+ku%Po);lr.push([Ux,Hp,my].flat()),fa=Co+g_}if(fa<Hs.length){const Qs=lr.length>0?(0,y.max)(lr.at(-1))[0]+1:0,Gr=Hs.length-fa;lr.push(Array.from({length:3*Gr},(Ac,Md)=>Qs+Md%Gr))}const zu=lr.reduce((Qs,Gr)=>Qs+Gr.length,0),El=new Array(zu);let Sh=0;for(let Qs=0;Qs<3;++Qs)for(let Gr=0;Gr<lr.length;++Gr){const Ac=lr[Gr],Md=Ac.length/3;for(let Vp=Qs*Md;Vp<(Qs+1)*Md;++Vp)El[Sh++]=Ac[Vp]}let Jm=0;const Ah=Un[Ji];for(let Qs=0;Qs<Ah.length;++Qs)if(Ah[Qs]==1){for(let Gr=0;Gr<3;++Gr)qn[Gr][Ji][Qs]=El[Gr*zu/3+Jm];++Jm}const zx=(0,y.max)(El)[0];Cn.push(zx+1-ii[Ji].length)}return[new h.Tensor("int64",qn.flat(1/0),[3,X.dims[0],X.dims[1]]),new h.Tensor("int64",Cn,[Cn.length,1])]}else if(xt){const{data:ii,dims:Un}=Be(xt),qn=BigInt64Array.from({length:3*ii.length},(Xn,kn)=>ii[kn%ii.length]),Ki=Array.from({length:Un[0]},(Xn,kn)=>(0,y.max)(ii.subarray(Un[1]*kn,Un[1]*(kn+1)))[0]+1n+BigInt(Un[1]));return[new h.Tensor("int64",qn,[3,...Un]),new h.Tensor("int64",Ki,[Ki.length,1])]}else{const[ii,Un]=X.dims,qn=BigInt64Array.from({length:3*ii*Un},(Ki,Xn)=>BigInt(Math.floor(Xn%Un/ii)));return[new h.Tensor("int64",qn,[3,...X.dims]),(0,h.zeros)([ii,1])]}}async encode_image({pixel_values:X,image_grid_thw:Pe}){return(await J(this.sessions.vision_encoder,{pixel_values:X,grid_thw:Pe})).image_features}_merge_input_ids_with_image_features(X){return ee({image_token_id:this.config.image_token_id,...X})}prepare_inputs_for_generation(X,Pe,ut){if(Pe.attention_mask&&!Pe.position_ids)if(!Pe.past_key_values)[Pe.position_ids,Pe.rope_deltas]=this.get_rope_index(Pe.input_ids,Pe.image_grid_thw,Pe.video_grid_thw,Pe.attention_mask);else{Pe.pixel_values=null;const xt=BigInt(Object.values(Pe.past_key_values)[0].dims.at(-2)),St=Pe.rope_deltas.map(Ht=>xt+Ht);Pe.position_ids=(0,h.stack)([St,St,St],0)}return Pe}}class Rr extends ye{}class nf extends Rr{}class ep extends Rr{}class tp extends ye{}class xm extends tp{}class np extends tp{}class Kn extends ye{}class ip extends Kn{}class Xr extends Kn{}class Mu extends ye{}class sp extends Mu{}class $l extends Mu{}class go extends ye{}class sd extends go{}class rp extends go{}class eh extends ye{}class wm extends eh{}class bu extends eh{async _call(X){return new di(await super._call(X))}}class zo extends ye{}class rd extends zo{}class th extends zo{async _call(X){return new di(await super._call(X))}}class xu extends ye{}class sf extends xu{}class _o extends ye{}class rf extends _o{}class Em extends _o{async _call(X){return new di(await super._call(X))}}class ap extends ye{}class pc extends ap{}class Jn extends ye{}class nh extends Jn{}class op extends Jn{async _call(X){return new di(await super._call(X))}}class wu extends ye{}class Eu extends wu{}class af extends ye{}class of extends af{}class lf extends af{async _call(X){return new di(await super._call(X))}}class ad extends ye{}class mc extends ad{async _call(X){return new Ym(await super._call(X))}}class lp extends ye{}class Tu extends lp{}class up extends lp{async _call(X){return new di(await super._call(X))}}class ih extends ye{}class pl extends ih{}class Wl extends ih{async _call(X){return new di(await super._call(X))}}class Kl extends ye{}class sh extends Kl{}class cp extends Kl{}class od extends ye{}class gc extends od{}class ml extends od{}class zr extends ye{}class qa extends zr{}class Ma extends zr{async _call(X){return new di(await super._call(X))}}class uf extends ye{}class dp extends uf{}class oa extends uf{async _call(X){return new Xa(await super._call(X))}}class Mr extends uf{async _call(X){return new Su(await super._call(X))}}class Xa extends xe{constructor({logits:X,pred_boxes:Pe}){super(),this.logits=X,this.pred_boxes=Pe}}class Su extends xe{constructor({logits:X,pred_boxes:Pe,pred_masks:ut}){super(),this.logits=X,this.pred_boxes=Pe,this.pred_masks=ut}}class rh extends ye{}class Tm extends rh{}class ql extends rh{async _call(X){return new la(await super._call(X))}}class la extends xe{constructor({logits:X,pred_boxes:Pe}){super(),this.logits=X,this.pred_boxes=Pe}}class Xs extends ye{}class ah extends Xs{}class Ia extends Xs{async _call(X){return new si(await super._call(X))}}class si extends la{}class _s extends ye{}class br extends _s{}class oh extends _s{async _call(X){return new gl(await super._call(X))}}class gl extends la{}class Au extends ye{}class lh extends Au{}class cf extends Au{async _call(X){return new la(await super._call(X))}}class Uo extends ye{}class s_ extends Uo{}class tr extends Uo{async _call(X){return new fp(await super._call(X))}}class fp extends Xa{}class uh extends ye{}class Sm extends uh{}class Am extends uh{async _call(X){return new di(await super._call(X))}}class Cm extends ye{}class hp extends Cm{}class pp extends Cm{async _call(X){return new di(await super._call(X))}}class ch extends ye{}class ba extends ch{}class fr extends ch{async _call(X){return new di(await super._call(X))}}class _c extends ye{}class df extends _c{}class dh extends _c{async _call(X){return new di(await super._call(X))}}class mp extends _c{}class _l extends ye{}class fh extends _l{}class gp extends _l{}class ff extends ye{}class _p extends ff{}class Pm extends ff{}class vp extends ye{}class yp extends vp{}class hf extends ye{}class hh extends hf{}class pf extends hf{}class Rm extends hf{}class r_ extends ye{}class Dm extends r_{}class Bm extends ye{}class Mp extends Bm{}class ph extends ye{}class Im extends ph{}class bp extends ye{}class Om extends bp{}class Lm extends bp{}class xp extends ye{}class a_ extends xp{}class Fm extends xp{}class ld extends ye{}class Nm extends ld{}class mf extends ye{}class mh extends mf{}class zm extends mf{async _call(X){return new di(await super._call(X))}}class gh extends ye{}class Um extends gh{}class km extends gh{async _call(X){return new di(await super._call(X))}}class wp extends ye{}class Ya extends wp{}class Ep extends wp{async _call(X){return new di(await super._call(X))}}class gf extends ye{}class _h extends gf{}class Tp extends gf{async _call(X){return new di(await super._call(X))}}class Sp extends ye{}class Ap extends Sp{}class Cp extends ye{}class Pp extends Cp{}class o_ extends ye{}class Rp extends o_{}class Dp extends ye{}class Bp extends Dp{}class Ip extends Dp{async _call(X){return new Yr(await super._call(X))}}class Yr extends xe{constructor({logits:X,pred_boxes:Pe}){super(),this.logits=X,this.pred_boxes=Pe}}class Op extends ye{}class l_ extends Op{async get_image_embeddings({pixel_values:X}){return await le(this,{pixel_values:X})}async forward(X){!X.image_embeddings||!X.image_positional_embeddings?X={...X,...await this.get_image_embeddings(X)}:X={...X},X.input_labels??=(0,h.ones)(X.input_points.dims.slice(0,-1));const Pe={image_embeddings:X.image_embeddings,image_positional_embeddings:X.image_positional_embeddings};return X.input_points&&(Pe.input_points=X.input_points),X.input_labels&&(Pe.input_labels=X.input_labels),X.input_boxes&&(Pe.input_boxes=X.input_boxes),await J(this.sessions.prompt_encoder_mask_decoder,Pe)}async _call(X){return new u_(await super._call(X))}}class u_ extends xe{constructor({iou_scores:X,pred_masks:Pe}){super(),this.iou_scores=X,this.pred_masks=Pe}}class Gm extends xe{constructor({iou_scores:X,pred_masks:Pe,object_score_logits:ut}){super(),this.iou_scores=X,this.pred_masks=Pe,this.object_score_logits=ut}}class ud extends ye{}class vc extends ud{async get_image_embeddings({pixel_values:X}){return await le(this,{pixel_values:X})}async forward(X){const{num_feature_levels:Pe}=this.config.vision_config;if(Array.from({length:Pe},(Ht,ln)=>`image_embeddings.${ln}`).some(Ht=>!X[Ht])?X={...X,...await this.get_image_embeddings(X)}:X={...X},X.input_points){if(X.input_boxes&&X.input_boxes.dims[1]!==1)throw new Error("When both `input_points` and `input_boxes` are provided, the number of boxes per image must be 1.");const Ht=X.input_points.dims;X.input_labels??=(0,h.ones)(Ht.slice(0,-1)),X.input_boxes??=(0,h.full)([Ht[0],0,4],0)}else if(X.input_boxes){const Ht=X.input_boxes.dims;X.input_labels=(0,h.full)([Ht[0],Ht[1],0],-1n),X.input_points=(0,h.full)([Ht[0],1,0,2],0)}else throw new Error("At least one of `input_points` or `input_boxes` must be provided.");const xt=this.sessions.prompt_encoder_mask_decoder,St=(0,l.pick)(X,xt.inputNames);return await J(xt,St)}async _call(X){return new Gm(await super._call(X))}}class Xl extends vc{}class yc extends vc{}class xa extends ye{}class _f extends xa{}class Vm extends xa{}class Mc extends ye{}class vf extends Mc{}class cd extends Mc{}class ko extends ye{}class Hm extends ko{}class jm extends ko{async _call(X){return new yi(await super._call(X))}}class Jr extends ko{async _call(X){return new di(await super._call(X))}}class Lp extends ko{async _call(X){return new gr(await super._call(X))}}class $m extends ye{}class vh extends $m{async _call(X){return new yi(await super._call(X))}}class yf extends ye{}class Wm extends yf{}class Fp extends yf{async _call(X){return new gr(await super._call(X))}}class dd extends ye{}class Oa extends dd{}class wa extends ye{}class yh extends wa{}class zs extends wa{async _call(X){return new yi(await super._call(X))}}class nr extends wa{async _call(X){return new di(await super._call(X))}}class Cu extends ye{}class Mf extends Cu{}class Ja extends Cu{async _call(X){return new yi(await super._call(X))}}class Qa extends Cu{async _call(X){return new di(await super._call(X))}}class Go extends Cu{async _call(X){return new gr(await super._call(X))}}class vo extends ye{}class yo extends vo{}class Ur extends vo{async _call(X){return new yi(await super._call(X))}}class bf extends vo{async _call(X){return new di(await super._call(X))}}class vl extends ye{}class fd extends ko{}class ua extends ko{async _call(X){return new yi(await super._call(X))}}class Qr extends ko{async _call(X){return new di(await super._call(X))}}class Di extends ye{}class Za extends Di{}class Mo extends Di{async _call(X){return new yi(await super._call(X))}}class xf extends Di{async _call(X){return new di(await super._call(X))}}class eo extends Di{async _call(X){return new hy(await super._call(X))}}class Pu extends Di{async _call(X){return new gr(await super._call(X))}}class hd extends ye{}class pd extends hd{}class Yl extends ye{}class Mh extends Yl{}class wf extends Yl{}class Vo extends Yl{async generate_speech(X,Pe,{threshold:ut=.5,minlenratio:xt=0,maxlenratio:St=20,vocoder:Ht=null}={}){const ln={input_ids:X},{encoder_outputs:hn,encoder_attention_mask:In}=await le(this,ln),Cn=hn.dims[1]/this.config.reduction_factor,ii=Math.floor(Cn*St),Un=Math.floor(Cn*xt),qn=this.config.num_mel_bins;let Ki=[],Xn=null,kn=null,Bi=0;for(;;){++Bi;const Js=ne(!!kn);let or;kn?or=kn.output_sequence_out:or=new h.Tensor("float32",new Float32Array(qn),[1,1,qn]);let _r={use_cache_branch:Js,output_sequence:or,encoder_attention_mask:In,speaker_embeddings:Pe,encoder_hidden_states:hn};this.addPastKeyValues(_r,Xn),kn=await J(this.sessions.decoder_model_merged,_r),Xn=this.getPastKeyValues(kn,Xn);const{prob:Ei,spectrum:lr}=kn;if(Ki.push(lr),Bi>=Un&&(Array.from(Ei.data).filter(fa=>fa>=ut).length>0||Bi>=ii))break}const Ji=(0,h.cat)(Ki),{waveform:Hs}=await J(Ht.sessions.model,{spectrogram:Ji});return{spectrogram:Ji,waveform:Hs}}}class Ru extends ye{main_input_name="spectrogram"}class Ef extends ye{}class Tf extends Ef{async generate_speech({input_ids:X,attention_mask:Pe,style:ut,num_inference_steps:xt=5,speed:St=1.05}){const{sampling_rate:Ht,chunk_compress_factor:ln,base_chunk_size:hn,latent_dim:In}=this.config,{last_hidden_state:Cn,durations:ii}=await J(this.sessions.text_encoder,{input_ids:X,attention_mask:Pe,style:ut});ii.div_(St);const Un=ii.max().item()*Ht,qn=hn*ln,Ki=Math.floor((Un+qn-1)/qn),Xn=X.dims[0],kn=(0,h.ones)([Xn,Ki]),Bi=(0,h.full)([Xn],xt);let Ji=(0,h.randn)([Xn,In*ln,Ki]);for(let Js=0;Js<xt;++Js){const or=(0,h.full)([Xn],Js);({denoised_latents:Ji}=await J(this.sessions.latent_denoiser,{style:ut,noisy_latents:Ji,latent_mask:kn,encoder_outputs:Cn,attention_mask:Pe,timestep:or,num_inference_steps:Bi}))}const{waveform:Hs}=await J(this.sessions.voice_decoder,{latents:Ji});return{waveform:Hs,durations:ii}}}class La extends ye{}class Du extends La{}class yl extends ye{}class md extends yl{}class Sf extends yl{}class is extends ye{}class Np extends is{}class bh extends is{}class Bu extends ye{}class Ml extends Bu{}class bo extends Bu{}class Jl extends ye{}class zp extends Jl{}class bl extends Jl{}class Ea extends ye{}class to extends Ea{}class xo extends Ea{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"text_model"})}}class xr extends Ea{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"audio_model"})}}class xl extends ye{}class gi extends xl{async _call(X){return new f_(await super._call(X))}}class Wi extends ye{}class wr extends Wi{}class wo extends Wi{}class Us extends Wi{}class wl extends ye{}class Af extends wl{}class ir extends wl{}class bc extends ye{}class Km extends bc{}class xh extends bc{async _call(X){return new di(await super._call(X))}}class Gi extends ye{}class Dr extends Gi{}class Ta extends Gi{}class Ql extends ye{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"];_apply_and_filter_by_delay_pattern_mask(X){const[Pe,ut]=X.dims,xt=this.config.decoder.num_codebooks,St=ut-xt;let Ht=0;for(let In=0;In<X.size;++In){if(X.data[In]===this.config.decoder.pad_token_id)continue;const Cn=In%ut,ii=Math.floor(In/ut)%xt,Un=Cn-ii;Un>0&&Un<=St&&(X.data[Ht++]=X.data[In])}const ln=Math.floor(Pe/xt),hn=Ht/(ln*xt);return new h.Tensor(X.type,X.data.slice(0,Ht),[ln,xt,hn])}prepare_inputs_for_generation(X,Pe,ut){let xt=structuredClone(X);for(let Ht=0;Ht<xt.length;++Ht)for(let ln=0;ln<xt[Ht].length;++ln)Ht%this.config.decoder.num_codebooks>=ln&&(xt[Ht][ln]=BigInt(this.config.decoder.pad_token_id));return ut.guidance_scale!==null&&ut.guidance_scale>1&&(xt=xt.concat(xt)),super.prepare_inputs_for_generation(xt,Pe,ut)}async generate(X){const Pe=await super.generate(X),ut=this._apply_and_filter_by_delay_pattern_mask(Pe).unsqueeze_(0),{audio_values:xt}=await J(this.sessions.encodec_decode,{audio_codes:ut});return xt}}class gd extends ye{}class Up extends gd{}class qm extends gd{async _call(X){return new di(await super._call(X))}}class hr extends gd{}class kr extends ye{}class Fa extends kr{}class Iu extends kr{async _call(X){return new di(await super._call(X))}}class sr extends kr{}class wh extends ye{}class Zl extends wh{}class xc extends wh{async _call(X){return new di(await super._call(X))}}class ss extends wh{}class _d extends ye{}class eu extends _d{}class Br extends _d{async _call(X){return new di(await super._call(X))}}class Ys extends _d{}class Ou extends ye{}class vd extends Ou{}class rr extends ye{}class wc extends rr{forward_params=["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"];constructor(...X){super(...X),this._generation_mode="text"}async forward(X){const Pe=this._generation_mode??"text";let ut;if(Pe==="text"||!X.past_key_values){const hn=this.sessions.prepare_inputs_embeds,In=(0,l.pick)(X,hn.inputNames);ut=await J(hn,In)}else{const hn=this.sessions.gen_img_embeds,In=(0,l.pick)({image_ids:X.input_ids},hn.inputNames);ut=await J(hn,In)}const xt={...X,...ut},St=await pe(this,xt),Ht=this.sessions[Pe==="text"?"lm_head":"gen_head"];if(!Ht)throw new Error(`Unable to find "${Ht}" generation head`);const ln=await J(Ht,(0,l.pick)(St,Ht.inputNames));return{...ut,...St,...ln}}async generate(X){return this._generation_mode="text",super.generate(X)}async generate_images(X){this._generation_mode="image";const Pe=(X.inputs??X[this.main_input_name]).dims[1],xt=(await super.generate(X)).slice(null,[Pe,null]),St=this.sessions.image_decode,{decoded_image:Ht}=await J(St,{generated_tokens:xt}),ln=Ht.add_(1).mul_(255/2).clamp_(0,255).to("uint8"),hn=[];for(const In of ln){const Cn=v.RawImage.fromTensor(In);hn.push(Cn)}return hn}}class pr extends xe{constructor({char_logits:X,bpe_logits:Pe,wp_logits:ut}){super(),this.char_logits=X,this.bpe_logits=Pe,this.wp_logits=ut}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class Na extends ye{}class Sa extends Na{async _call(X){return new pr(await super._call(X))}}class Lu extends ye{}class Eh extends Lu{}class Cf extends Lu{}class Pf extends ye{}class Th extends Pf{}class Vi extends Pf{}class rs extends ye{forward_params=["input_ids","attention_mask","position_ids","audio_values","past_key_values"]}class _i extends rs{_merge_input_ids_with_audio_features(X){const Pe=X.audio_features.dims.at(-1),ut=X.audio_features.view(-1,Pe);return te({audio_token_id:this.config.ignore_index??this.config.audio_token_id,...X,audio_features:ut})}}class Oi extends _i{}class jn extends ye{main_input_name="input_values";forward_params=["input_values"]}class Si extends xe{constructor({audio_codes:X}){super(),this.audio_codes=X}}class pi extends xe{constructor({audio_values:X}){super(),this.audio_values=X}}class wi extends jn{async encode(X){return new Si(await J(this.sessions.encoder_model,X))}async decode(X){return new pi(await J(this.sessions.decoder_model,X))}}class xs extends jn{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"encoder_model"})}}class mr extends jn{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"decoder_model"})}}class qi extends ye{main_input_name="input_values";forward_params=["input_values"]}class no extends xe{constructor({audio_codes:X}){super(),this.audio_codes=X}}class tu extends xe{constructor({audio_values:X}){super(),this.audio_values=X}}class Ho extends qi{async encode(X){return new no(await J(this.sessions.encoder_model,X))}async decode(X){return new tu(await J(this.sessions.decoder_model,X))}}class Hi extends qi{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"encoder_model"})}}class io extends qi{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"decoder_model"})}}class so extends ye{main_input_name="input_values";forward_params=["input_values"]}class ca extends so{async encode(X){return await J(this.sessions.encoder_model,X)}async decode(X){return await J(this.sessions.decoder_model,X)}}class za extends so{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"encoder_model"})}}class nu extends so{static async from_pretrained(X,Pe={}){return super.from_pretrained(X,{...Pe,model_file_name:Pe.model_file_name??"decoder_model"})}}class Li{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(X,{progress_callback:Pe=null,config:ut=null,cache_dir:xt=null,local_files_only:St=!1,revision:Ht="main",model_file_name:ln=null,subfolder:hn="onnx",device:In=null,dtype:Cn=null,use_external_data_format:ii=null,session_options:Un={}}={}){const qn={progress_callback:Pe,config:ut,cache_dir:xt,local_files_only:St,revision:Ht,model_file_name:ln,subfolder:hn,device:In,dtype:Cn,use_external_data_format:ii,session_options:Un};if(qn.config=await i.AutoConfig.from_pretrained(X,qn),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);const Ki=qn.config.model_type;for(const Xn of this.MODEL_CLASS_MAPPINGS){let kn=Xn.get(Ki);if(!kn){for(const Bi of Xn.values())if(Bi[0]===Ki){kn=Bi;break}if(!kn)continue}return await kn[1].from_pretrained(X,qn)}if(this.BASE_IF_FAIL)return Ir.has(Ki)||console.warn(`Unknown model class "${Ki}", attempting to construct from base class.`),await ye.from_pretrained(X,qn);throw Error(`Unsupported model type: ${Ki}`)}}const Eo=new Map([["bert",["BertModel",je]],["neobert",["NeoBertModel",Tt]],["modernbert",["ModernBertModel",at]],["nomic_bert",["NomicBertModel",We]],["roformer",["RoFormerModel",Yt]],["electra",["ElectraModel",re]],["esm",["EsmModel",ti]],["convbert",["ConvBertModel",I]],["camembert",["CamembertModel",nt]],["deberta",["DebertaModel",xn]],["deberta-v2",["DebertaV2Model",we]],["mpnet",["MPNetModel",ma]],["albert",["AlbertModel",$t]],["distilbert",["DistilBertModel",tn]],["roberta",["RobertaModel",Dl]],["xlm",["XLMModel",Hf]],["xlm-roberta",["XLMRobertaModel",Vd]],["clap",["ClapModel",to]],["clip",["CLIPModel",jc]],["clipseg",["CLIPSegModel",Xc]],["chinese_clip",["ChineseCLIPModel",Kf]],["siglip",["SiglipModel",Kc]],["jina_clip",["JinaCLIPModel",qc]],["mobilebert",["MobileBertModel",Qt]],["squeezebert",["SqueezeBertModel",de]],["wav2vec2",["Wav2Vec2Model",Hm]],["wav2vec2-bert",["Wav2Vec2BertModel",yo]],["unispeech",["UniSpeechModel",yh]],["unispeech-sat",["UniSpeechSatModel",Mf]],["hubert",["HubertModel",fd]],["wavlm",["WavLMModel",Za]],["audio-spectrogram-transformer",["ASTModel",Wd]],["vits",["VitsModel",gi]],["pyannote",["PyAnnoteModel",Wm]],["wespeaker-resnet",["WeSpeakerResNetModel",Oa]],["detr",["DetrModel",dp]],["rt_detr",["RTDetrModel",Tm]],["rt_detr_v2",["RTDetrV2Model",ah]],["rf_detr",["RFDetrModel",br]],["d_fine",["DFineModel",lh]],["table-transformer",["TableTransformerModel",s_]],["vit",["ViTModel",wm]],["ijepa",["IJepaModel",rd]],["pvt",["PvtModel",rf]],["vit_msn",["ViTMSNModel",nh]],["vit_mae",["ViTMAEModel",pc]],["groupvit",["GroupViTModel",Eu]],["fastvit",["FastViTModel",of]],["mobilevit",["MobileViTModel",Tu]],["mobilevitv2",["MobileViTV2Model",pl]],["owlvit",["OwlViTModel",sh]],["owlv2",["Owlv2Model",gc]],["beit",["BeitModel",qa]],["deit",["DeiTModel",Sm]],["hiera",["HieraModel",hp]],["convnext",["ConvNextModel",mh]],["convnextv2",["ConvNextV2Model",Um]],["dinov2",["Dinov2Model",Ya]],["dinov2_with_registers",["Dinov2WithRegistersModel",_h]],["dinov3_vit",["DINOv3ViTModel",Ap]],["dinov3_convnext",["DINOv3ConvNextModel",Pp]],["resnet",["ResNetModel",ba]],["swin",["SwinModel",df]],["swin2sr",["Swin2SRModel",fh]],["donut-swin",["DonutSwinModel",Nm]],["yolos",["YolosModel",Bp]],["dpt",["DPTModel",_p]],["glpn",["GLPNModel",a_]],["hifigan",["SpeechT5HifiGan",Ru]],["efficientnet",["EfficientNetModel",Km]],["decision_transformer",["DecisionTransformerModel",vd]],["patchtst",["PatchTSTForPrediction",Eh]],["patchtsmixer",["PatchTSMixerForPrediction",Th]],["mobilenet_v1",["MobileNetV1Model",Up]],["mobilenet_v2",["MobileNetV2Model",Fa]],["mobilenet_v3",["MobileNetV3Model",Zl]],["mobilenet_v4",["MobileNetV4Model",eu]],["maskformer",["MaskFormerModel",Om]],["mgp-str",["MgpstrForSceneTextRecognition",Sa]],["style_text_to_speech_2",["StyleTextToSpeech2Model",pd]]]),Rf=new Map([["t5",["T5Model",Qn]],["longt5",["LongT5Model",bs]],["mt5",["MT5Model",Ws]],["bart",["BartModel",Bs]],["mbart",["MBartModel",Sr]],["marian",["MarianModel",_f]],["whisper",["WhisperModel",Kd]],["m2m_100",["M2M100Model",vf]],["blenderbot",["BlenderbotModel",Gs]],["blenderbot-small",["BlenderbotSmallModel",Ns]]]),iu=new Map([["mimi",["MimiModel",wi]],["dac",["DacModel",Ho]],["snac",["SnacModel",ca]]]),ar=new Map([["bloom",["BloomModel",ip]],["jais",["JAISModel",lc]],["gpt2",["GPT2Model",Fl]],["gptj",["GPTJModel",Oo]],["gpt_bigcode",["GPTBigCodeModel",_e]],["gpt_neo",["GPTNeoModel",Yc]],["gpt_neox",["GPTNeoXModel",Nl]],["codegen",["CodeGenModel",ct]],["llama",["LlamaModel",pn]],["nanochat",["NanoChatModel",ki]],["arcee",["ArceeModel",cc]],["lfm2",["Lfm2Model",Zd]],["smollm3",["SmolLM3Model",Xf]],["exaone",["ExaoneModel",Gl]],["olmo",["OlmoModel",Fo]],["olmo2",["Olmo2Model",td]],["mobilellm",["MobileLLMModel",Lo]],["granite",["GraniteModel",cl]],["granitemoehybrid",["GraniteMoeHybridModel",Vl]],["cohere",["CohereModel",_u]],["gemma",["GemmaModel",Is]],["gemma2",["Gemma2Model",Nr]],["vaultgemma",["VaultGemmaModel",Qf]],["gemma3_text",["Gemma3Model",fc]],["helium",["HeliumModel",Mm]],["glm",["GlmModel",ul]],["openelm",["OpenELMModel",Zh]],["qwen2",["Qwen2Model",jl]],["qwen3",["Qwen3Model",Zf]],["phi",["PhiModel",nf]],["phi3",["Phi3Model",xm]],["mpt",["MptModel",sp]],["opt",["OPTModel",sd]],["mistral",["MistralModel",md]],["ernie4_5",["Ernie4_5_Model",Np]],["starcoder2",["Starcoder2Model",Ml]],["falcon",["FalconModel",zp]],["stablelm",["StableLmModel",Af]],["modernbert-decoder",["ModernBertDecoderModel",bt]]]),To=new Map([["speecht5",["SpeechT5ForSpeechToText",wf]],["whisper",["WhisperForConditionalGeneration",Vc]],["lite-whisper",["LiteWhisperForConditionalGeneration",Hc]],["moonshine",["MoonshineForConditionalGeneration",nc]]]),ro=new Map([["speecht5",["SpeechT5ForTextToSpeech",Vo]]]),So=new Map([["vits",["VitsModel",gi]],["musicgen",["MusicgenForConditionalGeneration",Ql]],["supertonic",["SupertonicForConditionalGeneration",Tf]]]),su=new Map([["bert",["BertForSequenceClassification",Ye]],["neobert",["NeoBertForSequenceClassification",me]],["modernbert",["ModernBertForSequenceClassification",Dt]],["roformer",["RoFormerForSequenceClassification",Kt]],["electra",["ElectraForSequenceClassification",ve]],["esm",["EsmForSequenceClassification",Ln]],["convbert",["ConvBertForSequenceClassification",F]],["camembert",["CamembertForSequenceClassification",yt]],["deberta",["DebertaForSequenceClassification",bi]],["deberta-v2",["DebertaV2ForSequenceClassification",Je]],["mpnet",["MPNetForSequenceClassification",ks]],["albert",["AlbertForSequenceClassification",vn]],["distilbert",["DistilBertForSequenceClassification",en]],["roberta",["RobertaForSequenceClassification",uu]],["xlm",["XLMForSequenceClassification",Uc]],["xlm-roberta",["XLMRobertaForSequenceClassification",kc]],["bart",["BartForSequenceClassification",es]],["mbart",["MBartForSequenceClassification",na]],["mobilebert",["MobileBertForSequenceClassification",Ss]],["squeezebert",["SqueezeBertForSequenceClassification",Ke]]]),Ec=new Map([["bert",["BertForTokenClassification",Ve]],["neobert",["NeoBertForTokenClassification",$e]],["modernbert",["ModernBertForTokenClassification",Vt]],["roformer",["RoFormerForTokenClassification",rn]],["electra",["ElectraForTokenClassification",ge]],["esm",["EsmForTokenClassification",Ct]],["convbert",["ConvBertForTokenClassification",K]],["camembert",["CamembertForTokenClassification",Ne]],["deberta",["DebertaForTokenClassification",gn]],["deberta-v2",["DebertaV2ForTokenClassification",Ue]],["mpnet",["MPNetForTokenClassification",$s]],["distilbert",["DistilBertForTokenClassification",dn]],["roberta",["RobertaForTokenClassification",tc]],["xlm",["XLMForTokenClassification",$f]],["xlm-roberta",["XLMRobertaForTokenClassification",jd]]]),Df=new Map([["t5",["T5ForConditionalGeneration",ni]],["longt5",["LongT5ForConditionalGeneration",Ci]],["mt5",["MT5ForConditionalGeneration",Wr]],["bart",["BartForConditionalGeneration",co]],["mbart",["MBartForConditionalGeneration",Fr]],["marian",["MarianMTModel",Vm]],["m2m_100",["M2M100ForConditionalGeneration",cd]],["blenderbot",["BlenderbotForConditionalGeneration",Pi]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",Vs]]]),Fu=new Map([["bloom",["BloomForCausalLM",Xr]],["gpt2",["GPT2LMHeadModel",ac]],["jais",["JAISLMHeadModel",uc]],["gptj",["GPTJForCausalLM",G]],["gpt_bigcode",["GPTBigCodeForCausalLM",Te]],["gpt_neo",["GPTNeoForCausalLM",ll]],["gpt_neox",["GPTNeoXForCausalLM",sa]],["codegen",["CodeGenForCausalLM",Nt]],["llama",["LlamaForCausalLM",On]],["nanochat",["NanoChatForCausalLM",ga]],["llama4_text",["Llama4ForCausalLM",hi]],["arcee",["ArceeForCausalLM",qf]],["lfm2",["Lfm2ForCausalLM",Jc]],["smollm3",["SmolLM3ForCausalLM",Qc]],["exaone",["ExaoneForCausalLM",Yf]],["olmo",["OlmoForCausalLM",dc]],["olmo2",["Olmo2ForCausalLM",Ka]],["mobilellm",["MobileLLMForCausalLM",Yh]],["granite",["GraniteForCausalLM",dl]],["granitemoehybrid",["GraniteMoeHybridForCausalLM",Jh]],["cohere",["CohereForCausalLM",tf]],["gemma",["GemmaForCausalLM",Ui]],["gemma2",["Gemma2ForCausalLM",Jf]],["vaultgemma",["VaultGemmaForCausalLM",bm]],["gemma3_text",["Gemma3ForCausalLM",Qh]],["helium",["HeliumForCausalLM",_a]],["glm",["GlmForCausalLM",aa]],["openelm",["OpenELMForCausalLM",Hl]],["qwen2",["Qwen2ForCausalLM",mo]],["qwen3",["Qwen3ForCausalLM",yu]],["phi",["PhiForCausalLM",ep]],["phi3",["Phi3ForCausalLM",np]],["mpt",["MptForCausalLM",$l]],["opt",["OPTForCausalLM",rp]],["mbart",["MBartForCausalLM",Ks]],["mistral",["MistralForCausalLM",Sf]],["ernie4_5",["Ernie4_5_ForCausalLM",bh]],["starcoder2",["Starcoder2ForCausalLM",bo]],["falcon",["FalconForCausalLM",bl]],["trocr",["TrOCRForCausalLM",Du]],["stablelm",["StableLmForCausalLM",ir]],["modernbert-decoder",["ModernBertDecoderForCausalLM",Jt]],["phi3_v",["Phi3VForCausalLM",sc]]]),yd=new Map([["multi_modality",["MultiModalityCausalLM",wc]]]),Aa=new Map([["bert",["BertForMaskedLM",Fe]],["neobert",["NeoBertForMaskedLM",Me]],["modernbert",["ModernBertForMaskedLM",Et]],["roformer",["RoFormerForMaskedLM",qe]],["electra",["ElectraForMaskedLM",Q]],["esm",["EsmForMaskedLM",Pn]],["convbert",["ConvBertForMaskedLM",A]],["camembert",["CamembertForMaskedLM",ft]],["deberta",["DebertaForMaskedLM",Bn]],["deberta-v2",["DebertaV2ForMaskedLM",Ge]],["mpnet",["MPNetForMaskedLM",fi]],["albert",["AlbertForMaskedLM",En]],["distilbert",["DistilBertForMaskedLM",_n]],["roberta",["RobertaForMaskedLM",ec]],["xlm",["XLMWithLMHeadModel",jf]],["xlm-roberta",["XLMRobertaForMaskedLM",Hd]],["mobilebert",["MobileBertForMaskedLM",Nn]],["squeezebert",["SqueezeBertForMaskedLM",Ie]]]),f=new Map([["bert",["BertForQuestionAnswering",Qe]],["neobert",["NeoBertForQuestionAnswering",et]],["roformer",["RoFormerForQuestionAnswering",fe]],["electra",["ElectraForQuestionAnswering",Le]],["convbert",["ConvBertForQuestionAnswering",Ee]],["camembert",["CamembertForQuestionAnswering",Bt]],["deberta",["DebertaForQuestionAnswering",Mn]],["deberta-v2",["DebertaV2ForQuestionAnswering",Ot]],["mpnet",["MPNetForQuestionAnswering",Ds]],["albert",["AlbertForQuestionAnswering",bn]],["distilbert",["DistilBertForQuestionAnswering",wn]],["roberta",["RobertaForQuestionAnswering",Vf]],["xlm",["XLMForQuestionAnswering",Wf]],["xlm-roberta",["XLMRobertaForQuestionAnswering",$d]],["mobilebert",["MobileBertForQuestionAnswering",yr]],["squeezebert",["SqueezeBertForQuestionAnswering",Ze]]]),m=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Xd]],["idefics3",["Idefics3ForConditionalGeneration",rl]],["smolvlm",["SmolVLMForConditionalGeneration",Io]]]),E=new Map([["llava",["LlavaForConditionalGeneration",fo]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",Bo]],["moondream1",["Moondream1ForConditionalGeneration",Jd]],["florence2",["Florence2ForConditionalGeneration",Bl]],["qwen2-vl",["Qwen2VLForConditionalGeneration",hc]],["idefics3",["Idefics3ForConditionalGeneration",rl]],["smolvlm",["SmolVLMForConditionalGeneration",Io]],["paligemma",["PaliGemmaForConditionalGeneration",Il]],["llava_qwen2",["LlavaQwen2ForCausalLM",Ar]],["gemma3n",["Gemma3nForConditionalGeneration",sl]]]),L=new Map([["ultravox",["UltravoxModel",_i]],["voxtral",["VoxtralForConditionalGeneration",Oi]]]),$=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Xd]]]),ie=new Map([["vit",["ViTForImageClassification",bu]],["ijepa",["IJepaForImageClassification",th]],["pvt",["PvtForImageClassification",Em]],["vit_msn",["ViTMSNForImageClassification",op]],["fastvit",["FastViTForImageClassification",lf]],["mobilevit",["MobileViTForImageClassification",up]],["mobilevitv2",["MobileViTV2ForImageClassification",Wl]],["beit",["BeitForImageClassification",Ma]],["deit",["DeiTForImageClassification",Am]],["hiera",["HieraForImageClassification",pp]],["convnext",["ConvNextForImageClassification",zm]],["convnextv2",["ConvNextV2ForImageClassification",km]],["dinov2",["Dinov2ForImageClassification",Ep]],["dinov2_with_registers",["Dinov2WithRegistersForImageClassification",Tp]],["resnet",["ResNetForImageClassification",fr]],["swin",["SwinForImageClassification",dh]],["segformer",["SegformerForImageClassification",wo]],["efficientnet",["EfficientNetForImageClassification",xh]],["mobilenet_v1",["MobileNetV1ForImageClassification",qm]],["mobilenet_v2",["MobileNetV2ForImageClassification",Iu]],["mobilenet_v3",["MobileNetV3ForImageClassification",xc]],["mobilenet_v4",["MobileNetV4ForImageClassification",Br]]]),De=new Map([["detr",["DetrForObjectDetection",oa]],["rt_detr",["RTDetrForObjectDetection",ql]],["rt_detr_v2",["RTDetrV2ForObjectDetection",Ia]],["rf_detr",["RFDetrForObjectDetection",oh]],["d_fine",["DFineForObjectDetection",cf]],["table-transformer",["TableTransformerForObjectDetection",tr]],["yolos",["YolosForObjectDetection",Ip]]]),it=new Map([["owlvit",["OwlViTForObjectDetection",cp]],["owlv2",["Owlv2ForObjectDetection",ml]],["grounding-dino",["GroundingDinoForObjectDetection",Rp]]]),pt=new Map([["detr",["DetrForSegmentation",Mr]],["clipseg",["CLIPSegForImageSegmentation",ol]]]),Xt=new Map([["segformer",["SegformerForSemanticSegmentation",Us]],["sapiens",["SapiensForSemanticSegmentation",hh]],["swin",["SwinForSemanticSegmentation",mp]],["mobilenet_v1",["MobileNetV1ForSemanticSegmentation",hr]],["mobilenet_v2",["MobileNetV2ForSemanticSegmentation",sr]],["mobilenet_v3",["MobileNetV3ForSemanticSegmentation",ss]],["mobilenet_v4",["MobileNetV4ForSemanticSegmentation",Ys]]]),mn=new Map([["detr",["DetrForSegmentation",Mr]],["maskformer",["MaskFormerForInstanceSegmentation",Lm]]]),An=new Map([["sam",["SamModel",l_]],["sam2",["Sam2Model",vc]],["edgetam",["EdgeTamModel",Xl]],["sam3_tracker",["Sam3TrackerModel",yc]]]),Rn=new Map([["wav2vec2",["Wav2Vec2ForCTC",jm]],["wav2vec2-bert",["Wav2Vec2BertForCTC",Ur]],["unispeech",["UniSpeechForCTC",zs]],["unispeech-sat",["UniSpeechSatForCTC",Ja]],["wavlm",["WavLMForCTC",Mo]],["hubert",["HubertForCTC",ua]],["parakeet_ctc",["ParakeetForCTC",vh]]]),ci=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Jr]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",bf]],["unispeech",["UniSpeechForSequenceClassification",nr]],["unispeech-sat",["UniSpeechSatForSequenceClassification",Qa]],["wavlm",["WavLMForSequenceClassification",xf]],["hubert",["HubertForSequenceClassification",Qr]],["audio-spectrogram-transformer",["ASTForAudioClassification",cu]]]),Ua=new Map([["wavlm",["WavLMForXVector",eo]]]),Bf=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",Go]],["wavlm",["WavLMForAudioFrameClassification",Pu]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",Lp]],["pyannote",["PyAnnoteForAudioFrameClassification",Fp]]]),Tc=new Map([["vitmatte",["VitMatteForImageMatting",mc]]]),Rt=new Map([["patchtst",["PatchTSTForPrediction",Cf]],["patchtsmixer",["PatchTSMixerForPrediction",Vi]]]),_t=new Map([["swin2sr",["Swin2SRForImageSuperResolution",gp]]]),Lt=new Map([["dpt",["DPTForDepthEstimation",Pm]],["depth_anything",["DepthAnythingForDepthEstimation",yp]],["glpn",["GLPNForDepthEstimation",Fm]],["sapiens",["SapiensForDepthEstimation",pf]],["depth_pro",["DepthProForDepthEstimation",Dm]],["metric3d",["Metric3DForDepthEstimation",Mp]],["metric3dv2",["Metric3Dv2ForDepthEstimation",Im]]]),cn=new Map([["sapiens",["SapiensForNormalEstimation",Rm]]]),$n=new Map([["vitpose",["VitPoseForPoseEstimation",sf]]]),Os=new Map([["clip",["CLIPVisionModelWithProjection",Wc]],["siglip",["SiglipVisionModel",ho]],["jina_clip",["JinaCLIPVisionModel",Cr]]]),ri=[[Eo,x.EncoderOnly],[Rf,x.EncoderDecoder],[ar,x.DecoderOnly],[iu,x.AutoEncoder],[su,x.EncoderOnly],[Ec,x.EncoderOnly],[Df,x.Seq2Seq],[To,x.Seq2Seq],[Fu,x.DecoderOnly],[yd,x.MultiModality],[Aa,x.EncoderOnly],[f,x.EncoderOnly],[m,x.Vision2Seq],[E,x.ImageTextToText],[L,x.AudioTextToText],[ie,x.EncoderOnly],[pt,x.EncoderOnly],[mn,x.EncoderOnly],[Xt,x.EncoderOnly],[Tc,x.EncoderOnly],[Rt,x.EncoderOnly],[_t,x.EncoderOnly],[Lt,x.EncoderOnly],[cn,x.EncoderOnly],[$n,x.EncoderOnly],[De,x.EncoderOnly],[it,x.EncoderOnly],[An,x.MaskGeneration],[Rn,x.EncoderOnly],[ci,x.EncoderOnly],[ro,x.Seq2Seq],[So,x.EncoderOnly],[Ua,x.EncoderOnly],[Bf,x.EncoderOnly],[Os,x.EncoderOnly]];for(const[Y,X]of ri)for(const[Pe,ut]of Y.values())R.set(Pe,X),D.set(ut,Pe),P.set(Pe,ut);const Xi=[["MusicgenForConditionalGeneration",Ql,x.Musicgen],["Phi3VForCausalLM",sc,x.Phi3V],["CLIPTextModelWithProjection",Ol,x.EncoderOnly],["SiglipTextModel",hu,x.EncoderOnly],["JinaCLIPTextModel",al,x.EncoderOnly],["ClapTextModelWithProjection",xo,x.EncoderOnly],["ClapAudioModelWithProjection",xr,x.EncoderOnly],["DacEncoderModel",Hi,x.EncoderOnly],["DacDecoderModel",io,x.EncoderOnly],["MimiEncoderModel",xs,x.EncoderOnly],["MimiDecoderModel",mr,x.EncoderOnly],["SnacEncoderModel",za,x.EncoderOnly],["SnacDecoderModel",nu,x.EncoderOnly],["Gemma3nForConditionalGeneration",sl,x.ImageAudioTextToText],["SupertonicForConditionalGeneration",Tf,x.Supertonic]];for(const[Y,X,Pe]of Xi)R.set(Y,Pe),D.set(X,Y),P.set(Y,X);const Ir=new Map([["modnet",pt],["birefnet",pt],["isnet",pt],["ben",pt]]);for(const[Y,X]of Ir.entries())X.set(Y,["PreTrainedModel",ye]),R.set(Y,x.EncoderOnly),D.set(ye,Y),P.set(Y,ye);class Yi extends Li{static MODEL_CLASS_MAPPINGS=ri.map(X=>X[0]);static BASE_IF_FAIL=!0}class Nu extends Li{static MODEL_CLASS_MAPPINGS=[su]}class kp extends Li{static MODEL_CLASS_MAPPINGS=[Ec]}class sy extends Li{static MODEL_CLASS_MAPPINGS=[Df]}class ry extends Li{static MODEL_CLASS_MAPPINGS=[To]}class Ls extends Li{static MODEL_CLASS_MAPPINGS=[ro]}class T0 extends Li{static MODEL_CLASS_MAPPINGS=[So]}class Dx extends Li{static MODEL_CLASS_MAPPINGS=[Fu]}class ay extends Li{static MODEL_CLASS_MAPPINGS=[Aa]}class Bx extends Li{static MODEL_CLASS_MAPPINGS=[f]}class Ix extends Li{static MODEL_CLASS_MAPPINGS=[m]}class Ox extends Li{static MODEL_CLASS_MAPPINGS=[ie]}class c_ extends Li{static MODEL_CLASS_MAPPINGS=[pt]}class Gp extends Li{static MODEL_CLASS_MAPPINGS=[Xt]}class S0 extends Li{static MODEL_CLASS_MAPPINGS=[mn]}class d_ extends Li{static MODEL_CLASS_MAPPINGS=[De]}class A0 extends Li{static MODEL_CLASS_MAPPINGS=[it]}class If extends Li{static MODEL_CLASS_MAPPINGS=[An]}class Sc extends Li{static MODEL_CLASS_MAPPINGS=[Rn]}class Xm extends Li{static MODEL_CLASS_MAPPINGS=[ci]}class Lx extends Li{static MODEL_CLASS_MAPPINGS=[Ua]}class oy extends Li{static MODEL_CLASS_MAPPINGS=[Bf]}class ly extends Li{static MODEL_CLASS_MAPPINGS=[$]}class uy extends Li{static MODEL_CLASS_MAPPINGS=[Tc]}class cy extends Li{static MODEL_CLASS_MAPPINGS=[_t]}class Fx extends Li{static MODEL_CLASS_MAPPINGS=[Lt]}class C0 extends Li{static MODEL_CLASS_MAPPINGS=[cn]}class dy extends Li{static MODEL_CLASS_MAPPINGS=[$n]}class fy extends Li{static MODEL_CLASS_MAPPINGS=[Os]}class Nx extends Li{static MODEL_CLASS_MAPPINGS=[E]}class P0 extends Li{static MODEL_CLASS_MAPPINGS=[L]}class R0 extends xe{constructor({logits:X,past_key_values:Pe,encoder_outputs:ut,decoder_attentions:xt=null,cross_attentions:St=null}){super(),this.logits=X,this.past_key_values=Pe,this.encoder_outputs=ut,this.decoder_attentions=xt,this.cross_attentions=St}}class di extends xe{constructor({logits:X,...Pe}){super(),this.logits=X;const ut=Object.values(Pe);ut.length>0&&(this.attentions=ut)}}class hy extends xe{constructor({logits:X,embeddings:Pe}){super(),this.logits=X,this.embeddings=Pe}}class gr extends xe{constructor({logits:X}){super(),this.logits=X}}class da extends xe{constructor({logits:X}){super(),this.logits=X}}class Ca extends xe{constructor({start_logits:X,end_logits:Pe}){super(),this.start_logits=X,this.end_logits=Pe}}class yi extends xe{constructor({logits:X}){super(),this.logits=X}}class D0 extends xe{constructor({logits:X,past_key_values:Pe}){super(),this.logits=X,this.past_key_values=Pe}}class Ym extends xe{constructor({alphas:X}){super(),this.alphas=X}}class f_ extends xe{constructor({waveform:X,spectrogram:Pe}){super(),this.waveform=X,this.spectrogram=Pe}}}),"./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js":((n,e,t)=>{t.r(e),t.d(e,{ASTFeatureExtractor:()=>r});var i=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var s=t("./src/utils/audio.js");class r extends i.FeatureExtractor{constructor(l){super(l);const c=this.config.sampling_rate,d=(0,s.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(c/2),c,null,"kaldi",!0);this.mel_filters=d,this.window=(0,s.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(l,c){return(0,s.spectrogram)(l,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:c,transpose:!0})}async _call(l){(0,i.validate_audio_inputs)(l,"ASTFeatureExtractor");const c=await this._extract_fbank_features(l,this.config.max_length);if(this.config.do_normalize){const d=this.std*2,g=c.data;for(let p=0;p<g.length;++p)g[p]=(g[p]-this.mean)/d}return{input_values:c.unsqueeze_(0)}}}}),"./src/models/auto/feature_extraction_auto.js":((n,e,t)=>{t.r(e),t.d(e,{AutoFeatureExtractor:()=>o});var i=t("./src/utils/constants.js"),s=t("./src/utils/hub.js");t("./src/base/feature_extraction_utils.js");var r=t("./src/models/feature_extractors.js");class o{static async from_pretrained(c,d={}){const g=await(0,s.getModelJSON)(c,i.FEATURE_EXTRACTOR_NAME,!0,d),p=g.feature_extractor_type,h=r[p];if(!h)throw new Error(`Unknown feature_extractor_type: '${p}'. Please report this at ${i.GITHUB_ISSUE_URL}.`);return new h(g)}}}),"./src/models/auto/image_processing_auto.js":((n,e,t)=>{t.r(e),t.d(e,{AutoImageProcessor:()=>l});var i=t("./src/utils/constants.js"),s=t("./src/utils/hub.js"),r=t("./src/base/image_processors_utils.js"),o=t("./src/models/image_processors.js");class l{static async from_pretrained(d,g={}){const p=await(0,s.getModelJSON)(d,i.IMAGE_PROCESSOR_NAME,!0,g),h=p.image_processor_type??p.feature_extractor_type;let v=o[h?.replace(/Fast$/,"")];return v||(h!==void 0&&console.warn(`Image processor type '${h}' not found, assuming base ImageProcessor. Please report this at ${i.GITHUB_ISSUE_URL}.`),v=r.ImageProcessor),new v(p)}}}),"./src/models/auto/processing_auto.js":((n,e,t)=>{t.r(e),t.d(e,{AutoProcessor:()=>d});var i=t("./src/utils/constants.js"),s=t("./src/utils/hub.js"),r=t("./src/base/processing_utils.js"),o=t("./src/models/processors.js"),l=t("./src/models/image_processors.js"),c=t("./src/models/feature_extractors.js");class d{static async from_pretrained(p,h={}){const v=await(0,s.getModelJSON)(p,i.IMAGE_PROCESSOR_NAME,!0,h),{image_processor_type:y,feature_extractor_type:w,processor_class:S}=v;if(S&&o[S])return o[S].from_pretrained(p,h);if(!y&&!w)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const M={};if(y){const C=l[y.replace(/Fast$/,"")];if(!C)throw new Error(`Unknown image_processor_type: '${y}'.`);M.image_processor=new C(v)}if(w){const C=l[w];if(C)M.image_processor=new C(v);else{const x=c[w];if(!x)throw new Error(`Unknown feature_extractor_type: '${w}'.`);M.feature_extractor=new x(v)}}const T={};return new r.Processor(T,M,null)}}}),"./src/models/beit/image_processing_beit.js":((n,e,t)=>{t.r(e),t.d(e,{BeitFeatureExtractor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}}),"./src/models/bit/image_processing_bit.js":((n,e,t)=>{t.r(e),t.d(e,{BitImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}}),"./src/models/chinese_clip/image_processing_chinese_clip.js":((n,e,t)=>{t.r(e),t.d(e,{ChineseCLIPFeatureExtractor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}}),"./src/models/clap/feature_extraction_clap.js":((n,e,t)=>{t.r(e),t.d(e,{ClapFeatureExtractor:()=>r});var i=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var s=t("./src/utils/audio.js");class r extends i.FeatureExtractor{constructor(l){super(l),this.mel_filters=(0,s.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,s.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,s.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(l,c,d,g){let p;const h=l.length-c;if(h>0)if(d==="rand_trunc"){const v=Math.floor(Math.random()*(h+1));l=l.subarray(v,v+c),p=await this._extract_fbank_features(l,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${d}" not implemented`);else{if(h<0){let v=new Float64Array(c);if(v.set(l),g==="repeat")for(let y=l.length;y<c;y+=l.length)v.set(l.subarray(0,Math.min(l.length,c-y)),y);else if(g==="repeatpad")for(let y=l.length;y<-h;y+=l.length)v.set(l,y);l=v}if(d==="fusion")throw new Error(`Truncation strategy "${d}" not implemented`);p=await this._extract_fbank_features(l,this.mel_filters_slaney,this.config.nb_max_samples)}return p.unsqueeze_(0)}async _extract_fbank_features(l,c,d=null){return(0,s.spectrogram)(l,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:c,log_mel:"dB",max_num_frames:d,do_pad:!1,transpose:!0})}async _call(l,{max_length:c=null}={}){return(0,i.validate_audio_inputs)(l,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(l,c??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}}),"./src/models/clip/image_processing_clip.js":((n,e,t)=>{t.r(e),t.d(e,{CLIPFeatureExtractor:()=>r,CLIPImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}class r extends s{}}),"./src/models/convnext/image_processing_convnext.js":((n,e,t)=>{t.r(e),t.d(e,{ConvNextFeatureExtractor:()=>r,ConvNextImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{constructor(l){super(l),this.crop_pct=this.config.crop_pct??224/256}async resize(l){const c=this.size?.shortest_edge;if(c===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(c<384){const d=Math.floor(c/this.crop_pct),[g,p]=this.get_resize_output_image_size(l,{shortest_edge:d});l=await l.resize(g,p,{resample:this.resample}),l=await l.center_crop(c,c)}else l=await l.resize(c,c,{resample:this.resample});return l}}class r extends s{}}),"./src/models/dac/feature_extraction_dac.js":((n,e,t)=>{t.r(e),t.d(e,{DacFeatureExtractor:()=>s});var i=t("./src/models/encodec/feature_extraction_encodec.js");class s extends i.EncodecFeatureExtractor{}}),"./src/models/deit/image_processing_deit.js":((n,e,t)=>{t.r(e),t.d(e,{DeiTFeatureExtractor:()=>r,DeiTImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}class r extends s{}}),"./src/models/detr/image_processing_detr.js":((n,e,t)=>{t.r(e),t.d(e,{DetrFeatureExtractor:()=>o,DetrImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js"),s=t("./src/utils/tensor.js");class r extends i.ImageProcessor{async _call(c){const d=await super._call(c),g=[d.pixel_values.dims[0],64,64],p=(0,s.full)(g,1n);return{...d,pixel_mask:p}}post_process_object_detection(...c){return(0,i.post_process_object_detection)(...c)}post_process_panoptic_segmentation(...c){return(0,i.post_process_panoptic_segmentation)(...c)}post_process_instance_segmentation(...c){return(0,i.post_process_instance_segmentation)(...c)}}class o extends r{}}),"./src/models/dinov3_vit/image_processing_dinov3_vit.js":((n,e,t)=>{t.r(e),t.d(e,{DINOv3ViTImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}}),"./src/models/donut/image_processing_donut.js":((n,e,t)=>{t.r(e),t.d(e,{DonutFeatureExtractor:()=>r,DonutImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{pad_image(l,c,d,g={}){const[p,h,v]=c;let y=this.image_mean;Array.isArray(this.image_mean)||(y=new Array(v).fill(y));let w=this.image_std;Array.isArray(w)||(w=new Array(v).fill(y));const S=y.map((M,T)=>-M/w[T]);return super.pad_image(l,c,d,{center:!0,constant_values:S,...g})}}class r extends s{}}),"./src/models/dpt/image_processing_dpt.js":((n,e,t)=>{t.r(e),t.d(e,{DPTFeatureExtractor:()=>r,DPTImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}class r extends s{}}),"./src/models/efficientnet/image_processing_efficientnet.js":((n,e,t)=>{t.r(e),t.d(e,{EfficientNetImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{constructor(o){super(o),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(l=>l*l))}}}),"./src/models/encodec/feature_extraction_encodec.js":((n,e,t)=>{t.r(e),t.d(e,{EncodecFeatureExtractor:()=>r});var i=t("./src/base/feature_extraction_utils.js"),s=t("./src/utils/tensor.js");class r extends i.FeatureExtractor{async _call(l){(0,i.validate_audio_inputs)(l,"EncodecFeatureExtractor"),l instanceof Float64Array&&(l=new Float32Array(l));const c=this.config.feature_size;if(l.length%c!==0)throw new Error(`The length of the audio data must be a multiple of the number of channels (${c}).`);const d=[1,c,l.length/c];return{input_values:new s.Tensor("float32",l,d)}}}}),"./src/models/feature_extractors.js":((n,e,t)=>{t.r(e),t.d(e,{ASTFeatureExtractor:()=>i.ASTFeatureExtractor,ClapFeatureExtractor:()=>r.ClapFeatureExtractor,DacFeatureExtractor:()=>o.DacFeatureExtractor,EncodecFeatureExtractor:()=>s.EncodecFeatureExtractor,Gemma3nAudioFeatureExtractor:()=>l.Gemma3nAudioFeatureExtractor,ImageFeatureExtractor:()=>M.ImageProcessor,MoonshineFeatureExtractor:()=>c.MoonshineFeatureExtractor,ParakeetFeatureExtractor:()=>d.ParakeetFeatureExtractor,PyAnnoteFeatureExtractor:()=>g.PyAnnoteFeatureExtractor,SeamlessM4TFeatureExtractor:()=>p.SeamlessM4TFeatureExtractor,SnacFeatureExtractor:()=>h.SnacFeatureExtractor,SpeechT5FeatureExtractor:()=>v.SpeechT5FeatureExtractor,Wav2Vec2FeatureExtractor:()=>y.Wav2Vec2FeatureExtractor,WeSpeakerFeatureExtractor:()=>w.WeSpeakerFeatureExtractor,WhisperFeatureExtractor:()=>S.WhisperFeatureExtractor});var i=t("./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js"),s=t("./src/models/encodec/feature_extraction_encodec.js"),r=t("./src/models/clap/feature_extraction_clap.js"),o=t("./src/models/dac/feature_extraction_dac.js"),l=t("./src/models/gemma3n/feature_extraction_gemma3n.js"),c=t("./src/models/moonshine/feature_extraction_moonshine.js"),d=t("./src/models/parakeet/feature_extraction_parakeet.js"),g=t("./src/models/pyannote/feature_extraction_pyannote.js"),p=t("./src/models/seamless_m4t/feature_extraction_seamless_m4t.js"),h=t("./src/models/snac/feature_extraction_snac.js"),v=t("./src/models/speecht5/feature_extraction_speecht5.js"),y=t("./src/models/wav2vec2/feature_extraction_wav2vec2.js"),w=t("./src/models/wespeaker/feature_extraction_wespeaker.js"),S=t("./src/models/whisper/feature_extraction_whisper.js"),M=t("./src/base/image_processors_utils.js")}),"./src/models/florence2/processing_florence2.js":((n,e,t)=>{t.r(e),t.d(e,{Florence2Processor:()=>o});var i=t("./src/base/processing_utils.js"),s=t("./src/models/auto/image_processing_auto.js"),r=t("./src/tokenizers.js");class o extends i.Processor{static tokenizer_class=r.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;constructor(c,d,g){super(c,d,g);const{tasks_answer_post_processing_type:p,task_prompts_without_inputs:h,task_prompts_with_input:v}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(p??{})),this.task_prompts_without_inputs=new Map(Object.entries(h??{})),this.task_prompts_with_input=new Map(Object.entries(v??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(c){typeof c=="string"&&(c=[c]);const d=[];for(const g of c)if(this.task_prompts_without_inputs.has(g))d.push(this.task_prompts_without_inputs.get(g));else{for(const[p,h]of this.task_prompts_with_input)if(g.includes(p)){d.push(h.replaceAll("{input}",g).replaceAll(p,""));break}d.length!==c.length&&d.push(g)}return d}post_process_generation(c,d,g){const p=this.tasks_answer_post_processing_type.get(d)??"pure_text";c=c.replaceAll("<s>","").replaceAll("</s>","");let h;switch(p){case"pure_text":h=c;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const v=p==="ocr"?"quad_boxes":"bboxes",y=c.matchAll(this.regexes[v]),w=[],S=[];for(const[M,T,...C]of y)w.push(T?T.trim():w.at(-1)??""),S.push(C.map((x,R)=>(Number(x)+.5)/this.size_per_bin*g[R%2]));h={labels:w,[v]:S};break;default:throw new Error(`Task "${d}" (of type "${p}") not yet implemented.`)}return{[d]:h}}async _call(c,d=null,g={}){if(!c&&!d)throw new Error("Either text or images must be provided");const p=await this.image_processor(c,g),h=d?this.tokenizer(this.construct_prompts(d),g):{};return{...p,...h}}}}),"./src/models/gemma3n/feature_extraction_gemma3n.js":((n,e,t)=>{t.r(e),t.d(e,{Gemma3nAudioFeatureExtractor:()=>o});var i=t("./src/base/feature_extraction_utils.js"),s=t("./src/utils/tensor.js"),r=t("./src/utils/audio.js");class o extends i.FeatureExtractor{constructor(c){super(c);const{fft_length:d,feature_size:g,min_frequency:p,max_frequency:h,sampling_rate:v,frame_length:y}=this.config,w=(0,r.mel_filter_bank)(Math.floor(1+d/2),g,p,h,v,null,"htk",!1);this.mel_filters=w,this.window=(0,r.window_function)(y,"hann")}async _extract_fbank_features(c,d){return(0,r.spectrogram)(c,this.window,this.config.frame_length,this.config.hop_length,{fft_length:this.config.fft_length,center:!1,onesided:!0,preemphasis:this.config.preemphasis,preemphasis_htk_flavor:this.config.preemphasis_htk_flavor,mel_filters:this.mel_filters,log_mel:"log",mel_floor:this.config.mel_floor,remove_dc_offset:!1,transpose:!0})}async _call(c,{max_length:d=48e4,truncation:g=!0,padding:p=!0,pad_to_multiple_of:h=128}={}){if((0,i.validate_audio_inputs)(c,"Gemma3nAudioFeatureExtractor"),g&&c.length>d&&(c=c.slice(0,d)),p&&c.length%h!==0){const w=h-c.length%h,S=new Float64Array(c.length+w);S.set(c),this.config.padding_value!==0&&S.fill(this.config.padding_value,c.length),c=S}const v=await this._extract_fbank_features(c,this.config.max_length),y=(0,s.full)([1,v.dims[0]],!0);return{input_features:v.unsqueeze_(0),input_features_mask:y}}}}),"./src/models/gemma3n/processing_gemma3n.js":((n,e,t)=>{t.r(e),t.d(e,{Gemma3nProcessor:()=>l});var i=t("./src/base/processing_utils.js"),s=t("./src/models/auto/image_processing_auto.js"),r=t("./src/models/auto/feature_extraction_auto.js"),o=t("./src/tokenizers.js");t("./src/utils/image.js"),t("./src/utils/audio.js");class l extends i.Processor{static image_processor_class=s.AutoImageProcessor;static feature_extractor_class=r.AutoFeatureExtractor;static tokenizer_class=o.AutoTokenizer;static uses_processor_config=!0;static uses_chat_template_file=!0;constructor(d,g,p){super(d,g,p),this.audio_seq_length=this.config.audio_seq_length,this.image_seq_length=this.config.image_seq_length;const{audio_token_id:h,boa_token:v,audio_token:y,eoa_token:w,image_token_id:S,boi_token:M,image_token:T,eoi_token:C}=this.tokenizer.config;this.audio_token_id=h,this.boa_token=v,this.audio_token=y;const x=y.repeat(this.audio_seq_length);this.full_audio_sequence=`

${v}${x}${w}

`,this.image_token_id=S,this.boi_token=M,this.image_token=T;const R=T.repeat(this.image_seq_length);this.full_image_sequence=`

${M}${R}${C}

`}async _call(d,g=null,p=null,h={}){typeof d=="string"&&(d=[d]);let v;p&&(v=await this.feature_extractor(p,h),d=d.map(S=>S.replaceAll(this.audio_token,this.full_audio_sequence)));let y;return g&&(y=await this.image_processor(g,h),d=d.map(S=>S.replaceAll(this.image_token,this.full_image_sequence))),{...this.tokenizer(d,h),...y,...v}}}}),"./src/models/glpn/image_processing_glpn.js":((n,e,t)=>{t.r(e),t.d(e,{GLPNFeatureExtractor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}}),"./src/models/grounding_dino/image_processing_grounding_dino.js":((n,e,t)=>{t.r(e),t.d(e,{GroundingDinoImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js"),s=t("./src/utils/tensor.js");class r extends i.ImageProcessor{async _call(l){const c=await super._call(l),d=c.pixel_values.dims,g=(0,s.ones)([d[0],d[2],d[3]]);return{...c,pixel_mask:g}}}}),"./src/models/grounding_dino/processing_grounding_dino.js":((n,e,t)=>{t.r(e),t.d(e,{GroundingDinoProcessor:()=>c});var i=t("./src/base/processing_utils.js"),s=t("./src/models/auto/image_processing_auto.js"),r=t("./src/tokenizers.js"),o=t("./src/base/image_processors_utils.js");function l(d,g){const h=d.dims.at(-1)-1,v=d.tolist();v.fill(!1,0,1),v.fill(!1,h);const y=g.tolist();return v.map((w,S)=>w?S:null).filter(w=>w!==null).map(w=>y[w])}class c extends i.Processor{static tokenizer_class=r.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;async _call(g,p,h={}){const v=g?await this.image_processor(g,h):{};return{...p?this.tokenizer(p,h):{},...v}}post_process_grounded_object_detection(g,p,{box_threshold:h=.25,text_threshold:v=.25,target_sizes:y=null}={}){const{logits:w,pred_boxes:S}=g,M=w.dims[0];if(y!==null&&y.length!==M)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const T=w.dims.at(1),C=w.sigmoid(),x=C.max(-1).tolist(),R=S.tolist().map(D=>D.map(z=>(0,o.center_to_corners_format)(z))),P=[];for(let D=0;D<M;++D){const z=y!==null?y[D]:null;z!==null&&(R[D]=R[D].map(W=>W.map((oe,ne)=>oe*z[(ne+1)%2])));const U=x[D],N=[],j=[],J=[];for(let W=0;W<T;++W){const oe=U[W];if(oe<=h)continue;const ne=R[D][W],q=C[D][W];N.push(oe),J.push(ne);const le=l(q.gt(v),p[D]);j.push(le)}P.push({scores:N,boxes:J,labels:this.batch_decode(j)})}return P}}}),"./src/models/idefics3/image_processing_idefics3.js":((n,e,t)=>{t.r(e),t.d(e,{Idefics3ImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js"),s=t("./src/utils/tensor.js");class r extends i.ImageProcessor{constructor(l){super(l),this.do_image_splitting=l.do_image_splitting??!0,this.max_image_size=l.max_image_size}get_resize_for_vision_encoder(l,c){let[d,g]=l.dims.slice(-2);const p=g/d;return g>=d?(g=Math.ceil(g/c)*c,d=Math.floor(g/p),d=Math.ceil(d/c)*c):(d=Math.ceil(d/c)*c,g=Math.floor(d*p),g=Math.ceil(g/c)*c),{height:d,width:g}}async _call(l,{do_image_splitting:c=null,return_row_col_info:d=!1}={}){let g;if(!Array.isArray(l))g=[[l]];else{if(l.length===0||!l[0])throw new Error("No images provided.");Array.isArray(l[0])?g=l:g=[l]}let p=[],h=[],v=[];const y=[],w=[];for(const D of g){let z=await Promise.all(D.map(j=>this.preprocess(j)));y.push(...z.map(j=>j.original_size)),w.push(...z.map(j=>j.reshaped_input_size)),z.forEach(j=>j.pixel_values.unsqueeze_(0));const{longest_edge:U}=this.max_image_size;let N;if(c??this.do_image_splitting){let j=new Array(z.length),J=new Array(z.length);N=await Promise.all(z.map(async(W,oe)=>{const ne=this.get_resize_for_vision_encoder(W.pixel_values,U),q=await(0,s.interpolate_4d)(W.pixel_values,{size:[ne.height,ne.width]}),{frames:le,num_splits_h:se,num_splits_w:pe}=await this.split_image(q,this.max_image_size);return j[oe]=se,J[oe]=pe,(0,s.cat)(le,0)})),h.push(j),v.push(J)}else{const j=[U,U];N=await Promise.all(z.map(J=>(0,s.interpolate_4d)(J.pixel_values,{size:j}))),h.push(new Array(z.length).fill(0)),v.push(new Array(z.length).fill(0))}p.push((0,s.cat)(N,0))}const S=p.length,[M,T,C,x]=p[0].dims;let R,P;if(S===1)R=p[0].unsqueeze_(0),P=(0,s.full)([S,M,C,x],!0);else{const D=Math.max(...p.map(N=>N.dims.at(0)));P=(0,s.full)([S,D,C,x],!0);const z=P.data,U=D*C*x;for(let N=0;N<S;++N){const j=p[N].dims[0];if(j<D){p[N]=(0,s.cat)([p[N],(0,s.full)([D-j,T,C,x],0)],0);const J=N*U+j*C*x,W=(N+1)*U;z.fill(!1,J,W)}}R=(0,s.stack)(p,0)}return{pixel_values:R,pixel_attention_mask:P,original_sizes:y,reshaped_input_sizes:w,...d?{rows:h,cols:v}:{}}}async split_image(l,{longest_edge:c}){const d=c,g=c,p=[],[h,v]=l.dims.slice(-2);let y=0,w=0;if(h>d||v>g){y=Math.ceil(h/d),w=Math.ceil(v/g);const S=Math.ceil(h/y),M=Math.ceil(v/w);for(let x=0;x<y;++x)for(let R=0;R<w;++R){let P,D,z,U;x===y-1?(D=h-S,U=h):(D=x*S,U=(x+1)*S),R===w-1?(P=v-M,z=v):(P=R*M,z=(R+1)*M);const N=[D,P],j=[U,z],J=await(0,s.slice)(l,N,j,[2,3]);p.push(J)}const T=d,C=g;(h!==T||v!==C)&&(l=await(0,s.interpolate_4d)(l,{size:[T,C]}))}return p.push(l),{frames:p,num_splits_h:y,num_splits_w:w}}}}),"./src/models/idefics3/processing_idefics3.js":((n,e,t)=>{t.r(e),t.d(e,{Idefics3Processor:()=>g});var i=t("./src/base/processing_utils.js"),s=t("./src/models/auto/image_processing_auto.js"),r=t("./src/tokenizers.js");t("./src/utils/image.js");var o=t("./src/utils/core.js");function l(p,h,v,y,w,S){let M="";for(let T=0;T<h;++T){for(let C=0;C<v;++C)M+=y+`<row_${T+1}_col_${C+1}>`+w.repeat(p);M+=`
`}return M+=`
${y}${S}`+w.repeat(p)+`${y}`,M}function c(p,h,v,y){return`${h}${y}`+v.repeat(p)+`${h}`}function d(p,h,v,y,w,S){return p===0&&h===0?c(v,y,w,S):l(v,p,h,y,w,S)}class g extends i.Processor{static image_processor_class=s.AutoImageProcessor;static tokenizer_class=r.AutoTokenizer;static uses_processor_config=!0;fake_image_token="<fake_token_around_image>";image_token="<image>";global_img_token="<global-img>";async _call(h,v=null,y={}){y.return_row_col_info??=!0;let w;v&&(w=await this.image_processor(v,y)),Array.isArray(h)||(h=[h]);const S=w.rows??[new Array(h.length).fill(0)],M=w.cols??[new Array(h.length).fill(0)],T=this.config.image_seq_len,C=[],x=[];for(let P=0;P<h.length;++P){const D=h[P],z=S[P],U=M[P];C.push((0,o.count)(D,this.image_token));const N=z.map((W,oe)=>d(W,U[oe],T,this.fake_image_token,this.image_token,this.global_img_token)),j=D.split(this.image_token);if(j.length===0)throw new Error("The image token should be present in the text.");let J=j[0];for(let W=0;W<N.length;++W)J+=N[W]+j[W+1];x.push(J)}return{...this.tokenizer(x),...w}}}}),"./src/models/image_processors.js":((n,e,t)=>{t.r(e),t.d(e,{BeitFeatureExtractor:()=>i.BeitFeatureExtractor,BitImageProcessor:()=>s.BitImageProcessor,CLIPFeatureExtractor:()=>o.CLIPFeatureExtractor,CLIPImageProcessor:()=>o.CLIPImageProcessor,ChineseCLIPFeatureExtractor:()=>r.ChineseCLIPFeatureExtractor,ConvNextFeatureExtractor:()=>l.ConvNextFeatureExtractor,ConvNextImageProcessor:()=>l.ConvNextImageProcessor,DINOv3ViTImageProcessor:()=>g.DINOv3ViTImageProcessor,DPTFeatureExtractor:()=>h.DPTFeatureExtractor,DPTImageProcessor:()=>h.DPTImageProcessor,DeiTFeatureExtractor:()=>c.DeiTFeatureExtractor,DeiTImageProcessor:()=>c.DeiTImageProcessor,DetrFeatureExtractor:()=>d.DetrFeatureExtractor,DetrImageProcessor:()=>d.DetrImageProcessor,DonutFeatureExtractor:()=>p.DonutFeatureExtractor,DonutImageProcessor:()=>p.DonutImageProcessor,EfficientNetImageProcessor:()=>v.EfficientNetImageProcessor,GLPNFeatureExtractor:()=>y.GLPNFeatureExtractor,GroundingDinoImageProcessor:()=>w.GroundingDinoImageProcessor,Idefics3ImageProcessor:()=>S.Idefics3ImageProcessor,JinaCLIPImageProcessor:()=>T.JinaCLIPImageProcessor,LlavaOnevisionImageProcessor:()=>C.LlavaOnevisionImageProcessor,Mask2FormerImageProcessor:()=>x.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>R.MaskFormerFeatureExtractor,MaskFormerImageProcessor:()=>R.MaskFormerImageProcessor,MobileNetV1FeatureExtractor:()=>P.MobileNetV1FeatureExtractor,MobileNetV1ImageProcessor:()=>P.MobileNetV1ImageProcessor,MobileNetV2FeatureExtractor:()=>D.MobileNetV2FeatureExtractor,MobileNetV2ImageProcessor:()=>D.MobileNetV2ImageProcessor,MobileNetV3FeatureExtractor:()=>z.MobileNetV3FeatureExtractor,MobileNetV3ImageProcessor:()=>z.MobileNetV3ImageProcessor,MobileNetV4FeatureExtractor:()=>U.MobileNetV4FeatureExtractor,MobileNetV4ImageProcessor:()=>U.MobileNetV4ImageProcessor,MobileViTFeatureExtractor:()=>N.MobileViTFeatureExtractor,MobileViTImageProcessor:()=>N.MobileViTImageProcessor,NougatImageProcessor:()=>j.NougatImageProcessor,OwlViTFeatureExtractor:()=>W.OwlViTFeatureExtractor,OwlViTImageProcessor:()=>W.OwlViTImageProcessor,Owlv2ImageProcessor:()=>J.Owlv2ImageProcessor,Phi3VImageProcessor:()=>oe.Phi3VImageProcessor,PvtImageProcessor:()=>ne.PvtImageProcessor,Qwen2VLImageProcessor:()=>q.Qwen2VLImageProcessor,RTDetrImageProcessor:()=>le.RTDetrImageProcessor,Sam2ImageProcessor:()=>pe.Sam2ImageProcessor,Sam3ImageProcessor:()=>be.Sam3ImageProcessor,SamImageProcessor:()=>se.SamImageProcessor,SegformerFeatureExtractor:()=>ee.SegformerFeatureExtractor,SegformerImageProcessor:()=>ee.SegformerImageProcessor,SiglipImageProcessor:()=>te.SiglipImageProcessor,SmolVLMImageProcessor:()=>ue.SmolVLMImageProcessor,Swin2SRImageProcessor:()=>ae.Swin2SRImageProcessor,VLMImageProcessor:()=>M.VLMImageProcessor,ViTFeatureExtractor:()=>ce.ViTFeatureExtractor,ViTImageProcessor:()=>ce.ViTImageProcessor,VitMatteImageProcessor:()=>Be.VitMatteImageProcessor,VitPoseImageProcessor:()=>He.VitPoseImageProcessor,YolosFeatureExtractor:()=>Xe.YolosFeatureExtractor,YolosImageProcessor:()=>Xe.YolosImageProcessor});var i=t("./src/models/beit/image_processing_beit.js"),s=t("./src/models/bit/image_processing_bit.js"),r=t("./src/models/chinese_clip/image_processing_chinese_clip.js"),o=t("./src/models/clip/image_processing_clip.js"),l=t("./src/models/convnext/image_processing_convnext.js"),c=t("./src/models/deit/image_processing_deit.js"),d=t("./src/models/detr/image_processing_detr.js"),g=t("./src/models/dinov3_vit/image_processing_dinov3_vit.js"),p=t("./src/models/donut/image_processing_donut.js"),h=t("./src/models/dpt/image_processing_dpt.js"),v=t("./src/models/efficientnet/image_processing_efficientnet.js"),y=t("./src/models/glpn/image_processing_glpn.js"),w=t("./src/models/grounding_dino/image_processing_grounding_dino.js"),S=t("./src/models/idefics3/image_processing_idefics3.js"),M=t("./src/models/janus/image_processing_janus.js"),T=t("./src/models/jina_clip/image_processing_jina_clip.js"),C=t("./src/models/llava_onevision/image_processing_llava_onevision.js"),x=t("./src/models/mask2former/image_processing_mask2former.js"),R=t("./src/models/maskformer/image_processing_maskformer.js"),P=t("./src/models/mobilenet_v1/image_processing_mobilenet_v1.js"),D=t("./src/models/mobilenet_v2/image_processing_mobilenet_v2.js"),z=t("./src/models/mobilenet_v3/image_processing_mobilenet_v3.js"),U=t("./src/models/mobilenet_v4/image_processing_mobilenet_v4.js"),N=t("./src/models/mobilevit/image_processing_mobilevit.js"),j=t("./src/models/nougat/image_processing_nougat.js"),J=t("./src/models/owlv2/image_processing_owlv2.js"),W=t("./src/models/owlvit/image_processing_owlvit.js"),oe=t("./src/models/phi3_v/image_processing_phi3_v.js"),ne=t("./src/models/pvt/image_processing_pvt.js"),q=t("./src/models/qwen2_vl/image_processing_qwen2_vl.js"),le=t("./src/models/rt_detr/image_processing_rt_detr.js"),se=t("./src/models/sam/image_processing_sam.js"),pe=t("./src/models/sam2/image_processing_sam2.js"),be=t("./src/models/sam3/image_processing_sam3.js"),ee=t("./src/models/segformer/image_processing_segformer.js"),te=t("./src/models/siglip/image_processing_siglip.js"),ue=t("./src/models/smolvlm/image_processing_smolvlm.js"),ae=t("./src/models/swin2sr/image_processing_swin2sr.js"),ce=t("./src/models/vit/image_processing_vit.js"),Be=t("./src/models/vitmatte/image_processing_vitmatte.js"),He=t("./src/models/vitpose/image_processing_vitpose.js"),Xe=t("./src/models/yolos/image_processing_yolos.js")}),"./src/models/janus/image_processing_janus.js":((n,e,t)=>{t.r(e),t.d(e,{VLMImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{constructor(o){super({do_pad:!0,pad_size:{width:o.image_size,height:o.image_size},...o}),this.constant_values=this.config.background_color.map(l=>l*this.rescale_factor)}pad_image(o,l,c,d){return super.pad_image(o,l,c,{constant_values:this.constant_values,center:!0,...d})}}}),"./src/models/janus/processing_janus.js":((n,e,t)=>{t.r(e),t.d(e,{VLChatProcessor:()=>d});var i=t("./src/base/processing_utils.js"),s=t("./src/models/auto/image_processing_auto.js"),r=t("./src/tokenizers.js"),o=t("./src/utils/core.js"),l=t("./src/utils/tensor.js"),c=t("./src/utils/image.js");class d extends i.Processor{static image_processor_class=s.AutoImageProcessor;static tokenizer_class=r.AutoTokenizer;static uses_processor_config=!0;constructor(p,h,v){super(p,h,v),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(p,{images:h=null,chat_template:v="default"}={}){h?Array.isArray(h)||(h=[h]):h=await Promise.all(p.filter(N=>N.images).flatMap(N=>N.images).map(N=>c.RawImage.read(N)));const y=this.tokenizer,w=y.apply_chat_template(p,{tokenize:!1,add_generation_prompt:!0,chat_template:v}),S=N=>y.encode(N,{add_special_tokens:!1}),M=w.split(this.image_tag),T=M.length-1;if(h.length!==T)throw new Error(`Number of images provided (${h.length}) does not match number of "${this.image_tag}" image tags (${T})`);const[C,x,R]=y.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let P=S(M[0]),D=new Array(P.length).fill(!1);for(let N=1;N<M.length;++N){const j=new Array(this.num_image_tokens).fill(C),J=S(M[N]);P=(0,o.mergeArrays)(P,[x],j,[R],J);const W=new Array(this.num_image_tokens).fill(!0);D=(0,o.mergeArrays)(D,[!1],W,[!1],new Array(J.length).fill(!1))}const z=[1,P.length],U={input_ids:new l.Tensor("int64",P,z),attention_mask:new l.Tensor("int64",new Array(P.length).fill(1),z),images_seq_mask:new l.Tensor("bool",D,z),images_emb_mask:new l.Tensor("bool",new Array(T*this.num_image_tokens).fill(!0),[1,T,this.num_image_tokens])};if(h&&h.length>0){const N=await this.image_processor(h);return N.pixel_values.unsqueeze_(0),{...U,...N}}return U}}}),"./src/models/jina_clip/image_processing_jina_clip.js":((n,e,t)=>{t.r(e),t.d(e,{JinaCLIPImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{constructor(o){const{resize_mode:l,fill_color:c,interpolation:d,size:g,...p}=o,h=l==="squash"?{width:g,height:g}:l==="shortest"?{shortest_edge:g}:{longest_edge:g},v=d==="bicubic"?3:2;super({...p,size:h,resample:v,do_center_crop:!0,crop_size:g,do_normalize:!0})}}}),"./src/models/jina_clip/processing_jina_clip.js":((n,e,t)=>{t.r(e),t.d(e,{JinaCLIPProcessor:()=>o});var i=t("./src/base/processing_utils.js"),s=t("./src/models/auto/image_processing_auto.js"),r=t("./src/tokenizers.js");class o extends i.Processor{static tokenizer_class=r.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;async _call(c=null,d=null,g={}){if(!c&&!d)throw new Error("Either text or images must be provided");const p=c?this.tokenizer(c,g):{},h=d?await this.image_processor(d,g):{};return{...p,...h}}}}),"./src/models/llava/processing_llava.js":((n,e,t)=>{t.r(e),t.d(e,{LlavaProcessor:()=>o});var i=t("./src/base/processing_utils.js"),s=t("./src/models/auto/image_processing_auto.js"),r=t("./src/tokenizers.js");class o extends i.Processor{static tokenizer_class=r.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;static uses_processor_config=!0;async _call(c,d=null,g={}){const p=await this.image_processor(c,g);if(d){const[v,y]=p.pixel_values.dims.slice(-2),{image_token:w,patch_size:S,num_additional_image_tokens:M}=this.config,T=Math.floor(v/S)*Math.floor(y/S)+M;d=structuredClone(d),Array.isArray(d)||(d=[d]);for(let C=0;C<d.length;++C)d[C]=d[C].replace(w,w.repeat(T))}const h=d?this.tokenizer(d,g):{};return{...p,...h}}}}),"./src/models/llava_onevision/image_processing_llava_onevision.js":((n,e,t)=>{t.r(e),t.d(e,{LlavaOnevisionImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}}),"./src/models/mask2former/image_processing_mask2former.js":((n,e,t)=>{t.r(e),t.d(e,{Mask2FormerImageProcessor:()=>s});var i=t("./src/models/maskformer/image_processing_maskformer.js");class s extends i.MaskFormerImageProcessor{}}),"./src/models/maskformer/image_processing_maskformer.js":((n,e,t)=>{t.r(e),t.d(e,{MaskFormerFeatureExtractor:()=>r,MaskFormerImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{post_process_panoptic_segmentation(...l){return(0,i.post_process_panoptic_segmentation)(...l)}post_process_instance_segmentation(...l){return(0,i.post_process_instance_segmentation)(...l)}}class r extends s{}}),"./src/models/mgp_str/processing_mgp_str.js":((n,e,t)=>{t.r(e),t.d(e,{MgpstrProcessor:()=>c});var i=t("./src/base/processing_utils.js"),s=t("./src/models/auto/image_processing_auto.js"),r=t("./src/tokenizers.js"),o=t("./src/utils/maths.js");const l={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class c extends i.Processor{static tokenizer_class=r.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(g,p){if(!l.hasOwnProperty(p))throw new Error(`Format ${p} is not supported.`);const[h,v]=l[p],y=this[h].bind(this),[w,S]=g.dims,M=[],T=[],C=g.tolist();for(let R=0;R<w;++R){const P=C[R],D=[],z=[];for(let N=1;N<S;++N){const[j,J]=(0,o.max)((0,o.softmax)(P[N]));if(z.push(j),J==v)break;D.push(J)}const U=z.length>0?z.reduce((N,j)=>N*j,1):0;T.push(D),M.push(U)}return[y(T),M]}char_decode(g){return this.char_tokenizer.batch_decode(g).map(p=>p.replaceAll(" ",""))}bpe_decode(g){return this.bpe_tokenizer.batch_decode(g)}wp_decode(g){return this.wp_tokenizer.batch_decode(g).map(p=>p.replaceAll(" ",""))}batch_decode([g,p,h]){const[v,y]=this._decode_helper(g,"char"),[w,S]=this._decode_helper(p,"bpe"),[M,T]=this._decode_helper(h,"wp"),C=[],x=[];for(let R=0;R<v.length;++R){const[P,D]=(0,o.max)([y[R],S[R],T[R]]);C.push([v[R],w[R],M[R]][D]),x.push(P)}return{generated_text:C,scores:x,char_preds:v,bpe_preds:w,wp_preds:M}}static async from_pretrained(...g){const p=await super.from_pretrained(...g),h=await r.AutoTokenizer.from_pretrained("Xenova/gpt2"),v=await r.AutoTokenizer.from_pretrained("Xenova/bert-base-uncased");return p.components={image_processor:p.image_processor,char_tokenizer:p.tokenizer,bpe_tokenizer:h,wp_tokenizer:v},p}async _call(g,p=null){const h=await this.image_processor(g);return p&&(h.labels=this.tokenizer(p).input_ids),h}}}),"./src/models/mobilenet_v1/image_processing_mobilenet_v1.js":((n,e,t)=>{t.r(e),t.d(e,{MobileNetV1FeatureExtractor:()=>r,MobileNetV1ImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}class r extends s{}}),"./src/models/mobilenet_v2/image_processing_mobilenet_v2.js":((n,e,t)=>{t.r(e),t.d(e,{MobileNetV2FeatureExtractor:()=>r,MobileNetV2ImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}class r extends s{}}),"./src/models/mobilenet_v3/image_processing_mobilenet_v3.js":((n,e,t)=>{t.r(e),t.d(e,{MobileNetV3FeatureExtractor:()=>r,MobileNetV3ImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}class r extends s{}}),"./src/models/mobilenet_v4/image_processing_mobilenet_v4.js":((n,e,t)=>{t.r(e),t.d(e,{MobileNetV4FeatureExtractor:()=>r,MobileNetV4ImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}class r extends s{}}),"./src/models/mobilevit/image_processing_mobilevit.js":((n,e,t)=>{t.r(e),t.d(e,{MobileViTFeatureExtractor:()=>r,MobileViTImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}class r extends s{}}),"./src/models/moonshine/feature_extraction_moonshine.js":((n,e,t)=>{t.r(e),t.d(e,{MoonshineFeatureExtractor:()=>r});var i=t("./src/base/feature_extraction_utils.js"),s=t("./src/utils/tensor.js");class r extends i.FeatureExtractor{async _call(l){(0,i.validate_audio_inputs)(l,"MoonshineFeatureExtractor"),l instanceof Float64Array&&(l=new Float32Array(l));const c=[1,l.length];return{input_values:new s.Tensor("float32",l,c)}}}}),"./src/models/moonshine/processing_moonshine.js":((n,e,t)=>{t.r(e),t.d(e,{MoonshineProcessor:()=>o});var i=t("./src/models/auto/feature_extraction_auto.js"),s=t("./src/tokenizers.js"),r=t("./src/base/processing_utils.js");class o extends r.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=i.AutoFeatureExtractor;async _call(c){return await this.feature_extractor(c)}}}),"./src/models/nougat/image_processing_nougat.js":((n,e,t)=>{t.r(e),t.d(e,{NougatImageProcessor:()=>s});var i=t("./src/models/donut/image_processing_donut.js");class s extends i.DonutImageProcessor{}}),"./src/models/owlv2/image_processing_owlv2.js":((n,e,t)=>{t.r(e),t.d(e,{Owlv2ImageProcessor:()=>s});var i=t("./src/models/owlvit/image_processing_owlvit.js");class s extends i.OwlViTImageProcessor{}}),"./src/models/owlvit/image_processing_owlvit.js":((n,e,t)=>{t.r(e),t.d(e,{OwlViTFeatureExtractor:()=>r,OwlViTImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{post_process_object_detection(...l){return(0,i.post_process_object_detection)(...l)}}class r extends s{}}),"./src/models/owlvit/processing_owlvit.js":((n,e,t)=>{t.r(e),t.d(e,{OwlViTProcessor:()=>o});var i=t("./src/base/processing_utils.js"),s=t("./src/models/auto/image_processing_auto.js"),r=t("./src/tokenizers.js");class o extends i.Processor{static tokenizer_class=r.AutoTokenizer;static image_processor_class=s.AutoImageProcessor}}),"./src/models/paligemma/processing_paligemma.js":((n,e,t)=>{t.r(e),t.d(e,{PaliGemmaProcessor:()=>c});var i=t("./src/base/processing_utils.js"),s=t("./src/models/auto/image_processing_auto.js"),r=t("./src/tokenizers.js");const o="<image>";function l(d,g,p,h,v){return`${h.repeat(p*v)}${g}${d}
`}class c extends i.Processor{static tokenizer_class=r.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;static uses_processor_config=!1;async _call(g,p=null,h={}){p||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),p=""),Array.isArray(g)||(g=[g]),Array.isArray(p)||(p=[p]);const v=this.tokenizer.bos_token,y=this.image_processor.config.image_seq_length;let w;p.some(T=>T.includes(o))?w=p.map(T=>{const C=T.replaceAll(o,o.repeat(y)),x=C.lastIndexOf(o),R=x===-1?0:x+o.length;return C.slice(0,R)+v+C.slice(R)+`
`}):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),w=p.map(T=>l(T,v,y,o,g.length)));const S=this.tokenizer(w,h);return{...await this.image_processor(g,h),...S}}}}),"./src/models/parakeet/feature_extraction_parakeet.js":((n,e,t)=>{t.r(e),t.d(e,{ParakeetFeatureExtractor:()=>l});var i=t("./src/base/feature_extraction_utils.js"),s=t("./src/utils/tensor.js"),r=t("./src/utils/audio.js");const o=1e-5;class l extends i.FeatureExtractor{constructor(d){super(d),this.config.mel_filters??=(0,r.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,this.config.sampling_rate/2,this.config.sampling_rate,"slaney","slaney");const g=(0,r.window_function)(this.config.win_length,"hann",{periodic:!1});this.window=new Float64Array(this.config.n_fft);const p=Math.floor((this.config.n_fft-this.config.win_length)/2);this.window.set(g,p)}async _extract_fbank_features(d){const g=this.config.preemphasis;d=new Float64Array(d);for(let h=d.length-1;h>=1;--h)d[h]-=g*d[h-1];return await(0,r.spectrogram)(d,this.window,this.window.length,this.config.hop_length,{fft_length:this.config.n_fft,power:2,mel_filters:this.config.mel_filters,log_mel:"log",mel_floor:-1/0,pad_mode:"constant",center:!0,transpose:!0,mel_offset:2**-24})}async _call(d){(0,i.validate_audio_inputs)(d,"ParakeetFeatureExtractor");const g=await this._extract_fbank_features(d),p=Math.floor((d.length+Math.floor(this.config.n_fft/2)*2-this.config.n_fft)/this.config.hop_length),h=g.data;h.fill(0,p*g.dims[1]);const[v,y]=g.dims,w=new Float64Array(y),S=new Float64Array(y);for(let C=0;C<p;++C){const x=C*y;for(let R=0;R<y;++R){const P=h[x+R];w[R]+=P,S[R]+=P*P}}const M=p>1?p-1:1;for(let C=0;C<y;++C){const x=w[C]/p,R=(S[C]-p*x*x)/M,D=1/(Math.sqrt(R)+o);for(let z=0;z<p;++z){const U=z*y+C;h[U]=(h[U]-x)*D}}const T=new BigInt64Array(v);return T.fill(1n,0,p),{input_features:g.unsqueeze_(0),attention_mask:new s.Tensor("int64",T,[1,v])}}}}),"./src/models/phi3_v/image_processing_phi3_v.js":((n,e,t)=>{t.r(e),t.d(e,{Phi3VImageProcessor:()=>g});var i=t("./src/base/image_processors_utils.js"),s=t("./src/utils/tensor.js");const r=336,o=[2,3],{ceil:l,floor:c,sqrt:d}=Math;class g extends i.ImageProcessor{constructor(h){super({...h,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=h.num_crops}calc_num_image_tokens_from_image_size(h,v){const{num_img_tokens:y}=this.config;return c((c(v/r)*c(h/r)+1)*y+1+(c(v/r)+1)*d(y))}get_resize_output_image_size(h,v){const y=this._num_crops,[w,S]=h.size;let M=w/S,T=1;for(;T*Math.ceil(T/M)<=y;)T+=1;T-=1;const C=Math.floor(T*336),x=Math.floor(C/M);return[C,x]}pad_image(h,v,y,w={}){const[S,M]=v,T=r*l(S/r),C=r*l(M/r),x=[1,1,1].map((R,P)=>(R-this.image_mean[P])/this.image_std[P]);return super.pad_image(h,v,{width:C,height:T},{center:!0,constant_values:x,...w})}async _call(h,{num_crops:v=null}={}){if(this._num_crops=v??=this.config.num_crops,v<4||d(v)%1!==0)throw new Error("num_crops must be a square number >= 4");Array.isArray(h)||(h=[h]);const y=h.length,w=await Promise.all(h.map(D=>this.preprocess(D))),S=w.map(D=>D.original_size),M=w.map(D=>D.reshaped_input_size),T=[];for(const{pixel_values:D}of w){D.unsqueeze_(0);const[z,U]=D.dims.slice(-2),N=await(0,s.interpolate_4d)(D,{size:[r,r],mode:"bicubic"});if(v>0){const j=[],J=d(v),W=c(U/J),oe=c(z/J);for(let q=0;q<J;++q)for(let le=0;le<J;++le){let se,pe,be,ee;q===J-1?(pe=z-oe,ee=z):(pe=q*oe,ee=(q+1)*oe),le===J-1?(se=U-W,be=U):(se=le*W,be=(le+1)*W);const te=[pe,se],ue=[ee,be],ae=await(0,s.slice)(D,te,ue,o);j.push(ae)}const ne=await(0,s.interpolate_4d)((0,s.cat)(j,0),{size:[r,r],mode:"bicubic"});T.push((0,s.cat)([N,ne],0))}else T.push(N)}const C=(0,s.stack)(T,0),x=M.map(D=>D.map(z=>r*l(z/r))),R=new s.Tensor("int64",x.flat(),[y,2]),P=x.map(([D,z])=>this.calc_num_image_tokens_from_image_size(z,D));return{pixel_values:C,original_sizes:S,reshaped_input_sizes:M,image_sizes:R,num_img_tokens:P}}}}),"./src/models/phi3_v/processing_phi3_v.js":((n,e,t)=>{t.r(e),t.d(e,{Phi3VProcessor:()=>c});var i=t("./src/base/processing_utils.js"),s=t("./src/models/auto/image_processing_auto.js"),r=t("./src/tokenizers.js");t("./src/utils/image.js");const o="<|image|>",l=/<\|image_\d+\|>/g;class c extends i.Processor{static image_processor_class=s.AutoImageProcessor;static tokenizer_class=r.AutoTokenizer;async _call(g,p=null,{padding:h=!0,truncation:v=!0,num_crops:y=null}={}){Array.isArray(g)||(g=[g]);let w,S;if(p){S=await this.image_processor(p,{num_crops:y});const{num_img_tokens:M}=S,T=g.map((x,R)=>x.split(l).join(o.repeat(M[R])));w=this.tokenizer(T,{padding:h,truncation:v});const C=this.tokenizer.model.convert_tokens_to_ids([o])[0];w.input_ids.map_(x=>x==C?-x:x)}else w=this.tokenizer(g);return{...w,...S}}}}),"./src/models/processors.js":((n,e,t)=>{t.r(e),t.d(e,{Florence2Processor:()=>i.Florence2Processor,Gemma3nProcessor:()=>s.Gemma3nProcessor,GroundingDinoProcessor:()=>r.GroundingDinoProcessor,Idefics3Processor:()=>o.Idefics3Processor,JinaCLIPProcessor:()=>c.JinaCLIPProcessor,LlavaProcessor:()=>d.LlavaProcessor,MgpstrProcessor:()=>g.MgpstrProcessor,MoonshineProcessor:()=>p.MoonshineProcessor,OwlViTProcessor:()=>h.OwlViTProcessor,PaliGemmaProcessor:()=>y.PaliGemmaProcessor,Phi3VProcessor:()=>v.Phi3VProcessor,PyAnnoteProcessor:()=>w.PyAnnoteProcessor,Qwen2VLProcessor:()=>S.Qwen2VLProcessor,Sam2Processor:()=>T.Sam2Processor,Sam2VideoProcessor:()=>T.Sam2VideoProcessor,SamProcessor:()=>M.SamProcessor,SmolVLMProcessor:()=>C.SmolVLMProcessor,SpeechT5Processor:()=>x.SpeechT5Processor,UltravoxProcessor:()=>R.UltravoxProcessor,VLChatProcessor:()=>l.VLChatProcessor,VoxtralProcessor:()=>P.VoxtralProcessor,Wav2Vec2Processor:()=>D.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>z.Wav2Vec2ProcessorWithLM,WhisperProcessor:()=>U.WhisperProcessor});var i=t("./src/models/florence2/processing_florence2.js"),s=t("./src/models/gemma3n/processing_gemma3n.js"),r=t("./src/models/grounding_dino/processing_grounding_dino.js"),o=t("./src/models/idefics3/processing_idefics3.js"),l=t("./src/models/janus/processing_janus.js"),c=t("./src/models/jina_clip/processing_jina_clip.js"),d=t("./src/models/llava/processing_llava.js"),g=t("./src/models/mgp_str/processing_mgp_str.js"),p=t("./src/models/moonshine/processing_moonshine.js"),h=t("./src/models/owlvit/processing_owlvit.js"),v=t("./src/models/phi3_v/processing_phi3_v.js"),y=t("./src/models/paligemma/processing_paligemma.js"),w=t("./src/models/pyannote/processing_pyannote.js"),S=t("./src/models/qwen2_vl/processing_qwen2_vl.js"),M=t("./src/models/sam/processing_sam.js"),T=t("./src/models/sam2/processing_sam2.js"),C=t("./src/models/smolvlm/processing_smolvlm.js"),x=t("./src/models/speecht5/processing_speecht5.js"),R=t("./src/models/ultravox/processing_ultravox.js"),P=t("./src/models/voxtral/processing_voxtral.js"),D=t("./src/models/wav2vec2/processing_wav2vec2.js"),z=t("./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js"),U=t("./src/models/whisper/processing_whisper.js")}),"./src/models/pvt/image_processing_pvt.js":((n,e,t)=>{t.r(e),t.d(e,{PvtImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}}),"./src/models/pyannote/feature_extraction_pyannote.js":((n,e,t)=>{t.r(e),t.d(e,{PyAnnoteFeatureExtractor:()=>o});var i=t("./src/base/feature_extraction_utils.js"),s=t("./src/utils/tensor.js"),r=t("./src/utils/maths.js");class o extends i.FeatureExtractor{async _call(c){(0,i.validate_audio_inputs)(c,"PyAnnoteFeatureExtractor"),c instanceof Float64Array&&(c=new Float32Array(c));const d=[1,1,c.length];return{input_values:new s.Tensor("float32",c,d)}}samples_to_frames(c){return(c-this.config.offset)/this.config.step}post_process_speaker_diarization(c,d){const g=d/this.samples_to_frames(d)/this.config.sampling_rate,p=[];for(const h of c.tolist()){const v=[];let y=-1;for(let w=0;w<h.length;++w){const S=(0,r.softmax)(h[w]),[M,T]=(0,r.max)(S),[C,x]=[w,w+1];T!==y?(y=T,v.push({id:T,start:C,end:x,score:M})):(v.at(-1).end=x,v.at(-1).score+=M)}p.push(v.map(({id:w,start:S,end:M,score:T})=>({id:w,start:S*g,end:M*g,confidence:T/(M-S)})))}return p}}}),"./src/models/pyannote/processing_pyannote.js":((n,e,t)=>{t.r(e),t.d(e,{PyAnnoteProcessor:()=>r});var i=t("./src/base/processing_utils.js"),s=t("./src/models/pyannote/feature_extraction_pyannote.js");class r extends i.Processor{static feature_extractor_class=s.PyAnnoteFeatureExtractor;async _call(l){return await this.feature_extractor(l)}post_process_speaker_diarization(...l){return this.feature_extractor.post_process_speaker_diarization(...l)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}}),"./src/models/qwen2_vl/image_processing_qwen2_vl.js":((n,e,t)=>{t.r(e),t.d(e,{Qwen2VLImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js"),s=t("./src/utils/tensor.js");class r extends i.ImageProcessor{async _call(l,...c){const{pixel_values:d,original_sizes:g,reshaped_input_sizes:p}=await super._call(l,...c);let h=d;const{temporal_patch_size:v,merge_size:y,patch_size:w}=this.config;h.dims[0]===1&&(h=(0,s.cat)(Array.from({length:v},()=>h),0));const S=h.dims[0]/v,M=h.dims[1],T=Math.floor(h.dims[2]/w),C=Math.floor(h.dims[3]/w),x=h.view(S,v,M,Math.floor(T/y),y,w,Math.floor(C/y),y,w).permute(0,3,6,4,7,2,1,5,8).view(S*T*C,M*v*w*w),R=new s.Tensor("int64",[S,T,C],[1,3]);return{pixel_values:x,image_grid_thw:R,original_sizes:g,reshaped_input_sizes:p}}}}),"./src/models/qwen2_vl/processing_qwen2_vl.js":((n,e,t)=>{t.r(e),t.d(e,{Qwen2VLProcessor:()=>o});var i=t("./src/base/processing_utils.js"),s=t("./src/models/auto/image_processing_auto.js"),r=t("./src/tokenizers.js");t("./src/utils/image.js");class o extends i.Processor{static image_processor_class=s.AutoImageProcessor;static tokenizer_class=r.AutoTokenizer;async _call(c,d=null,...g){Array.isArray(c)||(c=[c]);let p,h;if(d&&(p=await this.image_processor(d),h=p.image_grid_thw),h){let y=this.image_processor.config.merge_size**2,w=0;const S=h.tolist();c=c.map(M=>{for(;M.includes("<|image_pad|>");){const T=Number(S[w++].reduce((C,x)=>C*x,1n));M=M.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(T/y)))}return M.replaceAll("<|placeholder|>","<|image_pad|>")})}return{...this.tokenizer(c),...p}}}}),"./src/models/rt_detr/image_processing_rt_detr.js":((n,e,t)=>{t.r(e),t.d(e,{RTDetrImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{post_process_object_detection(...o){return(0,i.post_process_object_detection)(...o)}}}),"./src/models/sam/image_processing_sam.js":((n,e,t)=>{t.r(e),t.d(e,{SamImageProcessor:()=>o});var i=t("./src/base/image_processors_utils.js"),s=t("./src/utils/core.js"),r=t("./src/utils/tensor.js");class o extends i.ImageProcessor{reshape_input_points(c,d,g,p=!1){c=structuredClone(c);let h=(0,s.calculateDimensions)(c);if(h.length===3)p||(h=[1,...h]),c=[c];else if(h.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let v=0;v<c.length;++v){const[y,w]=d[v],[S,M]=g[v],T=[M/w,S/y];for(let C=0;C<c[v].length;++C)for(let x=0;x<c[v][C].length;++x)for(let R=0;R<c[v][C][x].length;++R)c[v][C][x][R]*=T[R%2]}return new r.Tensor("float32",Float32Array.from(c.flat(1/0)),h)}add_input_labels(c,d){let g=(0,s.calculateDimensions)(c);if(g.length===2)g=[1,...g],c=[c];else if(g.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(g.some((p,h)=>p!==d.dims[h]))throw Error(`The first ${g.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new r.Tensor("int64",c.flat(1/0).map(BigInt),g)}async _call(c,{input_points:d=null,input_labels:g=null,input_boxes:p=null}={}){const h=await super._call(c);if(d&&(h.input_points=this.reshape_input_points(d,h.original_sizes,h.reshaped_input_sizes)),g){if(!h.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");h.input_labels=this.add_input_labels(g,h.input_points)}return p&&(h.input_boxes=this.reshape_input_points(p,h.original_sizes,h.reshaped_input_sizes,!0)),h}async post_process_masks(c,d,g,{mask_threshold:p=0,binarize:h=!0,pad_size:v=null}={}){const y=[];v=v??this.pad_size??this.size;const w=[v.height,v.width];for(let S=0;S<d.length;++S){const M=d[S],T=g[S];let C=await(0,r.interpolate_4d)(c[S],{mode:"bilinear",size:w});if(C=C.slice(null,null,[0,T[0]],[0,T[1]]),C=await(0,r.interpolate_4d)(C,{mode:"bilinear",size:M}),h){const x=C.data,R=new Uint8Array(x.length);for(let P=0;P<x.length;++P)x[P]>p&&(R[P]=1);C=new r.Tensor("bool",R,C.dims)}y.push(C)}return y}generate_crop_boxes(c,d,{crop_n_layers:g=0,overlap_ratio:p=512/1500,points_per_crop:h=32,crop_n_points_downscale_factor:v=1}={}){}}}),"./src/models/sam/processing_sam.js":((n,e,t)=>{t.r(e),t.d(e,{SamProcessor:()=>r});var i=t("./src/base/processing_utils.js"),s=t("./src/models/auto/image_processing_auto.js");class r extends i.Processor{static image_processor_class=s.AutoImageProcessor;async _call(...l){return await this.image_processor(...l)}post_process_masks(...l){return this.image_processor.post_process_masks(...l)}reshape_input_points(...l){return this.image_processor.reshape_input_points(...l)}}}),"./src/models/sam2/image_processing_sam2.js":((n,e,t)=>{t.r(e),t.d(e,{Sam2ImageProcessor:()=>i.SamImageProcessor});var i=t("./src/models/sam/image_processing_sam.js")}),"./src/models/sam2/processing_sam2.js":((n,e,t)=>{t.r(e),t.d(e,{Sam2Processor:()=>s,Sam2VideoProcessor:()=>r});var i=t("./src/models/sam/processing_sam.js");class s extends i.SamProcessor{}class r extends s{}}),"./src/models/sam3/image_processing_sam3.js":((n,e,t)=>{t.r(e),t.d(e,{Sam3ImageProcessor:()=>i.Sam2ImageProcessor});var i=t("./src/models/sam2/image_processing_sam2.js")}),"./src/models/seamless_m4t/feature_extraction_seamless_m4t.js":((n,e,t)=>{t.r(e),t.d(e,{SeamlessM4TFeatureExtractor:()=>o});var i=t("./src/base/feature_extraction_utils.js"),s=t("./src/utils/tensor.js"),r=t("./src/utils/audio.js");class o extends i.FeatureExtractor{constructor(c){super(c);const d=this.config.sampling_rate,g=(0,r.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(d/2),d,null,"kaldi",!0);this.mel_filters=g,this.window=(0,r.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(c,d){return c=c.map(g=>g*32768),(0,r.spectrogram)(c,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:d,transpose:!0})}async _call(c,{padding:d=!0,pad_to_multiple_of:g=2,do_normalize_per_mel_bins:p=!0,return_attention_mask:h=!0}={}){(0,i.validate_audio_inputs)(c,"SeamlessM4TFeatureExtractor");let v=await this._extract_fbank_features(c,this.config.max_length);if(p){const[R,P]=v.dims,D=v.data;for(let z=0;z<P;++z){let U=0;for(let W=0;W<R;++W)U+=D[W*P+z];const N=U/R;let j=0;for(let W=0;W<R;++W)j+=(D[W*P+z]-N)**2;j/=R-1;const J=Math.sqrt(j+1e-7);for(let W=0;W<R;++W){const oe=W*P+z;D[oe]=(D[oe]-N)/J}}}let y;if(d){const[R,P]=v.dims,D=v.data,z=R%g;if(z>0){const U=new Float32Array(P*(R+z));U.set(D),U.fill(this.config.padding_value,D.length);const N=R+z;v=new s.Tensor(v.type,U,[N,P]),h&&(y=new s.Tensor("int64",new BigInt64Array(N),[1,N]),y.data.fill(1n,0,R))}}const[w,S]=v.dims,M=this.config.stride;if(w%M!==0)throw new Error(`The number of frames (${w}) must be a multiple of the stride (${M}).`);const C=v.view(1,Math.floor(w/M),S*M),x={input_features:C};if(h){const R=C.dims[1],P=new BigInt64Array(R);if(y){const D=y.data;for(let z=1,U=0;z<w;z+=M,++U)P[U]=D[z]}else P.fill(1n);x.attention_mask=new s.Tensor("int64",P,[1,R])}return x}}}),"./src/models/segformer/image_processing_segformer.js":((n,e,t)=>{t.r(e),t.d(e,{SegformerFeatureExtractor:()=>r,SegformerImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{post_process_semantic_segmentation(...l){return(0,i.post_process_semantic_segmentation)(...l)}}class r extends s{}}),"./src/models/siglip/image_processing_siglip.js":((n,e,t)=>{t.r(e),t.d(e,{SiglipImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}}),"./src/models/smolvlm/image_processing_smolvlm.js":((n,e,t)=>{t.r(e),t.d(e,{SmolVLMImageProcessor:()=>i.Idefics3ImageProcessor});var i=t("./src/models/idefics3/image_processing_idefics3.js")}),"./src/models/smolvlm/processing_smolvlm.js":((n,e,t)=>{t.r(e),t.d(e,{SmolVLMProcessor:()=>i.Idefics3Processor});var i=t("./src/models/idefics3/processing_idefics3.js")}),"./src/models/snac/feature_extraction_snac.js":((n,e,t)=>{t.r(e),t.d(e,{SnacFeatureExtractor:()=>s});var i=t("./src/models/dac/feature_extraction_dac.js");class s extends i.DacFeatureExtractor{}}),"./src/models/speecht5/feature_extraction_speecht5.js":((n,e,t)=>{t.r(e),t.d(e,{SpeechT5FeatureExtractor:()=>s});var i=t("./src/base/feature_extraction_utils.js");class s extends i.FeatureExtractor{}}),"./src/models/speecht5/processing_speecht5.js":((n,e,t)=>{t.r(e),t.d(e,{SpeechT5Processor:()=>o});var i=t("./src/base/processing_utils.js"),s=t("./src/tokenizers.js"),r=t("./src/models/auto/feature_extraction_auto.js");class o extends i.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=r.AutoFeatureExtractor;async _call(c){return await this.feature_extractor(c)}}}),"./src/models/swin2sr/image_processing_swin2sr.js":((n,e,t)=>{t.r(e),t.d(e,{Swin2SRImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{pad_image(o,l,c,d={}){const[g,p,h]=l;return super.pad_image(o,l,{width:p+(c-p%c)%c,height:g+(c-g%c)%c},{mode:"symmetric",center:!1,constant_values:-1,...d})}}}),"./src/models/ultravox/processing_ultravox.js":((n,e,t)=>{t.r(e),t.d(e,{UltravoxProcessor:()=>o});var i=t("./src/models/auto/feature_extraction_auto.js"),s=t("./src/tokenizers.js"),r=t("./src/base/processing_utils.js");class o extends r.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=i.AutoFeatureExtractor;static uses_processor_config=!0;async _call(c,d=null,g={}){if(Array.isArray(c))throw new Error("Batched inputs are not supported yet.");let p={};if(d){const v=d.length,{input_features:y}=await this.feature_extractor(d,{...g,max_length:v}),w=Math.round(v/this.config.encoder_ds_factor+1e-4),S=1+Math.ceil(w/this.config.stack_factor);p.audio_token_len=[S],p.audio_values=y;const M=this.config.audio_placeholder;if(!c.includes(M))throw new Error(`The input text does not contain the image token ${M}.`);c=c.replaceAll(M,M.repeat(S))}return{...this.tokenizer(c,{add_special_tokens:!1,...g}),...p}}}}),"./src/models/vit/image_processing_vit.js":((n,e,t)=>{t.r(e),t.d(e,{ViTFeatureExtractor:()=>r,ViTImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{}class r extends s{}}),"./src/models/vitmatte/image_processing_vitmatte.js":((n,e,t)=>{t.r(e),t.d(e,{VitMatteImageProcessor:()=>r});var i=t("./src/base/image_processors_utils.js"),s=t("./src/utils/tensor.js");class r extends i.ImageProcessor{async _call(l,c){Array.isArray(l)||(l=[l]),Array.isArray(c)||(c=[c]);const d=await Promise.all(l.map(h=>this.preprocess(h))),g=await Promise.all(c.map(h=>this.preprocess(h,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,s.stack)(d.map((h,v)=>(0,s.cat)([h.pixel_values,g[v].pixel_values],0)),0),original_sizes:d.map(h=>h.original_size),reshaped_input_sizes:d.map(h=>h.reshaped_input_size)}}}}),"./src/models/vitpose/image_processing_vitpose.js":((n,e,t)=>{t.r(e),t.d(e,{VitPoseImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{post_process_pose_estimation(o,l,{threshold:c=null}={}){const d=o.tolist(),[g,p,h,v]=o.dims,y=[];for(let w=0;w<g;++w){const S=d[w],M=l[w],T=[];for(let C=0;C<M.length;++C){const x=M[C],R=[],P=[],D=[],z=x.at(-2)/v,U=x.at(-1)/h;for(let N=0;N<S.length;++N){let[j,J]=[0,0],W=0,oe=-1/0;const ne=S[N];for(let le=0;le<ne.length;++le){const se=ne[le];for(let pe=0;pe<se.length;++pe){const be=se[pe];W+=be,oe=Math.max(oe,be),j+=(pe+.5)*be,J+=le*be}}if(c!=null&&oe<c)continue;const q=[z*j/W,U*J/W];R.push(q),D.push(N),P.push(oe)}T.push({bbox:x,scores:P,labels:D,keypoints:R})}y.push(T)}return y}}}),"./src/models/voxtral/processing_voxtral.js":((n,e,t)=>{t.r(e),t.d(e,{VoxtralProcessor:()=>p});var i=t("./src/models/auto/feature_extraction_auto.js"),s=t("./src/tokenizers.js"),r=t("./src/base/processing_utils.js"),o=t("./src/utils/tensor.js");const l="[AUDIO]",c="[BEGIN_AUDIO]",d=375;function g(h,v){const y=[];for(let w=0;w<h.length;w+=v)y.push(h.subarray(w,Math.min(w+v,h.length)));return y}class p extends r.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=i.AutoFeatureExtractor;static uses_processor_config=!1;async _call(v,y=null,w={}){if(Array.isArray(v))throw new Error("Batched inputs are not supported yet.");const S={};if(y){if(!v.includes(l))throw new Error(`The input text does not contain the audio token ${l}.`);Array.isArray(y)||(y=[y]);const T=v.split(l),C=T.length-1;if(C!==y.length)throw new Error(`The number of audio inputs (${y.length}) does not match the number of audio tokens in the text (${C}).`);const x=this.feature_extractor.config.n_samples,R=y.map(N=>g(N,x)),P=R.map(N=>N.length),D=R.flat(),z=(await Promise.all(D.map(N=>this.feature_extractor(N,w)))).map(N=>N.input_features);S.audio_values=z.length>1?(0,o.cat)(z,0):z[0];let U=T[0];for(let N=0;N<P.length;++N){U+=c;for(let j=0;j<P[N];++j)U+=l.repeat(d);U+=T[N+1]}v=U}return{...this.tokenizer(v,{add_special_tokens:!1,...w}),...S}}}}),"./src/models/wav2vec2/feature_extraction_wav2vec2.js":((n,e,t)=>{t.r(e),t.d(e,{Wav2Vec2FeatureExtractor:()=>r});var i=t("./src/base/feature_extraction_utils.js"),s=t("./src/utils/tensor.js");class r extends i.FeatureExtractor{_zero_mean_unit_var_norm(l){const d=l.reduce((p,h)=>p+h,0)/l.length,g=l.reduce((p,h)=>p+(h-d)**2,0)/l.length;return l.map(p=>(p-d)/Math.sqrt(g+1e-7))}async _call(l){(0,i.validate_audio_inputs)(l,"Wav2Vec2FeatureExtractor"),l instanceof Float64Array&&(l=new Float32Array(l));let c=l;this.config.do_normalize&&(c=this._zero_mean_unit_var_norm(c));const d=[1,c.length];return{input_values:new s.Tensor("float32",c,d),attention_mask:new s.Tensor("int64",new BigInt64Array(c.length).fill(1n),d)}}}}),"./src/models/wav2vec2/processing_wav2vec2.js":((n,e,t)=>{t.r(e),t.d(e,{Wav2Vec2Processor:()=>o});var i=t("./src/tokenizers.js"),s=t("./src/models/auto/feature_extraction_auto.js"),r=t("./src/base/processing_utils.js");class o extends r.Processor{static tokenizer_class=i.AutoTokenizer;static feature_extractor_class=s.AutoFeatureExtractor;async _call(c){return await this.feature_extractor(c)}}}),"./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js":((n,e,t)=>{t.r(e),t.d(e,{Wav2Vec2ProcessorWithLM:()=>o});var i=t("./src/tokenizers.js"),s=t("./src/models/auto/feature_extraction_auto.js"),r=t("./src/base/processing_utils.js");class o extends r.Processor{static tokenizer_class=i.AutoTokenizer;static feature_extractor_class=s.AutoFeatureExtractor;async _call(c){return await this.feature_extractor(c)}}}),"./src/models/wespeaker/feature_extraction_wespeaker.js":((n,e,t)=>{t.r(e),t.d(e,{WeSpeakerFeatureExtractor:()=>r});var i=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var s=t("./src/utils/audio.js");class r extends i.FeatureExtractor{constructor(l){super(l);const c=this.config.sampling_rate,d=(0,s.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(c/2),c,null,"kaldi",!0);this.mel_filters=d,this.window=(0,s.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(l){return l=l.map(c=>c*32768),(0,s.spectrogram)(l,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(l){(0,i.validate_audio_inputs)(l,"WeSpeakerFeatureExtractor");const c=(await this._extract_fbank_features(l)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const d=c.mean(1).data,g=c.data,[p,h,v]=c.dims;for(let y=0;y<p;++y){const w=y*h*v,S=y*v;for(let M=0;M<h;++M){const T=w+M*v;for(let C=0;C<v;++C)g[T+C]-=d[S+C]}}}return{input_features:c}}}}),"./src/models/whisper/common_whisper.js":((n,e,t)=>{t.r(e),t.d(e,{WHISPER_LANGUAGE_MAPPING:()=>s,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>r,whisper_language_to_code:()=>o});const i=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],s=new Map(i),r=new Map([...i.map(([l,c])=>[c,l]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function o(l){l=l.toLowerCase();let c=r.get(l);if(c===void 0){const d=l.match(/^<\|([a-z]{2})\|>$/);if(d&&(l=d[1]),s.has(l))c=l;else{const p=l.length===2?s.keys():s.values();throw new Error(`Language "${l}" is not supported. Must be one of: ${JSON.stringify(Array.from(p))}`)}}return c}}),"./src/models/whisper/feature_extraction_whisper.js":((n,e,t)=>{t.r(e),t.d(e,{WhisperFeatureExtractor:()=>o});var i=t("./src/base/feature_extraction_utils.js");t("./src/utils/tensor.js");var s=t("./src/utils/audio.js"),r=t("./src/utils/maths.js");class o extends i.FeatureExtractor{constructor(c){super(c),this.config.mel_filters??=(0,s.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=(0,s.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(c){const d=await(0,s.spectrogram)(c,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:Math.min(Math.floor(c.length/this.config.hop_length),this.config.nb_max_frames)}),g=d.data,p=(0,r.max)(g)[0];for(let h=0;h<g.length;++h)g[h]=(Math.max(g[h],p-8)+4)/4;return d}async _call(c,{max_length:d=null}={}){(0,i.validate_audio_inputs)(c,"WhisperFeatureExtractor");let g;const p=d??this.config.n_samples;return c.length>p?(c.length>this.config.n_samples&&console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),g=c.slice(0,p)):(g=new Float32Array(p),g.set(c)),{input_features:(await this._extract_fbank_features(g)).unsqueeze_(0)}}}}),"./src/models/whisper/generation_whisper.js":((n,e,t)=>{t.r(e),t.d(e,{WhisperGenerationConfig:()=>s});var i=t("./src/generation/configuration_utils.js");class s extends i.GenerationConfig{return_timestamps=null;return_token_timestamps=null;num_frames=null;alignment_heads=null;task=null;language=null;no_timestamps_token_id=null;prompt_ids=null;is_multilingual=null;lang_to_id=null;task_to_id=null;max_initial_timestamp_index=1}}),"./src/models/whisper/processing_whisper.js":((n,e,t)=>{t.r(e),t.d(e,{WhisperProcessor:()=>o});var i=t("./src/models/auto/feature_extraction_auto.js"),s=t("./src/tokenizers.js"),r=t("./src/base/processing_utils.js");class o extends r.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=i.AutoFeatureExtractor;async _call(c){return await this.feature_extractor(c)}}}),"./src/models/yolos/image_processing_yolos.js":((n,e,t)=>{t.r(e),t.d(e,{YolosFeatureExtractor:()=>r,YolosImageProcessor:()=>s});var i=t("./src/base/image_processors_utils.js");class s extends i.ImageProcessor{post_process_object_detection(...l){return(0,i.post_process_object_detection)(...l)}}class r extends s{}}),"./src/ops/registry.js":((n,e,t)=>{t.r(e),t.d(e,{TensorOpRegistry:()=>o});var i=t("./src/backends/onnx.js"),s=t("./src/utils/tensor.js");const r=async(l,c,d)=>{const g=await(0,i.createInferenceSession)(new Uint8Array(l),c);return(async p=>{const h=(0,i.isONNXProxy)(),v=Object.fromEntries(Object.entries(p).map(([w,S])=>[w,(h?S.clone():S).ort_tensor])),y=await(0,i.runInferenceSession)(g,v);return Array.isArray(d)?d.map(w=>new s.Tensor(y[w])):new s.Tensor(y[d])})};class o{static session_options={};static get nearest_interpolate_4d(){return this._nearest_interpolate_4d||(this._nearest_interpolate_4d=r([8,10,18,0,58,129,1,10,41,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,18,10,4,109,111,100,101,34,7,110,101,97,114,101,115,116,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,21],this.session_options,"y")),this._nearest_interpolate_4d}static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=r([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=r([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=r([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=r([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=r([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=r([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=r([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}}),"./src/pipelines.js":((n,e,t)=>{t.r(e),t.d(e,{AudioClassificationPipeline:()=>J,AutomaticSpeechRecognitionPipeline:()=>oe,BackgroundRemovalPipeline:()=>se,DepthEstimationPipeline:()=>ce,DocumentQuestionAnsweringPipeline:()=>te,FeatureExtractionPipeline:()=>N,FillMaskPipeline:()=>C,ImageClassificationPipeline:()=>q,ImageFeatureExtractionPipeline:()=>j,ImageSegmentationPipeline:()=>le,ImageToImagePipeline:()=>ae,ImageToTextPipeline:()=>ne,ObjectDetectionPipeline:()=>be,Pipeline:()=>w,QuestionAnsweringPipeline:()=>T,SummarizationPipeline:()=>R,Text2TextGenerationPipeline:()=>x,TextClassificationPipeline:()=>S,TextGenerationPipeline:()=>z,TextToAudioPipeline:()=>ue,TokenClassificationPipeline:()=>M,TranslationPipeline:()=>P,ZeroShotAudioClassificationPipeline:()=>W,ZeroShotClassificationPipeline:()=>U,ZeroShotImageClassificationPipeline:()=>pe,ZeroShotObjectDetectionPipeline:()=>ee,pipeline:()=>Xe});var i=t("./src/tokenizers.js"),s=t("./src/models.js"),r=t("./src/models/auto/processing_auto.js");t("./src/base/processing_utils.js");var o=t("./src/utils/generic.js"),l=t("./src/utils/core.js"),c=t("./src/utils/maths.js"),d=t("./src/utils/audio.js"),g=t("./src/utils/tensor.js"),p=t("./src/utils/image.js");async function h(tt){return Array.isArray(tt)||(tt=[tt]),await Promise.all(tt.map(Ae=>p.RawImage.read(Ae)))}async function v(tt,Ae){return Array.isArray(tt)||(tt=[tt]),await Promise.all(tt.map(ye=>typeof ye=="string"||ye instanceof URL?(0,d.read_audio)(ye,Ae):ye instanceof Float64Array?new Float32Array(ye):ye))}function y(tt,Ae){Ae&&(tt=tt.map(je=>je|0));const[ye,xe,ke,ze]=tt;return{xmin:ye,ymin:xe,xmax:ke,ymax:ze}}class w extends o.Callable{constructor({task:Ae,model:ye,tokenizer:xe=null,processor:ke=null}){super(),this.task=Ae,this.model=ye,this.tokenizer=xe,this.processor=ke}async dispose(){await this.model.dispose()}}class S extends w{constructor(Ae){super(Ae)}async _call(Ae,{top_k:ye=1}={}){const xe=this.tokenizer(Ae,{padding:!0,truncation:!0}),ke=await this.model(xe),ze=this.model.config.problem_type==="multi_label_classification"?Ye=>Ye.sigmoid():Ye=>new g.Tensor("float32",(0,c.softmax)(Ye.data),Ye.dims),je=this.model.config.id2label,Fe=[];for(const Ye of ke.logits){const Ve=ze(Ye),Qe=await(0,g.topk)(Ve,ye),mt=Qe[0].tolist(),Me=Qe[1].tolist().map((me,$e)=>({label:je?je[me]:`LABEL_${me}`,score:mt[$e]}));ye===1?Fe.push(...Me):Fe.push(Me)}return Array.isArray(Ae)||ye===1?Fe:Fe[0]}}class M extends w{constructor(Ae){super(Ae)}async _call(Ae,{ignore_labels:ye=["O"]}={}){const xe=Array.isArray(Ae),ke=this.tokenizer(xe?Ae:[Ae],{padding:!0,truncation:!0}),je=(await this.model(ke)).logits,Fe=this.model.config.id2label,Ye=[];for(let Ve=0;Ve<je.dims[0];++Ve){const Qe=ke.input_ids[Ve],mt=je[Ve],Tt=[];for(let Me=0;Me<mt.dims[0];++Me){const me=mt[Me],$e=(0,c.max)(me.data)[1],et=Fe?Fe[$e]:`LABEL_${$e}`;if(ye.includes(et))continue;const ht=this.tokenizer.decode([Qe[Me].item()],{skip_special_tokens:!0});if(ht==="")continue;const at=(0,c.softmax)(me.data);Tt.push({entity:et,score:at[$e],index:Me,word:ht})}Ye.push(Tt)}return xe?Ye:Ye[0]}}class T extends w{constructor(Ae){super(Ae)}async _call(Ae,ye,{top_k:xe=1}={}){const ke=this.tokenizer(Ae,{text_pair:ye,padding:!0,truncation:!0}),{start_logits:ze,end_logits:je}=await this.model(ke),Fe=ke.input_ids.tolist(),Ye=ke.attention_mask.tolist(),Ve=this.tokenizer.all_special_ids,Qe=[];for(let mt=0;mt<ze.dims[0];++mt){const Tt=Fe[mt],Me=Tt.findIndex(Et=>Et==this.tokenizer.sep_token_id);Ye[mt].map((Et,Dt)=>Et==1&&(Dt===0||Dt>Me&&Ve.findIndex(Vt=>Vt==Tt[Dt])===-1));const me=ze[mt].tolist(),$e=je[mt].tolist();for(let Et=1;Et<me.length;++Et)(Ye[mt]==0||Et<=Me||Ve.findIndex(Dt=>Dt==Tt[Et])!==-1)&&(me[Et]=-1/0,$e[Et]=-1/0);const et=(0,c.softmax)(me).map((Et,Dt)=>[Et,Dt]),ht=(0,c.softmax)($e).map((Et,Dt)=>[Et,Dt]);et[0][0]=0,ht[0][0]=0;const at=(0,l.product)(et,ht).filter(Et=>Et[0][1]<=Et[1][1]).map(Et=>[Et[0][1],Et[1][1],Et[0][0]*Et[1][0]]).sort((Et,Dt)=>Dt[2]-Et[2]);for(let Et=0;Et<Math.min(at.length,xe);++Et){const[Dt,Vt,an]=at[Et],bt=Tt.slice(Dt,Vt+1),Jt=this.tokenizer.decode(bt,{skip_special_tokens:!0});Qe.push({answer:Jt,score:an})}}return xe===1?Qe[0]:Qe}}class C extends w{constructor(Ae){super(Ae)}async _call(Ae,{top_k:ye=5}={}){const xe=this.tokenizer(Ae,{padding:!0,truncation:!0}),{logits:ke}=await this.model(xe),ze=[],je=xe.input_ids.tolist();for(let Fe=0;Fe<je.length;++Fe){const Ye=je[Fe],Ve=Ye.findIndex(me=>me==this.tokenizer.mask_token_id);if(Ve===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const Qe=ke[Fe][Ve],mt=await(0,g.topk)(new g.Tensor("float32",(0,c.softmax)(Qe.data),Qe.dims),ye),Tt=mt[0].tolist(),Me=mt[1].tolist();ze.push(Me.map((me,$e)=>{const et=Ye.slice();return et[Ve]=me,{score:Tt[$e],token:Number(me),token_str:this.tokenizer.decode([me]),sequence:this.tokenizer.decode(et,{skip_special_tokens:!0})}}))}return Array.isArray(Ae)?ze:ze[0]}}class x extends w{_key="generated_text";constructor(Ae){super(Ae)}async _call(Ae,ye={}){Array.isArray(Ae)||(Ae=[Ae]),this.model.config.prefix&&(Ae=Ae.map(Ye=>this.model.config.prefix+Ye));const xe=this.model.config.task_specific_params;xe&&xe[this.task]&&xe[this.task].prefix&&(Ae=Ae.map(Ye=>xe[this.task].prefix+Ye));const ke=this.tokenizer,ze={padding:!0,truncation:!0};let je;this instanceof P&&"_build_translation_inputs"in ke?je=ke._build_translation_inputs(Ae,ze,ye):je=ke(Ae,ze);const Fe=await this.model.generate({...je,...ye});return ke.batch_decode(Fe,{skip_special_tokens:!0}).map(Ye=>({[this._key]:Ye}))}}class R extends x{_key="summary_text";constructor(Ae){super(Ae)}}class P extends x{_key="translation_text";constructor(Ae){super(Ae)}}function D(tt){return Array.isArray(tt)&&tt.every(Ae=>"role"in Ae&&"content"in Ae)}class z extends w{constructor(Ae){super(Ae)}async _call(Ae,ye={}){let xe=!1,ke=!1,ze=ye.add_special_tokens??(this.tokenizer.add_bos_token||this.tokenizer.add_eos_token)??!1,je;if(typeof Ae=="string")je=Ae=[Ae];else if(Array.isArray(Ae)&&Ae.every(Me=>typeof Me=="string"))xe=!0,je=Ae;else{if(D(Ae))Ae=[Ae];else if(Array.isArray(Ae)&&Ae.every(D))xe=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");ke=!0,je=Ae.map(Me=>this.tokenizer.apply_chat_template(Me,{tokenize:!1,add_generation_prompt:!0})),ze=!1}const Fe=ke?!1:ye.return_full_text??!0;this.tokenizer.padding_side="left";const Ye=this.tokenizer(je,{add_special_tokens:ze,padding:!0,truncation:!0}),Ve=await this.model.generate({...Ye,...ye}),Qe=this.tokenizer.batch_decode(Ve,{skip_special_tokens:!0});let mt;!Fe&&Ye.input_ids.dims.at(-1)>0&&(mt=this.tokenizer.batch_decode(Ye.input_ids,{skip_special_tokens:!0}).map(Me=>Me.length));const Tt=Array.from({length:Ae.length},Me=>[]);for(let Me=0;Me<Qe.length;++Me){const me=Math.floor(Me/Ve.dims[0]*Ae.length);mt&&(Qe[Me]=Qe[Me].slice(mt[me])),Tt[me].push({generated_text:ke?[...Ae[me],{role:"assistant",content:Qe[Me]}]:Qe[Me]})}return!xe&&Tt.length===1?Tt[0]:Tt}}class U extends w{constructor(Ae){super(Ae),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([ye,xe])=>[ye.toLowerCase(),xe])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(Ae,ye,{hypothesis_template:xe="This example is {}.",multi_label:ke=!1}={}){const ze=Array.isArray(Ae);ze||(Ae=[Ae]),Array.isArray(ye)||(ye=[ye]);const je=ye.map(Ve=>xe.replace("{}",Ve)),Fe=ke||ye.length===1,Ye=[];for(const Ve of Ae){const Qe=[];for(const Me of je){const me=this.tokenizer(Ve,{text_pair:Me,padding:!0,truncation:!0}),$e=await this.model(me);Fe?Qe.push([$e.logits.data[this.contradiction_id],$e.logits.data[this.entailment_id]]):Qe.push($e.logits.data[this.entailment_id])}const Tt=(Fe?Qe.map(Me=>(0,c.softmax)(Me)[1]):(0,c.softmax)(Qe)).map((Me,me)=>[Me,me]).sort((Me,me)=>me[0]-Me[0]);Ye.push({sequence:Ve,labels:Tt.map(Me=>ye[Me[1]]),scores:Tt.map(Me=>Me[0])})}return ze?Ye:Ye[0]}}class N extends w{constructor(Ae){super(Ae)}async _call(Ae,{pooling:ye="none",normalize:xe=!1,quantize:ke=!1,precision:ze="binary"}={}){const je=this.tokenizer(Ae,{padding:!0,truncation:!0}),Fe=await this.model(je);let Ye=Fe.last_hidden_state??Fe.logits??Fe.token_embeddings;switch(ye){case"none":break;case"mean":Ye=(0,g.mean_pooling)(Ye,je.attention_mask);break;case"first_token":case"cls":Ye=Ye.slice(null,0);break;case"last_token":case"eos":Ye=Ye.slice(null,-1);break;default:throw Error(`Pooling method '${ye}' not supported.`)}return xe&&(Ye=Ye.normalize(2,-1)),ke&&(Ye=(0,g.quantize_embeddings)(Ye,ze)),Ye}}class j extends w{constructor(Ae){super(Ae)}async _call(Ae,{pool:ye=null}={}){const xe=await h(Ae),{pixel_values:ke}=await this.processor(xe),ze=await this.model({pixel_values:ke});let je;if(ye){if(!("pooler_output"in ze))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");je=ze.pooler_output}else je=ze.last_hidden_state??ze.logits??ze.image_embeds;return je}}class J extends w{constructor(Ae){super(Ae)}async _call(Ae,{top_k:ye=5}={}){const xe=this.processor.feature_extractor.config.sampling_rate,ke=await v(Ae,xe),ze=this.model.config.id2label,je=[];for(const Fe of ke){const Ye=await this.processor(Fe),Qe=(await this.model(Ye)).logits[0],mt=await(0,g.topk)(new g.Tensor("float32",(0,c.softmax)(Qe.data),Qe.dims),ye),Tt=mt[0].tolist(),me=mt[1].tolist().map(($e,et)=>({label:ze?ze[$e]:`LABEL_${$e}`,score:Tt[et]}));je.push(me)}return Array.isArray(Ae)?je:je[0]}}class W extends w{constructor(Ae){super(Ae)}async _call(Ae,ye,{hypothesis_template:xe="This is a sound of {}."}={}){const ke=!Array.isArray(Ae);ke&&(Ae=[Ae]);const ze=ye.map(Qe=>xe.replace("{}",Qe)),je=this.tokenizer(ze,{padding:!0,truncation:!0}),Fe=this.processor.feature_extractor.config.sampling_rate,Ye=await v(Ae,Fe),Ve=[];for(const Qe of Ye){const mt=await this.processor(Qe),Tt=await this.model({...je,...mt}),Me=(0,c.softmax)(Tt.logits_per_audio.data);Ve.push([...Me].map((me,$e)=>({score:me,label:ye[$e]})))}return ke?Ve[0]:Ve}}class oe extends w{constructor(Ae){super(Ae)}async _call(Ae,ye={}){switch(this.model.config.model_type){case"whisper":case"lite-whisper":return this._call_whisper(Ae,ye);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":case"parakeet_ctc":return this._call_wav2vec2(Ae,ye);case"moonshine":return this._call_moonshine(Ae,ye);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(Ae,ye){ye.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),ye.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const xe=!Array.isArray(Ae);xe&&(Ae=[Ae]);const ke=this.processor.feature_extractor.config.sampling_rate,ze=await v(Ae,ke),je=[];for(const Fe of ze){const Ye=await this.processor(Fe),Qe=(await this.model(Ye)).logits[0],mt=[];for(const Me of Qe)mt.push((0,c.max)(Me.data)[1]);const Tt=this.tokenizer.decode(mt,{skip_special_tokens:!0}).trim();je.push({text:Tt})}return xe?je[0]:je}async _call_whisper(Ae,ye){const xe=ye.return_timestamps??!1,ke=ye.chunk_length_s??0,ze=ye.force_full_sequences??!1;let je=ye.stride_length_s??null;const Fe={...ye};xe==="word"&&(Fe.return_token_timestamps=!0,Fe.return_timestamps=!1);const Ye=!Array.isArray(Ae);Ye&&(Ae=[Ae]);const Ve=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,Qe=this.processor.feature_extractor.config.hop_length,mt=this.processor.feature_extractor.config.sampling_rate,Tt=await v(Ae,mt),Me=[];for(const me of Tt){let $e=[];if(ke>0){if(je===null)je=ke/6;else if(ke<=je)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const at=mt*ke,Et=mt*je,Dt=at-2*Et;let Vt=0;for(;;){const an=Vt+at,bt=me.subarray(Vt,an),Jt=await this.processor(bt),Tn=Vt===0,We=an>=me.length;if($e.push({stride:[bt.length,Tn?0:Et,We?0:Et],input_features:Jt.input_features,is_last:We}),We)break;Vt+=Dt}}else $e=[{stride:[me.length,0,0],input_features:(await this.processor(me)).input_features,is_last:!0}];for(const at of $e){Fe.num_frames=Math.floor(at.stride[0]/Qe);const Et=await this.model.generate({inputs:at.input_features,...Fe});xe==="word"?(at.tokens=Et.sequences.tolist()[0],at.token_timestamps=Et.token_timestamps.tolist()[0].map(Dt=>(0,c.round)(Dt,2))):at.tokens=Et[0].tolist(),at.stride=at.stride.map(Dt=>Dt/mt)}const[et,ht]=this.tokenizer._decode_asr($e,{time_precision:Ve,return_timestamps:xe,force_full_sequences:ze});Me.push({text:et,...ht})}return Ye?Me[0]:Me}async _call_moonshine(Ae,ye){const xe=!Array.isArray(Ae);xe&&(Ae=[Ae]);const ke=this.processor.feature_extractor.config.sampling_rate,ze=await v(Ae,ke),je=[];for(const Fe of ze){const Ye=await this.processor(Fe),Ve=Math.floor(Fe.length/ke)*6,Qe=await this.model.generate({max_new_tokens:Ve,...ye,...Ye}),mt=this.processor.batch_decode(Qe,{skip_special_tokens:!0})[0];je.push({text:mt})}return xe?je[0]:je}}class ne extends w{constructor(Ae){super(Ae)}async _call(Ae,ye={}){const xe=Array.isArray(Ae),ke=await h(Ae),{pixel_values:ze}=await this.processor(ke),je=[];for(const Fe of ze){Fe.dims=[1,...Fe.dims];const Ye=await this.model.generate({inputs:Fe,...ye}),Ve=this.tokenizer.batch_decode(Ye,{skip_special_tokens:!0}).map(Qe=>({generated_text:Qe.trim()}));je.push(Ve)}return xe?je:je[0]}}class q extends w{constructor(Ae){super(Ae)}async _call(Ae,{top_k:ye=5}={}){const xe=await h(Ae),{pixel_values:ke}=await this.processor(xe),ze=await this.model({pixel_values:ke}),je=this.model.config.id2label,Fe=[];for(const Ye of ze.logits){const Ve=await(0,g.topk)(new g.Tensor("float32",(0,c.softmax)(Ye.data),Ye.dims),ye),Qe=Ve[0].tolist(),Tt=Ve[1].tolist().map((Me,me)=>({label:je?je[Me]:`LABEL_${Me}`,score:Qe[me]}));Fe.push(Tt)}return Array.isArray(Ae)?Fe:Fe[0]}}class le extends w{constructor(Ae){super(Ae),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(Ae,{threshold:ye=.5,mask_threshold:xe=.5,overlap_mask_area_threshold:ke=.8,label_ids_to_fuse:ze=null,target_sizes:je=null,subtask:Fe=null}={}){if(Array.isArray(Ae)&&Ae.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const Ve=await h(Ae),Qe=Ve.map(at=>[at.height,at.width]),mt=await this.processor(Ve),{inputNames:Tt,outputNames:Me}=this.model.sessions.model;if(!Tt.includes("pixel_values")){if(Tt.length!==1)throw Error(`Expected a single input name, but got ${Tt.length} inputs: ${Tt}.`);const at=Tt[0];if(at in mt)throw Error(`Input name ${at} already exists in the inputs.`);mt[at]=mt.pixel_values}const me=await this.model(mt);let $e=null;if(Fe!==null)$e=this.subtasks_mapping[Fe];else if(this.processor.image_processor){for(const[at,Et]of Object.entries(this.subtasks_mapping))if(Et in this.processor.image_processor){$e=this.processor.image_processor[Et].bind(this.processor.image_processor),Fe=at;break}}const et=this.model.config.id2label,ht=[];if(Fe)if(Fe==="panoptic"||Fe==="instance"){const at=$e(me,ye,xe,ke,ze,je??Qe)[0],Et=at.segmentation;for(const Dt of at.segments_info){const Vt=new Uint8ClampedArray(Et.data.length);for(let bt=0;bt<Et.data.length;++bt)Et.data[bt]===Dt.id&&(Vt[bt]=255);const an=new p.RawImage(Vt,Et.dims[1],Et.dims[0],1);ht.push({score:Dt.score,label:et[Dt.label_id],mask:an})}}else if(Fe==="semantic"){const{segmentation:at,labels:Et}=$e(me,je??Qe)[0];for(const Dt of Et){const Vt=new Uint8ClampedArray(at.data.length);for(let bt=0;bt<at.data.length;++bt)at.data[bt]===Dt&&(Vt[bt]=255);const an=new p.RawImage(Vt,at.dims[1],at.dims[0],1);ht.push({score:null,label:et[Dt],mask:an})}}else throw Error(`Subtask ${Fe} not supported.`);else{const Et=me[Me[0]];for(let Dt=0;Dt<Qe.length;++Dt){const Vt=Qe[Dt],an=Et[Dt];an.data.some(Jt=>Jt<-1e-5||Jt>1+1e-5)&&an.sigmoid_();const bt=await p.RawImage.fromTensor(an.mul_(255).to("uint8")).resize(Vt[1],Vt[0]);ht.push({label:null,score:null,mask:bt})}}return ht}}class se extends le{constructor(Ae){super(Ae)}async _call(Ae,ye={}){if(Array.isArray(Ae)&&Ae.length!==1)throw Error("Background removal pipeline currently only supports a batch size of 1.");const ke=await h(Ae),ze=await super._call(Ae,ye);return ke.map((Fe,Ye)=>{const Ve=Fe.clone();return Ve.putAlpha(ze[Ye].mask),Ve})}}class pe extends w{constructor(Ae){super(Ae)}async _call(Ae,ye,{hypothesis_template:xe="This is a photo of {}"}={}){const ke=Array.isArray(Ae),ze=await h(Ae),je=ye.map(Tt=>xe.replace("{}",Tt)),Fe=this.tokenizer(je,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:Ye}=await this.processor(ze),Ve=await this.model({...Fe,pixel_values:Ye}),Qe=this.model.config.model_type==="siglip"?Tt=>Tt.sigmoid().data:Tt=>(0,c.softmax)(Tt.data),mt=[];for(const Tt of Ve.logits_per_image){const me=[...Qe(Tt)].map(($e,et)=>({score:$e,label:ye[et]}));me.sort(($e,et)=>et.score-$e.score),mt.push(me)}return ke?mt:mt[0]}}class be extends w{constructor(Ae){super(Ae)}async _call(Ae,{threshold:ye=.9,percentage:xe=!1}={}){const ke=Array.isArray(Ae);if(ke&&Ae.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const ze=await h(Ae),je=xe?null:ze.map(Me=>[Me.height,Me.width]),{pixel_values:Fe,pixel_mask:Ye}=await this.processor(ze),Ve=await this.model({pixel_values:Fe,pixel_mask:Ye}),Qe=this.processor.image_processor.post_process_object_detection(Ve,ye,je),mt=this.model.config.id2label,Tt=Qe.map(Me=>Me.boxes.map((me,$e)=>({score:Me.scores[$e],label:mt[Me.classes[$e]],box:y(me,!xe)})));return ke?Tt:Tt[0]}}class ee extends w{constructor(Ae){super(Ae)}async _call(Ae,ye,{threshold:xe=.1,top_k:ke=null,percentage:ze=!1}={}){const je=Array.isArray(Ae),Fe=await h(Ae),Ye=this.tokenizer(ye,{padding:!0,truncation:!0}),Ve=await this.processor(Fe),Qe=[];for(let mt=0;mt<Fe.length;++mt){const Tt=Fe[mt],Me=ze?null:[[Tt.height,Tt.width]],me=Ve.pixel_values[mt].unsqueeze_(0),$e=await this.model({...Ye,pixel_values:me});let et;if("post_process_grounded_object_detection"in this.processor){const ht=this.processor.post_process_grounded_object_detection($e,Ye.input_ids,{box_threshold:xe,text_threshold:xe,target_sizes:Me})[0];et=ht.boxes.map((at,Et)=>({score:ht.scores[Et],label:ht.labels[Et],box:y(at,!ze)}))}else{const ht=this.processor.image_processor.post_process_object_detection($e,xe,Me,!0)[0];et=ht.boxes.map((at,Et)=>({score:ht.scores[Et],label:ye[ht.classes[Et]],box:y(at,!ze)}))}et.sort((ht,at)=>at.score-ht.score),ke!==null&&(et=et.slice(0,ke)),Qe.push(et)}return je?Qe:Qe[0]}}class te extends w{constructor(Ae){super(Ae)}async _call(Ae,ye,xe={}){const ke=(await h(Ae))[0],{pixel_values:ze}=await this.processor(ke),je=`<s_docvqa><s_question>${ye}</s_question><s_answer>`,Fe=this.tokenizer(je,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,Ye=await this.model.generate({inputs:ze,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:Fe,...xe}),Qe=this.tokenizer.batch_decode(Ye)[0].match(/<s_answer>(.*?)<\/s_answer>/);let mt=null;return Qe&&Qe.length>=2&&(mt=Qe[1].trim()),[{answer:mt}]}}class ue extends w{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(Ae){super(Ae),this.vocoder=Ae.vocoder??null}async _prepare_speaker_embeddings(Ae){if((typeof Ae=="string"||Ae instanceof URL)&&(Ae=new Float32Array(await(await fetch(Ae)).arrayBuffer())),Ae instanceof Float32Array)Ae=new g.Tensor("float32",Ae,[Ae.length]);else if(!(Ae instanceof g.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");return Ae}async _call(Ae,{speaker_embeddings:ye=null,num_inference_steps:xe,speed:ke}={}){return this.processor?this._call_text_to_spectrogram(Ae,{speaker_embeddings:ye}):this.model.config.model_type==="supertonic"?this._call_supertonic(Ae,{speaker_embeddings:ye,num_inference_steps:xe,speed:ke}):this._call_text_to_waveform(Ae)}async _call_supertonic(Ae,{speaker_embeddings:ye,num_inference_steps:xe,speed:ke}){if(!ye)throw new Error("Speaker embeddings must be provided for Supertonic models.");ye=await this._prepare_speaker_embeddings(ye);const{sampling_rate:ze,style_dim:je}=this.model.config;ye=ye.view(1,-1,je);const Fe=this.tokenizer(Ae,{padding:!0,truncation:!0}),{waveform:Ye}=await this.model.generate_speech({...Fe,style:ye,num_inference_steps:xe,speed:ke});return new d.RawAudio(Ye.data,ze)}async _call_text_to_waveform(Ae){const ye=this.tokenizer(Ae,{padding:!0,truncation:!0}),{waveform:xe}=await this.model(ye),ke=this.model.config.sampling_rate;return new d.RawAudio(xe.data,ke)}async _call_text_to_spectrogram(Ae,{speaker_embeddings:ye}){this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await s.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"}));const{input_ids:xe}=this.tokenizer(Ae,{padding:!0,truncation:!0});ye=await this._prepare_speaker_embeddings(ye),ye=ye.view(1,-1);const{waveform:ke}=await this.model.generate_speech(xe,ye,{vocoder:this.vocoder}),ze=this.processor.feature_extractor.config.sampling_rate;return new d.RawAudio(ke.data,ze)}}class ae extends w{constructor(Ae){super(Ae)}async _call(Ae){const ye=await h(Ae),xe=await this.processor(ye),ke=await this.model(xe),ze=[];for(const je of ke.reconstruction){const Fe=je.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");ze.push(p.RawImage.fromTensor(Fe))}return ze.length>1?ze:ze[0]}}class ce extends w{constructor(Ae){super(Ae)}async _call(Ae){const ye=await h(Ae),xe=await this.processor(ye),{predicted_depth:ke}=await this.model(xe),ze=[];for(let je=0;je<ye.length;++je){const Fe=ke[je],[Ye,Ve]=Fe.dims.slice(-2),[Qe,mt]=ye[je].size,Tt=(await(0,g.interpolate_4d)(Fe.view(1,1,Ye,Ve),{size:[mt,Qe],mode:"bilinear"})).view(mt,Qe),Me=Tt.min().item(),me=Tt.max().item(),$e=Tt.sub(Me).div_(me-Me).mul_(255).to("uint8").unsqueeze(0),et=p.RawImage.fromTensor($e);ze.push({predicted_depth:Tt,depth:et})}return ze.length>1?ze:ze[0]}}const Be=Object.freeze({"text-classification":{tokenizer:i.AutoTokenizer,pipeline:S,model:s.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:i.AutoTokenizer,pipeline:M,model:s.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:i.AutoTokenizer,pipeline:T,model:s.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:i.AutoTokenizer,pipeline:C,model:s.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:i.AutoTokenizer,pipeline:R,model:s.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:i.AutoTokenizer,pipeline:P,model:s.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:i.AutoTokenizer,pipeline:x,model:s.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:i.AutoTokenizer,pipeline:z,model:s.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:i.AutoTokenizer,pipeline:U,model:s.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:J,model:s.AutoModelForAudioClassification,processor:r.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:i.AutoTokenizer,pipeline:W,model:s.AutoModel,processor:r.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:i.AutoTokenizer,pipeline:oe,model:[s.AutoModelForSpeechSeq2Seq,s.AutoModelForCTC],processor:r.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:i.AutoTokenizer,pipeline:ue,model:[s.AutoModelForTextToWaveform,s.AutoModelForTextToSpectrogram],processor:[r.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:i.AutoTokenizer,pipeline:ne,model:s.AutoModelForVision2Seq,processor:r.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:q,model:s.AutoModelForImageClassification,processor:r.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:le,model:[s.AutoModelForImageSegmentation,s.AutoModelForSemanticSegmentation,s.AutoModelForUniversalSegmentation],processor:r.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"background-removal":{pipeline:se,model:[s.AutoModelForImageSegmentation,s.AutoModelForSemanticSegmentation,s.AutoModelForUniversalSegmentation],processor:r.AutoProcessor,default:{model:"Xenova/modnet"},type:"image"},"zero-shot-image-classification":{tokenizer:i.AutoTokenizer,pipeline:pe,model:s.AutoModel,processor:r.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:be,model:s.AutoModelForObjectDetection,processor:r.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:i.AutoTokenizer,pipeline:ee,model:s.AutoModelForZeroShotObjectDetection,processor:r.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:i.AutoTokenizer,pipeline:te,model:s.AutoModelForDocumentQuestionAnswering,processor:r.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:ae,model:s.AutoModelForImageToImage,processor:r.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:ce,model:s.AutoModelForDepthEstimation,processor:r.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:i.AutoTokenizer,pipeline:N,model:s.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:r.AutoProcessor,pipeline:j,model:[s.AutoModelForImageFeatureExtraction,s.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),He=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function Xe(tt,Ae=null,{progress_callback:ye=null,config:xe=null,cache_dir:ke=null,local_files_only:ze=!1,revision:je="main",device:Fe=null,dtype:Ye=null,subfolder:Ve="onnx",use_external_data_format:Qe=null,model_file_name:mt=null,session_options:Tt={}}={}){tt=He[tt]??tt;const Me=Be[tt.split("_",1)[0]];if(!Me)throw Error(`Unsupported pipeline: ${tt}. Must be one of [${Object.keys(Be)}]`);Ae||(Ae=Me.default.model,console.log(`No model specified. Using default model: "${Ae}".`));const me={progress_callback:ye,config:xe,cache_dir:ke,local_files_only:ze,revision:je,device:Fe,dtype:Ye,subfolder:Ve,use_external_data_format:Qe,model_file_name:mt,session_options:Tt},$e=new Map([["tokenizer",Me.tokenizer],["model",Me.model],["processor",Me.processor]]),et=await ot($e,Ae,me);et.task=tt,(0,l.dispatchCallback)(ye,{status:"ready",task:tt,model:Ae});const ht=Me.pipeline;return new ht(et)}async function ot(tt,Ae,ye){const xe=Object.create(null),ke=[];for(const[ze,je]of tt.entries()){if(!je)continue;let Fe;Array.isArray(je)?Fe=new Promise(async(Ye,Ve)=>{let Qe;for(const mt of je){if(mt===null){Ye(null);return}try{Ye(await mt.from_pretrained(Ae,ye));return}catch(Tt){if(Tt.message?.includes("Unsupported model type"))Qe=Tt;else if(Tt.message?.includes("Could not locate file"))Qe=Tt;else{Ve(Tt);return}}}Ve(Qe)}):Fe=je.from_pretrained(Ae,ye),xe[ze]=Fe,ke.push(Fe)}await Promise.all(ke);for(const[ze,je]of Object.entries(xe))xe[ze]=await je;return xe}}),"./src/tokenizers.js":((n,e,t)=>{t.r(e),t.d(e,{AlbertTokenizer:()=>K,AutoTokenizer:()=>Ds,BartTokenizer:()=>on,BertTokenizer:()=>F,BlenderbotSmallTokenizer:()=>Ss,BlenderbotTokenizer:()=>Nn,BloomTokenizer:()=>gn,CLIPTokenizer:()=>Ln,CamembertTokenizer:()=>nt,CodeGenTokenizer:()=>Pn,CodeLlamaTokenizer:()=>we,CohereTokenizer:()=>fi,ConvBertTokenizer:()=>ge,DebertaTokenizer:()=>re,DebertaV2Tokenizer:()=>Q,DistilBertTokenizer:()=>rt,ElectraTokenizer:()=>yt,Ernie4_5_Tokenizer:()=>$s,EsmTokenizer:()=>jt,FalconTokenizer:()=>Ue,GPT2Tokenizer:()=>Bt,GPTNeoXTokenizer:()=>Ot,GemmaTokenizer:()=>en,Grok1Tokenizer:()=>dn,HerbertTokenizer:()=>ve,LlamaTokenizer:()=>Se,M2M100Tokenizer:()=>Fn,MBart50Tokenizer:()=>Bn,MBartTokenizer:()=>xn,MPNetTokenizer:()=>Je,MarianTokenizer:()=>gt,MgpstrTokenizer:()=>ks,MobileBertTokenizer:()=>Ee,NllbTokenizer:()=>_n,NougatTokenizer:()=>$i,PreTrainedTokenizer:()=>A,Qwen2Tokenizer:()=>tn,RoFormerTokenizer:()=>Le,RobertaTokenizer:()=>bi,SiglipTokenizer:()=>Ct,SpeechT5Tokenizer:()=>yr,SqueezeBertTokenizer:()=>k,T5Tokenizer:()=>Ne,TokenizerModel:()=>j,VitsTokenizer:()=>ma,Wav2Vec2CTCTokenizer:()=>Qt,WhisperTokenizer:()=>ti,XLMRobertaTokenizer:()=>Ge,XLMTokenizer:()=>ft,is_chinese_char:()=>C});var i=t("./src/utils/generic.js"),s=t("./src/utils/core.js"),r=t("./src/utils/hub.js"),o=t("./src/utils/maths.js"),l=t("./src/utils/tensor.js"),c=t("./src/utils/data-structures.js"),d=t("./node_modules/@huggingface/jinja/dist/index.js"),g=t("./src/models/whisper/common_whisper.js");async function p(lt,de){const Ie=await Promise.all([(0,r.getModelJSON)(lt,"tokenizer.json",!0,de),(0,r.getModelJSON)(lt,"tokenizer_config.json",!0,de)]);return de.legacy!==null&&(Ie[1].legacy=de.legacy),Ie}function h(lt,de){const Ie=[];let Ke=0;for(const Ze of lt.matchAll(de)){const wt=Ze[0];Ke<Ze.index&&Ie.push(lt.slice(Ke,Ze.index)),wt.length>0&&Ie.push(wt),Ke=Ze.index+wt.length}return Ke<lt.length&&Ie.push(lt.slice(Ke)),Ie}function v(lt,de=!0){if(lt.Regex!==void 0){let Ie=lt.Regex.replace(/\\([#&~])/g,"$1");for(const[Ke,Ze]of U)Ie=Ie.replaceAll(Ke,Ze);return new RegExp(Ie,"gu")}else if(lt.String!==void 0){const Ie=(0,s.escapeRegExp)(lt.String);return new RegExp(de?Ie:`(${Ie})`,"gu")}else return console.warn("Unknown pattern type:",lt),null}function y(lt){return new Map(Object.entries(lt))}function w(lt){const de=lt.dims;switch(de.length){case 1:return lt.tolist();case 2:if(de[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return lt.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${de.length}.`)}}function S(lt){return lt.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function M(lt){return lt.replace(new RegExp("\\p{M}","gu"),"")}function T(lt){return M(lt.toLowerCase())}function C(lt){return lt>=19968&&lt<=40959||lt>=13312&&lt<=19903||lt>=131072&&lt<=173791||lt>=173824&&lt<=177983||lt>=177984&&lt<=178207||lt>=178208&&lt<=183983||lt>=63744&&lt<=64255||lt>=194560&&lt<=195103}function x(lt,de,Ie){const Ke=[];let Ze=0;for(;Ze<lt.length;){if(Ke.push(lt[Ze]),(de.get(lt[Ze])??Ie)!==Ie){++Ze;continue}for(;++Ze<lt.length&&(de.get(lt[Ze])??Ie)===Ie;)de.get(Ke.at(-1))!==Ie&&(Ke[Ke.length-1]+=lt[Ze])}return Ke}function R(lt){return lt.match(/\S+/g)||[]}const P="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",D=new RegExp(`^[${P}]+$`,"gu"),z=".,!?",U=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],["(?i:[sdmt]|ll|ve|re)","(?:[sS]|[dD]|[mM]|[tT]|[lL][lL]|[vV][eE]|[rR][eE])"],["[^\\r\\n\\p{L}\\p{N}]?+","[^\\r\\n\\p{L}\\p{N}]?"],["[^\\s\\p{L}\\p{N}]++","[^\\s\\p{L}\\p{N}]+"],[` ?[^(\\s|[${z}])]+`,` ?[^\\s${z}]+`]]);class N{constructor(de){this.content=de.content,this.id=de.id,this.single_word=de.single_word??!1,this.lstrip=de.lstrip??!1,this.rstrip=de.rstrip??!1,this.special=de.special??!1,this.normalized=de.normalized??null}}class j extends i.Callable{constructor(de){super(),this.config=de,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(de,...Ie){switch(de.type){case"WordPiece":return new J(de);case"Unigram":return new W(de,...Ie);case"BPE":return new q(de);default:if(de.vocab)return Array.isArray(de.vocab)?new W(de,...Ie):Object.hasOwn(de,"continuing_subword_prefix")&&Object.hasOwn(de,"unk_token")?Object.hasOwn(de,"merges")?new q(de):new J(de):new le(de,...Ie);throw new Error(`Unknown TokenizerModel type: ${de.type}`)}}_call(de){return de=this.encode(de),this.fuse_unk&&(de=x(de,this.tokens_to_ids,this.unk_token_id)),de}encode(de){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(de){return de.map(Ie=>this.tokens_to_ids.get(Ie)??this.unk_token_id)}convert_ids_to_tokens(de){return de.map(Ie=>this.vocab[Ie]??this.unk_token)}}class J extends j{constructor(de){super(de),this.tokens_to_ids=y(de.vocab),this.unk_token_id=this.tokens_to_ids.get(de.unk_token),this.unk_token=de.unk_token,this.max_input_chars_per_word=de.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[Ie,Ke]of this.tokens_to_ids)this.vocab[Ke]=Ie}encode(de){const Ie=[];for(const Ke of de){const Ze=[...Ke];if(Ze.length>this.max_input_chars_per_word){Ie.push(this.unk_token);continue}let wt=!1,$t=0;const vn=[];for(;$t<Ze.length;){let bn=Ze.length,En=null;for(;$t<bn;){let un=Ze.slice($t,bn).join("");if($t>0&&(un=this.config.continuing_subword_prefix+un),this.tokens_to_ids.has(un)){En=un;break}--bn}if(En===null){wt=!0;break}vn.push(En),$t=bn}wt?Ie.push(this.unk_token):Ie.push(...vn)}return Ie}}class W extends j{constructor(de,Ie){super(de);const Ke=de.vocab.length;this.vocab=new Array(Ke),this.scores=new Array(Ke);for(let Ze=0;Ze<Ke;++Ze)[this.vocab[Ze],this.scores[Ze]]=de.vocab[Ze];this.unk_token_id=de.unk_id,this.unk_token=this.vocab[de.unk_id],this.tokens_to_ids=new Map(this.vocab.map((Ze,wt)=>[Ze,wt])),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=Ie.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,o.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new c.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(de){const Ie=de.chars,Ke=1;let Ze=0;for(;Ze<Ie.length;){let wt=!1;const $t=Ie.slice(Ze).join(""),vn=this.trie.commonPrefixSearch($t);for(const bn of vn){const En=this.tokens_to_ids.get(bn),un=this.scores[En],Qn=(0,s.len)(bn);de.insert(Ze,Qn,un,En),!wt&&Qn===Ke&&(wt=!0)}wt||de.insert(Ze,Ke,this.unk_score,this.unk_token_id),Ze+=Ke}}tokenize(de){const Ie=new c.TokenLattice(de,this.bos_token_id,this.eos_token_id);return this.populateNodes(Ie),Ie.tokens()}encode(de){const Ie=[];for(const Ke of de){const Ze=this.tokenize(Ke);Ie.push(...Ze)}return Ie}}const oe=(()=>{const lt=[...Array.from({length:94},(Ze,wt)=>wt+33),...Array.from({length:12},(Ze,wt)=>wt+161),...Array.from({length:82},(Ze,wt)=>wt+174)],de=lt.slice();let Ie=0;for(let Ze=0;Ze<256;++Ze)lt.includes(Ze)||(lt.push(Ze),de.push(256+Ie),Ie+=1);const Ke=de.map(Ze=>String.fromCharCode(Ze));return Object.fromEntries(lt.map((Ze,wt)=>[Ze,Ke[wt]]))})(),ne=(0,s.reverseDictionary)(oe);class q extends j{constructor(de){super(de),this.tokens_to_ids=y(de.vocab),this.unk_token_id=this.tokens_to_ids.get(de.unk_token),this.unk_token=de.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[Ke,Ze]of this.tokens_to_ids)this.vocab[Ze]=Ke;const Ie=Array.isArray(de.merges[0]);this.merges=Ie?de.merges:de.merges.map(Ke=>Ke.split(" ",2)),this.bpe_ranks=new Map(this.merges.map((Ke,Ze)=>[JSON.stringify(Ke),Ze])),this.end_of_word_suffix=de.end_of_word_suffix,this.continuing_subword_suffix=de.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.max_length_to_cache=256,this.cache_capacity=1e4,this.cache=new c.LRUCache(this.cache_capacity)}clear_cache(){this.cache.clear()}bpe(de){if(de.length===0)return[];const Ie=this.cache.get(de);if(Ie!==void 0)return Ie;const Ke=Array.from(de);this.end_of_word_suffix&&(Ke[Ke.length-1]+=this.end_of_word_suffix);let Ze=[];if(Ke.length>1){const wt=new c.PriorityQueue((bn,En)=>bn.score<En.score);let $t={token:Ke[0],bias:0,prev:null,next:null},vn=$t;for(let bn=1;bn<Ke.length;++bn){const En={bias:bn/Ke.length,token:Ke[bn],prev:vn,next:null};vn.next=En,this._add_node(wt,vn),vn=En}for(;!wt.isEmpty();){const bn=wt.pop();if(bn.deleted||!bn.next||bn.next.deleted)continue;if(bn.deleted=!0,bn.next.deleted=!0,bn.prev){const un={...bn.prev};bn.prev.deleted=!0,bn.prev=un,un.prev?un.prev.next=un:$t=un}const En={token:bn.token+bn.next.token,bias:bn.bias,prev:bn.prev,next:bn.next.next};En.prev?(En.prev.next=En,this._add_node(wt,En.prev)):$t=En,En.next&&(En.next.prev=En,this._add_node(wt,En))}for(let bn=$t;bn!==null;bn=bn.next)Ze.push(bn.token)}else Ze=Ke;if(this.continuing_subword_suffix)for(let wt=0;wt<Ze.length-1;++wt)Ze[wt]+=this.continuing_subword_suffix;return de.length<this.max_length_to_cache&&this.cache.put(de,Ze),Ze}_add_node(de,Ie){const Ke=this.bpe_ranks.get(JSON.stringify([Ie.token,Ie.next.token]));Ke!==void 0&&(Ie.score=Ke+Ie.bias,de.push(Ie))}encode(de){const Ie=[];for(const Ke of de){if(this.ignore_merges&&this.tokens_to_ids.has(Ke)){Ie.push(Ke);continue}const Ze=this.bpe(Ke);for(const wt of Ze)if(this.tokens_to_ids.has(wt))Ie.push(wt);else if(this.byte_fallback){const $t=Array.from(this.text_encoder.encode(wt)).map(vn=>`<0x${vn.toString(16).toUpperCase().padStart(2,"0")}>`);$t.every(vn=>this.tokens_to_ids.has(vn))?Ie.push(...$t):Ie.push(this.unk_token)}else Ie.push(this.unk_token)}return Ie}}class le extends j{constructor(de,Ie){super(de),this.tokens_to_ids=y(Ie.target_lang?de.vocab[Ie.target_lang]:de.vocab),this.bos_token=Ie.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=Ie.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=Ie.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=Ie.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[Ke,Ze]of this.tokens_to_ids)this.vocab[Ze]=Ke}encode(de){return de}}class se extends i.Callable{constructor(de){super(),this.config=de}static fromConfig(de){if(de===null)return null;switch(de.type){case"BertNormalizer":return new tt(de);case"Precompiled":return new We(de);case"Sequence":return new ot(de);case"Replace":return new pe(de);case"NFC":return new ee(de);case"NFD":return new te(de);case"NFKC":return new ue(de);case"NFKD":return new ae(de);case"Strip":return new ce(de);case"StripAccents":return new Be(de);case"Lowercase":return new He(de);case"Prepend":return new Xe(de);default:throw new Error(`Unknown Normalizer type: ${de.type}`)}}normalize(de){throw Error("normalize should be implemented in subclass.")}_call(de){return this.normalize(de)}}class pe extends se{normalize(de){const Ie=v(this.config.pattern);return Ie===null?de:de.replaceAll(Ie,this.config.content)}}class be extends se{form=void 0;normalize(de){return de=de.normalize(this.form),de}}class ee extends be{form="NFC"}class te extends be{form="NFD"}class ue extends be{form="NFKC"}class ae extends be{form="NFKD"}class ce extends se{normalize(de){return this.config.strip_left&&this.config.strip_right?de=de.trim():(this.config.strip_left&&(de=de.trimStart()),this.config.strip_right&&(de=de.trimEnd())),de}}class Be extends se{normalize(de){return de=M(de),de}}class He extends se{normalize(de){return de=de.toLowerCase(),de}}class Xe extends se{normalize(de){return de=this.config.prepend+de,de}}class ot extends se{constructor(de){super(de),this.normalizers=de.normalizers.map(Ie=>se.fromConfig(Ie))}normalize(de){return this.normalizers.reduce((Ie,Ke)=>Ke.normalize(Ie),de)}}class tt extends se{_tokenize_chinese_chars(de){const Ie=[];for(let Ke=0;Ke<de.length;++Ke){const Ze=de[Ke],wt=Ze.charCodeAt(0);C(wt)?(Ie.push(" "),Ie.push(Ze),Ie.push(" ")):Ie.push(Ze)}return Ie.join("")}stripAccents(de){return de.normalize("NFD").replace(new RegExp("\\p{Mn}","gu"),"")}_is_control(de){switch(de){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(de)}}_clean_text(de){const Ie=[];for(const Ke of de){const Ze=Ke.charCodeAt(0);Ze===0||Ze===65533||this._is_control(Ke)||(/^\s$/.test(Ke)?Ie.push(" "):Ie.push(Ke))}return Ie.join("")}normalize(de){return this.config.clean_text&&(de=this._clean_text(de)),this.config.handle_chinese_chars&&(de=this._tokenize_chinese_chars(de)),this.config.lowercase?(de=de.toLowerCase(),this.config.strip_accents!==!1&&(de=this.stripAccents(de))):this.config.strip_accents&&(de=this.stripAccents(de)),de}}class Ae extends i.Callable{static fromConfig(de){if(de===null)return null;switch(de.type){case"BertPreTokenizer":return new ye(de);case"Sequence":return new vt(de);case"Whitespace":return new Yt(de);case"WhitespaceSplit":return new qe(de);case"Metaspace":return new Jt(de);case"ByteLevel":return new xe(de);case"Split":return new ke(de);case"Punctuation":return new ze(de);case"Digits":return new je(de);case"Replace":return new Kt(de);case"FixedLength":return new rn(de);default:throw new Error(`Unknown PreTokenizer type: ${de.type}`)}}pre_tokenize_text(de,Ie){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(de,Ie){return(Array.isArray(de)?de.map(Ke=>this.pre_tokenize_text(Ke,Ie)):this.pre_tokenize_text(de,Ie)).flat()}_call(de,Ie){return this.pre_tokenize(de,Ie)}}class ye extends Ae{constructor(de){super(),this.pattern=new RegExp(`[^\\s${P}]+|[${P}]`,"gu")}pre_tokenize_text(de,Ie){return de.trim().match(this.pattern)||[]}}class xe extends Ae{constructor(de){super(),this.config=de,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=oe,this.text_encoder=new TextEncoder}pre_tokenize_text(de,Ie){return this.add_prefix_space&&!de.startsWith(" ")&&(de=" "+de),(this.use_regex?de.match(this.pattern)||[]:[de]).map(Ze=>Array.from(this.text_encoder.encode(Ze),wt=>this.byte_encoder[wt]).join(""))}}class ke extends Ae{constructor(de){super(),this.config=de,this.pattern=v(this.config.pattern,this.config.invert)}pre_tokenize_text(de,Ie){return this.pattern===null?[]:this.config.invert?de.match(this.pattern)||[]:this.config.behavior?.toLowerCase()==="removed"?de.split(this.pattern).filter(Ke=>Ke):h(de,this.pattern)}}class ze extends Ae{constructor(de){super(),this.config=de,this.pattern=new RegExp(`[^${P}]+|[${P}]+`,"gu")}pre_tokenize_text(de,Ie){return de.match(this.pattern)||[]}}class je extends Ae{constructor(de){super(),this.config=de;const Ie=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(Ie,"gu")}pre_tokenize_text(de,Ie){return de.match(this.pattern)||[]}}class Fe extends i.Callable{constructor(de){super(),this.config=de}static fromConfig(de){if(de===null)return null;switch(de.type){case"TemplateProcessing":return new Qe(de);case"ByteLevel":return new mt(de);case"RobertaProcessing":return new Ve(de);case"BertProcessing":return new Ye(de);case"Sequence":return new Tt(de);default:throw new Error(`Unknown PostProcessor type: ${de.type}`)}}post_process(de,...Ie){throw Error("post_process should be implemented in subclass.")}_call(de,...Ie){return this.post_process(de,...Ie)}}class Ye extends Fe{constructor(de){super(de),this.cls=de.cls[0],this.sep=de.sep[0]}post_process(de,Ie=null,{add_special_tokens:Ke=!0}={}){Ke&&(de=(0,s.mergeArrays)([this.cls],de,[this.sep]));let Ze=new Array(de.length).fill(0);if(Ie!==null){const wt=Ke&&this instanceof Ve?[this.sep]:[],$t=Ke?[this.sep]:[];de=(0,s.mergeArrays)(de,wt,Ie,$t),Ze=(0,s.mergeArrays)(Ze,new Array(Ie.length+wt.length+$t.length).fill(1))}return{tokens:de,token_type_ids:Ze}}}class Ve extends Ye{}class Qe extends Fe{constructor(de){super(de),this.single=de.single,this.pair=de.pair}post_process(de,Ie=null,{add_special_tokens:Ke=!0}={}){const Ze=Ie===null?this.single:this.pair;let wt=[],$t=[];for(const vn of Ze)"SpecialToken"in vn?Ke&&(wt.push(vn.SpecialToken.id),$t.push(vn.SpecialToken.type_id)):"Sequence"in vn&&(vn.Sequence.id==="A"?(wt=(0,s.mergeArrays)(wt,de),$t=(0,s.mergeArrays)($t,new Array(de.length).fill(vn.Sequence.type_id))):vn.Sequence.id==="B"&&(wt=(0,s.mergeArrays)(wt,Ie),$t=(0,s.mergeArrays)($t,new Array(Ie.length).fill(vn.Sequence.type_id))));return{tokens:wt,token_type_ids:$t}}}class mt extends Fe{post_process(de,Ie=null){return Ie&&(de=(0,s.mergeArrays)(de,Ie)),{tokens:de}}}class Tt extends Fe{constructor(de){super(de),this.processors=de.processors.map(Ie=>Fe.fromConfig(Ie))}post_process(de,Ie=null,Ke={}){let Ze;for(const wt of this.processors)if(wt instanceof mt)de=wt.post_process(de).tokens,Ie&&(Ie=wt.post_process(Ie).tokens);else{const $t=wt.post_process(de,Ie,Ke);de=$t.tokens,Ze=$t.token_type_ids}return{tokens:de,token_type_ids:Ze}}}class Me extends i.Callable{constructor(de){super(),this.config=de,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=de.trim_offsets}static fromConfig(de){if(de===null)return null;switch(de.type){case"WordPiece":return new at(de);case"Metaspace":return new Tn(de);case"ByteLevel":return new Et(de);case"Replace":return new me(de);case"ByteFallback":return new $e(de);case"Fuse":return new et(de);case"Strip":return new ht(de);case"Sequence":return new Vt(de);case"CTC":return new Dt(de);case"BPEDecoder":return new an(de);default:throw new Error(`Unknown Decoder type: ${de.type}`)}}_call(de){return this.decode(de)}decode(de){return this.decode_chain(de).join("")}decode_chain(de){throw Error("`decode_chain` should be implemented in subclass.")}}class me extends Me{decode_chain(de){const Ie=v(this.config.pattern);return Ie===null?de:de.map(Ke=>Ke.replaceAll(Ie,this.config.content))}}class $e extends Me{constructor(de){super(de),this.text_decoder=new TextDecoder}decode_chain(de){const Ie=[];let Ke=[];for(const Ze of de){let wt=null;if(Ze.length===6&&Ze.startsWith("<0x")&&Ze.endsWith(">")){const $t=parseInt(Ze.slice(3,5),16);isNaN($t)||(wt=$t)}if(wt!==null)Ke.push(wt);else{if(Ke.length>0){const $t=this.text_decoder.decode(Uint8Array.from(Ke));Ie.push($t),Ke=[]}Ie.push(Ze)}}if(Ke.length>0){const Ze=this.text_decoder.decode(Uint8Array.from(Ke));Ie.push(Ze),Ke=[]}return Ie}}class et extends Me{decode_chain(de){return[de.join("")]}}class ht extends Me{constructor(de){super(de),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(de){return de.map(Ie=>{let Ke=0;for(let wt=0;wt<this.start&&Ie[wt]===this.content;++wt){Ke=wt+1;continue}let Ze=Ie.length;for(let wt=0;wt<this.stop;++wt){const $t=Ie.length-wt-1;if(Ie[$t]===this.content){Ze=$t;continue}else break}return Ie.slice(Ke,Ze)})}}class at extends Me{constructor(de){super(de),this.cleanup=de.cleanup}decode_chain(de){return de.map((Ie,Ke)=>(Ke!==0&&(Ie.startsWith(this.config.prefix)?Ie=Ie.replace(this.config.prefix,""):Ie=" "+Ie),this.cleanup&&(Ie=S(Ie)),Ie))}}class Et extends Me{constructor(de){super(de),this.byte_decoder=ne,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(de){const Ie=de.join(""),Ke=new Uint8Array([...Ie].map(wt=>this.byte_decoder[wt]));return this.text_decoder.decode(Ke)}decode_chain(de){const Ie=[];let Ke=[];for(const Ze of de)this.added_tokens.find(wt=>wt.content===Ze)!==void 0?(Ke.length>0&&(Ie.push(this.convert_tokens_to_string(Ke)),Ke=[]),Ie.push(Ze)):Ke.push(Ze);return Ke.length>0&&Ie.push(this.convert_tokens_to_string(Ke)),Ie}}class Dt extends Me{constructor(de){super(de),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(de){if(de.length===0)return"";const Ie=[de[0]];for(let wt=1;wt<de.length;++wt)de[wt]!==Ie.at(-1)&&Ie.push(de[wt]);let Ze=Ie.filter(wt=>wt!==this.pad_token).join("");return this.cleanup&&(Ze=S(Ze).replaceAll(this.word_delimiter_token," ").trim()),Ze}decode_chain(de){return[this.convert_tokens_to_string(de)]}}class Vt extends Me{constructor(de){super(de),this.decoders=de.decoders.map(Ie=>Me.fromConfig(Ie))}decode_chain(de){return this.decoders.reduce((Ie,Ke)=>Ke.decode_chain(Ie),de)}}class an extends Me{constructor(de){super(de),this.suffix=this.config.suffix}decode_chain(de){return de.map((Ie,Ke)=>Ie.replaceAll(this.suffix,Ke===de.length-1?"":" "))}}class bt extends Me{decode_chain(de){let Ie="";for(let Ke=1;Ke<de.length;Ke+=2)Ie+=de[Ke];return[Ie]}}class Jt extends Ae{constructor(de){super(),this.replacement=de.replacement,this.strRep=de.str_rep||this.replacement,this.prepend_scheme=de.prepend_scheme??"always"}pre_tokenize_text(de,{section_index:Ie=void 0}={}){let Ke=de.replaceAll(" ",this.strRep);return!Ke.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&Ie===0)&&(Ke=this.strRep+Ke),[Ke]}}class Tn extends Me{constructor(de){super(de),this.replacement=de.replacement}decode_chain(de){const Ie=[];for(let Ke=0;Ke<de.length;++Ke){let Ze=de[Ke].replaceAll(this.replacement," ");Ke==0&&Ze.startsWith(" ")&&(Ze=Ze.substring(1)),Ie.push(Ze)}return Ie}}class We extends se{constructor(de){super(de),this.charsmap=de.precompiled_charsmap}normalize(de){return de=de.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),de=de.replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," "),de.includes("")?de=de.split("").map(Ke=>Ke.normalize("NFKC")).join(""):de=de.normalize("NFKC"),de}}class vt extends Ae{constructor(de){super(),this.tokenizers=de.pretokenizers.map(Ie=>Ae.fromConfig(Ie))}pre_tokenize_text(de,Ie){return this.tokenizers.reduce((Ke,Ze)=>Ze.pre_tokenize(Ke,Ie),[de])}}class Yt extends Ae{constructor(de){super()}pre_tokenize_text(de,Ie){return de.match(/\w+|[^\w\s]+/g)||[]}}class qe extends Ae{constructor(de){super()}pre_tokenize_text(de,Ie){return R(de)}}class Kt extends Ae{constructor(de){super(),this.config=de,this.pattern=v(this.config.pattern),this.content=this.config.content}pre_tokenize_text(de,Ie){return this.pattern===null?[de]:[de.replaceAll(this.pattern,this.config.content)]}}class rn extends Ae{constructor(de){super(),this._length=de.length}pre_tokenize_text(de,Ie){const Ke=[];for(let Ze=0;Ze<de.length;Ze+=this._length)Ke.push(de.slice(Ze,Ze+this._length));return Ke}}const fe=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function B(lt,de,Ie,Ke){for(const Ze of Object.keys(lt)){const wt=de-lt[Ze].length,$t=Ie(Ze),vn=new Array(wt).fill($t);lt[Ze]=Ke==="right"?(0,s.mergeArrays)(lt[Ze],vn):(0,s.mergeArrays)(vn,lt[Ze])}}function I(lt,de){for(const Ie of Object.keys(lt))lt[Ie].length=de}class A extends i.Callable{return_token_type_ids=!1;padding_side="right";constructor(de,Ie){super(),this.config=Ie,this.normalizer=se.fromConfig(de.normalizer),this.pre_tokenizer=Ae.fromConfig(de.pre_tokenizer),this.model=j.fromConfig(de.model,Ie),this.post_processor=Fe.fromConfig(de.post_processor),this.decoder=Me.fromConfig(de.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const Ke of de.added_tokens){const Ze=new N(Ke);this.added_tokens.push(Ze),this.model.tokens_to_ids.set(Ze.content,Ze.id),this.model.vocab[Ze.id]=Ze.content,Ze.special&&(this.special_tokens.push(Ze.content),this.all_special_ids.push(Ze.id))}if(this.additional_special_tokens=Ie.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_splitter=new c.DictionarySplitter(this.added_tokens.map(Ke=>Ke.content)),this.added_tokens_map=new Map(this.added_tokens.map(Ke=>[Ke.content,Ke])),this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=Ie.model_max_length,this.remove_space=Ie.remove_space,this.clean_up_tokenization_spaces=Ie.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=Ie.do_lowercase_and_remove_accent??!1,Ie.padding_side&&(this.padding_side=Ie.padding_side),this.add_bos_token=Ie.add_bos_token,this.add_eos_token=Ie.add_eos_token,this.legacy=!1,this.chat_template=Ie.chat_template??null,Array.isArray(this.chat_template)){const Ke=Object.create(null);for(const{name:Ze,template:wt}of this.chat_template){if(typeof Ze!="string"||typeof wt!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');Ke[Ze]=wt}this.chat_template=Ke}this._compiled_template_cache=new Map}getToken(...de){for(const Ie of de){const Ke=this.config[Ie];if(Ke)if(typeof Ke=="object"){if(Ke.__type==="AddedToken")return Ke.content;throw Error(`Unknown token: ${Ke}`)}else return Ke}return null}static async from_pretrained(de,{progress_callback:Ie=null,config:Ke=null,cache_dir:Ze=null,local_files_only:wt=!1,revision:$t="main",legacy:vn=null}={}){const bn=await p(de,{progress_callback:Ie,config:Ke,cache_dir:Ze,local_files_only:wt,revision:$t,legacy:vn});return new this(...bn)}_call(de,{text_pair:Ie=null,add_special_tokens:Ke=!0,padding:Ze=!1,truncation:wt=null,max_length:$t=null,return_tensor:vn=!0,return_token_type_ids:bn=null}={}){const En=Array.isArray(de);let un;if(En){if(de.length===0)throw Error("text array must be non-empty");if(Ie!==null){if(Array.isArray(Ie)){if(de.length!==Ie.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");un=de.map((ni,Ms)=>this._encode_plus(ni,{text_pair:Ie[Ms],add_special_tokens:Ke,return_token_type_ids:bn}))}else un=de.map(ni=>this._encode_plus(ni,{add_special_tokens:Ke,return_token_type_ids:bn}))}else{if(de==null)throw Error("text may not be null or undefined");if(Array.isArray(Ie))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");un=[this._encode_plus(de,{text_pair:Ie,add_special_tokens:Ke,return_token_type_ids:bn})]}if($t===null?$t=this.model_max_length:wt===null&&(Ze===!0?(console.warn("`max_length` is ignored when `padding: true` and there is no truncation strategy. To pad to max length, use `padding: 'max_length'`."),$t=this.model_max_length):Ze===!1&&(console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation: true` to explicitly truncate examples to max length."),wt=!0)),Ze===!0&&($t=Math.min((0,o.max)(un.map(ni=>ni.input_ids.length))[0],$t??1/0)),$t=Math.min($t,this.model_max_length??1/0),Ze||wt)for(let ni=0;ni<un.length;++ni)un[ni].input_ids.length!==$t&&(un[ni].input_ids.length>$t?wt&&I(un[ni],$t):Ze&&B(un[ni],$t,Ms=>Ms==="input_ids"?this.pad_token_id:0,this.padding_side));const Qn={};if(vn){if(!(Ze&&wt)&&un.some(Ms=>{for(const bs of Object.keys(Ms))if(Ms[bs].length!==un[0][bs]?.length)return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const ni=[un.length,un[0].input_ids.length];for(const Ms of Object.keys(un[0]))Qn[Ms]=new l.Tensor("int64",BigInt64Array.from(un.flatMap(bs=>bs[Ms]).map(BigInt)),ni)}else{for(const ni of Object.keys(un[0]))Qn[ni]=un.map(Ms=>Ms[ni]);if(!En)for(const ni of Object.keys(Qn))Qn[ni]=Qn[ni][0]}return Qn}_encode_text(de){if(de===null)return null;const Ie=this.added_tokens_splitter.split(de);for(let Ze=0;Ze<Ie.length;++Ze){const wt=this.added_tokens_map.get(Ie[Ze]);wt&&(wt.lstrip&&Ze>0&&(Ie[Ze-1]=Ie[Ze-1].trimEnd()),wt.rstrip&&Ze<Ie.length-1&&(Ie[Ze+1]=Ie[Ze+1].trimStart()))}return Ie.flatMap((Ze,wt)=>{if(Ze.length===0)return[];if(this.added_tokens_map.has(Ze))return[Ze];if(this.remove_space===!0&&(Ze=Ze.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(Ze=T(Ze)),this.normalizer!==null&&(Ze=this.normalizer(Ze)),Ze.length===0)return[];const $t=this.pre_tokenizer!==null?this.pre_tokenizer(Ze,{section_index:wt}):[Ze];return this.model($t)})}_encode_plus(de,{text_pair:Ie=null,add_special_tokens:Ke=!0,return_token_type_ids:Ze=null}={}){const{tokens:wt,token_type_ids:$t}=this._tokenize_helper(de,{pair:Ie,add_special_tokens:Ke}),vn=this.model.convert_tokens_to_ids(wt),bn={input_ids:vn,attention_mask:new Array(vn.length).fill(1)};return(Ze??this.return_token_type_ids)&&$t&&(bn.token_type_ids=$t),bn}_tokenize_helper(de,{pair:Ie=null,add_special_tokens:Ke=!1}={}){const Ze=this._encode_text(de),wt=this._encode_text(Ie);return this.post_processor?this.post_processor(Ze,wt,{add_special_tokens:Ke}):{tokens:(0,s.mergeArrays)(Ze??[],wt??[])}}tokenize(de,{pair:Ie=null,add_special_tokens:Ke=!1}={}){return this._tokenize_helper(de,{pair:Ie,add_special_tokens:Ke}).tokens}encode(de,{text_pair:Ie=null,add_special_tokens:Ke=!0,return_token_type_ids:Ze=null}={}){return this._encode_plus(de,{text_pair:Ie,add_special_tokens:Ke,return_token_type_ids:Ze}).input_ids}batch_decode(de,Ie={}){return de instanceof l.Tensor&&(de=de.tolist()),de.map(Ke=>this.decode(Ke,Ie))}decode(de,Ie={}){if(de instanceof l.Tensor&&(de=w(de)),!Array.isArray(de)||de.length===0||!(0,s.isIntegralNumber)(de[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(de,Ie)}decode_single(de,{skip_special_tokens:Ie=!1,clean_up_tokenization_spaces:Ke=null}){let Ze=this.model.convert_ids_to_tokens(de);Ie&&(Ze=Ze.filter($t=>!this.special_tokens.includes($t)));let wt=this.decoder?this.decoder(Ze):Ze.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(wt=wt.replaceAll(this.decoder.end_of_word_suffix," "),Ie&&(wt=wt.trim())),(Ke??this.clean_up_tokenization_spaces)&&(wt=S(wt)),wt}get_chat_template({chat_template:de=null,tools:Ie=null}={}){if(this.chat_template&&typeof this.chat_template=="object"){const Ke=this.chat_template;if(de!==null&&Object.hasOwn(Ke,de))de=Ke[de];else if(de===null)if(Ie!==null&&"tool_use"in Ke)de=Ke.tool_use;else if("default"in Ke)de=Ke.default;else throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(Ke).sort()}.`)}else if(de===null)if(this.chat_template)de=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");return de}apply_chat_template(de,{tools:Ie=null,documents:Ke=null,chat_template:Ze=null,add_generation_prompt:wt=!1,tokenize:$t=!0,padding:vn=!1,truncation:bn=!1,max_length:En=null,return_tensor:un=!0,return_dict:Qn=!1,tokenizer_kwargs:ni={},...Ms}={}){if(Ze=this.get_chat_template({chat_template:Ze,tools:Ie}),typeof Ze!="string")throw Error(`chat_template must be a string, but got ${typeof Ze}`);let bs=this._compiled_template_cache.get(Ze);bs===void 0&&(bs=new d.Template(Ze),this._compiled_template_cache.set(Ze,bs));const Ci=Object.create(null);for(const Ws of fe){const Wr=this.getToken(Ws);Wr&&(Ci[Ws]=Wr)}const ps=bs.render({messages:de,add_generation_prompt:wt,tools:Ie,documents:Ke,...Ci,...Ms});if($t){const Ws=this._call(ps,{add_special_tokens:!1,padding:vn,truncation:bn,max_length:En,return_tensor:un,...ni});return Qn?Ws:Ws.input_ids}return ps}}class F extends A{return_token_type_ids=!0}class K extends A{return_token_type_ids=!0}class Ee extends A{return_token_type_ids=!0}class k extends A{return_token_type_ids=!0}class re extends A{return_token_type_ids=!0}class Q extends A{return_token_type_ids=!0}class ve extends A{return_token_type_ids=!0}class ge extends A{return_token_type_ids=!0}class Le extends A{return_token_type_ids=!0}class rt extends A{}class nt extends A{}class ft extends A{return_token_type_ids=!0;constructor(de,Ie){super(de,Ie),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class yt extends A{return_token_type_ids=!0}class Ne extends A{}class Bt extends A{}class on extends A{}class xn extends A{constructor(de,Ie){super(de,Ie),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(Ke=>this.languageRegex.test(Ke)),this.lang_to_token=Ke=>Ke}_build_translation_inputs(de,Ie,Ke){return wn(this,de,Ie,Ke)}}class Bn extends xn{}class bi extends A{}class gn extends A{}const Mn="";class Se extends A{padding_side="left";constructor(de,Ie){super(de,Ie),this.legacy=Ie.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new Jt({replacement:Mn,prepend_scheme:"first"}))}_encode_text(de){if(de===null)return null;if(this.legacy||de.length===0)return super._encode_text(de);let Ie=super._encode_text(Mn+de.replaceAll(Mn," "));return Ie.length>1&&Ie[0]===Mn&&this.special_tokens.includes(Ie[1])&&(Ie=Ie.slice(1)),Ie}}class we extends A{}class Ge extends A{}class Je extends A{}class Ue extends A{}class Ot extends A{}class jt extends A{}class tn extends A{}class en extends A{}class dn extends A{}function wn(lt,de,Ie,Ke){if(!("language_codes"in lt)||!Array.isArray(lt.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in lt)||!(lt.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in lt)||typeof lt.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const Ze=Ke.src_lang,wt=Ke.tgt_lang;if(!lt.language_codes.includes(wt))throw new Error(`Target language code "${wt}" is not valid. Must be one of: {${lt.language_codes.join(", ")}}`);if(Ze!==void 0){if(!lt.language_codes.includes(Ze))throw new Error(`Source language code "${Ze}" is not valid. Must be one of: {${lt.language_codes.join(", ")}}`);for(const $t of lt.post_processor.config.single)if("SpecialToken"in $t&&lt.languageRegex.test($t.SpecialToken.id)){$t.SpecialToken.id=lt.lang_to_token(Ze);break}}return Ke.forced_bos_token_id=lt.model.convert_tokens_to_ids([lt.lang_to_token(wt)])[0],lt._call(de,Ie)}class _n extends A{constructor(de,Ie){super(de,Ie),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(Ke=>this.languageRegex.test(Ke)),this.lang_to_token=Ke=>Ke}_build_translation_inputs(de,Ie,Ke){return wn(this,de,Ie,Ke)}}class Fn extends A{constructor(de,Ie){super(de,Ie),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(Ke=>this.languageRegex.test(Ke)).map(Ke=>Ke.slice(2,-2)),this.lang_to_token=Ke=>`__${Ke}__`}_build_translation_inputs(de,Ie,Ke){return wn(this,de,Ie,Ke)}}class ti extends A{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(de,{return_timestamps:Ie=!1,return_language:Ke=!1,time_precision:Ze=null,force_full_sequences:wt=!0}={}){if(Ze===null)throw Error("Must specify time_precision");let $t=null;const vn=Ie==="word";function bn(){return{language:$t,timestamp:[null,null],text:""}}const En=[];let un=bn(),Qn=0;const ni=this.timestamp_begin,bs=ni+1500;let Ci=[],ps=[],Ws=!1,Wr=null;const Kr=new Set(this.all_special_ids);for(const es of de){const ms=es.tokens,Sr=vn?es.token_timestamps:null;let Fr=null,na=ni;if("stride"in es){const[Gs,Pi,ns]=es.stride;if(Qn-=Pi,Wr=Gs-ns,Pi&&(na=Pi/Ze+ni),ns)for(let Ns=ms.length-1;Ns>=0;--Ns){const Vs=Number(ms[Ns]);if(Vs>=ni){if(Fr!==null&&(Vs-ni)*Ze<Wr)break;Fr=Vs}}}let Ks=[],ia=[];for(let Gs=0;Gs<ms.length;++Gs){const Pi=Number(ms[Gs]);if(Kr.has(Pi)){const ns=this.decode([Pi]),Ns=g.WHISPER_LANGUAGE_MAPPING.get(ns.slice(2,-2));if(Ns!==void 0){if($t!==null&&Ns!==$t&&!Ie){Ci.push(Ks);const Vs=this.findLongestCommonSequence(Ci)[0],Ba=this.decode(Vs);un.text=Ba,En.push(un),Ci=[],Ks=[],un=bn()}$t=un.language=Ns}}else if(Pi>=ni&&Pi<=bs){const ns=(Pi-ni)*Ze+Qn,Ns=(0,o.round)(ns,2);if(Fr!==null&&Pi>=Fr)Ws=!0;else if(Ws||Ci.length>0&&Pi<na)Ws=!1;else if(un.timestamp[0]===null)un.timestamp[0]=Ns;else if(Ns!==un.timestamp[0]){un.timestamp[1]=Ns,Ci.push(Ks),vn&&ps.push(ia);const[Vs,Ba]=this.findLongestCommonSequence(Ci,ps),Dl=this.decode(Vs);un.text=Dl,vn&&(un.words=this.collateWordTimestamps(Vs,Ba,$t)),En.push(un),Ci=[],Ks=[],ps=[],ia=[],un=bn()}}else if(Ks.push(Pi),vn){let ns=(0,o.round)(Sr[Gs]+Qn,2),Ns;if(Gs+1<Sr.length){Ns=(0,o.round)(Sr[Gs+1]+Qn,2);const Vs=this.decode([Pi]);D.test(Vs)&&(Ns=(0,o.round)(Math.min(ns+Ze,Ns),2))}else Ns=null;ia.push([ns,Ns])}}if("stride"in es){const[Gs,Pi,ns]=es.stride;Qn+=Gs-ns}Ks.length>0?(Ci.push(Ks),vn&&ps.push(ia)):Ci.every(Gs=>Gs.length===0)&&(un=bn(),Ci=[],Ks=[],ps=[],ia=[])}if(Ci.length>0){if(wt&&Ie)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[es,ms]=this.findLongestCommonSequence(Ci,ps),Sr=this.decode(es);un.text=Sr,vn&&(un.words=this.collateWordTimestamps(es,ms,$t)),En.push(un)}let Bs=Object.create(null);const co=En.map(es=>es.text).join("");if(Ie||Ke){for(let es=0;es<En.length;++es){const ms=En[es];Ie||delete ms.timestamp,Ke||delete ms.language}if(vn){const es=[];for(const ms of En)for(const Sr of ms.words)es.push(Sr);Bs={chunks:es}}else Bs={chunks:En}}return[co,Bs]}findLongestCommonSequence(de,Ie=null){let Ke=de[0],Ze=Ke.length,wt=[];const $t=Array.isArray(Ie)&&Ie.length>0;let vn=$t?[]:null,bn=$t?Ie[0]:null;for(let En=1;En<de.length;++En){const un=de[En];let Qn=0,ni=[Ze,Ze,0,0];const Ms=un.length;for(let Bs=1;Bs<Ze+Ms;++Bs){const co=Math.max(0,Ze-Bs),es=Math.min(Ze,Ze+Ms-Bs),ms=Ke.slice(co,es),Sr=Math.max(0,Bs-Ze),Fr=Math.min(Ms,Bs),na=un.slice(Sr,Fr);if(ms.length!==na.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let Ks;$t?Ks=ms.filter((Pi,ns)=>Pi===na[ns]&&bn[co+ns]<=Ie[En][Sr+ns]).length:Ks=ms.filter((Pi,ns)=>Pi===na[ns]).length;const ia=Bs/1e4,Gs=Ks/Bs+ia;Ks>1&&Gs>Qn&&(Qn=Gs,ni=[co,es,Sr,Fr])}const[bs,Ci,ps,Ws]=ni,Wr=Math.floor((Ci+bs)/2),Kr=Math.floor((Ws+ps)/2);wt.push(...Ke.slice(0,Wr)),Ke=un.slice(Kr),Ze=Ke.length,$t&&(vn.push(...bn.slice(0,Wr)),bn=Ie[En].slice(Kr))}return wt.push(...Ke),$t?(vn.push(...bn),[wt,vn]):[wt,[]]}collateWordTimestamps(de,Ie,Ke){const[Ze,wt,$t]=this.combineTokensIntoWords(de,Ke),vn=[];for(let bn=0;bn<Ze.length;++bn){const En=$t[bn];vn.push({text:Ze[bn],timestamp:[Ie[En.at(0)][0],Ie[En.at(-1)][1]]})}return vn}combineTokensIntoWords(de,Ie,Ke=`"'([{-`,Ze=`"'.,!?:)]}`){Ie=Ie??"english";let wt,$t,vn;return["chinese","japanese","thai","lao","myanmar"].includes(Ie)?[wt,$t,vn]=this.splitTokensOnUnicode(de):[wt,$t,vn]=this.splitTokensOnSpaces(de),this.mergePunctuations(wt,$t,vn,Ke,Ze)}decode(de,Ie){let Ke;return Ie?.decode_with_timestamps?(de instanceof l.Tensor&&(de=w(de)),Ke=this.decodeWithTimestamps(de,Ie)):Ke=super.decode(de,Ie),Ke}decodeWithTimestamps(de,Ie){const Ke=Ie?.time_precision??.02,Ze=Array.from(this.all_special_ids).at(-1)+1;let wt=[[]];for(let $t of de)if($t=Number($t),$t>=Ze){const vn=(($t-Ze)*Ke).toFixed(2);wt.push(`<|${vn}|>`),wt.push([])}else wt[wt.length-1].push($t);return wt=wt.map($t=>typeof $t=="string"?$t:super.decode($t,Ie)),wt.join("")}splitTokensOnUnicode(de){const Ie=this.decode(de,{decode_with_timestamps:!0}),Ke="",Ze=[],wt=[],$t=[];let vn=[],bn=[],En=0;for(let un=0;un<de.length;++un){const Qn=de[un];vn.push(Qn),bn.push(un);const ni=this.decode(vn,{decode_with_timestamps:!0});(!ni.includes(Ke)||Ie[En+ni.indexOf(Ke)]===Ke)&&(Ze.push(ni),wt.push(vn),$t.push(bn),vn=[],bn=[],En+=ni.length)}return[Ze,wt,$t]}splitTokensOnSpaces(de){const[Ie,Ke,Ze]=this.splitTokensOnUnicode(de),wt=[],$t=[],vn=[],bn=new RegExp(`^[${P}]$`,"gu");for(let En=0;En<Ie.length;++En){const un=Ie[En],Qn=Ke[En],ni=Ze[En],Ms=Qn[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),bs=un.startsWith(" "),Ci=un.trim(),ps=bn.test(Ci);if(Ms||bs||ps||wt.length===0)wt.push(un),$t.push(Qn),vn.push(ni);else{const Ws=wt.length-1;wt[Ws]+=un,$t[Ws].push(...Qn),vn[Ws].push(...ni)}}return[wt,$t,vn]}mergePunctuations(de,Ie,Ke,Ze,wt){const $t=structuredClone(de),vn=structuredClone(Ie),bn=structuredClone(Ke);let En=$t.length-2,un=$t.length-1;for(;En>=0;)$t[En].startsWith(" ")&&Ze.includes($t[En].trim())?($t[un]=$t[En]+$t[un],vn[un]=(0,s.mergeArrays)(vn[En],vn[un]),bn[un]=(0,s.mergeArrays)(bn[En],bn[un]),$t[En]="",vn[En]=[],bn[En]=[]):un=En,--En;for(En=0,un=1;un<$t.length;)!$t[En].endsWith(" ")&&wt.includes($t[un])?($t[En]+=$t[un],vn[En]=(0,s.mergeArrays)(vn[En],vn[un]),bn[En]=(0,s.mergeArrays)(bn[En],bn[un]),$t[un]="",vn[un]=[],bn[un]=[]):En=un,++un;return[$t.filter(Qn=>Qn),vn.filter(Qn=>Qn.length>0),bn.filter(Qn=>Qn.length>0)]}}class Pn extends A{}class Ln extends A{}class Ct extends A{}class gt extends A{constructor(de,Ie){super(de,Ie),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(Ke=>this.languageRegex.test(Ke)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(de){if(de===null)return null;const[Ie,...Ke]=de.trim().split(this.languageRegex);if(Ke.length===0)return super._encode_text(Ie);if(Ke.length===2){const[Ze,wt]=Ke;return this.supported_language_codes.includes(Ze)||console.warn(`Unsupported language code "${Ze}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,s.mergeArrays)([Ze],super._encode_text(wt))}}}class Qt extends A{}class Nn extends A{}class Ss extends A{}class yr extends A{}class $i extends A{}class ma extends A{constructor(de,Ie){super(de,Ie),this.decoder=new bt({})}}class fi extends A{}class ks extends A{}class $s extends A{}class Ds{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:Ne,DistilBertTokenizer:rt,CamembertTokenizer:nt,DebertaTokenizer:re,DebertaV2Tokenizer:Q,BertTokenizer:F,HerbertTokenizer:ve,ConvBertTokenizer:ge,RoFormerTokenizer:Le,XLMTokenizer:ft,ElectraTokenizer:yt,MobileBertTokenizer:Ee,SqueezeBertTokenizer:k,AlbertTokenizer:K,GPT2Tokenizer:Bt,BartTokenizer:on,MBartTokenizer:xn,MBart50Tokenizer:Bn,RobertaTokenizer:bi,WhisperTokenizer:ti,CodeGenTokenizer:Pn,CLIPTokenizer:Ln,SiglipTokenizer:Ct,MarianTokenizer:gt,BloomTokenizer:gn,NllbTokenizer:_n,M2M100Tokenizer:Fn,LlamaTokenizer:Se,CodeLlamaTokenizer:we,XLMRobertaTokenizer:Ge,MPNetTokenizer:Je,FalconTokenizer:Ue,GPTNeoXTokenizer:Ot,EsmTokenizer:jt,Wav2Vec2CTCTokenizer:Qt,BlenderbotTokenizer:Nn,BlenderbotSmallTokenizer:Ss,SpeechT5Tokenizer:yr,NougatTokenizer:$i,VitsTokenizer:ma,Qwen2Tokenizer:tn,GemmaTokenizer:en,Grok1Tokenizer:dn,CohereTokenizer:fi,MgpstrTokenizer:ks,Ernie4_5_Tokenizer:$s,PreTrainedTokenizer:A};static async from_pretrained(de,{progress_callback:Ie=null,config:Ke=null,cache_dir:Ze=null,local_files_only:wt=!1,revision:$t="main",legacy:vn=null}={}){const[bn,En]=await p(de,{progress_callback:Ie,config:Ke,cache_dir:Ze,local_files_only:wt,revision:$t,legacy:vn}),un=En.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let Qn=this.TOKENIZER_CLASS_MAPPING[un];return Qn||(console.warn(`Unknown tokenizer class "${un}", attempting to construct from base class.`),Qn=A),new Qn(bn,En)}}}),"./src/utils/audio.js":((n,e,t)=>{t.r(e),t.d(e,{RawAudio:()=>J,hamming:()=>h,hanning:()=>p,mel_filter_bank:()=>C,read_audio:()=>d,spectrogram:()=>z,window_function:()=>U});var i=t("./src/utils/hub.js"),s=t("./src/utils/maths.js"),r=t("./src/utils/core.js"),o=t("./src/env.js"),l=t("./src/utils/tensor.js"),c=t("?7992");async function d(W,oe){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const ne=await(await(0,i.getFile)(W)).arrayBuffer(),q=new AudioContext({sampleRate:oe});typeof oe>"u"&&console.warn(`No sampling rate provided, using default of ${q.sampleRate}Hz.`);const le=await q.decodeAudioData(ne);let se;if(le.numberOfChannels===2){const pe=Math.sqrt(2),be=le.getChannelData(0),ee=le.getChannelData(1);se=new Float32Array(be.length);for(let te=0;te<le.length;++te)se[te]=pe*(be[te]+ee[te])/2}else se=le.getChannelData(0);return se}function g(W,oe){if(W<1)return new Float64Array;if(W===1)return new Float64Array([1]);const ne=1-oe,q=2*Math.PI/(W-1),le=new Float64Array(W);for(let se=0;se<W;++se)le[se]=oe-ne*Math.cos(se*q);return le}function p(W){return g(W,.5)}function h(W){return g(W,.54)}const v={htk:W=>2595*Math.log10(1+W/700),kaldi:W=>1127*Math.log(1+W/700),slaney:(W,oe=1e3,ne=15,q=27/Math.log(6.4))=>W>=oe?ne+Math.log(W/oe)*q:3*W/200};function y(W,oe="htk"){const ne=v[oe];if(!ne)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof W=="number"?ne(W):W.map(q=>ne(q))}const w={htk:W=>700*(10**(W/2595)-1),kaldi:W=>700*(Math.exp(W/1127)-1),slaney:(W,oe=1e3,ne=15,q=Math.log(6.4)/27)=>W>=ne?oe*Math.exp(q*(W-ne)):200*W/3};function S(W,oe="htk"){const ne=w[oe];if(!ne)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof W=="number"?ne(W):W.map(q=>ne(q))}function M(W,oe){const ne=Float64Array.from({length:oe.length-1},(pe,be)=>oe[be+1]-oe[be]),q=Array.from({length:W.length},()=>new Array(oe.length));for(let pe=0;pe<W.length;++pe){const be=q[pe];for(let ee=0;ee<oe.length;++ee)be[ee]=oe[ee]-W[pe]}const le=oe.length-2,se=Array.from({length:le},()=>new Array(W.length));for(let pe=0;pe<W.length;++pe){const be=q[pe];for(let ee=0;ee<le;++ee){const te=-be[ee]/ne[ee],ue=be[ee+2]/ne[ee+1];se[ee][pe]=Math.max(0,Math.min(te,ue))}}return se}function T(W,oe,ne){const q=(oe-W)/(ne-1);return Float64Array.from({length:ne},(le,se)=>W+q*se)}function C(W,oe,ne,q,le,se=null,pe="htk",be=!1){if(se!==null&&se!=="slaney")throw new Error('norm must be one of null or "slaney"');if(W<2)throw new Error(`Require num_frequency_bins: ${W} >= 2`);if(ne>q)throw new Error(`Require min_frequency: ${ne} <= max_frequency: ${q}`);const ee=y(ne,pe),te=y(q,pe),ue=T(ee,te,oe+2);let ae=S(ue,pe),ce;if(be){const He=le/((W-1)*2);ce=y(Float64Array.from({length:W},(Xe,ot)=>ot*He),pe),ae=ue}else ce=T(0,Math.floor(le/2),W);const Be=M(ce,ae);if(se!==null&&se==="slaney")for(let He=0;He<oe;++He){const Xe=Be[He],ot=2/(ae[He+2]-ae[He]);for(let tt=0;tt<W;++tt)Xe[tt]*=ot}return Be}function x(W,oe,ne){const q=new W.constructor(W.length+oe+ne),le=W.length-1;for(let se=0;se<W.length;++se)q[oe+se]=W[se];for(let se=1;se<=oe;++se)q[oe-se]=W[(0,r.calculateReflectOffset)(se,le)];for(let se=1;se<=ne;++se)q[le+oe+se]=W[(0,r.calculateReflectOffset)(le-se,le)];return q}function R(W,oe,ne,q,le){if(ne<=0)throw new Error("reference must be greater than zero");if(q<=0)throw new Error("min_value must be greater than zero");ne=Math.max(q,ne);const se=Math.log10(ne);for(let pe=0;pe<W.length;++pe)W[pe]=oe*Math.log10(Math.max(q,W[pe])-se);if(le!==null){if(le<=0)throw new Error("db_range must be greater than zero");const pe=(0,s.max)(W)[0]-le;for(let be=0;be<W.length;++be)W[be]=Math.max(W[be],pe)}return W}function P(W,oe=1,ne=1e-5,q=null){return R(W,20,oe,ne,q)}function D(W,oe=1,ne=1e-10,q=null){return R(W,10,oe,ne,q)}async function z(W,oe,ne,q,{fft_length:le=null,power:se=1,center:pe=!0,pad_mode:be="reflect",onesided:ee=!0,preemphasis:te=null,preemphasis_htk_flavor:ue=!0,mel_filters:ae=null,mel_floor:ce=1e-10,log_mel:Be=null,reference:He=1,min_value:Xe=1e-10,db_range:ot=null,remove_dc_offset:tt=null,min_num_frames:Ae=null,max_num_frames:ye=null,do_pad:xe=!0,transpose:ke=!1,mel_offset:ze=0}={}){const je=oe.length;if(le===null&&(le=ne),ne>le)throw Error(`frame_length (${ne}) may not be larger than fft_length (${le})`);if(je!==ne)throw new Error(`Length of the window (${je}) must equal frame_length (${ne})`);if(q<=0)throw new Error("hop_length must be greater than zero");if(se===null&&ae!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(!ue)throw new Error("`preemphasis_htk_flavor=false` is not currently supported.");if(pe)switch(be){case"reflect":{const at=Math.floor((le-1)/2)+1;W=x(W,at,at);break}case"constant":{const at=Math.floor(le/2),Et=new W.constructor(W.length+2*at);Et.set(W,at),W=Et;break}default:throw new Error(`pad_mode="${be}" not implemented yet.`)}let Fe=Math.floor(1+Math.floor((W.length-ne)/q));Ae!==null&&Fe<Ae&&(Fe=Ae);const Ye=ee?Math.floor(le/2)+1:le;let Ve=Fe,Qe=Fe;ye!==null&&(ye>Fe?xe&&(Qe=ye):Qe=Ve=ye);const mt=new s.FFT(le),Tt=new Float64Array(le),Me=new Float64Array(mt.outputBufferSize),me=new Float32Array(Ye*Qe);for(let at=0;at<Ve;++at){const Et=at*q,Dt=Math.min(W.length-Et,ne);Dt!==ne&&Tt.fill(0,0,ne);for(let Vt=0;Vt<Dt;++Vt)Tt[Vt]=W[Et+Vt];if(tt){let Vt=0;for(let bt=0;bt<Dt;++bt)Vt+=Tt[bt];const an=Vt/Dt;for(let bt=0;bt<Dt;++bt)Tt[bt]-=an}if(te!==null){for(let Vt=Dt-1;Vt>=1;--Vt)Tt[Vt]-=te*Tt[Vt-1];Tt[0]*=1-te}for(let Vt=0;Vt<oe.length;++Vt)Tt[Vt]*=oe[Vt];mt.realTransform(Me,Tt);for(let Vt=0;Vt<Ye;++Vt){const an=Vt<<1;me[Vt*Qe+at]=Me[an]**2+Me[an+1]**2}}if(se!==null&&se!==2){const at=se/2;for(let Et=0;Et<me.length;++Et)me[Et]**=at}const $e=ae.length;let et=await(0,l.matmul)(new l.Tensor("float32",ae.flat(),[$e,Ye]),new l.Tensor("float32",me,[Ye,Qe]));ke&&(et=et.transpose(1,0));const ht=et.data;for(let at=0;at<ht.length;++at)ht[at]=ze+Math.max(ce,ht[at]);if(se!==null&&Be!==null){const at=Math.min(ht.length,Ve*$e);switch(Be){case"log":for(let Et=0;Et<at;++Et)ht[Et]=Math.log(ht[Et]);break;case"log10":for(let Et=0;Et<at;++Et)ht[Et]=Math.log10(ht[Et]);break;case"dB":if(se===1)P(ht,He,Xe,ot);else if(se===2)D(ht,He,Xe,ot);else throw new Error(`Cannot use log_mel option '${Be}' with power ${se}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${Be}'`)}}return et}function U(W,oe,{periodic:ne=!0,frame_length:q=null,center:le=!0}={}){const se=ne?W+1:W;let pe;switch(oe){case"boxcar":pe=new Float64Array(se).fill(1);break;case"hann":case"hann_window":pe=p(se);break;case"hamming":pe=h(se);break;case"povey":pe=p(se).map(be=>Math.pow(be,.85));break;default:throw new Error(`Unknown window type ${oe}.`)}if(ne&&(pe=pe.subarray(0,W)),q===null)return pe;if(W>q)throw new Error(`Length of the window (${W}) may not be larger than frame_length (${q})`);return pe}function N(W,oe){let ne=44;const q=new ArrayBuffer(ne+W.length*4),le=new DataView(q);j(le,0,"RIFF"),le.setUint32(4,36+W.length*4,!0),j(le,8,"WAVE"),j(le,12,"fmt "),le.setUint32(16,16,!0),le.setUint16(20,3,!0),le.setUint16(22,1,!0),le.setUint32(24,oe,!0),le.setUint32(28,oe*4,!0),le.setUint16(32,4,!0),le.setUint16(34,32,!0),j(le,36,"data"),le.setUint32(40,W.length*4,!0);for(let se=0;se<W.length;++se,ne+=4)le.setFloat32(ne,W[se],!0);return q}function j(W,oe,ne){for(let q=0;q<ne.length;++q)W.setUint8(oe+q,ne.charCodeAt(q))}class J{constructor(oe,ne){this.audio=oe,this.sampling_rate=ne}toWav(){return N(this.audio,this.sampling_rate)}toBlob(){const oe=this.toWav();return new Blob([oe],{type:"audio/wav"})}async save(oe){let ne;if(o.apis.IS_BROWSER_ENV){if(o.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save a file from a Web Worker.");ne=r.saveBlob}else if(o.apis.IS_FS_AVAILABLE)ne=async(q,le)=>{let se=await le.arrayBuffer();c.writeFileSync(q,Buffer.from(se))};else throw new Error("Unable to save because filesystem is disabled in this environment.");await ne(oe,this.toBlob())}}}),"./src/utils/constants.js":((n,e,t)=>{t.r(e),t.d(e,{CHAT_TEMPLATE_NAME:()=>c,CONFIG_NAME:()=>s,FEATURE_EXTRACTOR_NAME:()=>r,GENERATION_CONFIG_NAME:()=>d,GITHUB_ISSUE_URL:()=>i,IMAGE_PROCESSOR_NAME:()=>o,PROCESSOR_NAME:()=>l});const i="https://github.com/huggingface/transformers.js/issues/new/choose",s="config.json",r="preprocessor_config.json",o=r,l="processor_config.json",c="chat_template.jinja",d="generation_config.json"}),"./src/utils/core.js":((n,e,t)=>{t.r(e),t.d(e,{calculateDimensions:()=>d,calculateReflectOffset:()=>v,count:()=>M,dispatchCallback:()=>i,escapeRegExp:()=>r,isIntegralNumber:()=>l,isNullishDimension:()=>c,isTypedArray:()=>o,len:()=>S,mergeArrays:()=>p,pick:()=>w,pop:()=>g,product:()=>h,reverseDictionary:()=>s,saveBlob:()=>y});function i(T,C){T&&T(C)}function s(T){return Object.fromEntries(Object.entries(T).map(([C,x])=>[x,C]))}function r(T){return T.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function o(T){return T?.prototype?.__proto__?.constructor?.name==="TypedArray"}function l(T){return Number.isInteger(T)||typeof T=="bigint"}function c(T){return T==null||T===-1}function d(T){const C=[];let x=T;for(;Array.isArray(x);)C.push(x.length),x=x[0];return C}function g(T,C,x=void 0){const R=T[C];if(R!==void 0)return delete T[C],R;if(x===void 0)throw Error(`Key ${C} does not exist in object.`);return x}function p(...T){return Array.prototype.concat.apply([],T)}function h(...T){return T.reduce((C,x)=>C.flatMap(R=>x.map(P=>[R,P])))}function v(T,C){return Math.abs((T+C)%(2*C)-C)}function y(T,C){const x=URL.createObjectURL(C),R=document.createElement("a");R.href=x,R.download=T,R.click(),R.remove(),URL.revokeObjectURL(x)}function w(T,C){return Object.assign({},...C.map(x=>{if(T[x]!==void 0)return{[x]:T[x]}}))}function S(T){let C=0;for(const x of T)++C;return C}function M(T,C){let x=0;for(const R of T)R===C&&++x;return x}}),"./src/utils/data-structures.js":((n,e,t)=>{t.r(e),t.d(e,{CharTrie:()=>s,DictionarySplitter:()=>c,LRUCache:()=>d,PriorityQueue:()=>i,TokenLattice:()=>o});class i{constructor(p=(v,y)=>v>y,h=1/0){this._heap=[],this._comparator=p,this._maxSize=h}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...p){return this.extend(p)}extend(p){for(const h of p)if(this.size<this._maxSize)this._heap.push(h),this._siftUp();else{const v=this._smallest();this._comparator(h,this._heap[v])&&(this._heap[v]=h,this._siftUpFrom(v))}return this.size}pop(){const p=this.peek(),h=this.size-1;return h>0&&this._swap(0,h),this._heap.pop(),this._siftDown(),p}replace(p){const h=this.peek();return this._heap[0]=p,this._siftDown(),h}_parent(p){return(p+1>>>1)-1}_left(p){return(p<<1)+1}_right(p){return p+1<<1}_greater(p,h){return this._comparator(this._heap[p],this._heap[h])}_swap(p,h){const v=this._heap[p];this._heap[p]=this._heap[h],this._heap[h]=v}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(p){for(;p>0&&this._greater(p,this._parent(p));)this._swap(p,this._parent(p)),p=this._parent(p)}_siftDown(){let p=0;for(;this._left(p)<this.size&&this._greater(this._left(p),p)||this._right(p)<this.size&&this._greater(this._right(p),p);){const h=this._right(p)<this.size&&this._greater(this._right(p),this._left(p))?this._right(p):this._left(p);this._swap(p,h),p=h}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class s{constructor(){this.root=r.default()}extend(p){for(const h of p)this.push(h)}push(p){let h=this.root;for(const v of p){let y=h.children.get(v);y===void 0&&(y=r.default(),h.children.set(v,y)),h=y}h.isLeaf=!0}*commonPrefixSearch(p){let h=this.root;if(h===void 0)return;let v="";for(const y of p){if(v+=y,h=h.children.get(y),h===void 0)return;h.isLeaf&&(yield v)}}}class r{constructor(p,h){this.isLeaf=p,this.children=h}static default(){return new r(!1,new Map)}}class o{constructor(p,h,v){this.chars=Array.from(p),this.len=this.chars.length,this.bosTokenId=h,this.eosTokenId=v,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const y=new l(this.bosTokenId,0,0,0,0),w=new l(this.eosTokenId,1,this.len,0,0);this.nodes.push(y.clone()),this.nodes.push(w.clone()),this.beginNodes[this.len].push(w),this.endNodes[0].push(y)}insert(p,h,v,y){const w=this.nodes.length,S=new l(y,w,p,h,v);this.beginNodes[p].push(S),this.endNodes[p+h].push(S),this.nodes.push(S)}viterbi(){const p=this.len;let h=0;for(;h<=p;){if(this.beginNodes[h].length==0)return[];for(let M of this.beginNodes[h]){M.prev=null;let T=0,C=null;for(let x of this.endNodes[h]){const R=x.backtraceScore+M.score;(C===null||R>T)&&(C=x.clone(),T=R)}if(C!==null)M.prev=C,M.backtraceScore=T;else return[]}++h}const v=[],w=this.beginNodes[p][0].prev;if(w===null)return[];let S=w.clone();for(;S.prev!==null;)v.push(S.clone()),S=S.clone().prev.clone();return v.reverse(),v}piece(p){return this.chars.slice(p.pos,p.pos+p.length).join("")}tokens(){return this.viterbi().map(h=>this.piece(h))}tokenIds(){return this.viterbi().map(h=>h.tokenId)}}class l{constructor(p,h,v,y,w){this.tokenId=p,this.nodeId=h,this.pos=v,this.length=y,this.score=w,this.prev=null,this.backtraceScore=0}clone(){const p=new l(this.tokenId,this.nodeId,this.pos,this.length,this.score);return p.prev=this.prev,p.backtraceScore=this.backtraceScore,p}}class c{constructor(p){this.trie=this._buildTrie(p)}_buildTrie(p){const h=Object.create(null);for(const v of p){let y=h;for(let w=0;w<v.length;++w)y=y[v[w]]??=Object.create(null);y.end=v}return h}split(p){const h=[],v=p.length;let y=0,w=0;for(;w<v;){let S=this.trie,M=null,T=w;for(;T<v&&(S=S[p[T]]);)S.end&&(M=S.end),++T;M?(w>y&&h.push(p.slice(y,w)),h.push(M),w+=M.length,y=w):++w}return y<v&&h.push(p.slice(y)),h}}class d{constructor(p){this.capacity=p,this.cache=new Map}get(p){if(!this.cache.has(p))return;const h=this.cache.get(p);return this.cache.delete(p),this.cache.set(p,h),h}put(p,h){this.cache.has(p)&&this.cache.delete(p),this.cache.set(p,h),this.cache.size>this.capacity&&this.cache.delete(this.cache.keys().next().value)}clear(){this.cache.clear()}}}),"./src/utils/devices.js":((n,e,t)=>{t.r(e),t.d(e,{DEVICE_TYPES:()=>i});const i=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})}),"./src/utils/dtypes.js":((n,e,t)=>{t.r(e),t.d(e,{DATA_TYPES:()=>o,DEFAULT_DEVICE_DTYPE_MAPPING:()=>l,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>c,isWebGpuFp16Supported:()=>r});var i=t("./src/env.js"),s=t("./src/utils/devices.js");const r=(function(){let d;return async function(){if(d===void 0)if(!i.apis.IS_WEBGPU_AVAILABLE)d=!1;else try{d=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{d=!1}return d}})(),o=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),l=Object.freeze({[s.DEVICE_TYPES.wasm]:o.q8}),c=Object.freeze({[o.fp32]:"",[o.fp16]:"_fp16",[o.int8]:"_int8",[o.uint8]:"_uint8",[o.q8]:"_quantized",[o.q4]:"_q4",[o.q4f16]:"_q4f16",[o.bnb4]:"_bnb4"})}),"./src/utils/generic.js":((n,e,t)=>{t.r(e),t.d(e,{Callable:()=>i});const i=class{constructor(){let s=function(...r){return s._call(...r)};return Object.setPrototypeOf(s,new.target.prototype)}_call(...s){throw Error("Must implement _call method in subclass")}}}),"./src/utils/hub.js":((n,e,t)=>{t.r(e),t.d(e,{MAX_EXTERNAL_DATA_CHUNKS:()=>l,getFile:()=>v,getModelFile:()=>T,getModelJSON:()=>x,getModelText:()=>C});var i=t("?7992"),s=t("?5af5"),r=t("./src/env.js"),o=t("./src/utils/core.js");const l=100,c={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class d{constructor(z){if(this.filePath=z,this.headers=new Headers,this.exists=i.existsSync(z),this.exists){this.status=200,this.statusText="OK";let U=i.statSync(z);this.headers.set("content-length",U.size.toString()),this.updateContentType();const N=i.createReadStream(z);this.body=new ReadableStream({start(j){N.on("data",J=>j.enqueue(J)),N.on("end",()=>j.close()),N.on("error",J=>j.error(J))},cancel(){N.destroy()}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const z=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",c[z]??"application/octet-stream")}clone(){let z=new d(this.filePath);return z.exists=this.exists,z.status=this.status,z.statusText=this.statusText,z.headers=new Headers(this.headers),z}async arrayBuffer(){return(await i.promises.readFile(this.filePath)).buffer}async blob(){const z=await i.promises.readFile(this.filePath);return new Blob([z],{type:this.headers.get("content-type")})}async text(){return await i.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function g(D,z=null,U=null){let N;try{N=new URL(D)}catch{return!1}return!(z&&!z.includes(N.protocol)||U&&!U.includes(N.hostname))}const p=/^(\b[\w\-.]+\b\/)?\b[\w\-.]{1,96}\b$/;function h(D){return!(!p.test(D)||D.includes("..")||D.includes("--")||D.endsWith(".git")||D.endsWith(".ipynb"))}async function v(D){if(r.env.useFS&&!g(D,["http:","https:","blob:"]))return new d(D instanceof URL?D.protocol==="file:"?D.pathname:D.toString():D);if(typeof process<"u"&&process?.release?.name==="node"){const z=!!gE?.TESTING_REMOTELY,U=r.env.version,N=new Headers;if(N.set("User-Agent",`transformers.js/${U}; is_ci/${z};`),g(D,["http:","https:"],["huggingface.co","hf.co"])){const J=gE?.HF_TOKEN??gE?.HF_ACCESS_TOKEN;J&&N.set("Authorization",`Bearer ${J}`)}return fetch(D,{headers:N})}else return fetch(D)}const y={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function w(D,z,U){if(!U)return null;const N=y[D]??`Error (${D}) occurred while trying to load file`;throw Error(`${N}: "${z}".`)}class S{constructor(z){this.path=z}async match(z){let U=s.join(this.path,z),N=new d(U);if(N.exists)return N}async put(z,U,N=void 0){let j=s.join(this.path,z);try{const J=U.headers.get("Content-Length"),W=parseInt(J??"0");let oe=0;await i.promises.mkdir(s.dirname(j),{recursive:!0});const ne=i.createWriteStream(j),q=U.body.getReader();for(;;){const{done:le,value:se}=await q.read();if(le)break;await new Promise((be,ee)=>{ne.write(se,te=>{if(te){ee(te);return}be()})}),oe+=se.length;const pe=W?oe/W*100:0;N?.({progress:pe,loaded:oe,total:W})}ne.close()}catch(J){try{await i.promises.unlink(j)}catch{}throw J}}}async function M(D,...z){for(let U of z)try{let N=await D.match(U);if(N)return N}catch{continue}}async function T(D,z,U=!0,N={},j=!1){if(!r.env.allowLocalModels){if(N.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!r.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,o.dispatchCallback)(N.progress_callback,{status:"initiate",name:D,file:z});let J;if(!J&&r.env.useCustomCache){if(!r.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!r.env.customCache.match||!r.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");J=r.env.customCache}if(!J&&r.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{J=await caches.open("transformers-cache")}catch(ce){console.warn("An error occurred while opening the browser cache:",ce)}}if(!J&&r.env.useFSCache){if(!r.apis.IS_FS_AVAILABLE)throw Error("File System Cache is not available in this environment.");J=new S(N.cache_dir??r.env.cacheDir)}const W=N.revision??"main",oe=P(D,z),ne=h(D),q=ne?P(r.env.localModelPath,oe):oe,le=P(r.env.remoteHost,r.env.remotePathTemplate.replaceAll("{model}",D).replaceAll("{revision}",encodeURIComponent(W)),z);let se;const pe=J instanceof S?W==="main"?oe:P(D,W,z):le;let be=!1,ee;J&&(ee=await M(J,q,pe));const te=ee!==void 0;if(ee===void 0){if(r.env.allowLocalModels)if(g(oe,["http:","https:"])){if(N.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${oe}.`);if(!r.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${oe}.`)}else try{ee=await v(q),se=q}catch(Be){console.warn(`Unable to load from local path "${q}": "${Be}"`)}if(ee===void 0||ee.status===404){if(N.local_files_only||!r.env.allowRemoteModels){if(U)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${q}".`);return null}if(!ne)throw Error(`Local file missing at "${q}" and download aborted due to invalid model ID "${D}".`);if(ee=await v(le),ee.status!==200)return w(ee.status,le,U);se=pe}be=J&&typeof Response<"u"&&ee instanceof Response&&ee.status===200}(0,o.dispatchCallback)(N.progress_callback,{status:"download",name:D,file:z});let ue;if(!(r.apis.IS_NODE_ENV&&j)){let ce;N.progress_callback?te&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(ce=new Uint8Array(await ee.arrayBuffer()),(0,o.dispatchCallback)(N.progress_callback,{status:"progress",name:D,file:z,progress:100,loaded:ce.length,total:ce.length})):ce=await R(ee,Be=>{(0,o.dispatchCallback)(N.progress_callback,{status:"progress",name:D,file:z,...Be})}):ce=new Uint8Array(await ee.arrayBuffer()),ue=ce}if(be&&se&&await J.match(se)===void 0)if(ue)await J.put(se,new Response(ue,{headers:ee.headers})).catch(ce=>{console.warn(`Unable to add response to browser cache: ${ce}.`)});else{const ce=N.progress_callback?Be=>(0,o.dispatchCallback)(N.progress_callback,{status:"progress",name:D,file:z,...Be}):void 0;await J.put(se,ee,ce)}if((0,o.dispatchCallback)(N.progress_callback,{status:"done",name:D,file:z}),ue){if(!r.apis.IS_NODE_ENV&&j)throw new Error("Cannot return path in a browser environment.");return ue}if(ee instanceof d)return ee.filePath;const ae=await J?.match(se);if(ae instanceof d)return ae.filePath;if(ae instanceof Response)return new Uint8Array(await ae.arrayBuffer());if(typeof ae=="string")return ae;throw new Error("Unable to get model file path or buffer.")}async function C(D,z,U=!0,N={}){const j=await T(D,z,U,N,!1);return j===null?null:new TextDecoder("utf-8").decode(j)}async function x(D,z,U=!0,N={}){const j=await C(D,z,U,N);return j===null?{}:JSON.parse(j)}async function R(D,z){const U=D.headers.get("Content-Length");U===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let N=parseInt(U??"0"),j=new Uint8Array(N),J=0;const W=D.body.getReader();async function oe(){const{done:ne,value:q}=await W.read();if(ne)return;const le=J+q.length;if(le>N){N=le;const pe=new Uint8Array(N);pe.set(j),j=pe}j.set(q,J),J=le;const se=J/N*100;return z({progress:se,loaded:J,total:N}),oe()}return await oe(),j}function P(...D){return D=D.map((z,U)=>(U&&(z=z.replace(new RegExp("^/"),"")),U!==D.length-1&&(z=z.replace(new RegExp("/$"),"")),z)),D.join("/")}}),"./src/utils/image.js":((n,e,t)=>{t.r(e),t.d(e,{RawImage:()=>y,load_image:()=>w});var i=t("./src/utils/core.js"),s=t("./src/utils/hub.js"),r=t("./src/env.js"),o=t("./src/utils/tensor.js"),l=t("?2b25");let c,d,g;const p=r.apis.IS_BROWSER_ENV||r.apis.IS_WEBWORKER_ENV;if(p)c=(S,M)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(S,M)},g=self.createImageBitmap,d=self.ImageData;else if(l)g=async S=>{const T=(await S.metadata()).channels,{data:C,info:x}=await S.rotate().raw().toBuffer({resolveWithObject:!0}),R=new y(new Uint8ClampedArray(C),x.width,x.height,x.channels);return T!==void 0&&T!==x.channels&&R.convert(T),R};else throw new Error("Unable to load image processing library.");const h={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},v=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class y{constructor(M,T,C,x){this.data=M,this.width=T,this.height=C,this.channels=x}get size(){return[this.width,this.height]}static async read(M){if(M instanceof y)return M;if(typeof M=="string"||M instanceof URL)return await this.fromURL(M);if(M instanceof Blob)return await this.fromBlob(M);if(typeof HTMLCanvasElement<"u"&&M instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&M instanceof OffscreenCanvas)return this.fromCanvas(M);throw new Error(`Unsupported input type: ${typeof M}`)}static fromCanvas(M){if(!p)throw new Error("fromCanvas() is only supported in browser environments.");const C=M.getContext("2d").getImageData(0,0,M.width,M.height).data;return new y(C,M.width,M.height,4)}static async fromURL(M){const T=await(0,s.getFile)(M);if(T.status!==200)throw new Error(`Unable to read image from "${M}" (${T.status} ${T.statusText})`);const C=await T.blob();return this.fromBlob(C)}static async fromBlob(M){if(p){const T=await g(M),C=c(T.width,T.height).getContext("2d");return C.drawImage(T,0,0),new this(C.getImageData(0,0,T.width,T.height).data,T.width,T.height,4)}else{const T=l(await M.arrayBuffer());return await g(T)}}static fromTensor(M,T="CHW"){if(M.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${M.dims.length} dimensions.`);if(T==="CHW")M=M.transpose(1,2,0);else if(T!=="HWC")throw new Error(`Unsupported channel format: ${T}`);if(!(M.data instanceof Uint8ClampedArray||M.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${M.type}`);switch(M.dims[2]){case 1:case 2:case 3:case 4:return new y(M.data,M.dims[1],M.dims[0],M.dims[2]);default:throw new Error(`Unsupported number of channels: ${M.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const M=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let T=0,C=0;T<this.data.length;T+=this.channels){const x=this.data[T],R=this.data[T+1],P=this.data[T+2];M[C++]=Math.round(.2989*x+.587*R+.114*P)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(M,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const M=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let T=0,C=0;T<this.data.length;++T)M[C++]=this.data[T],M[C++]=this.data[T],M[C++]=this.data[T];break;case 4:for(let T=0,C=0;T<this.data.length;T+=4)M[C++]=this.data[T],M[C++]=this.data[T+1],M[C++]=this.data[T+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(M,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const M=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let T=0,C=0;T<this.data.length;++T)M[C++]=this.data[T],M[C++]=this.data[T],M[C++]=this.data[T],M[C++]=255;break;case 3:for(let T=0,C=0;T<this.data.length;T+=3)M[C++]=this.data[T],M[C++]=this.data[T+1],M[C++]=this.data[T+2],M[C++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(M,this.width,this.height,4)}putAlpha(M){if(M.width!==this.width||M.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${M.width}x${M.height}`);if(M.channels!==1)throw new Error(`Expected mask to have 1 channel, but got ${M.channels}`);const T=this.data,C=M.data,x=this.width*this.height;if(this.channels===3){const R=new Uint8ClampedArray(x*4);for(let P=0,D=0,z=0;P<x;++P)R[z++]=T[D++],R[z++]=T[D++],R[z++]=T[D++],R[z++]=C[P];return this._update(R,this.width,this.height,4)}else if(this.channels===4){for(let R=0;R<x;++R)T[4*R+3]=C[R];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(M,T,{resample:C=2}={}){if(this.width===M&&this.height===T)return this;let x=h[C]??C;const R=(0,i.isNullishDimension)(M),P=(0,i.isNullishDimension)(T);if(R&&P)return this;if(R?M=T/this.height*this.width:P&&(T=M/this.width*this.height),p){const D=this.channels,z=this.toCanvas(),U=c(M,T).getContext("2d");return U.drawImage(z,0,0,M,T),new y(U.getImageData(0,0,M,T).data,M,T,4).convert(D)}else{let D=this.toSharp();switch(x){case"box":case"hamming":(x==="box"||x==="hamming")&&(console.warn(`Resampling method ${x} is not yet supported. Using bilinear instead.`),x="bilinear");case"nearest":case"bilinear":case"bicubic":D=D.affine([M/this.width,0,0,T/this.height],{interpolator:x});break;case"lanczos":D=D.resize({width:M,height:T,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${x} is not supported.`)}return await g(D)}}async pad([M,T,C,x]){if(M=Math.max(M,0),T=Math.max(T,0),C=Math.max(C,0),x=Math.max(x,0),M===0&&T===0&&C===0&&x===0)return this;if(p){const R=this.channels,P=this.toCanvas(),D=this.width+M+T,z=this.height+C+x,U=c(D,z).getContext("2d");return U.drawImage(P,0,0,this.width,this.height,M,C,this.width,this.height),new y(U.getImageData(0,0,D,z).data,D,z,4).convert(R)}else{const R=this.toSharp().extend({left:M,right:T,top:C,bottom:x});return await g(R)}}async crop([M,T,C,x]){if(M=Math.max(M,0),T=Math.max(T,0),C=Math.min(C,this.width-1),x=Math.min(x,this.height-1),M===0&&T===0&&C===this.width-1&&x===this.height-1)return this;const R=C-M+1,P=x-T+1;if(p){const D=this.channels,z=this.toCanvas(),U=c(R,P).getContext("2d");return U.drawImage(z,M,T,R,P,0,0,R,P),new y(U.getImageData(0,0,R,P).data,R,P,4).convert(D)}else{const D=this.toSharp().extract({left:M,top:T,width:R,height:P});return await g(D)}}async center_crop(M,T){if(this.width===M&&this.height===T)return this;const C=(this.width-M)/2,x=(this.height-T)/2;if(p){const R=this.channels,P=this.toCanvas(),D=c(M,T).getContext("2d");let z=0,U=0,N=0,j=0;return C>=0?z=C:N=-C,x>=0?U=x:j=-x,D.drawImage(P,z,U,M,T,N,j,M,T),new y(D.getImageData(0,0,M,T).data,M,T,4).convert(R)}else{let R=this.toSharp();if(C>=0&&x>=0)R=R.extract({left:Math.floor(C),top:Math.floor(x),width:M,height:T});else if(C<=0&&x<=0){const P=Math.floor(-x),D=Math.floor(-C);R=R.extend({top:P,left:D,right:M-this.width-D,bottom:T-this.height-P})}else{let P=[0,0],D=0;x<0?(P[0]=Math.floor(-x),P[1]=T-this.height-P[0]):D=Math.floor(x);let z=[0,0],U=0;C<0?(z[0]=Math.floor(-C),z[1]=M-this.width-z[0]):U=Math.floor(C),R=R.extend({top:P[0],bottom:P[1],left:z[0],right:z[1]}).extract({left:U,top:D,width:M,height:T})}return await g(R)}}async toBlob(M="image/png",T=1){if(!p)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:M,quality:T})}toTensor(M="CHW"){let T=new o.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(M!=="HWC")if(M==="CHW")T=T.permute(2,0,1);else throw new Error(`Unsupported channel format: ${M}`);return T}toCanvas(){if(!p)throw new Error("toCanvas() is only supported in browser environments.");const M=this.clone().rgba(),T=c(M.width,M.height),C=new d(M.data,M.width,M.height);return T.getContext("2d").putImageData(C,0,0),T}split(){const{data:M,width:T,height:C,channels:x}=this,R=M.constructor,P=M.length/x,D=Array.from({length:x},()=>new R(P));for(let z=0;z<P;++z){const U=x*z;for(let N=0;N<x;++N)D[N][z]=M[U+N]}return D.map(z=>new y(z,T,C,1))}_update(M,T,C,x=null){return this.data=M,this.width=T,this.height=C,x!==null&&(this.channels=x),this}clone(){return new y(this.data.slice(),this.width,this.height,this.channels)}convert(M){if(this.channels===M)return this;switch(M){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(M){if(p){if(r.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const T=M.split(".").pop().toLowerCase(),C=v.get(T)??"image/png",x=await this.toBlob(C);(0,i.saveBlob)(M,x)}else{if(r.apis.IS_FS_AVAILABLE)return await this.toSharp().toFile(M);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(p)throw new Error("toSharp() is only supported in server-side environments.");return l(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}const w=y.read.bind(y)}),"./src/utils/maths.js":((n,e,t)=>{t.r(e),t.d(e,{FFT:()=>w,bankers_round:()=>T,cos_sim:()=>c,dot:()=>l,dynamic_time_warping:()=>C,interpolate_data:()=>i,log_softmax:()=>o,magnitude:()=>d,max:()=>p,medianFilter:()=>S,min:()=>g,permute_data:()=>s,round:()=>M,softmax:()=>r});function i(x,[R,P,D],[z,U],N="bilinear",j=!1){const J=U/D,W=z/P,oe=new x.constructor(z*U*R),ne=P*D,q=z*U;for(let le=0;le<z;++le)for(let se=0;se<U;++se){const pe=le*U+se,be=(se+.5)/J-.5,ee=(le+.5)/W-.5;let te=Math.floor(be),ue=Math.floor(ee);const ae=Math.min(te+1,D-1),ce=Math.min(ue+1,P-1);te=Math.max(te,0),ue=Math.max(ue,0);const Be=be-te,He=ee-ue,Xe=(1-Be)*(1-He),ot=Be*(1-He),tt=(1-Be)*He,Ae=Be*He,ye=ue*D,xe=ce*D,ke=ye+te,ze=ye+ae,je=xe+te,Fe=xe+ae;for(let Ye=0;Ye<R;++Ye){const Ve=Ye*ne;oe[Ye*q+pe]=Xe*x[Ve+ke]+ot*x[Ve+ze]+tt*x[Ve+je]+Ae*x[Ve+Fe]}}return oe}function s(x,R,P){const D=new Array(P.length),z=new Array(P.length);for(let j=P.length-1,J=1;j>=0;--j)z[j]=J,D[j]=R[P[j]],J*=D[j];const U=P.map((j,J)=>z[P.indexOf(J)]),N=new x.constructor(x.length);for(let j=0;j<x.length;++j){let J=0;for(let W=R.length-1,oe=j;W>=0;--W)J+=oe%R[W]*U[W],oe=Math.floor(oe/R[W]);N[J]=x[j]}return[N,D]}function r(x){const R=p(x)[0],P=x.map(U=>Math.exp(U-R)),D=P.reduce((U,N)=>U+N,0);return P.map(U=>U/D)}function o(x){const R=p(x)[0];let P=0;for(let U=0;U<x.length;++U)P+=Math.exp(x[U]-R);const D=Math.log(P);return x.map(U=>U-R-D)}function l(x,R){let P=0;for(let D=0;D<x.length;++D)P+=x[D]*R[D];return P}function c(x,R){const P=l(x,R),D=d(x),z=d(R);return P/(D*z)}function d(x){return Math.sqrt(x.reduce((R,P)=>R+P*P,0))}function g(x){if(x.length===0)throw Error("Array must not be empty");let R=x[0],P=0;for(let D=1;D<x.length;++D)x[D]<R&&(R=x[D],P=D);return[R,P]}function p(x){if(x.length===0)throw Error("Array must not be empty");let R=x[0],P=0;for(let D=1;D<x.length;++D)x[D]>R&&(R=x[D],P=D);return[R,P]}function h(x){return x>0&&(x&x-1)===0}class v{constructor(R){if(this.size=R|0,this.size<=1||!h(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=R<<1,this.table=new Float64Array(this.size*2);for(let D=0;D<this.table.length;D+=2){const z=Math.PI*D/this.size;this.table[D]=Math.cos(z),this.table[D+1]=-Math.sin(z)}let P=0;for(let D=1;this.size>D;D<<=1)++P;this._width=P%2===0?P-1:P,this._bitrev=new Int32Array(1<<this._width);for(let D=0;D<this._bitrev.length;++D){this._bitrev[D]=0;for(let z=0;z<this._width;z+=2){const U=this._width-z-2;this._bitrev[D]|=(D>>>z&3)<<U}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(R,P){const D=P||new Array(R.length>>>1);for(let z=0;z<R.length;z+=2)D[z>>>1]=R[z];return D}toComplexArray(R,P){const D=P||this.createComplexArray();for(let z=0;z<D.length;z+=2)D[z]=R[z>>>1],D[z+1]=0;return D}transform(R,P){if(R===P)throw new Error("Input and output buffers must be different");this._transform4(R,P,1)}realTransform(R,P){if(R===P)throw new Error("Input and output buffers must be different");this._realTransform4(R,P,1)}inverseTransform(R,P){if(R===P)throw new Error("Input and output buffers must be different");this._transform4(R,P,-1);for(let D=0;D<R.length;++D)R[D]/=this.size}_transform4(R,P,D){const z=this._csize;let N=1<<this._width,j=z/N<<1,J,W;const oe=this._bitrev;if(j===4)for(J=0,W=0;J<z;J+=j,++W){const q=oe[W];this._singleTransform2(P,R,J,q,N)}else for(J=0,W=0;J<z;J+=j,++W){const q=oe[W];this._singleTransform4(P,R,J,q,N,D)}const ne=this.table;for(N>>=2;N>=2;N>>=2){j=z/N<<1;const q=j>>>2;for(J=0;J<z;J+=j){const le=J+q-1;for(let se=J,pe=0;se<le;se+=2,pe+=N){const be=se,ee=be+q,te=ee+q,ue=te+q,ae=R[be],ce=R[be+1],Be=R[ee],He=R[ee+1],Xe=R[te],ot=R[te+1],tt=R[ue],Ae=R[ue+1],ye=ne[pe],xe=D*ne[pe+1],ke=Be*ye-He*xe,ze=Be*xe+He*ye,je=ne[2*pe],Fe=D*ne[2*pe+1],Ye=Xe*je-ot*Fe,Ve=Xe*Fe+ot*je,Qe=ne[3*pe],mt=D*ne[3*pe+1],Tt=tt*Qe-Ae*mt,Me=tt*mt+Ae*Qe,me=ae+Ye,$e=ce+Ve,et=ae-Ye,ht=ce-Ve,at=ke+Tt,Et=ze+Me,Dt=D*(ke-Tt),Vt=D*(ze-Me);R[be]=me+at,R[be+1]=$e+Et,R[ee]=et+Vt,R[ee+1]=ht-Dt,R[te]=me-at,R[te+1]=$e-Et,R[ue]=et-Vt,R[ue+1]=ht+Dt}}}}_singleTransform2(R,P,D,z,U){const N=R[z],j=R[z+1],J=R[z+U],W=R[z+U+1];P[D]=N+J,P[D+1]=j+W,P[D+2]=N-J,P[D+3]=j-W}_singleTransform4(R,P,D,z,U,N){const j=U*2,J=U*3,W=R[z],oe=R[z+1],ne=R[z+U],q=R[z+U+1],le=R[z+j],se=R[z+j+1],pe=R[z+J],be=R[z+J+1],ee=W+le,te=oe+se,ue=W-le,ae=oe-se,ce=ne+pe,Be=q+be,He=N*(ne-pe),Xe=N*(q-be);P[D]=ee+ce,P[D+1]=te+Be,P[D+2]=ue+Xe,P[D+3]=ae-He,P[D+4]=ee-ce,P[D+5]=te-Be,P[D+6]=ue-Xe,P[D+7]=ae+He}_realTransform4(R,P,D){const z=this._csize;let N=1<<this._width,j=z/N<<1,J,W;const oe=this._bitrev;if(j===4)for(J=0,W=0;J<z;J+=j,++W){const le=oe[W];this._singleRealTransform2(P,R,J,le>>>1,N>>>1)}else for(J=0,W=0;J<z;J+=j,++W){const le=oe[W];this._singleRealTransform4(P,R,J,le>>>1,N>>>1,D)}const ne=this.table;for(N>>=2;N>=2;N>>=2){j=z/N<<1;const le=j>>>1,se=le>>>1,pe=se>>>1;for(J=0;J<z;J+=j)for(let be=0,ee=0;be<=pe;be+=2,ee+=N){const te=J+be,ue=te+se,ae=ue+se,ce=ae+se,Be=R[te],He=R[te+1],Xe=R[ue],ot=R[ue+1],tt=R[ae],Ae=R[ae+1],ye=R[ce],xe=R[ce+1],ke=Be,ze=He,je=ne[ee],Fe=D*ne[ee+1],Ye=Xe*je-ot*Fe,Ve=Xe*Fe+ot*je,Qe=ne[2*ee],mt=D*ne[2*ee+1],Tt=tt*Qe-Ae*mt,Me=tt*mt+Ae*Qe,me=ne[3*ee],$e=D*ne[3*ee+1],et=ye*me-xe*$e,ht=ye*$e+xe*me,at=ke+Tt,Et=ze+Me,Dt=ke-Tt,Vt=ze-Me,an=Ye+et,bt=Ve+ht,Jt=D*(Ye-et),Tn=D*(Ve-ht);if(R[te]=at+an,R[te+1]=Et+bt,R[ue]=Dt+Tn,R[ue+1]=Vt-Jt,be===0){R[ae]=at-an,R[ae+1]=Et-bt;continue}if(be===pe)continue;const We=J+se-be,vt=J+le-be;R[We]=Dt-D*Tn,R[We+1]=-Vt-D*Jt,R[vt]=at-D*an,R[vt+1]=-Et+D*bt}}const q=z>>>1;for(let le=2;le<q;le+=2)R[z-le]=R[le],R[z-le+1]=-R[le+1]}_singleRealTransform2(R,P,D,z,U){const N=R[z],j=R[z+U];P[D]=N+j,P[D+1]=0,P[D+2]=N-j,P[D+3]=0}_singleRealTransform4(R,P,D,z,U,N){const j=U*2,J=U*3,W=R[z],oe=R[z+U],ne=R[z+j],q=R[z+J],le=W+ne,se=W-ne,pe=oe+q,be=N*(oe-q);P[D]=le+pe,P[D+1]=0,P[D+2]=se,P[D+3]=-be,P[D+4]=le-pe,P[D+5]=0,P[D+6]=se,P[D+7]=be}}class y{constructor(R){const P=2*(R-1),D=2*(2*R-1),z=2**Math.ceil(Math.log2(D));this.bufferSize=z,this._a=P;const U=new Float64Array(D),N=new Float64Array(z);this._chirpBuffer=new Float64Array(z),this._buffer1=new Float64Array(z),this._buffer2=new Float64Array(z),this._outBuffer1=new Float64Array(z),this._outBuffer2=new Float64Array(z);const j=-2*Math.PI/R,J=Math.cos(j),W=Math.sin(j);for(let oe=0;oe<D>>1;++oe){const ne=(oe+1-R)**2/2,q=Math.sqrt(J**2+W**2)**ne,le=ne*Math.atan2(W,J),se=2*oe;U[se]=q*Math.cos(le),U[se+1]=q*Math.sin(le),N[se]=U[se],N[se+1]=-U[se+1]}this._slicedChirpBuffer=U.subarray(P,D),this._f=new v(z>>1),this._f.transform(this._chirpBuffer,N)}_transform(R,P,D){const z=this._buffer1,U=this._buffer2,N=this._outBuffer1,j=this._outBuffer2,J=this._chirpBuffer,W=this._slicedChirpBuffer,oe=this._a;if(D)for(let ne=0;ne<W.length;ne+=2){const q=ne+1,le=ne>>1,se=P[le];z[ne]=se*W[ne],z[q]=se*W[q]}else for(let ne=0;ne<W.length;ne+=2){const q=ne+1;z[ne]=P[ne]*W[ne]-P[q]*W[q],z[q]=P[ne]*W[q]+P[q]*W[ne]}this._f.transform(N,z);for(let ne=0;ne<J.length;ne+=2){const q=ne+1;U[ne]=N[ne]*J[ne]-N[q]*J[q],U[q]=N[ne]*J[q]+N[q]*J[ne]}this._f.inverseTransform(j,U);for(let ne=0;ne<j.length;ne+=2){const q=j[ne+oe],le=j[ne+oe+1],se=W[ne],pe=W[ne+1];R[ne]=q*se-le*pe,R[ne+1]=q*pe+le*se}}transform(R,P){this._transform(R,P,!1)}realTransform(R,P){this._transform(R,P,!0)}}class w{constructor(R){this.fft_length=R,this.isPowerOfTwo=h(R),this.isPowerOfTwo?(this.fft=new v(R),this.outputBufferSize=2*R):(this.fft=new y(R),this.outputBufferSize=this.fft.bufferSize)}realTransform(R,P){this.fft.realTransform(R,P)}transform(R,P){this.fft.transform(R,P)}}function S(x,R){if(R%2===0||R<=0)throw new Error("Window size must be a positive odd number");const P=new x.constructor(x.length),D=new x.constructor(R),z=Math.floor(R/2);for(let U=0;U<x.length;++U){let N=0;for(let j=-z;j<=z;++j){let J=U+j;J<0?J=Math.abs(J):J>=x.length&&(J=2*(x.length-1)-J),D[N++]=x[J]}D.sort(),P[U]=D[z]}return P}function M(x,R){const P=Math.pow(10,R);return Math.round(x*P)/P}function T(x){const R=Math.round(x);return Math.abs(x)%1===.5?R%2===0?R:R-1:R}function C(x){const R=x.length,P=x[0].length,D=[R+1,P+1],z=Array.from({length:D[0]},()=>Array(D[1]).fill(1/0));z[0][0]=0;const U=Array.from({length:D[0]},()=>Array(D[1]).fill(-1));for(let oe=1;oe<D[1];++oe)for(let ne=1;ne<D[0];++ne){const q=z[ne-1][oe-1],le=z[ne-1][oe],se=z[ne][oe-1];let pe,be;q<le&&q<se?(pe=q,be=0):le<q&&le<se?(pe=le,be=1):(pe=se,be=2),z[ne][oe]=x[ne-1][oe-1]+pe,U[ne][oe]=be}for(let oe=0;oe<D[1];++oe)U[0][oe]=2;for(let oe=0;oe<D[0];++oe)U[oe][0]=1;let N=R,j=P,J=[],W=[];for(;N>0||j>0;)switch(J.push(N-1),W.push(j-1),U[N][j]){case 0:--N,--j;break;case 1:--N;break;case 2:--j;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${N}, ${j}]. Please file a bug report.`)}return J.reverse(),W.reverse(),[J,W]}}),"./src/utils/tensor.js":((n,e,t)=>{t.r(e),t.d(e,{DataTypeMap:()=>o,Tensor:()=>l,cat:()=>P,full:()=>W,full_like:()=>oe,interpolate:()=>g,interpolate_4d:()=>p,layer_norm:()=>T,matmul:()=>h,mean:()=>N,mean_pooling:()=>M,ones:()=>ne,ones_like:()=>q,permute:()=>d,quantize_embeddings:()=>ee,rand:()=>pe,randn:()=>be,rfft:()=>v,slice:()=>S,stack:()=>D,std_mean:()=>U,topk:()=>y,zeros:()=>le,zeros_like:()=>se});var i=t("./src/utils/maths.js"),s=t("./src/backends/onnx.js"),r=t("./src/ops/registry.js");const o=Object.freeze({float32:Float32Array,float16:typeof Float16Array<"u"?Float16Array:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class l{get dims(){return this.ort_tensor.dims}set dims(ue){this.ort_tensor.dims=ue}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}ort_tensor;constructor(...ue){return(0,s.isONNXTensor)(ue[0])?this.ort_tensor=ue[0]:this.ort_tensor=new s.Tensor(ue[0],ue[1],ue[2]),new Proxy(this,{get:(ae,ce)=>{if(typeof ce=="string"){let Be=Number(ce);if(Number.isInteger(Be))return ae._getitem(Be)}return ae[ce]},set:(ae,ce,Be)=>ae[ce]=Be})}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[ue,...ae]=this.dims;if(ae.length>0){const ce=ae.reduce((Be,He)=>Be*He);for(let Be=0;Be<ue;++Be)yield this._subarray(Be,ce,ae)}else yield*this.data}_getitem(ue){const[ae,...ce]=this.dims;if(ue=R(ue,ae),ce.length>0){const Be=ce.reduce((He,Xe)=>He*Xe);return this._subarray(ue,Be,ce)}else return new l(this.type,[this.data[ue]],ce)}indexOf(ue){const ae=this.data;for(let ce=0;ce<ae.length;++ce)if(ae[ce]==ue)return ce;return-1}_subarray(ue,ae,ce){const Be=ue*ae,He=(ue+1)*ae,Xe="subarray"in this.data?this.data.subarray(Be,He):this.data.slice(Be,He);return new l(this.type,Xe,ce)}item(){const ue=this.data;if(ue.length!==1)throw new Error(`a Tensor with ${ue.length} elements cannot be converted to Scalar`);return ue[0]}tolist(){return c(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const ue=this.data;for(let ae=0;ae<ue.length;++ae)ue[ae]=1/(1+Math.exp(-ue[ae]));return this}map(ue){return this.clone().map_(ue)}map_(ue){const ae=this.data;for(let ce=0;ce<ae.length;++ce)ae[ce]=ue(ae[ce],ce,ae);return this}mul(ue){return this.clone().mul_(ue)}mul_(ue){const ae=this.data;for(let ce=0;ce<ae.length;++ce)ae[ce]*=ue;return this}div(ue){return this.clone().div_(ue)}div_(ue){const ae=this.data;for(let ce=0;ce<ae.length;++ce)ae[ce]/=ue;return this}add(ue){return this.clone().add_(ue)}add_(ue){const ae=this.data;for(let ce=0;ce<ae.length;++ce)ae[ce]+=ue;return this}sub(ue){return this.clone().sub_(ue)}sub_(ue){const ae=this.data;for(let ce=0;ce<ae.length;++ce)ae[ce]-=ue;return this}clone(){return new l(this.type,this.data.slice(),this.dims.slice())}slice(...ue){const ae=[],ce=[];for(let ye=0;ye<this.dims.length;++ye){let xe=ue[ye];if(xe==null)ce.push([0,this.dims[ye]]),ae.push(this.dims[ye]);else if(typeof xe=="number")xe=R(xe,this.dims[ye],ye),ce.push([xe,xe+1]);else if(Array.isArray(xe)&&xe.length===2){let[ke,ze]=xe;if(ke=ke===null?0:R(ke,this.dims[ye],ye,!1),ze=ze===null?this.dims[ye]:R(ze,this.dims[ye],ye,!1),ke>ze)throw new Error(`Invalid slice: ${xe}`);const je=[Math.max(ke,0),Math.min(ze,this.dims[ye])];ce.push(je),ae.push(je[1]-je[0])}else throw new Error(`Invalid slice: ${xe}`)}const Be=ce.map(([ye,xe])=>xe-ye),He=Be.reduce((ye,xe)=>ye*xe),Xe=this.data,ot=new Xe.constructor(He),tt=this.stride();let Ae=!0;for(let ye=1;ye<Be.length;++ye)if(ce[ye][0]!==0||ce[ye][1]!==this.dims[ye]){Ae=!1;break}if(Ae){const ye=ce[0][0]*tt[0],xe=ce[0][1]*tt[0];if(ArrayBuffer.isView(Xe))ot.set(Xe.subarray(ye,xe));else if(Array.isArray(Xe)){const ke=Xe.slice(ye,xe);for(let ze=0;ze<ke.length;++ze)ot[ze]=ke[ze]}else throw new Error("Unsupported data type for slicing")}else for(let ye=0;ye<He;++ye){let xe=0;for(let ke=Be.length-1,ze=ye;ke>=0;--ke){const je=Be[ke];xe+=(ze%je+ce[ke][0])*tt[ke],ze=Math.floor(ze/je)}ot[ye]=Xe[xe]}return new l(this.type,ot,ae)}permute(...ue){return d(this,ue)}transpose(...ue){return this.permute(...ue)}sum(ue=null,ae=!1){return this.norm(1,ue,ae)}norm(ue="fro",ae=null,ce=!1){if(ue==="fro")ue=2;else if(typeof ue=="string")throw Error(`Unsupported norm: ${ue}`);const Be=this.data,He=(Ae,ye)=>Ae+ye**ue;if(ae===null){const Ae=Be.reduce(He,0)**(1/ue);return new l(this.type,[Ae],[])}const[Xe,ot,tt]=z(He,this,ae,ce);if(ue!==1)for(let Ae=0;Ae<ot.length;++Ae)ot[Ae]=ot[Ae]**(1/ue);return new l(Xe,ot,tt)}normalize_(ue=2,ae=1){ae=R(ae,this.dims.length);const ce=this.norm(ue,ae,!0),Be=this.data,He=ce.data;for(let Xe=0;Xe<Be.length;++Xe){let ot=0;for(let tt=this.dims.length-1,Ae=Xe,ye=1;tt>=0;--tt){const xe=this.dims[tt];if(tt!==ae){const ke=Ae%xe;ot+=ke*ye,ye*=this.dims[tt]}Ae=Math.floor(Ae/xe)}Be[Xe]/=He[ot]}return this}normalize(ue=2,ae=1){return this.clone().normalize_(ue,ae)}stride(){return j(this.dims)}squeeze(ue=null){return new l(this.type,this.data,C(this.dims,ue))}squeeze_(ue=null){return this.dims=C(this.dims,ue),this}unsqueeze(ue=null){return new l(this.type,this.data,x(this.dims,ue))}unsqueeze_(ue=null){return this.dims=x(this.dims,ue),this}flatten_(ue=0,ae=-1){ae=(ae+this.dims.length)%this.dims.length;let ce=this.dims.slice(0,ue),Be=this.dims.slice(ue,ae+1),He=this.dims.slice(ae+1);return this.dims=[...ce,Be.reduce((Xe,ot)=>Xe*ot,1),...He],this}flatten(ue=0,ae=-1){return this.clone().flatten_(ue,ae)}view(...ue){let ae=-1;for(let Be=0;Be<ue.length;++Be)if(ue[Be]===-1){if(ae!==-1)throw new Error("Only one dimension can be inferred");ae=Be}const ce=this.data;if(ae!==-1){const Be=ue.reduce((He,Xe,ot)=>ot!==ae?He*Xe:He,1);ue[ae]=ce.length/Be}return new l(this.type,ce,ue)}neg_(){const ue=this.data;for(let ae=0;ae<ue.length;++ae)ue[ae]=-ue[ae];return this}neg(){return this.clone().neg_()}gt(ue){const ae=new Uint8Array(this.data.length),ce=this.data;for(let Be=0;Be<ce.length;++Be)ae[Be]=ce[Be]>ue?1:0;return new l("bool",ae,this.dims)}lt(ue){const ae=new Uint8Array(this.data.length),ce=this.data;for(let Be=0;Be<ce.length;++Be)ae[Be]=ce[Be]<ue?1:0;return new l("bool",ae,this.dims)}clamp_(ue,ae){const ce=this.data;for(let Be=0;Be<ce.length;++Be)ce[Be]=Math.min(Math.max(ce[Be],ue),ae);return this}clamp(ue,ae){return this.clone().clamp_(ue,ae)}round_(){const ue=this.data;for(let ae=0;ae<ue.length;++ae)ue[ae]=Math.round(ue[ae]);return this}round(){return this.clone().round_()}mean(ue=null,ae=!1){return N(this,ue,ae)}min(ue=null,ae=!1){if(ue===null){const Xe=(0,i.min)(this.data)[0];return new l(this.type,[Xe],[])}const[ce,Be,He]=z((Xe,ot)=>Math.min(Xe,ot),this,ue,ae,1/0);return new l(ce,Be,He)}max(ue=null,ae=!1){if(ue===null){const Xe=(0,i.max)(this.data)[0];return new l(this.type,[Xe],[])}const[ce,Be,He]=z((Xe,ot)=>Math.max(Xe,ot),this,ue,ae,-1/0);return new l(ce,Be,He)}argmin(ue=null,ae=!1){if(ue!==null)throw new Error("`dim !== null` not yet implemented.");const ce=(0,i.min)(this.data)[1];return new l("int64",[BigInt(ce)],[])}argmax(ue=null,ae=!1){if(ue!==null)throw new Error("`dim !== null` not yet implemented.");const ce=(0,i.max)(this.data)[1];return new l("int64",[BigInt(ce)],[])}to(ue){if(this.type===ue)return this;if(!o.hasOwnProperty(ue))throw new Error(`Unsupported type: ${ue}`);let ae;const ce=["int64","uint64"].includes(this.type),Be=["int64","uint64"].includes(ue);return ce&&!Be?ae=Number:!ce&&Be&&(["float16","float32","float64"].includes(this.type)?ae=He=>BigInt(Math.floor(He)):ae=BigInt),new l(ue,o[ue].from(this.data,ae),this.dims)}}function c(te,ue){const ae=te.length,ce=ue.reduce((He,Xe)=>He*Xe);if(ae!==ce)throw Error(`cannot reshape array of size ${ae} into shape (${ue})`);let Be=te;for(let He=ue.length-1;He>=0;He--)Be=Be.reduce((Xe,ot)=>{let tt=Xe[Xe.length-1];return tt.length<ue[He]?tt.push(ot):Xe.push([ot]),Xe},[[]]);return Be[0]}function d(te,ue){const[ae,ce]=(0,i.permute_data)(te.data,te.dims,ue);return new l(te.type,ae,ce)}function g(te,[ue,ae],ce="bilinear",Be=!1){const He=te.dims.at(-3)??1,Xe=te.dims.at(-2),ot=te.dims.at(-1);let tt=(0,i.interpolate_data)(te.data,[He,Xe,ot],[ue,ae],ce,Be);return new l(te.type,tt,[He,ue,ae])}async function p(te,{size:ue=null,mode:ae="bilinear"}={}){if(te.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!ue)throw new Error("`interpolate_4d` requires a `size` argument.");let ce;if(ue.length===2)ce=[...te.dims.slice(0,2),...ue];else if(ue.length===3)ce=[te.dims[0],...ue];else if(ue.length===4)ce=ue;else throw new Error("`size` must be of length 2, 3, or 4.");let Be;if(ae==="nearest")Be=await r.TensorOpRegistry.nearest_interpolate_4d;else if(ae==="bilinear")Be=await r.TensorOpRegistry.bilinear_interpolate_4d;else if(ae==="bicubic")Be=await r.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${ae}`);const He=new l("int64",new BigInt64Array(ce.map(BigInt)),[ce.length]);return await Be({x:te,s:He})}async function h(te,ue){return await(await r.TensorOpRegistry.matmul)({a:te,b:ue})}async function v(te,ue){return await(await r.TensorOpRegistry.rfft)({x:te,a:ue})}async function y(te,ue){const ae=await r.TensorOpRegistry.top_k;return ue==null?ue=te.dims.at(-1):ue=Math.min(ue,te.dims.at(-1)),await ae({x:te,k:new l("int64",[BigInt(ue)],[1])})}const w=te=>new l("int64",te,[te.length]);async function S(te,ue,ae,ce,Be){return await(await r.TensorOpRegistry.slice)({x:te,s:w(ue),e:w(ae),a:w(ce),t:w(Be??new Array(ce.length).fill(1))})}function M(te,ue){const ae=te.data,ce=ue.data,Be=[te.dims[0],te.dims[2]],He=new ae.constructor(Be[0]*Be[1]),[Xe,ot,tt]=te.dims;let Ae=0;for(let ye=0;ye<Xe;++ye){const xe=ye*tt*ot;for(let ke=0;ke<tt;++ke){let ze=0,je=0;const Fe=ye*ot,Ye=xe+ke;for(let Qe=0;Qe<ot;++Qe){const mt=Number(ce[Fe+Qe]);je+=mt,ze+=ae[Ye+Qe*tt]*mt}const Ve=ze/je;He[Ae++]=Ve}}return new l(te.type,He,Be)}function T(te,ue,{eps:ae=1e-5}={}){if(te.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[ce,Be]=te.dims;if(ue.length!==1&&ue[0]!==Be)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[He,Xe]=U(te,1,0,!0),ot=He.data,tt=Xe.data,Ae=te.data,ye=new Ae.constructor(Ae.length);for(let xe=0;xe<ce;++xe){const ke=xe*Be;for(let ze=0;ze<Be;++ze){const je=ke+ze;ye[je]=(Ae[je]-tt[xe])/(ot[xe]+ae)}}return new l(te.type,ye,te.dims)}function C(te,ue){return te=te.slice(),ue===null?te=te.filter(ae=>ae!==1):typeof ue=="number"?te[ue]===1&&te.splice(ue,1):Array.isArray(ue)&&(te=te.filter((ae,ce)=>ae!==1||!ue.includes(ce))),te}function x(te,ue){return ue=R(ue,te.length+1),te=te.slice(),te.splice(ue,0,1),te}function R(te,ue,ae=null,ce=!0){if(te<-ue||te>=ue){if(ce)throw new Error(`IndexError: index ${te} is out of bounds for dimension${ae===null?"":" "+ae} with size ${ue}`);return te<-ue?0:ue}return te<0&&(te=(te%ue+ue)%ue),te}function P(te,ue=0){ue=R(ue,te[0].dims.length);const ae=te[0].dims.slice();ae[ue]=te.reduce((Xe,ot)=>Xe+ot.dims[ue],0);const ce=ae.reduce((Xe,ot)=>Xe*ot,1),Be=new te[0].data.constructor(ce),He=te[0].type;if(ue===0){let Xe=0;for(const ot of te){const tt=ot.data;Be.set(tt,Xe),Xe+=tt.length}}else{let Xe=0;for(let ot=0;ot<te.length;++ot){const{data:tt,dims:Ae}=te[ot];for(let ye=0;ye<tt.length;++ye){let xe=0;for(let ke=Ae.length-1,ze=ye,je=1;ke>=0;--ke){const Fe=Ae[ke];let Ye=ze%Fe;ke===ue&&(Ye+=Xe),xe+=Ye*je,je*=ae[ke],ze=Math.floor(ze/Fe)}Be[xe]=tt[ye]}Xe+=Ae[ue]}}return new l(He,Be,ae)}function D(te,ue=0){return P(te.map(ae=>ae.unsqueeze(ue)),ue)}function z(te,ue,ae=null,ce=!1,Be=null){const He=ue.data,Xe=ue.dims;ae=R(ae,Xe.length);const ot=Xe.slice();ot[ae]=1;const tt=new He.constructor(He.length/Xe[ae]);Be!==null&&tt.fill(Be);for(let Ae=0;Ae<He.length;++Ae){let ye=0;for(let xe=Xe.length-1,ke=Ae,ze=1;xe>=0;--xe){const je=Xe[xe];if(xe!==ae){const Fe=ke%je;ye+=Fe*ze,ze*=ot[xe]}ke=Math.floor(ke/je)}tt[ye]=te(tt[ye],He[Ae],Ae,ye)}return ce||ot.splice(ae,1),[ue.type,tt,ot]}function U(te,ue=null,ae=1,ce=!1){const Be=te.data,He=te.dims;if(ue===null){const ze=Be.reduce((Ve,Qe)=>Ve+Qe,0)/Be.length,je=Math.sqrt(Be.reduce((Ve,Qe)=>Ve+(Qe-ze)**2,0)/(Be.length-ae)),Fe=new l(te.type,[ze],[]);return[new l(te.type,[je],[]),Fe]}ue=R(ue,He.length);const Xe=N(te,ue,ce),ot=Xe.data,[tt,Ae,ye]=z((ke,ze,je,Fe)=>ke+(ze-ot[Fe])**2,te,ue,ce);for(let ke=0;ke<Ae.length;++ke)Ae[ke]=Math.sqrt(Ae[ke]/(He[ue]-ae));return[new l(tt,Ae,ye),Xe]}function N(te,ue=null,ae=!1){const ce=te.dims,Be=te.data;if(ue===null){const tt=Be.reduce((Ae,ye)=>Ae+ye,0);return new l(te.type,[tt/Be.length],[])}ue=R(ue,ce.length);const[He,Xe,ot]=z((tt,Ae)=>tt+Ae,te,ue,ae);if(ce[ue]!==1)for(let tt=0;tt<Xe.length;++tt)Xe[tt]/=ce[ue];return new l(He,Xe,ot)}function j(te){const ue=new Array(te.length);for(let ae=te.length-1,ce=1;ae>=0;--ae)ue[ae]=ce,ce*=te[ae];return ue}function J(te,ue,ae,ce){const Be=te.reduce((He,Xe)=>He*Xe,1);return new l(ae,new ce(Be).fill(ue),te)}function W(te,ue){let ae,ce;if(typeof ue=="number")ae="float32",ce=Float32Array;else if(typeof ue=="bigint")ae="int64",ce=BigInt64Array;else if(typeof ue=="boolean")ae="bool",ce=Uint8Array;else throw new Error(`Unsupported data type: ${typeof ue}`);return J(te,ue,ae,ce)}function oe(te,ue){return W(te.dims,ue)}function ne(te){return J(te,1n,"int64",BigInt64Array)}function q(te){return ne(te.dims)}function le(te){return J(te,0n,"int64",BigInt64Array)}function se(te){return le(te.dims)}function pe(te){const ue=te.reduce((ae,ce)=>ae*ce,1);return new l("float32",Float32Array.from({length:ue},()=>Math.random()),te)}function be(te){const ue=te.reduce((ce,Be)=>ce*Be,1);function ae(){const ce=1-Math.random(),Be=1-Math.random();return Math.sqrt(-2*Math.log(ce))*Math.cos(2*Math.PI*Be)}return new l("float32",Float32Array.from({length:ue},()=>ae()),te)}function ee(te,ue){if(te.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(te.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(ue))throw new Error("The precision must be either 'binary' or 'ubinary'");const ae=ue==="binary",ce=ae?"int8":"uint8",Be=ae?Int8Array:Uint8Array,He=te.data,Xe=new Be(He.length/8);for(let ot=0;ot<He.length;++ot){const tt=He[ot]>0?1:0,Ae=Math.floor(ot/8),ye=ot%8;Xe[Ae]|=tt<<7-ye,ae&&ye===0&&(Xe[Ae]-=128)}return new l(ce,Xe,[te.dims[0],te.dims[1]/8])}}),"./src/utils/video.js":((n,e,t)=>{t.r(e),t.d(e,{RawVideo:()=>o,RawVideoFrame:()=>r,load_video:()=>l});var i=t("./src/utils/image.js"),s=t("./src/env.js");class r{constructor(d,g){this.image=d,this.timestamp=g}}class o{constructor(d,g){d.length>0&&d[0]instanceof i.RawImage&&(d=d.map((p,h)=>new r(p,(h+1)/(d.length+1)*g))),this.frames=d,this.duration=g}get width(){return this.frames[0].image.width}get height(){return this.frames[0].image.height}get fps(){return this.frames.length/this.duration}}async function l(c,{num_frames:d=null,fps:g=null}={}){if(!s.apis.IS_BROWSER_ENV)throw new Error("`load_video` is currently only supported in browser environments.");if(d==null&&g==null)throw new Error("Either num_frames or fps must be provided.");const p=[],h=document.createElement("video");if(h.crossOrigin="anonymous",h.muted=!0,typeof c=="string")h.src=c;else if(c instanceof Blob)h.src=URL.createObjectURL(c);else if(c instanceof HTMLVideoElement)h.src=c.src;else throw new Error("Invalid URL or video element provided.");if(await new Promise(C=>h.onloadedmetadata=C),h.seekable.start(0)===h.seekable.end(0)){const x=await(await fetch(h.src)).blob();h.src=URL.createObjectURL(x),await new Promise(R=>h.onloadedmetadata=R)}const v=h.duration;let y,w;d!=null?(y=d,w=d===1?0:v/(d-1)):(w=1/g,y=Math.floor(v/w));let S=[];for(let C=0;C<y;++C)S.push(d===1?v/2:C*w);const M=document.createElement("canvas");M.width=h.videoWidth,M.height=h.videoHeight;const T=M.getContext("2d",{willReadFrequently:!0});for(const C of S){h.currentTime=C,await new Promise(D=>{h.onseeked=D}),T.drawImage(h,0,0,M.width,M.height);const x=T.getImageData(0,0,M.width,M.height),R=new i.RawImage(x.data,M.width,M.height,4),P=new r(R,C);p.push(P)}return h.remove(),new o(p,v)}})},MB={};function Es(n){var e=MB[n];if(e!==void 0)return e.exports;var t=MB[n]={exports:{}};return EK[n](t,t.exports,Es),t.exports}(()=>{var n=Object.getPrototypeOf?t=>Object.getPrototypeOf(t):t=>t.__proto__,e;Es.t=function(t,i){if(i&1&&(t=this(t)),i&8||typeof t=="object"&&t&&(i&4&&t.__esModule||i&16&&typeof t.then=="function"))return t;var s=Object.create(null);Es.r(s);var r={};e=e||[null,n({}),n([]),n(n)];for(var o=i&2&&t;typeof o=="object"&&!~e.indexOf(o);o=n(o))Object.getOwnPropertyNames(o).forEach(l=>r[l]=()=>t[l]);return r.default=()=>t,Es.d(s,r),s}})();Es.d=(n,e)=>{for(var t in e)Es.o(e,t)&&!Es.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})};Es.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e);Es.r=n=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})};var H={};(()=>{Es.r(H),Es.d(H,{ASTFeatureExtractor:()=>p.ASTFeatureExtractor,ASTForAudioClassification:()=>t.ASTForAudioClassification,ASTModel:()=>t.ASTModel,ASTPreTrainedModel:()=>t.ASTPreTrainedModel,AlbertForMaskedLM:()=>t.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>t.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>t.AlbertForSequenceClassification,AlbertModel:()=>t.AlbertModel,AlbertPreTrainedModel:()=>t.AlbertPreTrainedModel,AlbertTokenizer:()=>i.AlbertTokenizer,ArceeForCausalLM:()=>t.ArceeForCausalLM,ArceeModel:()=>t.ArceeModel,ArceePreTrainedModel:()=>t.ArceePreTrainedModel,AudioClassificationPipeline:()=>e.AudioClassificationPipeline,AutoConfig:()=>s.AutoConfig,AutoFeatureExtractor:()=>h.AutoFeatureExtractor,AutoImageProcessor:()=>w.AutoImageProcessor,AutoModel:()=>t.AutoModel,AutoModelForAudioClassification:()=>t.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>t.AutoModelForAudioFrameClassification,AutoModelForAudioTextToText:()=>t.AutoModelForAudioTextToText,AutoModelForCTC:()=>t.AutoModelForCTC,AutoModelForCausalLM:()=>t.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>t.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>t.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>t.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>t.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>t.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>t.AutoModelForImageSegmentation,AutoModelForImageTextToText:()=>t.AutoModelForImageTextToText,AutoModelForImageToImage:()=>t.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>t.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>t.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>t.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>t.AutoModelForObjectDetection,AutoModelForPoseEstimation:()=>t.AutoModelForPoseEstimation,AutoModelForQuestionAnswering:()=>t.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>t.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>t.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>t.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>t.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>t.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>t.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>t.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>t.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>t.AutoModelForVision2Seq,AutoModelForXVector:()=>t.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>t.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>T.AutoProcessor,AutoTokenizer:()=>i.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>e.AutomaticSpeechRecognitionPipeline,BackgroundRemovalPipeline:()=>e.BackgroundRemovalPipeline,BartForConditionalGeneration:()=>t.BartForConditionalGeneration,BartForSequenceClassification:()=>t.BartForSequenceClassification,BartModel:()=>t.BartModel,BartPretrainedModel:()=>t.BartPretrainedModel,BartTokenizer:()=>i.BartTokenizer,BaseModelOutput:()=>t.BaseModelOutput,BaseStreamer:()=>C.BaseStreamer,BeitFeatureExtractor:()=>y.BeitFeatureExtractor,BeitForImageClassification:()=>t.BeitForImageClassification,BeitModel:()=>t.BeitModel,BeitPreTrainedModel:()=>t.BeitPreTrainedModel,BertForMaskedLM:()=>t.BertForMaskedLM,BertForQuestionAnswering:()=>t.BertForQuestionAnswering,BertForSequenceClassification:()=>t.BertForSequenceClassification,BertForTokenClassification:()=>t.BertForTokenClassification,BertModel:()=>t.BertModel,BertPreTrainedModel:()=>t.BertPreTrainedModel,BertTokenizer:()=>i.BertTokenizer,BitImageProcessor:()=>y.BitImageProcessor,BlenderbotForConditionalGeneration:()=>t.BlenderbotForConditionalGeneration,BlenderbotModel:()=>t.BlenderbotModel,BlenderbotPreTrainedModel:()=>t.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>t.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>t.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>t.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>i.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>i.BlenderbotTokenizer,BloomForCausalLM:()=>t.BloomForCausalLM,BloomModel:()=>t.BloomModel,BloomPreTrainedModel:()=>t.BloomPreTrainedModel,BloomTokenizer:()=>i.BloomTokenizer,CLIPFeatureExtractor:()=>y.CLIPFeatureExtractor,CLIPImageProcessor:()=>y.CLIPImageProcessor,CLIPModel:()=>t.CLIPModel,CLIPPreTrainedModel:()=>t.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>t.CLIPSegForImageSegmentation,CLIPSegModel:()=>t.CLIPSegModel,CLIPSegPreTrainedModel:()=>t.CLIPSegPreTrainedModel,CLIPTextModel:()=>t.CLIPTextModel,CLIPTextModelWithProjection:()=>t.CLIPTextModelWithProjection,CLIPTokenizer:()=>i.CLIPTokenizer,CLIPVisionModel:()=>t.CLIPVisionModel,CLIPVisionModelWithProjection:()=>t.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>t.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>t.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>t.CamembertForSequenceClassification,CamembertForTokenClassification:()=>t.CamembertForTokenClassification,CamembertModel:()=>t.CamembertModel,CamembertPreTrainedModel:()=>t.CamembertPreTrainedModel,CamembertTokenizer:()=>i.CamembertTokenizer,CausalLMOutput:()=>t.CausalLMOutput,CausalLMOutputWithPast:()=>t.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>y.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>t.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>t.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>t.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>p.ClapFeatureExtractor,ClapModel:()=>t.ClapModel,ClapPreTrainedModel:()=>t.ClapPreTrainedModel,ClapTextModelWithProjection:()=>t.ClapTextModelWithProjection,ClassifierFreeGuidanceLogitsProcessor:()=>R.ClassifierFreeGuidanceLogitsProcessor,CodeGenForCausalLM:()=>t.CodeGenForCausalLM,CodeGenModel:()=>t.CodeGenModel,CodeGenPreTrainedModel:()=>t.CodeGenPreTrainedModel,CodeGenTokenizer:()=>i.CodeGenTokenizer,CodeLlamaTokenizer:()=>i.CodeLlamaTokenizer,CohereForCausalLM:()=>t.CohereForCausalLM,CohereModel:()=>t.CohereModel,CoherePreTrainedModel:()=>t.CoherePreTrainedModel,CohereTokenizer:()=>i.CohereTokenizer,ConvBertForMaskedLM:()=>t.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>t.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>t.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>t.ConvBertForTokenClassification,ConvBertModel:()=>t.ConvBertModel,ConvBertPreTrainedModel:()=>t.ConvBertPreTrainedModel,ConvBertTokenizer:()=>i.ConvBertTokenizer,ConvNextFeatureExtractor:()=>y.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>t.ConvNextForImageClassification,ConvNextImageProcessor:()=>y.ConvNextImageProcessor,ConvNextModel:()=>t.ConvNextModel,ConvNextPreTrainedModel:()=>t.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>t.ConvNextV2ForImageClassification,ConvNextV2Model:()=>t.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>t.ConvNextV2PreTrainedModel,DFineForObjectDetection:()=>t.DFineForObjectDetection,DFineModel:()=>t.DFineModel,DFinePreTrainedModel:()=>t.DFinePreTrainedModel,DINOv3ConvNextModel:()=>t.DINOv3ConvNextModel,DINOv3ConvNextPreTrainedModel:()=>t.DINOv3ConvNextPreTrainedModel,DINOv3ViTImageProcessor:()=>y.DINOv3ViTImageProcessor,DINOv3ViTModel:()=>t.DINOv3ViTModel,DINOv3ViTPreTrainedModel:()=>t.DINOv3ViTPreTrainedModel,DPTFeatureExtractor:()=>y.DPTFeatureExtractor,DPTForDepthEstimation:()=>t.DPTForDepthEstimation,DPTImageProcessor:()=>y.DPTImageProcessor,DPTModel:()=>t.DPTModel,DPTPreTrainedModel:()=>t.DPTPreTrainedModel,DacDecoderModel:()=>t.DacDecoderModel,DacDecoderOutput:()=>t.DacDecoderOutput,DacEncoderModel:()=>t.DacEncoderModel,DacEncoderOutput:()=>t.DacEncoderOutput,DacFeatureExtractor:()=>p.DacFeatureExtractor,DacModel:()=>t.DacModel,DacPreTrainedModel:()=>t.DacPreTrainedModel,DataTypeMap:()=>c.DataTypeMap,DebertaForMaskedLM:()=>t.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>t.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>t.DebertaForSequenceClassification,DebertaForTokenClassification:()=>t.DebertaForTokenClassification,DebertaModel:()=>t.DebertaModel,DebertaPreTrainedModel:()=>t.DebertaPreTrainedModel,DebertaTokenizer:()=>i.DebertaTokenizer,DebertaV2ForMaskedLM:()=>t.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>t.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>t.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>t.DebertaV2ForTokenClassification,DebertaV2Model:()=>t.DebertaV2Model,DebertaV2PreTrainedModel:()=>t.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>i.DebertaV2Tokenizer,DecisionTransformerModel:()=>t.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>t.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>y.DeiTFeatureExtractor,DeiTForImageClassification:()=>t.DeiTForImageClassification,DeiTImageProcessor:()=>y.DeiTImageProcessor,DeiTModel:()=>t.DeiTModel,DeiTPreTrainedModel:()=>t.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>t.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>t.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>e.DepthEstimationPipeline,DepthProForDepthEstimation:()=>t.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>t.DepthProPreTrainedModel,DetrFeatureExtractor:()=>y.DetrFeatureExtractor,DetrForObjectDetection:()=>t.DetrForObjectDetection,DetrForSegmentation:()=>t.DetrForSegmentation,DetrImageProcessor:()=>y.DetrImageProcessor,DetrModel:()=>t.DetrModel,DetrObjectDetectionOutput:()=>t.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>t.DetrPreTrainedModel,DetrSegmentationOutput:()=>t.DetrSegmentationOutput,Dinov2ForImageClassification:()=>t.Dinov2ForImageClassification,Dinov2Model:()=>t.Dinov2Model,Dinov2PreTrainedModel:()=>t.Dinov2PreTrainedModel,Dinov2WithRegistersForImageClassification:()=>t.Dinov2WithRegistersForImageClassification,Dinov2WithRegistersModel:()=>t.Dinov2WithRegistersModel,Dinov2WithRegistersPreTrainedModel:()=>t.Dinov2WithRegistersPreTrainedModel,DistilBertForMaskedLM:()=>t.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>t.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>t.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>t.DistilBertForTokenClassification,DistilBertModel:()=>t.DistilBertModel,DistilBertPreTrainedModel:()=>t.DistilBertPreTrainedModel,DistilBertTokenizer:()=>i.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>e.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>y.DonutFeatureExtractor,DonutImageProcessor:()=>y.DonutImageProcessor,DonutSwinModel:()=>t.DonutSwinModel,DonutSwinPreTrainedModel:()=>t.DonutSwinPreTrainedModel,EdgeTamModel:()=>t.EdgeTamModel,EfficientNetForImageClassification:()=>t.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>y.EfficientNetImageProcessor,EfficientNetModel:()=>t.EfficientNetModel,EfficientNetPreTrainedModel:()=>t.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>t.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>t.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>t.ElectraForSequenceClassification,ElectraForTokenClassification:()=>t.ElectraForTokenClassification,ElectraModel:()=>t.ElectraModel,ElectraPreTrainedModel:()=>t.ElectraPreTrainedModel,ElectraTokenizer:()=>i.ElectraTokenizer,EncodecFeatureExtractor:()=>p.EncodecFeatureExtractor,EosTokenCriteria:()=>x.EosTokenCriteria,Ernie4_5_ForCausalLM:()=>t.Ernie4_5_ForCausalLM,Ernie4_5_Model:()=>t.Ernie4_5_Model,Ernie4_5_PretrainedModel:()=>t.Ernie4_5_PretrainedModel,Ernie4_5_Tokenizer:()=>i.Ernie4_5_Tokenizer,EsmForMaskedLM:()=>t.EsmForMaskedLM,EsmForSequenceClassification:()=>t.EsmForSequenceClassification,EsmForTokenClassification:()=>t.EsmForTokenClassification,EsmModel:()=>t.EsmModel,EsmPreTrainedModel:()=>t.EsmPreTrainedModel,EsmTokenizer:()=>i.EsmTokenizer,ExaoneForCausalLM:()=>t.ExaoneForCausalLM,ExaoneModel:()=>t.ExaoneModel,ExaonePreTrainedModel:()=>t.ExaonePreTrainedModel,FFT:()=>d.FFT,FalconForCausalLM:()=>t.FalconForCausalLM,FalconModel:()=>t.FalconModel,FalconPreTrainedModel:()=>t.FalconPreTrainedModel,FalconTokenizer:()=>i.FalconTokenizer,FastViTForImageClassification:()=>t.FastViTForImageClassification,FastViTModel:()=>t.FastViTModel,FastViTPreTrainedModel:()=>t.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>e.FeatureExtractionPipeline,FeatureExtractor:()=>g.FeatureExtractor,FillMaskPipeline:()=>e.FillMaskPipeline,Florence2ForConditionalGeneration:()=>t.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>t.Florence2PreTrainedModel,Florence2Processor:()=>M.Florence2Processor,ForcedBOSTokenLogitsProcessor:()=>R.ForcedBOSTokenLogitsProcessor,ForcedEOSTokenLogitsProcessor:()=>R.ForcedEOSTokenLogitsProcessor,GLPNFeatureExtractor:()=>y.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>t.GLPNForDepthEstimation,GLPNModel:()=>t.GLPNModel,GLPNPreTrainedModel:()=>t.GLPNPreTrainedModel,GPT2LMHeadModel:()=>t.GPT2LMHeadModel,GPT2Model:()=>t.GPT2Model,GPT2PreTrainedModel:()=>t.GPT2PreTrainedModel,GPT2Tokenizer:()=>i.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>t.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>t.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>t.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>t.GPTJForCausalLM,GPTJModel:()=>t.GPTJModel,GPTJPreTrainedModel:()=>t.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>t.GPTNeoForCausalLM,GPTNeoModel:()=>t.GPTNeoModel,GPTNeoPreTrainedModel:()=>t.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>t.GPTNeoXForCausalLM,GPTNeoXModel:()=>t.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>t.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>i.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>t.Gemma2ForCausalLM,Gemma2Model:()=>t.Gemma2Model,Gemma2PreTrainedModel:()=>t.Gemma2PreTrainedModel,Gemma3ForCausalLM:()=>t.Gemma3ForCausalLM,Gemma3Model:()=>t.Gemma3Model,Gemma3PreTrainedModel:()=>t.Gemma3PreTrainedModel,Gemma3nAudioFeatureExtractor:()=>p.Gemma3nAudioFeatureExtractor,Gemma3nForConditionalGeneration:()=>t.Gemma3nForConditionalGeneration,Gemma3nPreTrainedModel:()=>t.Gemma3nPreTrainedModel,Gemma3nProcessor:()=>M.Gemma3nProcessor,GemmaForCausalLM:()=>t.GemmaForCausalLM,GemmaModel:()=>t.GemmaModel,GemmaPreTrainedModel:()=>t.GemmaPreTrainedModel,GemmaTokenizer:()=>i.GemmaTokenizer,GlmForCausalLM:()=>t.GlmForCausalLM,GlmModel:()=>t.GlmModel,GlmPreTrainedModel:()=>t.GlmPreTrainedModel,GraniteForCausalLM:()=>t.GraniteForCausalLM,GraniteModel:()=>t.GraniteModel,GraniteMoeHybridForCausalLM:()=>t.GraniteMoeHybridForCausalLM,GraniteMoeHybridModel:()=>t.GraniteMoeHybridModel,GraniteMoeHybridPreTrainedModel:()=>t.GraniteMoeHybridPreTrainedModel,GranitePreTrainedModel:()=>t.GranitePreTrainedModel,Grok1Tokenizer:()=>i.Grok1Tokenizer,GroundingDinoForObjectDetection:()=>t.GroundingDinoForObjectDetection,GroundingDinoImageProcessor:()=>y.GroundingDinoImageProcessor,GroundingDinoPreTrainedModel:()=>t.GroundingDinoPreTrainedModel,GroundingDinoProcessor:()=>M.GroundingDinoProcessor,GroupViTModel:()=>t.GroupViTModel,GroupViTPreTrainedModel:()=>t.GroupViTPreTrainedModel,HeliumForCausalLM:()=>t.HeliumForCausalLM,HeliumModel:()=>t.HeliumModel,HeliumPreTrainedModel:()=>t.HeliumPreTrainedModel,HerbertTokenizer:()=>i.HerbertTokenizer,HieraForImageClassification:()=>t.HieraForImageClassification,HieraModel:()=>t.HieraModel,HieraPreTrainedModel:()=>t.HieraPreTrainedModel,HubertForCTC:()=>t.HubertForCTC,HubertForSequenceClassification:()=>t.HubertForSequenceClassification,HubertModel:()=>t.HubertModel,HubertPreTrainedModel:()=>t.HubertPreTrainedModel,IJepaForImageClassification:()=>t.IJepaForImageClassification,IJepaModel:()=>t.IJepaModel,IJepaPreTrainedModel:()=>t.IJepaPreTrainedModel,Idefics3ForConditionalGeneration:()=>t.Idefics3ForConditionalGeneration,Idefics3ImageProcessor:()=>y.Idefics3ImageProcessor,Idefics3PreTrainedModel:()=>t.Idefics3PreTrainedModel,Idefics3Processor:()=>M.Idefics3Processor,ImageClassificationPipeline:()=>e.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>e.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>p.ImageFeatureExtractor,ImageMattingOutput:()=>t.ImageMattingOutput,ImageProcessor:()=>v.ImageProcessor,ImageSegmentationPipeline:()=>e.ImageSegmentationPipeline,ImageToImagePipeline:()=>e.ImageToImagePipeline,ImageToTextPipeline:()=>e.ImageToTextPipeline,InterruptableStoppingCriteria:()=>x.InterruptableStoppingCriteria,JAISLMHeadModel:()=>t.JAISLMHeadModel,JAISModel:()=>t.JAISModel,JAISPreTrainedModel:()=>t.JAISPreTrainedModel,JinaCLIPImageProcessor:()=>y.JinaCLIPImageProcessor,JinaCLIPModel:()=>t.JinaCLIPModel,JinaCLIPPreTrainedModel:()=>t.JinaCLIPPreTrainedModel,JinaCLIPProcessor:()=>M.JinaCLIPProcessor,JinaCLIPTextModel:()=>t.JinaCLIPTextModel,JinaCLIPVisionModel:()=>t.JinaCLIPVisionModel,Lfm2ForCausalLM:()=>t.Lfm2ForCausalLM,Lfm2Model:()=>t.Lfm2Model,Lfm2PreTrainedModel:()=>t.Lfm2PreTrainedModel,LiteWhisperForConditionalGeneration:()=>t.LiteWhisperForConditionalGeneration,Llama4ForCausalLM:()=>t.Llama4ForCausalLM,Llama4PreTrainedModel:()=>t.Llama4PreTrainedModel,LlamaForCausalLM:()=>t.LlamaForCausalLM,LlamaModel:()=>t.LlamaModel,LlamaPreTrainedModel:()=>t.LlamaPreTrainedModel,LlamaTokenizer:()=>i.LlamaTokenizer,LlavaForConditionalGeneration:()=>t.LlavaForConditionalGeneration,LlavaOnevisionForConditionalGeneration:()=>t.LlavaOnevisionForConditionalGeneration,LlavaOnevisionImageProcessor:()=>y.LlavaOnevisionImageProcessor,LlavaPreTrainedModel:()=>t.LlavaPreTrainedModel,LlavaProcessor:()=>M.LlavaProcessor,LlavaQwen2ForCausalLM:()=>t.LlavaQwen2ForCausalLM,LogitsProcessor:()=>R.LogitsProcessor,LogitsProcessorList:()=>R.LogitsProcessorList,LogitsWarper:()=>R.LogitsWarper,LongT5ForConditionalGeneration:()=>t.LongT5ForConditionalGeneration,LongT5Model:()=>t.LongT5Model,LongT5PreTrainedModel:()=>t.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>t.M2M100ForConditionalGeneration,M2M100Model:()=>t.M2M100Model,M2M100PreTrainedModel:()=>t.M2M100PreTrainedModel,M2M100Tokenizer:()=>i.M2M100Tokenizer,MBart50Tokenizer:()=>i.MBart50Tokenizer,MBartForCausalLM:()=>t.MBartForCausalLM,MBartForConditionalGeneration:()=>t.MBartForConditionalGeneration,MBartForSequenceClassification:()=>t.MBartForSequenceClassification,MBartModel:()=>t.MBartModel,MBartPreTrainedModel:()=>t.MBartPreTrainedModel,MBartTokenizer:()=>i.MBartTokenizer,MPNetForMaskedLM:()=>t.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>t.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>t.MPNetForSequenceClassification,MPNetForTokenClassification:()=>t.MPNetForTokenClassification,MPNetModel:()=>t.MPNetModel,MPNetPreTrainedModel:()=>t.MPNetPreTrainedModel,MPNetTokenizer:()=>i.MPNetTokenizer,MT5ForConditionalGeneration:()=>t.MT5ForConditionalGeneration,MT5Model:()=>t.MT5Model,MT5PreTrainedModel:()=>t.MT5PreTrainedModel,MarianMTModel:()=>t.MarianMTModel,MarianModel:()=>t.MarianModel,MarianPreTrainedModel:()=>t.MarianPreTrainedModel,MarianTokenizer:()=>i.MarianTokenizer,Mask2FormerImageProcessor:()=>y.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>y.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>t.MaskFormerForInstanceSegmentation,MaskFormerImageProcessor:()=>y.MaskFormerImageProcessor,MaskFormerModel:()=>t.MaskFormerModel,MaskFormerPreTrainedModel:()=>t.MaskFormerPreTrainedModel,MaskedLMOutput:()=>t.MaskedLMOutput,MaxLengthCriteria:()=>x.MaxLengthCriteria,Metric3DForDepthEstimation:()=>t.Metric3DForDepthEstimation,Metric3DPreTrainedModel:()=>t.Metric3DPreTrainedModel,Metric3Dv2ForDepthEstimation:()=>t.Metric3Dv2ForDepthEstimation,Metric3Dv2PreTrainedModel:()=>t.Metric3Dv2PreTrainedModel,MgpstrForSceneTextRecognition:()=>t.MgpstrForSceneTextRecognition,MgpstrModelOutput:()=>t.MgpstrModelOutput,MgpstrPreTrainedModel:()=>t.MgpstrPreTrainedModel,MgpstrProcessor:()=>M.MgpstrProcessor,MgpstrTokenizer:()=>i.MgpstrTokenizer,MimiDecoderModel:()=>t.MimiDecoderModel,MimiDecoderOutput:()=>t.MimiDecoderOutput,MimiEncoderModel:()=>t.MimiEncoderModel,MimiEncoderOutput:()=>t.MimiEncoderOutput,MimiModel:()=>t.MimiModel,MimiPreTrainedModel:()=>t.MimiPreTrainedModel,MinLengthLogitsProcessor:()=>R.MinLengthLogitsProcessor,MinNewTokensLengthLogitsProcessor:()=>R.MinNewTokensLengthLogitsProcessor,MistralForCausalLM:()=>t.MistralForCausalLM,MistralModel:()=>t.MistralModel,MistralPreTrainedModel:()=>t.MistralPreTrainedModel,MobileBertForMaskedLM:()=>t.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>t.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>t.MobileBertForSequenceClassification,MobileBertModel:()=>t.MobileBertModel,MobileBertPreTrainedModel:()=>t.MobileBertPreTrainedModel,MobileBertTokenizer:()=>i.MobileBertTokenizer,MobileLLMForCausalLM:()=>t.MobileLLMForCausalLM,MobileLLMModel:()=>t.MobileLLMModel,MobileLLMPreTrainedModel:()=>t.MobileLLMPreTrainedModel,MobileNetV1FeatureExtractor:()=>y.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>t.MobileNetV1ForImageClassification,MobileNetV1ForSemanticSegmentation:()=>t.MobileNetV1ForSemanticSegmentation,MobileNetV1ImageProcessor:()=>y.MobileNetV1ImageProcessor,MobileNetV1Model:()=>t.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>t.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>y.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>t.MobileNetV2ForImageClassification,MobileNetV2ForSemanticSegmentation:()=>t.MobileNetV2ForSemanticSegmentation,MobileNetV2ImageProcessor:()=>y.MobileNetV2ImageProcessor,MobileNetV2Model:()=>t.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>t.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>y.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>t.MobileNetV3ForImageClassification,MobileNetV3ForSemanticSegmentation:()=>t.MobileNetV3ForSemanticSegmentation,MobileNetV3ImageProcessor:()=>y.MobileNetV3ImageProcessor,MobileNetV3Model:()=>t.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>t.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>y.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>t.MobileNetV4ForImageClassification,MobileNetV4ForSemanticSegmentation:()=>t.MobileNetV4ForSemanticSegmentation,MobileNetV4ImageProcessor:()=>y.MobileNetV4ImageProcessor,MobileNetV4Model:()=>t.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>t.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>y.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>t.MobileViTForImageClassification,MobileViTImageProcessor:()=>y.MobileViTImageProcessor,MobileViTModel:()=>t.MobileViTModel,MobileViTPreTrainedModel:()=>t.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>t.MobileViTV2ForImageClassification,MobileViTV2Model:()=>t.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>t.MobileViTV2PreTrainedModel,ModelOutput:()=>t.ModelOutput,ModernBertDecoderForCausalLM:()=>t.ModernBertDecoderForCausalLM,ModernBertDecoderModel:()=>t.ModernBertDecoderModel,ModernBertDecoderPreTrainedModel:()=>t.ModernBertDecoderPreTrainedModel,ModernBertForMaskedLM:()=>t.ModernBertForMaskedLM,ModernBertForSequenceClassification:()=>t.ModernBertForSequenceClassification,ModernBertForTokenClassification:()=>t.ModernBertForTokenClassification,ModernBertModel:()=>t.ModernBertModel,ModernBertPreTrainedModel:()=>t.ModernBertPreTrainedModel,Moondream1ForConditionalGeneration:()=>t.Moondream1ForConditionalGeneration,MoonshineFeatureExtractor:()=>p.MoonshineFeatureExtractor,MoonshineForConditionalGeneration:()=>t.MoonshineForConditionalGeneration,MoonshineModel:()=>t.MoonshineModel,MoonshinePreTrainedModel:()=>t.MoonshinePreTrainedModel,MoonshineProcessor:()=>M.MoonshineProcessor,MptForCausalLM:()=>t.MptForCausalLM,MptModel:()=>t.MptModel,MptPreTrainedModel:()=>t.MptPreTrainedModel,MultiModalityCausalLM:()=>t.MultiModalityCausalLM,MultiModalityPreTrainedModel:()=>t.MultiModalityPreTrainedModel,MusicgenForCausalLM:()=>t.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>t.MusicgenForConditionalGeneration,MusicgenModel:()=>t.MusicgenModel,MusicgenPreTrainedModel:()=>t.MusicgenPreTrainedModel,NanoChatForCausalLM:()=>t.NanoChatForCausalLM,NanoChatModel:()=>t.NanoChatModel,NanoChatPreTrainedModel:()=>t.NanoChatPreTrainedModel,NeoBertForMaskedLM:()=>t.NeoBertForMaskedLM,NeoBertForQuestionAnswering:()=>t.NeoBertForQuestionAnswering,NeoBertForSequenceClassification:()=>t.NeoBertForSequenceClassification,NeoBertForTokenClassification:()=>t.NeoBertForTokenClassification,NeoBertModel:()=>t.NeoBertModel,NeoBertPreTrainedModel:()=>t.NeoBertPreTrainedModel,NllbTokenizer:()=>i.NllbTokenizer,NoBadWordsLogitsProcessor:()=>R.NoBadWordsLogitsProcessor,NoRepeatNGramLogitsProcessor:()=>R.NoRepeatNGramLogitsProcessor,NomicBertModel:()=>t.NomicBertModel,NomicBertPreTrainedModel:()=>t.NomicBertPreTrainedModel,NougatImageProcessor:()=>y.NougatImageProcessor,NougatTokenizer:()=>i.NougatTokenizer,OPTForCausalLM:()=>t.OPTForCausalLM,OPTModel:()=>t.OPTModel,OPTPreTrainedModel:()=>t.OPTPreTrainedModel,ObjectDetectionPipeline:()=>e.ObjectDetectionPipeline,Olmo2ForCausalLM:()=>t.Olmo2ForCausalLM,Olmo2Model:()=>t.Olmo2Model,Olmo2PreTrainedModel:()=>t.Olmo2PreTrainedModel,OlmoForCausalLM:()=>t.OlmoForCausalLM,OlmoModel:()=>t.OlmoModel,OlmoPreTrainedModel:()=>t.OlmoPreTrainedModel,OpenELMForCausalLM:()=>t.OpenELMForCausalLM,OpenELMModel:()=>t.OpenELMModel,OpenELMPreTrainedModel:()=>t.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>y.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>t.OwlViTForObjectDetection,OwlViTImageProcessor:()=>y.OwlViTImageProcessor,OwlViTModel:()=>t.OwlViTModel,OwlViTPreTrainedModel:()=>t.OwlViTPreTrainedModel,OwlViTProcessor:()=>M.OwlViTProcessor,Owlv2ForObjectDetection:()=>t.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>y.Owlv2ImageProcessor,Owlv2Model:()=>t.Owlv2Model,Owlv2PreTrainedModel:()=>t.Owlv2PreTrainedModel,PaliGemmaForConditionalGeneration:()=>t.PaliGemmaForConditionalGeneration,PaliGemmaPreTrainedModel:()=>t.PaliGemmaPreTrainedModel,PaliGemmaProcessor:()=>M.PaliGemmaProcessor,ParakeetFeatureExtractor:()=>p.ParakeetFeatureExtractor,ParakeetForCTC:()=>t.ParakeetForCTC,ParakeetPreTrainedModel:()=>t.ParakeetPreTrainedModel,PatchTSMixerForPrediction:()=>t.PatchTSMixerForPrediction,PatchTSMixerModel:()=>t.PatchTSMixerModel,PatchTSMixerPreTrainedModel:()=>t.PatchTSMixerPreTrainedModel,PatchTSTForPrediction:()=>t.PatchTSTForPrediction,PatchTSTModel:()=>t.PatchTSTModel,PatchTSTPreTrainedModel:()=>t.PatchTSTPreTrainedModel,Phi3ForCausalLM:()=>t.Phi3ForCausalLM,Phi3Model:()=>t.Phi3Model,Phi3PreTrainedModel:()=>t.Phi3PreTrainedModel,Phi3VForCausalLM:()=>t.Phi3VForCausalLM,Phi3VImageProcessor:()=>y.Phi3VImageProcessor,Phi3VPreTrainedModel:()=>t.Phi3VPreTrainedModel,Phi3VProcessor:()=>M.Phi3VProcessor,PhiForCausalLM:()=>t.PhiForCausalLM,PhiModel:()=>t.PhiModel,PhiPreTrainedModel:()=>t.PhiPreTrainedModel,Pipeline:()=>e.Pipeline,PreTrainedModel:()=>t.PreTrainedModel,PreTrainedTokenizer:()=>i.PreTrainedTokenizer,PretrainedConfig:()=>s.PretrainedConfig,PretrainedMixin:()=>t.PretrainedMixin,Processor:()=>S.Processor,PvtForImageClassification:()=>t.PvtForImageClassification,PvtImageProcessor:()=>y.PvtImageProcessor,PvtModel:()=>t.PvtModel,PvtPreTrainedModel:()=>t.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>p.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>t.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>t.PyAnnoteModel,PyAnnotePreTrainedModel:()=>t.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>M.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>t.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>e.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>t.Qwen2ForCausalLM,Qwen2Model:()=>t.Qwen2Model,Qwen2PreTrainedModel:()=>t.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>i.Qwen2Tokenizer,Qwen2VLForConditionalGeneration:()=>t.Qwen2VLForConditionalGeneration,Qwen2VLImageProcessor:()=>y.Qwen2VLImageProcessor,Qwen2VLPreTrainedModel:()=>t.Qwen2VLPreTrainedModel,Qwen2VLProcessor:()=>M.Qwen2VLProcessor,Qwen3ForCausalLM:()=>t.Qwen3ForCausalLM,Qwen3Model:()=>t.Qwen3Model,Qwen3PreTrainedModel:()=>t.Qwen3PreTrainedModel,RFDetrForObjectDetection:()=>t.RFDetrForObjectDetection,RFDetrModel:()=>t.RFDetrModel,RFDetrObjectDetectionOutput:()=>t.RFDetrObjectDetectionOutput,RFDetrPreTrainedModel:()=>t.RFDetrPreTrainedModel,RTDetrForObjectDetection:()=>t.RTDetrForObjectDetection,RTDetrImageProcessor:()=>y.RTDetrImageProcessor,RTDetrModel:()=>t.RTDetrModel,RTDetrObjectDetectionOutput:()=>t.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>t.RTDetrPreTrainedModel,RTDetrV2ForObjectDetection:()=>t.RTDetrV2ForObjectDetection,RTDetrV2Model:()=>t.RTDetrV2Model,RTDetrV2ObjectDetectionOutput:()=>t.RTDetrV2ObjectDetectionOutput,RTDetrV2PreTrainedModel:()=>t.RTDetrV2PreTrainedModel,RawAudio:()=>r.RawAudio,RawImage:()=>o.RawImage,RawVideo:()=>l.RawVideo,RawVideoFrame:()=>l.RawVideoFrame,RepetitionPenaltyLogitsProcessor:()=>R.RepetitionPenaltyLogitsProcessor,ResNetForImageClassification:()=>t.ResNetForImageClassification,ResNetModel:()=>t.ResNetModel,ResNetPreTrainedModel:()=>t.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>t.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>t.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>t.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>t.RoFormerForTokenClassification,RoFormerModel:()=>t.RoFormerModel,RoFormerPreTrainedModel:()=>t.RoFormerPreTrainedModel,RoFormerTokenizer:()=>i.RoFormerTokenizer,RobertaForMaskedLM:()=>t.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>t.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>t.RobertaForSequenceClassification,RobertaForTokenClassification:()=>t.RobertaForTokenClassification,RobertaModel:()=>t.RobertaModel,RobertaPreTrainedModel:()=>t.RobertaPreTrainedModel,RobertaTokenizer:()=>i.RobertaTokenizer,Sam2ImageProcessor:()=>y.Sam2ImageProcessor,Sam2ImageSegmentationOutput:()=>t.Sam2ImageSegmentationOutput,Sam2Model:()=>t.Sam2Model,Sam2PreTrainedModel:()=>t.Sam2PreTrainedModel,Sam2Processor:()=>M.Sam2Processor,Sam2VideoProcessor:()=>M.Sam2VideoProcessor,Sam3ImageProcessor:()=>y.Sam3ImageProcessor,Sam3TrackerModel:()=>t.Sam3TrackerModel,SamImageProcessor:()=>y.SamImageProcessor,SamImageSegmentationOutput:()=>t.SamImageSegmentationOutput,SamModel:()=>t.SamModel,SamPreTrainedModel:()=>t.SamPreTrainedModel,SamProcessor:()=>M.SamProcessor,SapiensForDepthEstimation:()=>t.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>t.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>t.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>t.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>p.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>y.SegformerFeatureExtractor,SegformerForImageClassification:()=>t.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>t.SegformerForSemanticSegmentation,SegformerImageProcessor:()=>y.SegformerImageProcessor,SegformerModel:()=>t.SegformerModel,SegformerPreTrainedModel:()=>t.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>t.Seq2SeqLMOutput,SequenceClassifierOutput:()=>t.SequenceClassifierOutput,SiglipImageProcessor:()=>y.SiglipImageProcessor,SiglipModel:()=>t.SiglipModel,SiglipPreTrainedModel:()=>t.SiglipPreTrainedModel,SiglipTextModel:()=>t.SiglipTextModel,SiglipTokenizer:()=>i.SiglipTokenizer,SiglipVisionModel:()=>t.SiglipVisionModel,SmolLM3ForCausalLM:()=>t.SmolLM3ForCausalLM,SmolLM3Model:()=>t.SmolLM3Model,SmolLM3PreTrainedModel:()=>t.SmolLM3PreTrainedModel,SmolVLMForConditionalGeneration:()=>t.SmolVLMForConditionalGeneration,SmolVLMImageProcessor:()=>y.SmolVLMImageProcessor,SmolVLMProcessor:()=>M.SmolVLMProcessor,SnacDecoderModel:()=>t.SnacDecoderModel,SnacEncoderModel:()=>t.SnacEncoderModel,SnacFeatureExtractor:()=>p.SnacFeatureExtractor,SnacModel:()=>t.SnacModel,SnacPreTrainedModel:()=>t.SnacPreTrainedModel,SpeechT5FeatureExtractor:()=>p.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>t.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>t.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>t.SpeechT5HifiGan,SpeechT5Model:()=>t.SpeechT5Model,SpeechT5PreTrainedModel:()=>t.SpeechT5PreTrainedModel,SpeechT5Processor:()=>M.SpeechT5Processor,SpeechT5Tokenizer:()=>i.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>t.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>t.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>t.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>t.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>t.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>i.SqueezeBertTokenizer,StableLmForCausalLM:()=>t.StableLmForCausalLM,StableLmModel:()=>t.StableLmModel,StableLmPreTrainedModel:()=>t.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>t.Starcoder2ForCausalLM,Starcoder2Model:()=>t.Starcoder2Model,Starcoder2PreTrainedModel:()=>t.Starcoder2PreTrainedModel,StoppingCriteria:()=>x.StoppingCriteria,StoppingCriteriaList:()=>x.StoppingCriteriaList,StyleTextToSpeech2Model:()=>t.StyleTextToSpeech2Model,StyleTextToSpeech2PreTrainedModel:()=>t.StyleTextToSpeech2PreTrainedModel,SummarizationPipeline:()=>e.SummarizationPipeline,SupertonicForConditionalGeneration:()=>t.SupertonicForConditionalGeneration,SupertonicPreTrainedModel:()=>t.SupertonicPreTrainedModel,SuppressTokensAtBeginLogitsProcessor:()=>R.SuppressTokensAtBeginLogitsProcessor,Swin2SRForImageSuperResolution:()=>t.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>y.Swin2SRImageProcessor,Swin2SRModel:()=>t.Swin2SRModel,Swin2SRPreTrainedModel:()=>t.Swin2SRPreTrainedModel,SwinForImageClassification:()=>t.SwinForImageClassification,SwinForSemanticSegmentation:()=>t.SwinForSemanticSegmentation,SwinModel:()=>t.SwinModel,SwinPreTrainedModel:()=>t.SwinPreTrainedModel,T5ForConditionalGeneration:()=>t.T5ForConditionalGeneration,T5Model:()=>t.T5Model,T5PreTrainedModel:()=>t.T5PreTrainedModel,T5Tokenizer:()=>i.T5Tokenizer,TableTransformerForObjectDetection:()=>t.TableTransformerForObjectDetection,TableTransformerModel:()=>t.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>t.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>t.TableTransformerPreTrainedModel,TemperatureLogitsWarper:()=>R.TemperatureLogitsWarper,Tensor:()=>c.Tensor,Text2TextGenerationPipeline:()=>e.Text2TextGenerationPipeline,TextClassificationPipeline:()=>e.TextClassificationPipeline,TextGenerationPipeline:()=>e.TextGenerationPipeline,TextStreamer:()=>C.TextStreamer,TextToAudioPipeline:()=>e.TextToAudioPipeline,TokenClassificationPipeline:()=>e.TokenClassificationPipeline,TokenClassifierOutput:()=>t.TokenClassifierOutput,TokenizerModel:()=>i.TokenizerModel,TopKLogitsWarper:()=>R.TopKLogitsWarper,TopPLogitsWarper:()=>R.TopPLogitsWarper,TrOCRForCausalLM:()=>t.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>t.TrOCRPreTrainedModel,TranslationPipeline:()=>e.TranslationPipeline,UltravoxModel:()=>t.UltravoxModel,UltravoxPreTrainedModel:()=>t.UltravoxPreTrainedModel,UltravoxProcessor:()=>M.UltravoxProcessor,UniSpeechForCTC:()=>t.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>t.UniSpeechForSequenceClassification,UniSpeechModel:()=>t.UniSpeechModel,UniSpeechPreTrainedModel:()=>t.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>t.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>t.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>t.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>t.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>t.UniSpeechSatPreTrainedModel,VLChatProcessor:()=>M.VLChatProcessor,VLMImageProcessor:()=>y.VLMImageProcessor,VaultGemmaForCausalLM:()=>t.VaultGemmaForCausalLM,VaultGemmaModel:()=>t.VaultGemmaModel,VaultGemmaPreTrainedModel:()=>t.VaultGemmaPreTrainedModel,ViTFeatureExtractor:()=>y.ViTFeatureExtractor,ViTForImageClassification:()=>t.ViTForImageClassification,ViTImageProcessor:()=>y.ViTImageProcessor,ViTMAEModel:()=>t.ViTMAEModel,ViTMAEPreTrainedModel:()=>t.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>t.ViTMSNForImageClassification,ViTMSNModel:()=>t.ViTMSNModel,ViTMSNPreTrainedModel:()=>t.ViTMSNPreTrainedModel,ViTModel:()=>t.ViTModel,ViTPreTrainedModel:()=>t.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>t.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>t.VitMatteForImageMatting,VitMatteImageProcessor:()=>y.VitMatteImageProcessor,VitMattePreTrainedModel:()=>t.VitMattePreTrainedModel,VitPoseForPoseEstimation:()=>t.VitPoseForPoseEstimation,VitPoseImageProcessor:()=>y.VitPoseImageProcessor,VitPosePreTrainedModel:()=>t.VitPosePreTrainedModel,VitsModel:()=>t.VitsModel,VitsModelOutput:()=>t.VitsModelOutput,VitsPreTrainedModel:()=>t.VitsPreTrainedModel,VitsTokenizer:()=>i.VitsTokenizer,VoxtralForConditionalGeneration:()=>t.VoxtralForConditionalGeneration,VoxtralProcessor:()=>M.VoxtralProcessor,Wav2Vec2BertForCTC:()=>t.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>t.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>t.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>t.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>i.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>p.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>t.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>t.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>t.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>t.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>t.Wav2Vec2PreTrainedModel,Wav2Vec2Processor:()=>M.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>M.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>t.WavLMForAudioFrameClassification,WavLMForCTC:()=>t.WavLMForCTC,WavLMForSequenceClassification:()=>t.WavLMForSequenceClassification,WavLMForXVector:()=>t.WavLMForXVector,WavLMModel:()=>t.WavLMModel,WavLMPreTrainedModel:()=>t.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>p.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>t.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>t.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>p.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>t.WhisperForConditionalGeneration,WhisperModel:()=>t.WhisperModel,WhisperPreTrainedModel:()=>t.WhisperPreTrainedModel,WhisperProcessor:()=>M.WhisperProcessor,WhisperTextStreamer:()=>C.WhisperTextStreamer,WhisperTimeStampLogitsProcessor:()=>R.WhisperTimeStampLogitsProcessor,WhisperTokenizer:()=>i.WhisperTokenizer,XLMForQuestionAnswering:()=>t.XLMForQuestionAnswering,XLMForSequenceClassification:()=>t.XLMForSequenceClassification,XLMForTokenClassification:()=>t.XLMForTokenClassification,XLMModel:()=>t.XLMModel,XLMPreTrainedModel:()=>t.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>t.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>t.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>t.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>t.XLMRobertaForTokenClassification,XLMRobertaModel:()=>t.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>t.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>i.XLMRobertaTokenizer,XLMTokenizer:()=>i.XLMTokenizer,XLMWithLMHeadModel:()=>t.XLMWithLMHeadModel,XVectorOutput:()=>t.XVectorOutput,YolosFeatureExtractor:()=>y.YolosFeatureExtractor,YolosForObjectDetection:()=>t.YolosForObjectDetection,YolosImageProcessor:()=>y.YolosImageProcessor,YolosModel:()=>t.YolosModel,YolosObjectDetectionOutput:()=>t.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>t.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>e.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>e.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>e.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>e.ZeroShotObjectDetectionPipeline,bankers_round:()=>d.bankers_round,cat:()=>c.cat,cos_sim:()=>d.cos_sim,dot:()=>d.dot,dynamic_time_warping:()=>d.dynamic_time_warping,env:()=>n.env,full:()=>c.full,full_like:()=>c.full_like,getCacheShapes:()=>s.getCacheShapes,hamming:()=>r.hamming,hanning:()=>r.hanning,interpolate:()=>c.interpolate,interpolate_4d:()=>c.interpolate_4d,interpolate_data:()=>d.interpolate_data,is_chinese_char:()=>i.is_chinese_char,layer_norm:()=>c.layer_norm,load_image:()=>o.load_image,load_video:()=>l.load_video,log_softmax:()=>d.log_softmax,magnitude:()=>d.magnitude,matmul:()=>c.matmul,max:()=>d.max,mean:()=>c.mean,mean_pooling:()=>c.mean_pooling,medianFilter:()=>d.medianFilter,mel_filter_bank:()=>r.mel_filter_bank,min:()=>d.min,ones:()=>c.ones,ones_like:()=>c.ones_like,permute:()=>c.permute,permute_data:()=>d.permute_data,pipeline:()=>e.pipeline,quantize_embeddings:()=>c.quantize_embeddings,rand:()=>c.rand,randn:()=>c.randn,read_audio:()=>r.read_audio,rfft:()=>c.rfft,round:()=>d.round,slice:()=>c.slice,softmax:()=>d.softmax,spectrogram:()=>r.spectrogram,stack:()=>c.stack,std_mean:()=>c.std_mean,topk:()=>c.topk,window_function:()=>r.window_function,zeros:()=>c.zeros,zeros_like:()=>c.zeros_like});var n=Es("./src/env.js"),e=Es("./src/pipelines.js"),t=Es("./src/models.js"),i=Es("./src/tokenizers.js"),s=Es("./src/configs.js"),r=Es("./src/utils/audio.js"),o=Es("./src/utils/image.js"),l=Es("./src/utils/video.js"),c=Es("./src/utils/tensor.js"),d=Es("./src/utils/maths.js"),g=Es("./src/base/feature_extraction_utils.js"),p=Es("./src/models/feature_extractors.js"),h=Es("./src/models/auto/feature_extraction_auto.js"),v=Es("./src/base/image_processors_utils.js"),y=Es("./src/models/image_processors.js"),w=Es("./src/models/auto/image_processing_auto.js"),S=Es("./src/base/processing_utils.js"),M=Es("./src/models/processors.js"),T=Es("./src/models/auto/processing_auto.js"),C=Es("./src/generation/streamers.js"),x=Es("./src/generation/stopping_criteria.js"),R=Es("./src/generation/logits_process.js")})();H.ASTFeatureExtractor;H.ASTForAudioClassification;H.ASTModel;H.ASTPreTrainedModel;H.AlbertForMaskedLM;H.AlbertForQuestionAnswering;H.AlbertForSequenceClassification;H.AlbertModel;H.AlbertPreTrainedModel;H.AlbertTokenizer;H.ArceeForCausalLM;H.ArceeModel;H.ArceePreTrainedModel;H.AudioClassificationPipeline;H.AutoConfig;H.AutoFeatureExtractor;H.AutoImageProcessor;H.AutoModel;H.AutoModelForAudioClassification;H.AutoModelForAudioFrameClassification;H.AutoModelForAudioTextToText;H.AutoModelForCTC;H.AutoModelForCausalLM;H.AutoModelForDepthEstimation;H.AutoModelForDocumentQuestionAnswering;H.AutoModelForImageClassification;H.AutoModelForImageFeatureExtraction;H.AutoModelForImageMatting;H.AutoModelForImageSegmentation;H.AutoModelForImageTextToText;H.AutoModelForImageToImage;H.AutoModelForMaskGeneration;H.AutoModelForMaskedLM;H.AutoModelForNormalEstimation;H.AutoModelForObjectDetection;H.AutoModelForPoseEstimation;H.AutoModelForQuestionAnswering;H.AutoModelForSemanticSegmentation;H.AutoModelForSeq2SeqLM;H.AutoModelForSequenceClassification;H.AutoModelForSpeechSeq2Seq;H.AutoModelForTextToSpectrogram;H.AutoModelForTextToWaveform;H.AutoModelForTokenClassification;H.AutoModelForUniversalSegmentation;H.AutoModelForVision2Seq;H.AutoModelForXVector;H.AutoModelForZeroShotObjectDetection;H.AutoProcessor;H.AutoTokenizer;H.AutomaticSpeechRecognitionPipeline;H.BackgroundRemovalPipeline;H.BartForConditionalGeneration;H.BartForSequenceClassification;H.BartModel;H.BartPretrainedModel;H.BartTokenizer;H.BaseModelOutput;H.BaseStreamer;H.BeitFeatureExtractor;H.BeitForImageClassification;H.BeitModel;H.BeitPreTrainedModel;H.BertForMaskedLM;H.BertForQuestionAnswering;H.BertForSequenceClassification;H.BertForTokenClassification;H.BertModel;H.BertPreTrainedModel;H.BertTokenizer;H.BitImageProcessor;H.BlenderbotForConditionalGeneration;H.BlenderbotModel;H.BlenderbotPreTrainedModel;H.BlenderbotSmallForConditionalGeneration;H.BlenderbotSmallModel;H.BlenderbotSmallPreTrainedModel;H.BlenderbotSmallTokenizer;H.BlenderbotTokenizer;H.BloomForCausalLM;H.BloomModel;H.BloomPreTrainedModel;H.BloomTokenizer;H.CLIPFeatureExtractor;H.CLIPImageProcessor;H.CLIPModel;H.CLIPPreTrainedModel;H.CLIPSegForImageSegmentation;H.CLIPSegModel;H.CLIPSegPreTrainedModel;H.CLIPTextModel;H.CLIPTextModelWithProjection;H.CLIPTokenizer;H.CLIPVisionModel;H.CLIPVisionModelWithProjection;H.CamembertForMaskedLM;H.CamembertForQuestionAnswering;H.CamembertForSequenceClassification;H.CamembertForTokenClassification;H.CamembertModel;H.CamembertPreTrainedModel;H.CamembertTokenizer;H.CausalLMOutput;H.CausalLMOutputWithPast;H.ChineseCLIPFeatureExtractor;H.ChineseCLIPModel;H.ChineseCLIPPreTrainedModel;H.ClapAudioModelWithProjection;H.ClapFeatureExtractor;H.ClapModel;H.ClapPreTrainedModel;H.ClapTextModelWithProjection;H.ClassifierFreeGuidanceLogitsProcessor;H.CodeGenForCausalLM;H.CodeGenModel;H.CodeGenPreTrainedModel;H.CodeGenTokenizer;H.CodeLlamaTokenizer;H.CohereForCausalLM;H.CohereModel;H.CoherePreTrainedModel;H.CohereTokenizer;H.ConvBertForMaskedLM;H.ConvBertForQuestionAnswering;H.ConvBertForSequenceClassification;H.ConvBertForTokenClassification;H.ConvBertModel;H.ConvBertPreTrainedModel;H.ConvBertTokenizer;H.ConvNextFeatureExtractor;H.ConvNextForImageClassification;H.ConvNextImageProcessor;H.ConvNextModel;H.ConvNextPreTrainedModel;H.ConvNextV2ForImageClassification;H.ConvNextV2Model;H.ConvNextV2PreTrainedModel;H.DFineForObjectDetection;H.DFineModel;H.DFinePreTrainedModel;H.DINOv3ConvNextModel;H.DINOv3ConvNextPreTrainedModel;H.DINOv3ViTImageProcessor;H.DINOv3ViTModel;H.DINOv3ViTPreTrainedModel;H.DPTFeatureExtractor;H.DPTForDepthEstimation;H.DPTImageProcessor;H.DPTModel;H.DPTPreTrainedModel;H.DacDecoderModel;H.DacDecoderOutput;H.DacEncoderModel;H.DacEncoderOutput;H.DacFeatureExtractor;H.DacModel;H.DacPreTrainedModel;H.DataTypeMap;H.DebertaForMaskedLM;H.DebertaForQuestionAnswering;H.DebertaForSequenceClassification;H.DebertaForTokenClassification;H.DebertaModel;H.DebertaPreTrainedModel;H.DebertaTokenizer;H.DebertaV2ForMaskedLM;H.DebertaV2ForQuestionAnswering;H.DebertaV2ForSequenceClassification;H.DebertaV2ForTokenClassification;H.DebertaV2Model;H.DebertaV2PreTrainedModel;H.DebertaV2Tokenizer;H.DecisionTransformerModel;H.DecisionTransformerPreTrainedModel;H.DeiTFeatureExtractor;H.DeiTForImageClassification;H.DeiTImageProcessor;H.DeiTModel;H.DeiTPreTrainedModel;H.DepthAnythingForDepthEstimation;H.DepthAnythingPreTrainedModel;H.DepthEstimationPipeline;H.DepthProForDepthEstimation;H.DepthProPreTrainedModel;H.DetrFeatureExtractor;H.DetrForObjectDetection;H.DetrForSegmentation;H.DetrImageProcessor;H.DetrModel;H.DetrObjectDetectionOutput;H.DetrPreTrainedModel;H.DetrSegmentationOutput;H.Dinov2ForImageClassification;H.Dinov2Model;H.Dinov2PreTrainedModel;H.Dinov2WithRegistersForImageClassification;H.Dinov2WithRegistersModel;H.Dinov2WithRegistersPreTrainedModel;H.DistilBertForMaskedLM;H.DistilBertForQuestionAnswering;H.DistilBertForSequenceClassification;H.DistilBertForTokenClassification;H.DistilBertModel;H.DistilBertPreTrainedModel;H.DistilBertTokenizer;H.DocumentQuestionAnsweringPipeline;H.DonutFeatureExtractor;H.DonutImageProcessor;H.DonutSwinModel;H.DonutSwinPreTrainedModel;H.EdgeTamModel;H.EfficientNetForImageClassification;H.EfficientNetImageProcessor;H.EfficientNetModel;H.EfficientNetPreTrainedModel;H.ElectraForMaskedLM;H.ElectraForQuestionAnswering;H.ElectraForSequenceClassification;H.ElectraForTokenClassification;H.ElectraModel;H.ElectraPreTrainedModel;H.ElectraTokenizer;H.EncodecFeatureExtractor;H.EosTokenCriteria;H.Ernie4_5_ForCausalLM;H.Ernie4_5_Model;H.Ernie4_5_PretrainedModel;H.Ernie4_5_Tokenizer;H.EsmForMaskedLM;H.EsmForSequenceClassification;H.EsmForTokenClassification;H.EsmModel;H.EsmPreTrainedModel;H.EsmTokenizer;H.ExaoneForCausalLM;H.ExaoneModel;H.ExaonePreTrainedModel;H.FFT;H.FalconForCausalLM;H.FalconModel;H.FalconPreTrainedModel;H.FalconTokenizer;H.FastViTForImageClassification;H.FastViTModel;H.FastViTPreTrainedModel;H.FeatureExtractionPipeline;H.FeatureExtractor;H.FillMaskPipeline;H.Florence2ForConditionalGeneration;H.Florence2PreTrainedModel;H.Florence2Processor;H.ForcedBOSTokenLogitsProcessor;H.ForcedEOSTokenLogitsProcessor;H.GLPNFeatureExtractor;H.GLPNForDepthEstimation;H.GLPNModel;H.GLPNPreTrainedModel;H.GPT2LMHeadModel;H.GPT2Model;H.GPT2PreTrainedModel;H.GPT2Tokenizer;H.GPTBigCodeForCausalLM;H.GPTBigCodeModel;H.GPTBigCodePreTrainedModel;H.GPTJForCausalLM;H.GPTJModel;H.GPTJPreTrainedModel;H.GPTNeoForCausalLM;H.GPTNeoModel;H.GPTNeoPreTrainedModel;H.GPTNeoXForCausalLM;H.GPTNeoXModel;H.GPTNeoXPreTrainedModel;H.GPTNeoXTokenizer;H.Gemma2ForCausalLM;H.Gemma2Model;H.Gemma2PreTrainedModel;H.Gemma3ForCausalLM;H.Gemma3Model;H.Gemma3PreTrainedModel;H.Gemma3nAudioFeatureExtractor;H.Gemma3nForConditionalGeneration;H.Gemma3nPreTrainedModel;H.Gemma3nProcessor;H.GemmaForCausalLM;H.GemmaModel;H.GemmaPreTrainedModel;H.GemmaTokenizer;H.GlmForCausalLM;H.GlmModel;H.GlmPreTrainedModel;H.GraniteForCausalLM;H.GraniteModel;H.GraniteMoeHybridForCausalLM;H.GraniteMoeHybridModel;H.GraniteMoeHybridPreTrainedModel;H.GranitePreTrainedModel;H.Grok1Tokenizer;H.GroundingDinoForObjectDetection;H.GroundingDinoImageProcessor;H.GroundingDinoPreTrainedModel;H.GroundingDinoProcessor;H.GroupViTModel;H.GroupViTPreTrainedModel;H.HeliumForCausalLM;H.HeliumModel;H.HeliumPreTrainedModel;H.HerbertTokenizer;H.HieraForImageClassification;H.HieraModel;H.HieraPreTrainedModel;H.HubertForCTC;H.HubertForSequenceClassification;H.HubertModel;H.HubertPreTrainedModel;H.IJepaForImageClassification;H.IJepaModel;H.IJepaPreTrainedModel;H.Idefics3ForConditionalGeneration;H.Idefics3ImageProcessor;H.Idefics3PreTrainedModel;H.Idefics3Processor;H.ImageClassificationPipeline;H.ImageFeatureExtractionPipeline;H.ImageFeatureExtractor;H.ImageMattingOutput;H.ImageProcessor;H.ImageSegmentationPipeline;H.ImageToImagePipeline;H.ImageToTextPipeline;H.InterruptableStoppingCriteria;H.JAISLMHeadModel;H.JAISModel;H.JAISPreTrainedModel;H.JinaCLIPImageProcessor;H.JinaCLIPModel;H.JinaCLIPPreTrainedModel;H.JinaCLIPProcessor;H.JinaCLIPTextModel;H.JinaCLIPVisionModel;H.Lfm2ForCausalLM;H.Lfm2Model;H.Lfm2PreTrainedModel;H.LiteWhisperForConditionalGeneration;H.Llama4ForCausalLM;H.Llama4PreTrainedModel;H.LlamaForCausalLM;H.LlamaModel;H.LlamaPreTrainedModel;H.LlamaTokenizer;H.LlavaForConditionalGeneration;H.LlavaOnevisionForConditionalGeneration;H.LlavaOnevisionImageProcessor;H.LlavaPreTrainedModel;H.LlavaProcessor;H.LlavaQwen2ForCausalLM;H.LogitsProcessor;H.LogitsProcessorList;H.LogitsWarper;H.LongT5ForConditionalGeneration;H.LongT5Model;H.LongT5PreTrainedModel;H.M2M100ForConditionalGeneration;H.M2M100Model;H.M2M100PreTrainedModel;H.M2M100Tokenizer;H.MBart50Tokenizer;H.MBartForCausalLM;H.MBartForConditionalGeneration;H.MBartForSequenceClassification;H.MBartModel;H.MBartPreTrainedModel;H.MBartTokenizer;H.MPNetForMaskedLM;H.MPNetForQuestionAnswering;H.MPNetForSequenceClassification;H.MPNetForTokenClassification;H.MPNetModel;H.MPNetPreTrainedModel;H.MPNetTokenizer;H.MT5ForConditionalGeneration;H.MT5Model;H.MT5PreTrainedModel;H.MarianMTModel;H.MarianModel;H.MarianPreTrainedModel;H.MarianTokenizer;H.Mask2FormerImageProcessor;H.MaskFormerFeatureExtractor;H.MaskFormerForInstanceSegmentation;H.MaskFormerImageProcessor;H.MaskFormerModel;H.MaskFormerPreTrainedModel;H.MaskedLMOutput;H.MaxLengthCriteria;H.Metric3DForDepthEstimation;H.Metric3DPreTrainedModel;H.Metric3Dv2ForDepthEstimation;H.Metric3Dv2PreTrainedModel;H.MgpstrForSceneTextRecognition;H.MgpstrModelOutput;H.MgpstrPreTrainedModel;H.MgpstrProcessor;H.MgpstrTokenizer;H.MimiDecoderModel;H.MimiDecoderOutput;H.MimiEncoderModel;H.MimiEncoderOutput;H.MimiModel;H.MimiPreTrainedModel;H.MinLengthLogitsProcessor;H.MinNewTokensLengthLogitsProcessor;H.MistralForCausalLM;H.MistralModel;H.MistralPreTrainedModel;H.MobileBertForMaskedLM;H.MobileBertForQuestionAnswering;H.MobileBertForSequenceClassification;H.MobileBertModel;H.MobileBertPreTrainedModel;H.MobileBertTokenizer;H.MobileLLMForCausalLM;H.MobileLLMModel;H.MobileLLMPreTrainedModel;H.MobileNetV1FeatureExtractor;H.MobileNetV1ForImageClassification;H.MobileNetV1ForSemanticSegmentation;H.MobileNetV1ImageProcessor;H.MobileNetV1Model;H.MobileNetV1PreTrainedModel;H.MobileNetV2FeatureExtractor;H.MobileNetV2ForImageClassification;H.MobileNetV2ForSemanticSegmentation;H.MobileNetV2ImageProcessor;H.MobileNetV2Model;H.MobileNetV2PreTrainedModel;H.MobileNetV3FeatureExtractor;H.MobileNetV3ForImageClassification;H.MobileNetV3ForSemanticSegmentation;H.MobileNetV3ImageProcessor;H.MobileNetV3Model;H.MobileNetV3PreTrainedModel;H.MobileNetV4FeatureExtractor;H.MobileNetV4ForImageClassification;H.MobileNetV4ForSemanticSegmentation;H.MobileNetV4ImageProcessor;H.MobileNetV4Model;H.MobileNetV4PreTrainedModel;H.MobileViTFeatureExtractor;H.MobileViTForImageClassification;H.MobileViTImageProcessor;H.MobileViTModel;H.MobileViTPreTrainedModel;H.MobileViTV2ForImageClassification;H.MobileViTV2Model;H.MobileViTV2PreTrainedModel;H.ModelOutput;H.ModernBertDecoderForCausalLM;H.ModernBertDecoderModel;H.ModernBertDecoderPreTrainedModel;H.ModernBertForMaskedLM;H.ModernBertForSequenceClassification;H.ModernBertForTokenClassification;H.ModernBertModel;H.ModernBertPreTrainedModel;H.Moondream1ForConditionalGeneration;H.MoonshineFeatureExtractor;H.MoonshineForConditionalGeneration;H.MoonshineModel;H.MoonshinePreTrainedModel;H.MoonshineProcessor;H.MptForCausalLM;H.MptModel;H.MptPreTrainedModel;H.MultiModalityCausalLM;H.MultiModalityPreTrainedModel;H.MusicgenForCausalLM;H.MusicgenForConditionalGeneration;H.MusicgenModel;H.MusicgenPreTrainedModel;H.NanoChatForCausalLM;H.NanoChatModel;H.NanoChatPreTrainedModel;H.NeoBertForMaskedLM;H.NeoBertForQuestionAnswering;H.NeoBertForSequenceClassification;H.NeoBertForTokenClassification;H.NeoBertModel;H.NeoBertPreTrainedModel;H.NllbTokenizer;H.NoBadWordsLogitsProcessor;H.NoRepeatNGramLogitsProcessor;H.NomicBertModel;H.NomicBertPreTrainedModel;H.NougatImageProcessor;H.NougatTokenizer;H.OPTForCausalLM;H.OPTModel;H.OPTPreTrainedModel;H.ObjectDetectionPipeline;H.Olmo2ForCausalLM;H.Olmo2Model;H.Olmo2PreTrainedModel;H.OlmoForCausalLM;H.OlmoModel;H.OlmoPreTrainedModel;H.OpenELMForCausalLM;H.OpenELMModel;H.OpenELMPreTrainedModel;H.OwlViTFeatureExtractor;H.OwlViTForObjectDetection;H.OwlViTImageProcessor;H.OwlViTModel;H.OwlViTPreTrainedModel;H.OwlViTProcessor;H.Owlv2ForObjectDetection;H.Owlv2ImageProcessor;H.Owlv2Model;H.Owlv2PreTrainedModel;H.PaliGemmaForConditionalGeneration;H.PaliGemmaPreTrainedModel;H.PaliGemmaProcessor;H.ParakeetFeatureExtractor;H.ParakeetForCTC;H.ParakeetPreTrainedModel;H.PatchTSMixerForPrediction;H.PatchTSMixerModel;H.PatchTSMixerPreTrainedModel;H.PatchTSTForPrediction;H.PatchTSTModel;H.PatchTSTPreTrainedModel;H.Phi3ForCausalLM;H.Phi3Model;H.Phi3PreTrainedModel;H.Phi3VForCausalLM;H.Phi3VImageProcessor;H.Phi3VPreTrainedModel;H.Phi3VProcessor;H.PhiForCausalLM;H.PhiModel;H.PhiPreTrainedModel;H.Pipeline;H.PreTrainedModel;H.PreTrainedTokenizer;H.PretrainedConfig;H.PretrainedMixin;H.Processor;H.PvtForImageClassification;H.PvtImageProcessor;H.PvtModel;H.PvtPreTrainedModel;H.PyAnnoteFeatureExtractor;H.PyAnnoteForAudioFrameClassification;H.PyAnnoteModel;H.PyAnnotePreTrainedModel;H.PyAnnoteProcessor;H.QuestionAnsweringModelOutput;H.QuestionAnsweringPipeline;H.Qwen2ForCausalLM;H.Qwen2Model;H.Qwen2PreTrainedModel;H.Qwen2Tokenizer;H.Qwen2VLForConditionalGeneration;H.Qwen2VLImageProcessor;H.Qwen2VLPreTrainedModel;H.Qwen2VLProcessor;H.Qwen3ForCausalLM;H.Qwen3Model;H.Qwen3PreTrainedModel;H.RFDetrForObjectDetection;H.RFDetrModel;H.RFDetrObjectDetectionOutput;H.RFDetrPreTrainedModel;H.RTDetrForObjectDetection;H.RTDetrImageProcessor;H.RTDetrModel;H.RTDetrObjectDetectionOutput;H.RTDetrPreTrainedModel;H.RTDetrV2ForObjectDetection;H.RTDetrV2Model;H.RTDetrV2ObjectDetectionOutput;H.RTDetrV2PreTrainedModel;H.RawAudio;H.RawImage;H.RawVideo;H.RawVideoFrame;H.RepetitionPenaltyLogitsProcessor;H.ResNetForImageClassification;H.ResNetModel;H.ResNetPreTrainedModel;H.RoFormerForMaskedLM;H.RoFormerForQuestionAnswering;H.RoFormerForSequenceClassification;H.RoFormerForTokenClassification;H.RoFormerModel;H.RoFormerPreTrainedModel;H.RoFormerTokenizer;H.RobertaForMaskedLM;H.RobertaForQuestionAnswering;H.RobertaForSequenceClassification;H.RobertaForTokenClassification;H.RobertaModel;H.RobertaPreTrainedModel;H.RobertaTokenizer;H.Sam2ImageProcessor;H.Sam2ImageSegmentationOutput;H.Sam2Model;H.Sam2PreTrainedModel;H.Sam2Processor;H.Sam2VideoProcessor;H.Sam3ImageProcessor;H.Sam3TrackerModel;H.SamImageProcessor;H.SamImageSegmentationOutput;H.SamModel;H.SamPreTrainedModel;H.SamProcessor;H.SapiensForDepthEstimation;H.SapiensForNormalEstimation;H.SapiensForSemanticSegmentation;H.SapiensPreTrainedModel;H.SeamlessM4TFeatureExtractor;H.SegformerFeatureExtractor;H.SegformerForImageClassification;H.SegformerForSemanticSegmentation;H.SegformerImageProcessor;H.SegformerModel;H.SegformerPreTrainedModel;H.Seq2SeqLMOutput;H.SequenceClassifierOutput;H.SiglipImageProcessor;H.SiglipModel;H.SiglipPreTrainedModel;H.SiglipTextModel;H.SiglipTokenizer;H.SiglipVisionModel;H.SmolLM3ForCausalLM;H.SmolLM3Model;H.SmolLM3PreTrainedModel;H.SmolVLMForConditionalGeneration;H.SmolVLMImageProcessor;H.SmolVLMProcessor;H.SnacDecoderModel;H.SnacEncoderModel;H.SnacFeatureExtractor;H.SnacModel;H.SnacPreTrainedModel;H.SpeechT5FeatureExtractor;H.SpeechT5ForSpeechToText;H.SpeechT5ForTextToSpeech;H.SpeechT5HifiGan;H.SpeechT5Model;H.SpeechT5PreTrainedModel;H.SpeechT5Processor;H.SpeechT5Tokenizer;H.SqueezeBertForMaskedLM;H.SqueezeBertForQuestionAnswering;H.SqueezeBertForSequenceClassification;H.SqueezeBertModel;H.SqueezeBertPreTrainedModel;H.SqueezeBertTokenizer;H.StableLmForCausalLM;H.StableLmModel;H.StableLmPreTrainedModel;H.Starcoder2ForCausalLM;H.Starcoder2Model;H.Starcoder2PreTrainedModel;H.StoppingCriteria;H.StoppingCriteriaList;H.StyleTextToSpeech2Model;H.StyleTextToSpeech2PreTrainedModel;H.SummarizationPipeline;H.SupertonicForConditionalGeneration;H.SupertonicPreTrainedModel;H.SuppressTokensAtBeginLogitsProcessor;H.Swin2SRForImageSuperResolution;H.Swin2SRImageProcessor;H.Swin2SRModel;H.Swin2SRPreTrainedModel;H.SwinForImageClassification;H.SwinForSemanticSegmentation;H.SwinModel;H.SwinPreTrainedModel;H.T5ForConditionalGeneration;H.T5Model;H.T5PreTrainedModel;H.T5Tokenizer;H.TableTransformerForObjectDetection;H.TableTransformerModel;H.TableTransformerObjectDetectionOutput;H.TableTransformerPreTrainedModel;H.TemperatureLogitsWarper;H.Tensor;H.Text2TextGenerationPipeline;H.TextClassificationPipeline;H.TextGenerationPipeline;H.TextStreamer;H.TextToAudioPipeline;H.TokenClassificationPipeline;H.TokenClassifierOutput;H.TokenizerModel;H.TopKLogitsWarper;H.TopPLogitsWarper;H.TrOCRForCausalLM;H.TrOCRPreTrainedModel;H.TranslationPipeline;H.UltravoxModel;H.UltravoxPreTrainedModel;H.UltravoxProcessor;H.UniSpeechForCTC;H.UniSpeechForSequenceClassification;H.UniSpeechModel;H.UniSpeechPreTrainedModel;H.UniSpeechSatForAudioFrameClassification;H.UniSpeechSatForCTC;H.UniSpeechSatForSequenceClassification;H.UniSpeechSatModel;H.UniSpeechSatPreTrainedModel;H.VLChatProcessor;H.VLMImageProcessor;H.VaultGemmaForCausalLM;H.VaultGemmaModel;H.VaultGemmaPreTrainedModel;H.ViTFeatureExtractor;H.ViTForImageClassification;H.ViTImageProcessor;H.ViTMAEModel;H.ViTMAEPreTrainedModel;H.ViTMSNForImageClassification;H.ViTMSNModel;H.ViTMSNPreTrainedModel;H.ViTModel;H.ViTPreTrainedModel;H.VisionEncoderDecoderModel;H.VitMatteForImageMatting;H.VitMatteImageProcessor;H.VitMattePreTrainedModel;H.VitPoseForPoseEstimation;H.VitPoseImageProcessor;H.VitPosePreTrainedModel;H.VitsModel;H.VitsModelOutput;H.VitsPreTrainedModel;H.VitsTokenizer;H.VoxtralForConditionalGeneration;H.VoxtralProcessor;H.Wav2Vec2BertForCTC;H.Wav2Vec2BertForSequenceClassification;H.Wav2Vec2BertModel;H.Wav2Vec2BertPreTrainedModel;H.Wav2Vec2CTCTokenizer;H.Wav2Vec2FeatureExtractor;H.Wav2Vec2ForAudioFrameClassification;H.Wav2Vec2ForCTC;H.Wav2Vec2ForSequenceClassification;H.Wav2Vec2Model;H.Wav2Vec2PreTrainedModel;H.Wav2Vec2Processor;H.Wav2Vec2ProcessorWithLM;H.WavLMForAudioFrameClassification;H.WavLMForCTC;H.WavLMForSequenceClassification;H.WavLMForXVector;H.WavLMModel;H.WavLMPreTrainedModel;H.WeSpeakerFeatureExtractor;H.WeSpeakerResNetModel;H.WeSpeakerResNetPreTrainedModel;H.WhisperFeatureExtractor;H.WhisperForConditionalGeneration;H.WhisperModel;H.WhisperPreTrainedModel;H.WhisperProcessor;H.WhisperTextStreamer;H.WhisperTimeStampLogitsProcessor;H.WhisperTokenizer;H.XLMForQuestionAnswering;H.XLMForSequenceClassification;H.XLMForTokenClassification;H.XLMModel;H.XLMPreTrainedModel;H.XLMRobertaForMaskedLM;H.XLMRobertaForQuestionAnswering;H.XLMRobertaForSequenceClassification;H.XLMRobertaForTokenClassification;H.XLMRobertaModel;H.XLMRobertaPreTrainedModel;H.XLMRobertaTokenizer;H.XLMTokenizer;H.XLMWithLMHeadModel;H.XVectorOutput;H.YolosFeatureExtractor;H.YolosForObjectDetection;H.YolosImageProcessor;H.YolosModel;H.YolosObjectDetectionOutput;H.YolosPreTrainedModel;H.ZeroShotAudioClassificationPipeline;H.ZeroShotClassificationPipeline;H.ZeroShotImageClassificationPipeline;H.ZeroShotObjectDetectionPipeline;H.bankers_round;H.cat;var bB=H.cos_sim;H.dot;H.dynamic_time_warping;H.env;H.full;H.full_like;H.getCacheShapes;H.hamming;H.hanning;H.interpolate;H.interpolate_4d;H.interpolate_data;H.is_chinese_char;H.layer_norm;H.load_image;H.load_video;H.log_softmax;H.magnitude;H.matmul;H.max;H.mean;H.mean_pooling;H.medianFilter;H.mel_filter_bank;H.min;H.ones;H.ones_like;H.permute;H.permute_data;H.pipeline;H.quantize_embeddings;H.rand;H.randn;H.read_audio;H.rfft;H.round;H.slice;H.softmax;H.spectrogram;H.stack;H.std_mean;H.topk;H.window_function;H.zeros;H.zeros_like;const TK=["He sprinkled chili flakes over the pasta to add a gentle heat.","The stew thickened slowly as the vegetables softened in the pot.","A drizzle of honey balanced the bitterness of the dark chocolate.","They grilled the salmon until the skin became perfectly crisp.","The bakery filled with the smell of freshly baked cinnamon rolls.","She kneaded the dough patiently until it became smooth and elastic.","The chef reduced the wine sauce until it turned glossy and rich.","A handful of crushed pistachios added a satisfying crunch to the dessert.","The risotto became creamy as he gradually stirred in warm broth.","Freshly grated ginger gave the soup a bright, warming flavor.","A new firmware update improved the security features on the device.","The development team implemented containerization to streamline deployments.","He monitored CPU usage as the microservices processed incoming requests.","The platform used edge computing to reduce response times.","Developers refactored legacy code to improve overall maintainability.","An outage in the server cluster triggered an automatic failover sequence.","The UI team redesigned the dashboard for better accessibility.","QA engineers documented several bugs after running automated tests overnight.","A script optimized the data pipeline, reducing processing time significantly.","The network administrator updated routing tables to improve packet flow.","Bond yields rose steadily as investors sought safer assets.","The central bank issued a statement that shifted market expectations.","A sudden drop in commodity prices affected several global indexes.","Hedge funds rebalanced their positions to hedge against volatility.","Corporate earnings reports fueled speculation about long-term growth.","Financial analysts built predictive models to estimate revenue trends.","The credit market tightened as interest rates climbed.","Real estate investors evaluated capital flows across different regions.","The stock rallied after positive announcements from regulators.","A rescue shelter posted photos of newly adoptable puppies.","The cat stretched lazily across the back of the sofa.","A rabbit nibbled on fresh greens inside its enclosure.","She took her dog to obedience classes three times a week.","The hamster stored tiny seeds in the corner of its cage.","A pair of kittens wrestled energetically on the living room rug.","The parakeet chirped loudly when it heard footsteps approaching.","The guinea pig squeaked happily when given its favorite snack.","A senior dog rested peacefully after a long walk through the park.","The aquarium glowed softly as the fish swam in slow circles.","Students practiced solving equations to prepare for the math competition.","He organized his notes before beginning his study session.","The tutor reviewed sample questions to help him understand the concept better.","A classroom debate encouraged students to defend their ideas logically.","She submitted her research project after weeks of careful preparation.","The science lab buzzed with excitement during the experiment.","They created flashcards to memorize important historical dates.","The lecturer explained the topic using diagrams and real-world examples.","A study group formed to help each other revise before finals.","He tossed fresh herbs into the pan just before serving the dish.","The broth simmered gently, filling the room with a savory aroma.","A swirl of cream gave the soup a silky finish.","They toasted the bread until golden and crisp on the edges.","The chef decorated the cake with edible flowers and powdered sugar.","A squeeze of lime brightened the grilled vegetables instantly.","The currys spices deepened after hours of slow cooking.","The tart crust crumbled perfectly with each bite.","He monitored API logs to diagnose a sudden spike in errors.","The machine learning pipeline retrained models on updated datasets.","A new authentication protocol strengthened the systems defenses.","The helpdesk resolved connectivity issues affecting remote users.","Real-time metrics displayed traffic surges across multiple services.","A patch fixed memory leaks that had caused repeated crashes.","The blockchain node synced new blocks after a network upgrade.","The cloud instance autoscaled to handle additional workload.","She updated access permissions to improve data security.","Retail investors reacted quickly to shifting market sentiment.","The treasury department reviewed liquidity ratios before the audit.","Foreign exchange rates fluctuated throughout the trading session.","A dividend announcement boosted investor confidence overnight.","The commodities market responded sharply to new supply forecasts.","Analysts compiled quarterly data to predict future performance.","A pension fund diversified holdings to reduce long-term exposure.","International markets opened lower following geopolitical tension.","The puppy barked excitedly when the doorbell rang.","A small bird perched on the window ledge observing the room.","He brushed his cats fur until it shone smoothly.","The ferret darted playfully through a series of tunnels.","A turtle settled quietly on its warm basking rock.","She trained her parrot to repeat simple phrases.","Students rehearsed their presentations in the school auditorium.","He drafted an essay outline before writing the first paragraph.","The librarian recommended several books to support his research.","A digital learning app helped kids practice reading comprehension."],SK="/logo.png",NS=n=>zt.jsx("img",{src:SK,alt:"ThoughtNebula logo",...n}),xB=({muted:n})=>{const e=Ft.useRef(null);return Ft.useEffect(()=>{const t=e.current,s=typeof window<"u"&&(window.matchMedia("(max-width: 768px)").matches||/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent))?.14:.24;if(!t)return;const r=()=>{t.volume=s,t.muted=n,t.play().catch(l=>console.error("Could not play audio on click.",l))};t.volume=s,t.muted=n;const o=t.play();return o!==void 0&&o.catch(()=>{document.addEventListener("click",r,{once:!0})}),()=>{document.removeEventListener("click",r)}},[n]),zt.jsx("audio",{ref:e,src:"/music.mp3",loop:!0})};let uv=null,_E=!1,vE=[];const AK=()=>{const[n,e]=Ft.useState({isLoading:!1,isReady:!1,error:null,progress:0,status:"Waiting to start...",device:null});Ft.useEffect(()=>{uv||(uv=new Worker(new URL("/assets/worker-BhUPEyL3.js",import.meta.url),{type:"module"}),uv.onmessage=s=>{const{type:r,payload:o}=s.data;r==="progress"?e(l=>({...l,progress:o.percentage,status:o.status})):r==="ready"?(_E=!0,e(l=>({...l,isLoading:!1,isReady:!0,progress:100,status:"Ready. Enter sentences and generate the galaxy!",device:o.device}))):r==="error"?e(l=>({...l,isLoading:!1,error:o,status:"An error occurred"})):r==="embeddings"&&vE.length>0&&vE.shift()?.(o.embeddings)})},[]);const t=Ft.useCallback(async()=>_E&&n.device?{device:n.device}:(e(s=>({...s,isLoading:!0,error:null,progress:0,status:"Initializing..."})),uv?.postMessage({type:"load-model"}),new Promise((s,r)=>{const o=()=>{_E&&n.device?s({device:n.device}):n.error?r(n.error):setTimeout(o,100)};o()})),[n.error,n.device]),i=Ft.useCallback(async(s,r)=>new Promise((o,l)=>{vE.push(o),uv?.postMessage({type:"embed",payload:{sentences:s,options:r}})}),[]);return{...n,loadModel:t,embed:i}},CK={low:{label:"Battery saver",dpr:[1,1.15],antialias:!1,enableBloom:!1,bloomIntensity:.8,bloomHeight:240,powerPreference:"default",menu:{pointCount:8e3,starCount:1500,starFactor:4},scene:{starCount:1200,starFactor:3}},medium:{label:"Balanced",dpr:[1,1.5],antialias:!0,enableBloom:!0,bloomIntensity:1.1,bloomHeight:260,powerPreference:"default",menu:{pointCount:15e3,starCount:3e3,starFactor:6},scene:{starCount:2500,starFactor:5}},high:{label:"Max fidelity",dpr:[1,2],antialias:!0,enableBloom:!0,bloomIntensity:1.5,bloomHeight:320,powerPreference:"high-performance",menu:{pointCount:25e3,starCount:5e3,starFactor:8},scene:{starCount:4e3,starFactor:7}}},PK=()=>{if(typeof navigator>"u")return"high";const n=/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)||typeof window<"u"&&window.matchMedia("(max-width: 768px)").matches,e=navigator.deviceMemory?navigator.deviceMemory<=4:!1,t=typeof navigator.hardwareConcurrency=="number"&&navigator.hardwareConcurrency<=4;return n?"low":e||t?"medium":"high"},RK=n=>{const e=n.clone();e.y*=1.4,e.z*=.7;const t=Math.sign(e.x)||(Math.random()<.5?-1:1),i=.5,s=Math.pow(Math.abs(e.z),.3);e.x=e.x*.6+t*i*s;const r=Math.sqrt(e.x*e.x+e.z*e.z),o=1+.3*Math.exp(-r*r*.5);return e.y*=o,e},DK=({onLoadModel:n})=>zt.jsx("div",{className:"absolute inset-0 flex items-center justify-center z-10 pointer-events-none px-4",children:zt.jsx("div",{className:"max-w-5xl w-full bg-white/85 border border-gray-200 backdrop-blur-xl rounded-2xl shadow-2xl p-8 sm:p-10 pointer-events-auto text-gray-900",children:zt.jsxs("div",{className:"grid grid-cols-1 lg:grid-cols-2 gap-8 items-center",children:[zt.jsxs("div",{className:"space-y-4",children:[zt.jsxs("div",{className:"inline-flex items-center gap-2 rounded-full bg-gray-900 text-white px-3 py-1 text-sm",children:[zt.jsx("span",{className:"h-2 w-2 rounded-full bg-emerald-400 animate-pulse"}),"Web-native embeddings  3D semantic brain"]}),zt.jsxs("div",{className:"flex items-center gap-3",children:[zt.jsx(NS,{className:"w-12 h-12 rounded-xl shadow-md"}),zt.jsx("h1",{className:"text-4xl sm:text-5xl font-bold leading-tight",children:"ThoughtNebula"})]}),zt.jsx("p",{className:"text-base sm:text-lg text-gray-700",children:"Load the model in-browser and explore your text as neuron sparks inside a brain-shaped volume. No servers, no uploads."}),zt.jsxs("div",{className:"flex flex-wrap gap-3 text-sm text-gray-800",children:[zt.jsx("span",{className:"px-3 py-1 rounded-full bg-gray-100 border border-gray-200",children:"EmbeddingGemma  Transformers.js"}),zt.jsx("span",{className:"px-3 py-1 rounded-full bg-gray-100 border border-gray-200",children:"UMAP 3D projection"}),zt.jsx("span",{className:"px-3 py-1 rounded-full bg-gray-100 border border-gray-200",children:"Runs entirely local"})]}),zt.jsxs("div",{className:"flex gap-3 flex-wrap",children:[zt.jsx("button",{onClick:n,className:"bg-blue-600 hover:bg-blue-500 text-white font-semibold px-6 py-3 rounded-xl shadow-lg shadow-blue-900/20 transition-all duration-200",children:"Load Model & Demo"}),zt.jsxs("div",{className:"flex items-center text-sm text-gray-800",children:[zt.jsx("div",{className:"h-10 w-10 rounded-lg bg-gray-900 text-white flex items-center justify-center font-semibold mr-3",children:"40MB"}),zt.jsxs("div",{children:[zt.jsx("div",{className:"font-semibold",children:"Download once"}),zt.jsx("div",{className:"text-gray-600",children:"Cached in your browser"})]})]})]})]}),zt.jsxs("div",{className:"space-y-4",children:[zt.jsxs("div",{className:"grid grid-cols-2 gap-3 text-sm text-gray-800",children:[zt.jsxs("div",{className:"rounded-xl border border-gray-200 bg-white p-4 shadow-sm",children:[zt.jsx("div",{className:"text-gray-500",children:"How it works"}),zt.jsxs("ul",{className:"list-disc list-inside leading-relaxed text-gray-800",children:[zt.jsx("li",{children:"Embed your lines of text"}),zt.jsx("li",{children:"UMAP compresses to 3D"}),zt.jsx("li",{children:"Points light up by similarity"})]})]}),zt.jsxs("div",{className:"rounded-xl border border-gray-200 bg-white p-4 shadow-sm",children:[zt.jsx("div",{className:"text-gray-500",children:"Best on"}),zt.jsx("div",{className:"font-semibold text-gray-900",children:"Desktop WebGPU / WASM"}),zt.jsx("div",{className:"text-gray-600",children:"Mobile works; lower quality preset recommended."})]})]}),zt.jsxs("div",{className:"rounded-xl border border-gray-200 bg-white p-4 text-sm text-gray-800 shadow-sm",children:[zt.jsx("div",{className:"font-semibold text-gray-900",children:"Pro tip"}),"Use short, varied sentences for faster embedding. You can always edit after generation."]})]})]})})}),BK=({status:n,progress:e})=>zt.jsx("div",{className:"absolute top-0 left-0 w-full h-full flex flex-col items-center justify-center z-10 bg-black/50 backdrop-blur-sm",children:zt.jsxs("div",{className:"w-full max-w-md text-center p-4",children:[zt.jsx(NS,{className:"w-24 mx-auto mb-6"}),zt.jsx("h2",{className:"text-2xl font-bold mb-4",children:"Initializing Brain..."}),zt.jsx("div",{className:"w-full bg-gray-700 rounded-full h-2.5 mb-2",children:zt.jsx("div",{className:"bg-blue-500 h-2.5 rounded-full transition-all duration-500 ease-out",style:{width:`${e}%`}})}),zt.jsx("p",{className:"text-gray-400 h-5",children:n})]})}),IK=({point:n,color:e,similarity:t,onClick:i,isPreEmbedding:s})=>{const[r,o]=Ft.useState(!1),l=Ft.useRef(null),c=Ft.useRef(null),d=Ft.useRef(null),{camera:g,invalidate:p}=ju(),h=Ft.useRef(0),v=Ft.useRef(null),[y,w]=n.position;Ft.useEffect(()=>()=>{v.current!==null&&window.clearTimeout(v.current)},[]),ey(()=>{if(!l.current||!c.current)return;h.current+=1,c.current.opacity<1&&(c.current.opacity=Vh.lerp(c.current.opacity,1,.05));const T=l.current.position.distanceTo(g.position),C=Vh.mapLinear(T,100,25,2,1),x=Vh.clamp(C,1,2),R=r?1.25:1,D=c.current.opacity*x*R;l.current.scale.set(D,D,D),d.current&&(d.current.style.transform=`translateX(-50%) scale(${c.current.opacity})`);const z=t!==null?1.2:s?.55:.35,U=t!==null?.4*Math.sin(h.current*.06+y*.2+w*.15):s?.35*Math.sin(h.current*.09+y*.27+w*.21):0;c.current.emissiveIntensity=z+U,p()});const S=t!==null?`(${t.toFixed(2)}) ${n.text}`:n.text,M=t!==null?1:.4;return zt.jsxs("group",{position:n.position,children:[zt.jsxs("mesh",{ref:l,onClick:()=>i(n),onPointerOver:T=>{T.stopPropagation(),o(!0)},onPointerOut:T=>{T.stopPropagation(),o(!1)},onPointerDown:T=>{T.stopPropagation(),v.current!==null&&window.clearTimeout(v.current),o(!0),v.current=window.setTimeout(()=>{o(!1)},2e3)},children:[zt.jsx("sphereGeometry",{args:[.25,16,16]}),zt.jsx("meshStandardMaterial",{ref:c,color:e,roughness:.5,emissive:e,emissiveIntensity:M,transparent:!0,opacity:0})]}),r&&zt.jsx(HO,{distanceFactor:12,children:zt.jsx("div",{ref:d,className:"text-white bg-black/60 p-1.5 rounded-md text-sm whitespace-nowrap shadow-lg backdrop-blur-md",style:{transformOrigin:"center top",userSelect:"none"},children:zt.jsx("div",{children:S})})})]})},OK=({galaxyPoints:n,searchResults:e,onSphereClick:t,searchQuery:i})=>{const s=Ft.useRef(null),r=Ft.useRef(null),o=Ft.useRef(new Oe),l=Ft.useRef(new Oe),c=Ft.useRef(!1),d=Ft.useRef(0),[g,p]=Ft.useState([]),{camera:h,invalidate:v}=ju(),y=Px("/brain_hologram.glb"),w=Ft.useMemo(()=>y?.scene?.clone()??null,[y]);Ft.useEffect(()=>{w&&w.traverse(se=>{if(se.isMesh){const pe=se;pe.material=new M0({color:"#5a3fbf",emissive:"#2a1766",emissiveIntensity:.3,transparent:!0,opacity:.5,roughness:1,side:Ro})}})},[w]);const S=Ft.useMemo(()=>{if(!w)return{scale:1,offset:new Oe(0,0,0),halfSize:new Oe(55,55,55)};const se=new Ra().setFromObject(w),pe=new Oe;se.getSize(pe);const be=se.getCenter(new Oe),te=100/(Math.max(pe.x,pe.y,pe.z)||1),ue=be.multiplyScalar(-te),ae=pe.clone().multiplyScalar(te/2);return{scale:te,offset:ue,halfSize:ae}},[w]),M=Ft.useMemo(()=>{if(!w)return null;let se=null;return w.traverse(pe=>{!se&&pe.isMesh&&(se=pe.geometry.clone())}),se?new DT(se):null},[w]),T=.66,C=Ft.useMemo(()=>new Oe(-2,18,0),[]),x=Ft.useMemo(()=>new Oe(1.3,.75,1.2),[]),R=Ft.useMemo(()=>S.halfSize.clone().multiplyScalar(T).multiply(x),[S.halfSize,T,x]),P=Ft.useMemo(()=>R.clone().multiplyScalar(.95),[R]),D=Ft.useMemo(()=>S.offset.clone().negate().add(C),[S.offset,C]),z=Ft.useMemo(()=>new y0(1,48,48),[]),U=Ft.useRef(null),N=Ft.useCallback(()=>{if(!s.current)return null;const se=S.offset.clone().negate(),pe=Math.max(S.halfSize.x,S.halfSize.y,S.halfSize.z)*2,be=h.fov*(Math.PI/180),ee=Math.abs(pe/2/Math.tan(be/2)),te=typeof window<"u"&&(window.matchMedia("(max-width: 768px)").matches||/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)),ue=ee*(te?1.35:.85);return{pos:new Oe(se.x+pe*.25,se.y+pe*.12,se.z+ue),target:se}},[S.halfSize.x,S.halfSize.y,S.halfSize.z,S.offset,h]),j=Ft.useMemo(()=>{if(!w)return[];const se=200,pe=[];for(let be=0;be<se;be++){let ee=new Oe;do ee.set(Math.random()*2-1,Math.random()*2-1,Math.random()*2-1);while(ee.lengthSq()>1);ee.multiplyScalar(.97);const te=new Oe(ee.x*P.x+D.x,ee.y*P.y+D.y,ee.z*P.z+D.z);pe.push({text:`Placeholder ${be+1}`,position:[te.x,te.y,te.z],embedding:[]})}return pe},[w,P,D]),J=Ft.useMemo(()=>{if(!w||n.length===0)return n;const se=n.map(ue=>new Oe(...ue.position)),pe=new Ra().setFromPoints(se),be=pe.getCenter(new Oe),ee=pe.getSize(new Oe),te=Math.max(ee.x,ee.y,ee.z)||1;return n.map((ue,ae)=>{const Be=new Oe(...ue.position).clone().sub(be).divideScalar(te/2),He=Be.length();if(He>.95&&Be.normalize().multiplyScalar(.95),He<.05){const Ae=xe=>{const ke=Math.sin(xe*12.9898+78.233)*43758.5453;return ke-Math.floor(ke)},ye=new Oe(Ae(ae*3)*2-1,Ae(ae*3+1)*2-1,Ae(ae*3+2)*2-1).normalize();Be.copy(ye.multiplyScalar(.05+Ae(ae*7)*.1))}Be.multiplyScalar(.97);const Xe=Be.x*P.x+D.x,ot=Be.y*P.y+D.y,tt=Be.z*P.z+D.z;return{...ue,position:[Xe,ot,tt]}})},[n,P,D,w]),W=Ft.useCallback(()=>{if(!s.current)return;const se=N();se&&(h.position.copy(se.pos),s.current.target.copy(se.target),s.current.update(),v(),U.current={pos:se.pos.clone(),target:se.target.clone()})},[N,h,v]);Ft.useEffect(()=>{W()},[W]),Ft.useEffect(()=>{if(J.length===0||!s.current)return;const se=N();se&&(h.position.copy(se.pos),s.current.target.copy(se.target),s.current.update(),v(),U.current={pos:se.pos.clone(),target:se.target.clone()})},[J.length,N,h,v]),Ft.useEffect(()=>{if(!s.current)return;if(e.length===0||!e[0]?.text){U.current&&(h.position.copy(U.current.pos),s.current.target.copy(U.current.target),s.current.update(),v());return}const se=e[0],pe=J.find(Ae=>Ae.text===se.text);if(!pe)return;const be=new Oe(...pe.position),ee=new Oe().subVectors(h.position,s.current.target).normalize(),te=6,ue=20,ae=Vh.clamp(se.similarity,0,1),ce=Vh.mapLinear(ae,0,1,ue,te),Be=typeof window<"u"&&(window.matchMedia("(max-width: 768px)").matches||/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)),He=Vh.clamp((se.text.length-40)/80,0,1),Xe=Be?1+.4*He:1,ot=ce*Xe,tt=ee.multiplyScalar(ot);o.current.copy(be).add(tt),l.current.copy(be),c.current=!0},[e,h,J,v]),Ft.useEffect(()=>{e.length===0&&U.current&&s.current&&(c.current=!1,s.current.enabled=!0,h.position.copy(U.current.pos),s.current.target.copy(U.current.target),s.current.update(),v())},[e.length,W,h,v]),Ft.useEffect(()=>{i.trim()||(c.current=!1,U.current&&s.current?(s.current.enabled=!0,h.position.copy(U.current.pos),s.current.target.copy(U.current.target),s.current.update(),v()):W())},[i,W]),ey(()=>{n.length===0&&r.current&&(r.current.rotation.y+=.003,v()),c.current&&s.current&&(s.current.enabled=!1,h.position.distanceTo(o.current)>.01?(h.position.lerp(o.current,.08),s.current.target.lerp(l.current,.08)):(h.position.copy(o.current),s.current.target.copy(l.current),c.current=!1,s.current.enabled=!0),v())});const oe=n.length>0?J:j,ne=n.length===0;Ft.useEffect(()=>{if(!ne){p([]);return}if(j.length===0)return;const se=window.setInterval(()=>{p(pe=>{const be=pe.map(te=>({...te,life:te.life-.12})).filter(te=>te.life>0),ee=6;for(;be.length<ee;){const te=Math.floor(Math.random()*j.length);let ue=Math.floor(Math.random()*j.length);te===ue&&(ue=(ue+1)%j.length),be.push({id:d.current++,start:j[te].position,end:j[ue].position,life:1})}return be})},240);return()=>window.clearInterval(se)},[ne,j]);const{pointColors:q,similarityMap:le}=Ft.useMemo(()=>{const se=new Sn("#34215f"),pe=new Sn("#5a3fbf"),be=new Sn("#9b7bff"),ee=n.length>0?n:j;if(e.length===0){if(n.length===0){const ae=Math.max(j.length,1);return{pointColors:j.map((Be,He)=>{const Xe=ae===1?0:He/(ae-1),ot=.5+.5*Math.sin(2*Math.PI*Xe),tt=.5+.5*Math.sin(2*Math.PI*Xe+2*Math.PI/3),Ae=.5+.5*Math.sin(2*Math.PI*Xe+4*Math.PI/3);return`#${new Sn(ot,tt,Ae).getHexString()}`}),similarityMap:new Map}}return{pointColors:ee.map(()=>"#5a3fbf"),similarityMap:new Map}}const te=new Map(e.map(ae=>[ae.text,ae.similarity]));return{pointColors:ee.map(ae=>{const ce=te.get(ae.text);if(ce===void 0)return"#5a3fbf";const Be=new Sn,He=Vh.clamp(ce,0,1);return Be.lerpColors(se,pe,Math.min(He*2,1)),Be.lerpColors(Be,be,Math.max(0,He-.5)*2),`#${Be.getHexString()}`}),similarityMap:te}},[n,e,j]);return zt.jsxs(zt.Fragment,{children:[zt.jsx("fog",{attach:"fog",args:["#e8ecf2",30,160]}),zt.jsx("ambientLight",{intensity:.6}),zt.jsx("hemisphereLight",{intensity:.35,args:["#ffffff","#888888",1]}),zt.jsx("pointLight",{position:[0,40,20],intensity:1.4}),zt.jsx("pointLight",{position:[0,-30,-10],intensity:.6,color:"#7cf0ff"}),zt.jsx(G5,{ref:s,makeDefault:!0,enableZoom:!0,enablePan:!0}),w&&zt.jsxs("group",{ref:r,scale:[S.scale,S.scale,S.scale],position:[S.offset.x,S.offset.y,S.offset.z],children:[zt.jsx("primitive",{object:w}),M&&zt.jsxs("lineSegments",{children:[zt.jsx("primitive",{object:M,attach:"geometry"}),zt.jsx("lineBasicMaterial",{color:"#a78bfa",transparent:!0,opacity:.35})]})]}),zt.jsx("mesh",{geometry:z,scale:[R.x,R.y,R.z],position:[D.x,D.y,D.z],visible:!1,children:zt.jsx("meshBasicMaterial",{color:"#000000",opacity:0,transparent:!0})}),oe.map((se,pe)=>zt.jsx(IK,{point:se,color:q[pe],similarity:le.get(se.text)??null,onClick:t,isPreEmbedding:ne},se.text+pe)),ne&&g.length>0&&zt.jsx("group",{children:g.map(se=>zt.jsxs("line",{children:[zt.jsx("bufferGeometry",{attach:"geometry",onUpdate:pe=>pe.setFromPoints([new Oe(...se.start),new Oe(...se.end)])}),zt.jsx("lineBasicMaterial",{color:"#7cf8ff",transparent:!0,opacity:Math.max(0,Math.min(1,se.life)),linewidth:1})]},se.id))})]})};function LK(){const{device:n,loadModel:e,isLoading:t,isReady:i,progress:s,status:r,error:o,embed:l}=AK(),[c,d]=Ft.useState(()=>PK()),g=CK[c],[p,h]=Ft.useState(""),[v,y]=Ft.useState([]),[w,S]=Ft.useState(""),[M,T]=Ft.useState([]),[C,x]=Ft.useState(!1),[R,P]=Ft.useState(!0),[D,z]=Ft.useState(!1),[U,N]=Ft.useState(!1),j=Ft.useRef(null),[J,W]=Ft.useState(""),oe=Ft.useRef(!1),ne=Ft.useRef(null),q=()=>{let be=TK;n==="wasm"&&(be=be.filter((ee,te)=>te%2===0)),h(be.join(`
`))};Ft.useEffect(()=>{q()},[n]);const le=async()=>{if(!i||!p.trim()){alert("Model not ready or no text provided.");return}x(!0),T([]),S(""),j.current=null,W("Generating brain...");const be=p.split(`
`).map(te=>te.trim()).filter(Boolean).sort(te=>te.length);if(be.length<3){alert("Please provide at least 3 sentences for UMAP to work effectively."),x(!1);return}const ee=n==="webgpu"?4:1;try{const te=[];W("Embedding... (0%)");for(let ze=0;ze<be.length;ze+=ee){const je=be.slice(ze,ze+ee),Fe=(ze+je.length)/be.length*100,Ye=await l(je,{padding:!0,truncation:!0,max_length:256});te.push(...Ye),W(`Embedding... (${Fe.toFixed(0)}%)`)}W("Running UMAP to create 3D projection...");const ue=Math.max(2,Math.min(be.length-1,15)),Be=new z9.UMAP({nComponents:3,nNeighbors:ue,minDist:.1}).fit(te).map(ze=>new Oe(...ze)),Xe=new Ra().setFromPoints(Be).getCenter(new Oe),ot=Be.map(ze=>ze.sub(Xe));let tt=0;for(const ze of ot)tt=Math.max(tt,ze.length());const Ae=50,xe=ot.map(ze=>{const je=tt>0?ze.divideScalar(tt):ze;return RK(je).multiplyScalar(Ae)}).map(ze=>ze.toArray()),ke=be.map((ze,je)=>({text:ze,position:xe[je],embedding:te[je]}));y(ke),W(`Brain generated with ${ke.length} neuron sparks. Ready to explore!`),P(!1)}catch{W("An error occurred during generation.")}finally{x(!1)}};Ft.useEffect(()=>{ne.current=w;const be=async()=>{if(oe.current||ne.current===null)return;oe.current=!0;const ee=ne.current;if(ne.current=null,!ee.trim()||!i||v.length===0){T([]),j.current=null,oe.current=!1,ne.current!==null&&be();return}try{const[te]=await l([ee],{padding:!0,truncation:!0,max_length:256});j.current=te;const ue=v.map(ae=>({...ae,similarity:bB(te,ae.embedding)})).sort((ae,ce)=>ce.similarity-ae.similarity);T(ue)}catch{}finally{oe.current=!1,ne.current!==null&&be()}};be()},[w,v,i,l]);const se=be=>{let ee=be.similarity;if(ee===void 0)if(j.current)ee=bB(j.current,be.embedding);else return;const ue=[{...be,similarity:ee},...M.filter(ae=>ae.text!==be.text)];T(ue)},pe=()=>zt.jsxs(U8,{camera:{position:[0,0,25],fov:45},dpr:g.dpr,gl:{antialias:g.antialias,powerPreference:g.powerPreference},children:[zt.jsx("color",{attach:"background",args:["#f2f2f2"]}),zt.jsxs(Ft.Suspense,{fallback:zt.jsx(HO,{center:!0,children:zt.jsx("div",{className:"text-gray-900",children:"Loading 3D Scene..."})}),children:[zt.jsx(OK,{galaxyPoints:v,searchResults:M,onSphereClick:se,searchQuery:w}),g.enableBloom&&zt.jsx(l9,{enableNormalPass:!1,children:zt.jsx(d9,{luminanceThreshold:.1,luminanceSmoothing:.9,height:g.bloomHeight,intensity:g.bloomIntensity})})]})]});return i?zt.jsxs("div",{className:"h-screen w-screen bg-[#f2f2f2] text-gray-900 relative",children:[zt.jsx(xB,{muted:U}),zt.jsx("div",{className:"absolute top-0 left-0 w-full h-full z-0",children:pe()}),zt.jsxs("div",{className:"absolute top-0 left-0 w-full h-full pointer-events-none z-10",children:[zt.jsx("div",{className:`absolute top-0 left-0 h-full bg-white/90 backdrop-blur-xl border-r border-gray-300 transition-transform duration-300 ease-in-out ${R?"translate-x-0":"-translate-x-full"} pointer-events-auto text-gray-900 shadow-2xl`,style:{width:"min(420px, 92vw)"},children:zt.jsxs("div",{className:"flex flex-col h-full p-6 gap-4",children:[zt.jsxs("div",{className:`flex flex-col transition-all duration-300 ease-in-out ${D?"flex-grow-[10]":"flex-grow-[2]"}`,children:[zt.jsxs("div",{className:"flex gap-2 items-center mb-2",children:[zt.jsx(NS,{className:"w-12 ml-[-6px]"}),zt.jsxs("div",{children:[zt.jsx("h1",{className:"text-3xl font-bold text-gray-900 leading-tight",children:"ThoughtNebula"}),zt.jsx("p",{className:"text-sm text-gray-600",children:"Turn your text into glowing neurons inside a brain."})]})]}),zt.jsxs("div",{className:"flex items-center justify-between mb-3 gap-2",children:[zt.jsx("label",{className:"font-semibold text-gray-700",children:"Performance"}),zt.jsxs("select",{value:c,onChange:be=>d(be.target.value),className:"bg-white text-sm rounded-md px-2 py-1 border border-gray-300 focus:ring-2 focus:ring-blue-500 focus:outline-none text-gray-900",children:[zt.jsx("option",{value:"low",children:"Low  battery saver"}),zt.jsx("option",{value:"medium",children:"Medium  balanced"}),zt.jsx("option",{value:"high",children:"High  max fidelity"})]})]}),zt.jsxs("div",{className:"flex justify-between items-center mb-1",children:[zt.jsx("label",{htmlFor:"text-input",className:"font-semibold text-gray-700",children:"Your Dataset"}),zt.jsxs("div",{className:"flex items-center gap-3",children:[zt.jsx("button",{onClick:q,className:"text-sm font-medium text-blue-600 hover:text-blue-500 transition-colors",children:"Try Example"}),zt.jsx("button",{onClick:()=>N(be=>!be),"aria-pressed":U,className:"text-sm font-medium text-blue-600 hover:text-blue-500 transition-colors",children:U?"Unmute Music":"Mute Music"})]})]}),zt.jsx("p",{className:"text-xs text-gray-600 mb-2",children:"Enter full sentences, one per line. Short, natural sentences embed best."}),zt.jsx("textarea",{id:"text-input",value:p,onChange:be=>h(be.target.value),onFocus:()=>z(!0),onBlur:()=>z(!1),className:"flex-grow bg-white border border-gray-300 rounded-md p-3 text-sm text-gray-900 resize-none focus:ring-2 focus:ring-blue-500 focus:outline-none whitespace-pre-wrap overflow-auto transition-all duration-300 ease-in-out shadow-inner",placeholder:"Enter sentences here, one per line."}),zt.jsx("button",{onClick:le,disabled:C||!i,className:"mt-4 w-full bg-blue-600 hover:bg-blue-500 disabled:bg-gray-300 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-xl transition-colors shadow-md",children:C?J:"Generate Brain"}),zt.jsx("p",{className:"text-center text-sm mt-2 text-gray-600 h-5",children:C?"":J})]}),v.length>0&&zt.jsxs("div",{className:`mt-4 flex flex-col min-h-0 transition-all duration-300 ease-in-out ${D?"flex-grow-[1] opacity-50":"flex-grow-[3] opacity-100"}`,children:[zt.jsx("h2",{className:"font-semibold mb-2 text-gray-800",children:"Search Results"}),zt.jsxs("div",{className:"overflow-y-auto pr-2",children:[M.length===0&&zt.jsx("p",{className:"text-sm text-gray-600",children:"Search to see results."}),M.map((be,ee)=>zt.jsx("div",{onClick:()=>se(be),className:`p-2 mb-1 rounded-md cursor-pointer transition-colors ${ee===0?"bg-blue-50 border border-blue-200":"bg-gray-100 hover:bg-gray-200 border border-gray-200"}`,children:zt.jsxs("div",{className:"flex justify-between items-center",children:[zt.jsx("p",{className:"font-semibold text-sm truncate pr-2 text-gray-900",children:be.text}),zt.jsx("span",{className:"text-xs font-mono bg-blue-100 text-blue-700 px-1.5 py-0.5 rounded",children:be.similarity.toFixed(3)})]})},be.text+ee))]})]})]})}),zt.jsx("button",{onClick:()=>P(!R),className:"absolute top-6 bg-black/30 backdrop-blur-lg p-2 rounded-full transition-all duration-300 ease-in-out pointer-events-auto",style:{left:R?"min(400px, 90vw)":"0",transform:"translateX(1.5rem)"},children:zt.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",className:`h-6 w-6 text-white transition-transform duration-300 ${R?"rotate-180":"rotate-0"}`,fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:zt.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M9 5l7 7-7 7"})})}),v.length>0&&zt.jsx("div",{className:"absolute bottom-8 left-1/2 -translate-x-1/2 w-full max-w-2xl px-4 pointer-events-auto",children:zt.jsx("div",{className:"relative",children:zt.jsx("input",{type:"text",placeholder:"Type words to search for similar neurons...",value:w,onChange:be=>S(be.target.value),className:"w-full bg-black/30 backdrop-blur-lg border border-white/10 rounded-full py-3 px-8 text-lg focus:ring-2 focus:ring-blue-500 focus:outline-none"})})})]})]}):zt.jsxs("div",{className:"h-screen w-screen bg-[#f2f2f2] text-gray-900 relative",children:[zt.jsx(xB,{muted:U}),zt.jsx("div",{className:"absolute top-0 left-0 w-full h-full z-0",children:pe()}),!t&&zt.jsx(DK,{onLoadModel:e}),t&&zt.jsx(BK,{status:r,progress:s}),o&&zt.jsx("div",{className:"absolute bottom-4 left-4 bg-red-500/50 text-white p-4 rounded-lg",children:zt.jsxs("p",{children:["Error: ",o]})})]})}EB.createRoot(document.getElementById("root")).render(zt.jsx(Ft.StrictMode,{children:zt.jsx(LK,{})}));
